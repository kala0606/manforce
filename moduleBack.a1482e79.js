// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../node_modules/regenerator-runtime/runtime.js":[function(require,module,exports) {
var define;
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{}],"../../../../node_modules/three/build/three.module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CameraHelper = exports.Camera = exports.Cache = exports.ByteType = exports.BufferGeometryLoader = exports.BufferGeometry = exports.BufferAttribute = exports.BoxHelper = exports.BoxGeometry = exports.BoxBufferGeometry = exports.Box3Helper = exports.Box3 = exports.Box2 = exports.BoundingBoxHelper = exports.BooleanKeyframeTrack = exports.Bone = exports.BinaryTextureLoader = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AxisHelper = exports.AxesHelper = exports.AudioLoader = exports.AudioListener = exports.AudioContext = exports.AudioAnalyser = exports.Audio = exports.ArrowHelper = exports.ArrayCamera = exports.ArcCurve = exports.AnimationUtils = exports.AnimationObjectGroup = exports.AnimationMixer = exports.AnimationLoader = exports.AnimationClip = exports.AmbientLightProbe = exports.AmbientLight = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.CanvasRenderer = CanvasRenderer;
exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = exports.DiscreteInterpolant = exports.DirectionalLightHelper = exports.DirectionalLight = exports.DepthTexture = exports.DepthStencilFormat = exports.DepthFormat = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.DataUtils = exports.DataTextureLoader = exports.DataTexture3D = exports.DataTexture2DArray = exports.DataTexture = exports.DataArrayTexture = exports.Data3DTexture = exports.Cylindrical = exports.CylinderGeometry = exports.CylinderBufferGeometry = exports.CustomToneMapping = exports.CustomBlending = exports.CurvePath = exports.Curve = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubicInterpolant = exports.CubicBezierCurve3 = exports.CubicBezierCurve = exports.CubeUVReflectionMapping = exports.CubeTextureLoader = exports.CubeTexture = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.CubeCamera = exports.ConeGeometry = exports.ConeBufferGeometry = exports.CompressedTextureLoader = exports.CompressedTexture = exports.ColorManagement = exports.ColorKeyframeTrack = exports.Color = exports.Clock = exports.ClampToEdgeWrapping = exports.CircleGeometry = exports.CircleBufferGeometry = exports.CineonToneMapping = exports.CatmullRomCurve3 = exports.CapsuleGeometry = exports.CapsuleBufferGeometry = exports.CanvasTexture = void 0;
exports.FogExp2 = exports.Fog = exports.FloatType = exports.Float64BufferAttribute = exports.Float64Attribute = exports.Float32BufferAttribute = exports.Float32Attribute = exports.Float16BufferAttribute = exports.FlatShading = exports.FileLoader = exports.FaceColors = exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = exports.EventDispatcher = exports.Euler = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.EllipseCurve = exports.EdgesHelper = exports.EdgesGeometry = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DynamicBufferAttribute = exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = void 0;
exports.Font = Font;
exports.FontLoader = FontLoader;
exports.ImageUtils = exports.ImageLoader = exports.ImageBitmapLoader = exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = exports.HemisphereLightProbe = exports.HemisphereLightHelper = exports.HemisphereLight = exports.HalfFloatType = exports.Group = exports.GridHelper = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterDepth = exports.GLSL3 = exports.GLSL1 = exports.GLBufferAttribute = exports.Frustum = exports.FrontSide = exports.FramebufferTexture = void 0;
exports.ImmediateRenderObject = ImmediateRenderObject;
exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.Interpolant = exports.InterleavedBufferAttribute = exports.InterleavedBuffer = exports.IntType = exports.Int8BufferAttribute = exports.Int8Attribute = exports.Int32BufferAttribute = exports.Int32Attribute = exports.Int16BufferAttribute = exports.Int16Attribute = exports.InstancedMesh = exports.InstancedInterleavedBuffer = exports.InstancedBufferGeometry = exports.InstancedBufferAttribute = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = void 0;
exports.JSONLoader = JSONLoader;
exports.Layers = exports.LatheGeometry = exports.LatheBufferGeometry = exports.LOD = exports.KeyframeTrack = exports.KeepStencilOp = void 0;
exports.LensFlare = LensFlare;
exports.LinearInterpolant = exports.LinearFilter = exports.LinearEncoding = exports.LineStrip = exports.LineSegments = exports.LinePieces = exports.LineLoop = exports.LineDashedMaterial = exports.LineCurve3 = exports.LineCurve = exports.LineBasicMaterial = exports.Line3 = exports.Line = exports.LightProbe = exports.Light = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessDepth = void 0;
exports.MeshDistanceMaterial = exports.MeshDepthMaterial = exports.MeshBasicMaterial = exports.Mesh = exports.MaxEquation = exports.Matrix4 = exports.Matrix3 = exports.MathUtils = exports.Math = exports.MaterialLoader = exports.Material = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LoadingManager = exports.LoaderUtils = exports.Loader = exports.LinearToneMapping = exports.LinearSRGBColorSpace = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = void 0;
exports.MeshFaceMaterial = MeshFaceMaterial;
exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MeshToonMaterial = exports.MeshStandardMaterial = exports.MeshPhysicalMaterial = exports.MeshPhongMaterial = exports.MeshNormalMaterial = exports.MeshMatcapMaterial = exports.MeshLambertMaterial = void 0;
exports.MultiMaterial = MultiMaterial;
exports.RGBADepthPacking = exports.REVISION = exports.QuaternionLinearInterpolant = exports.QuaternionKeyframeTrack = exports.Quaternion = exports.QuadraticBezierCurve3 = exports.QuadraticBezierCurve = exports.PropertyMixer = exports.PropertyBinding = exports.PositionalAudio = exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = exports.PolarGridHelper = exports.PointsMaterial = exports.Points = exports.PointLightHelper = exports.PointLight = exports.PointCloudMaterial = exports.PointCloud = exports.PlaneHelper = exports.PlaneGeometry = exports.PlaneBufferGeometry = exports.Plane = exports.PerspectiveCamera = exports.Path = exports.ParticleSystemMaterial = exports.ParticleSystem = exports.ParticleBasicMaterial = exports.Particle = exports.ParametricGeometry = exports.PMREMGenerator = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OrthographicCamera = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.OctahedronGeometry = exports.OctahedronBufferGeometry = exports.ObjectSpaceNormalMap = exports.ObjectLoader = exports.Object3D = exports.NumberKeyframeTrack = exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColors = exports.NoColorSpace = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = void 0;
exports.TubeBufferGeometry = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.Triangle = exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = exports.TorusGeometry = exports.TorusBufferGeometry = exports.TextureLoader = exports.Texture = exports.TextGeometry = exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StringKeyframeTrack = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StereoCamera = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.SpriteMaterial = exports.Sprite = exports.SpotLightHelper = exports.SpotLight = exports.SplineCurve = exports.SphericalHarmonics3 = exports.Spherical = exports.SphereGeometry = exports.SphereBufferGeometry = exports.Sphere = exports.Source = exports.SmoothShading = exports.SkinnedMesh = exports.SkeletonHelper = exports.Skeleton = exports.ShortType = exports.ShapeUtils = exports.ShapePath = exports.ShapeGeometry = exports.ShapeBufferGeometry = exports.Shape = exports.ShadowMaterial = exports.ShaderMaterial = exports.ShaderLib = exports.ShaderChunk = exports.SceneUtils = exports.Scene = exports.SRGBColorSpace = exports.RingGeometry = exports.RingBufferGeometry = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RectAreaLight = exports.Raycaster = exports.Ray = exports.RawShaderMaterial = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGBFormat = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = void 0;
exports.WebGLRenderTargetCube = exports.WebGLRenderTarget = exports.WebGLMultisampleRenderTarget = exports.WebGLMultipleRenderTargets = exports.WebGLCubeRenderTarget = exports.WebGLArrayRenderTarget = exports.WebGL3DRenderTarget = exports.WebGL1Renderer = exports.VideoTexture = exports.VertexColors = exports.Vertex = exports.VectorKeyframeTrack = exports.Vector4 = exports.Vector3 = exports.Vector2 = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsLib = exports.Uniform = exports.Uint8ClampedBufferAttribute = exports.Uint8ClampedAttribute = exports.Uint8BufferAttribute = exports.Uint8Attribute = exports.Uint32BufferAttribute = exports.Uint32Attribute = exports.Uint16BufferAttribute = exports.Uint16Attribute = exports.UVMapping = exports.TubeGeometry = void 0;
exports.WebGLRenderer = WebGLRenderer;
exports.WebGLUtils = WebGLUtils;
exports.sRGBEncoding = exports._SRGBAFormat = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.XHRLoader = exports.WrapAroundEnding = exports.WireframeHelper = exports.WireframeGeometry = void 0;

var _FN;

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e3) { throw _e3; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e4) { didErr = true; err = _e4; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
var REVISION = '139';
exports.REVISION = REVISION;
var MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2
};
exports.MOUSE = MOUSE;
var TOUCH = {
  ROTATE: 0,
  PAN: 1,
  DOLLY_PAN: 2,
  DOLLY_ROTATE: 3
};
exports.TOUCH = TOUCH;
var CullFaceNone = 0;
exports.CullFaceNone = CullFaceNone;
var CullFaceBack = 1;
exports.CullFaceBack = CullFaceBack;
var CullFaceFront = 2;
exports.CullFaceFront = CullFaceFront;
var CullFaceFrontBack = 3;
exports.CullFaceFrontBack = CullFaceFrontBack;
var BasicShadowMap = 0;
exports.BasicShadowMap = BasicShadowMap;
var PCFShadowMap = 1;
exports.PCFShadowMap = PCFShadowMap;
var PCFSoftShadowMap = 2;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
var VSMShadowMap = 3;
exports.VSMShadowMap = VSMShadowMap;
var FrontSide = 0;
exports.FrontSide = FrontSide;
var BackSide = 1;
exports.BackSide = BackSide;
var DoubleSide = 2;
exports.DoubleSide = DoubleSide;
var FlatShading = 1;
exports.FlatShading = FlatShading;
var SmoothShading = 2;
exports.SmoothShading = SmoothShading;
var NoBlending = 0;
exports.NoBlending = NoBlending;
var NormalBlending = 1;
exports.NormalBlending = NormalBlending;
var AdditiveBlending = 2;
exports.AdditiveBlending = AdditiveBlending;
var SubtractiveBlending = 3;
exports.SubtractiveBlending = SubtractiveBlending;
var MultiplyBlending = 4;
exports.MultiplyBlending = MultiplyBlending;
var CustomBlending = 5;
exports.CustomBlending = CustomBlending;
var AddEquation = 100;
exports.AddEquation = AddEquation;
var SubtractEquation = 101;
exports.SubtractEquation = SubtractEquation;
var ReverseSubtractEquation = 102;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
var MinEquation = 103;
exports.MinEquation = MinEquation;
var MaxEquation = 104;
exports.MaxEquation = MaxEquation;
var ZeroFactor = 200;
exports.ZeroFactor = ZeroFactor;
var OneFactor = 201;
exports.OneFactor = OneFactor;
var SrcColorFactor = 202;
exports.SrcColorFactor = SrcColorFactor;
var OneMinusSrcColorFactor = 203;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
var SrcAlphaFactor = 204;
exports.SrcAlphaFactor = SrcAlphaFactor;
var OneMinusSrcAlphaFactor = 205;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
var DstAlphaFactor = 206;
exports.DstAlphaFactor = DstAlphaFactor;
var OneMinusDstAlphaFactor = 207;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
var DstColorFactor = 208;
exports.DstColorFactor = DstColorFactor;
var OneMinusDstColorFactor = 209;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
var SrcAlphaSaturateFactor = 210;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
var NeverDepth = 0;
exports.NeverDepth = NeverDepth;
var AlwaysDepth = 1;
exports.AlwaysDepth = AlwaysDepth;
var LessDepth = 2;
exports.LessDepth = LessDepth;
var LessEqualDepth = 3;
exports.LessEqualDepth = LessEqualDepth;
var EqualDepth = 4;
exports.EqualDepth = EqualDepth;
var GreaterEqualDepth = 5;
exports.GreaterEqualDepth = GreaterEqualDepth;
var GreaterDepth = 6;
exports.GreaterDepth = GreaterDepth;
var NotEqualDepth = 7;
exports.NotEqualDepth = NotEqualDepth;
var MultiplyOperation = 0;
exports.MultiplyOperation = MultiplyOperation;
var MixOperation = 1;
exports.MixOperation = MixOperation;
var AddOperation = 2;
exports.AddOperation = AddOperation;
var NoToneMapping = 0;
exports.NoToneMapping = NoToneMapping;
var LinearToneMapping = 1;
exports.LinearToneMapping = LinearToneMapping;
var ReinhardToneMapping = 2;
exports.ReinhardToneMapping = ReinhardToneMapping;
var CineonToneMapping = 3;
exports.CineonToneMapping = CineonToneMapping;
var ACESFilmicToneMapping = 4;
exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
var CustomToneMapping = 5;
exports.CustomToneMapping = CustomToneMapping;
var UVMapping = 300;
exports.UVMapping = UVMapping;
var CubeReflectionMapping = 301;
exports.CubeReflectionMapping = CubeReflectionMapping;
var CubeRefractionMapping = 302;
exports.CubeRefractionMapping = CubeRefractionMapping;
var EquirectangularReflectionMapping = 303;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
var EquirectangularRefractionMapping = 304;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
var CubeUVReflectionMapping = 306;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
var RepeatWrapping = 1000;
exports.RepeatWrapping = RepeatWrapping;
var ClampToEdgeWrapping = 1001;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
var MirroredRepeatWrapping = 1002;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
var NearestFilter = 1003;
exports.NearestFilter = NearestFilter;
var NearestMipmapNearestFilter = 1004;
exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
var NearestMipMapNearestFilter = 1004;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
var NearestMipmapLinearFilter = 1005;
exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
var NearestMipMapLinearFilter = 1005;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
var LinearFilter = 1006;
exports.LinearFilter = LinearFilter;
var LinearMipmapNearestFilter = 1007;
exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
var LinearMipMapNearestFilter = 1007;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
var LinearMipmapLinearFilter = 1008;
exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
var LinearMipMapLinearFilter = 1008;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
var UnsignedByteType = 1009;
exports.UnsignedByteType = UnsignedByteType;
var ByteType = 1010;
exports.ByteType = ByteType;
var ShortType = 1011;
exports.ShortType = ShortType;
var UnsignedShortType = 1012;
exports.UnsignedShortType = UnsignedShortType;
var IntType = 1013;
exports.IntType = IntType;
var UnsignedIntType = 1014;
exports.UnsignedIntType = UnsignedIntType;
var FloatType = 1015;
exports.FloatType = FloatType;
var HalfFloatType = 1016;
exports.HalfFloatType = HalfFloatType;
var UnsignedShort4444Type = 1017;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
var UnsignedShort5551Type = 1018;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
var UnsignedInt248Type = 1020;
exports.UnsignedInt248Type = UnsignedInt248Type;
var AlphaFormat = 1021;
exports.AlphaFormat = AlphaFormat;
var RGBFormat = 1022;
exports.RGBFormat = RGBFormat;
var RGBAFormat = 1023;
exports.RGBAFormat = RGBAFormat;
var LuminanceFormat = 1024;
exports.LuminanceFormat = LuminanceFormat;
var LuminanceAlphaFormat = 1025;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
var DepthFormat = 1026;
exports.DepthFormat = DepthFormat;
var DepthStencilFormat = 1027;
exports.DepthStencilFormat = DepthStencilFormat;
var RedFormat = 1028;
exports.RedFormat = RedFormat;
var RedIntegerFormat = 1029;
exports.RedIntegerFormat = RedIntegerFormat;
var RGFormat = 1030;
exports.RGFormat = RGFormat;
var RGIntegerFormat = 1031;
exports.RGIntegerFormat = RGIntegerFormat;
var RGBAIntegerFormat = 1033;
exports.RGBAIntegerFormat = RGBAIntegerFormat;
var RGB_S3TC_DXT1_Format = 33776;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
var RGBA_S3TC_DXT1_Format = 33777;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
var RGBA_S3TC_DXT3_Format = 33778;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
var RGBA_S3TC_DXT5_Format = 33779;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
var RGB_PVRTC_4BPPV1_Format = 35840;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
var RGB_PVRTC_2BPPV1_Format = 35841;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
var RGBA_PVRTC_4BPPV1_Format = 35842;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
var RGBA_PVRTC_2BPPV1_Format = 35843;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
var RGB_ETC1_Format = 36196;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
var RGB_ETC2_Format = 37492;
exports.RGB_ETC2_Format = RGB_ETC2_Format;
var RGBA_ETC2_EAC_Format = 37496;
exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
var RGBA_ASTC_4x4_Format = 37808;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
var RGBA_ASTC_5x4_Format = 37809;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
var RGBA_ASTC_5x5_Format = 37810;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
var RGBA_ASTC_6x5_Format = 37811;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
var RGBA_ASTC_6x6_Format = 37812;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
var RGBA_ASTC_8x5_Format = 37813;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
var RGBA_ASTC_8x6_Format = 37814;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
var RGBA_ASTC_8x8_Format = 37815;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
var RGBA_ASTC_10x5_Format = 37816;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
var RGBA_ASTC_10x6_Format = 37817;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
var RGBA_ASTC_10x8_Format = 37818;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
var RGBA_ASTC_10x10_Format = 37819;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
var RGBA_ASTC_12x10_Format = 37820;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
var RGBA_ASTC_12x12_Format = 37821;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
var RGBA_BPTC_Format = 36492;
exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
var LoopOnce = 2200;
exports.LoopOnce = LoopOnce;
var LoopRepeat = 2201;
exports.LoopRepeat = LoopRepeat;
var LoopPingPong = 2202;
exports.LoopPingPong = LoopPingPong;
var InterpolateDiscrete = 2300;
exports.InterpolateDiscrete = InterpolateDiscrete;
var InterpolateLinear = 2301;
exports.InterpolateLinear = InterpolateLinear;
var InterpolateSmooth = 2302;
exports.InterpolateSmooth = InterpolateSmooth;
var ZeroCurvatureEnding = 2400;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
var ZeroSlopeEnding = 2401;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
var WrapAroundEnding = 2402;
exports.WrapAroundEnding = WrapAroundEnding;
var NormalAnimationBlendMode = 2500;
exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
var AdditiveAnimationBlendMode = 2501;
exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
var TrianglesDrawMode = 0;
exports.TrianglesDrawMode = TrianglesDrawMode;
var TriangleStripDrawMode = 1;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
var TriangleFanDrawMode = 2;
exports.TriangleFanDrawMode = TriangleFanDrawMode;
var LinearEncoding = 3000;
exports.LinearEncoding = LinearEncoding;
var sRGBEncoding = 3001;
exports.sRGBEncoding = sRGBEncoding;
var BasicDepthPacking = 3200;
exports.BasicDepthPacking = BasicDepthPacking;
var RGBADepthPacking = 3201;
exports.RGBADepthPacking = RGBADepthPacking;
var TangentSpaceNormalMap = 0;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
var ObjectSpaceNormalMap = 1; // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.

exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
var NoColorSpace = '';
exports.NoColorSpace = NoColorSpace;
var SRGBColorSpace = 'srgb';
exports.SRGBColorSpace = SRGBColorSpace;
var LinearSRGBColorSpace = 'srgb-linear';
exports.LinearSRGBColorSpace = LinearSRGBColorSpace;
var ZeroStencilOp = 0;
exports.ZeroStencilOp = ZeroStencilOp;
var KeepStencilOp = 7680;
exports.KeepStencilOp = KeepStencilOp;
var ReplaceStencilOp = 7681;
exports.ReplaceStencilOp = ReplaceStencilOp;
var IncrementStencilOp = 7682;
exports.IncrementStencilOp = IncrementStencilOp;
var DecrementStencilOp = 7683;
exports.DecrementStencilOp = DecrementStencilOp;
var IncrementWrapStencilOp = 34055;
exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
var DecrementWrapStencilOp = 34056;
exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
var InvertStencilOp = 5386;
exports.InvertStencilOp = InvertStencilOp;
var NeverStencilFunc = 512;
exports.NeverStencilFunc = NeverStencilFunc;
var LessStencilFunc = 513;
exports.LessStencilFunc = LessStencilFunc;
var EqualStencilFunc = 514;
exports.EqualStencilFunc = EqualStencilFunc;
var LessEqualStencilFunc = 515;
exports.LessEqualStencilFunc = LessEqualStencilFunc;
var GreaterStencilFunc = 516;
exports.GreaterStencilFunc = GreaterStencilFunc;
var NotEqualStencilFunc = 517;
exports.NotEqualStencilFunc = NotEqualStencilFunc;
var GreaterEqualStencilFunc = 518;
exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
var AlwaysStencilFunc = 519;
exports.AlwaysStencilFunc = AlwaysStencilFunc;
var StaticDrawUsage = 35044;
exports.StaticDrawUsage = StaticDrawUsage;
var DynamicDrawUsage = 35048;
exports.DynamicDrawUsage = DynamicDrawUsage;
var StreamDrawUsage = 35040;
exports.StreamDrawUsage = StreamDrawUsage;
var StaticReadUsage = 35045;
exports.StaticReadUsage = StaticReadUsage;
var DynamicReadUsage = 35049;
exports.DynamicReadUsage = DynamicReadUsage;
var StreamReadUsage = 35041;
exports.StreamReadUsage = StreamReadUsage;
var StaticCopyUsage = 35046;
exports.StaticCopyUsage = StaticCopyUsage;
var DynamicCopyUsage = 35050;
exports.DynamicCopyUsage = DynamicCopyUsage;
var StreamCopyUsage = 35042;
exports.StreamCopyUsage = StreamCopyUsage;
var GLSL1 = '100';
exports.GLSL1 = GLSL1;
var GLSL3 = '300 es';
exports.GLSL3 = GLSL3;
var _SRGBAFormat = 1035; // fallback for WebGL 1

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

exports._SRGBAFormat = _SRGBAFormat;

var EventDispatcher = /*#__PURE__*/function () {
  function EventDispatcher() {
    _classCallCheck(this, EventDispatcher);
  }

  _createClass(EventDispatcher, [{
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      if (this._listeners === undefined) this._listeners = {};
      var listeners = this._listeners;

      if (listeners[type] === undefined) {
        listeners[type] = [];
      }

      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    }
  }, {
    key: "hasEventListener",
    value: function hasEventListener(type, listener) {
      if (this._listeners === undefined) return false;
      var listeners = this._listeners;
      return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener) {
      if (this._listeners === undefined) return;
      var listeners = this._listeners;
      var listenerArray = listeners[type];

      if (listenerArray !== undefined) {
        var index = listenerArray.indexOf(listener);

        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (this._listeners === undefined) return;
      var listeners = this._listeners;
      var listenerArray = listeners[event.type];

      if (listenerArray !== undefined) {
        event.target = this; // Make a copy, in case listeners are removed while iterating.

        var array = listenerArray.slice(0);

        for (var i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }

        event.target = null;
      }
    }
  }]);

  return EventDispatcher;
}();

exports.EventDispatcher = EventDispatcher;
var _lut = [];

for (var i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);
}

var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

function generateUUID() {
  var d0 = Math.random() * 0xffffffff | 0;
  var d1 = Math.random() * 0xffffffff | 0;
  var d2 = Math.random() * 0xffffffff | 0;
  var d3 = Math.random() * 0xffffffff | 0;
  var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toLowerCase() here flattens concatenated strings to save heap memory space.

  return uuid.toLowerCase();
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
} // compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation


function euclideanModulo(n, m) {
  return (n % m + m) % m;
} // Linear mapping from range <a1, a2> to range <b1, b2>


function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/


function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
} // https://en.wikipedia.org/wiki/Linear_interpolation


function lerp(x, y, t) {
  return (1 - t) * x + t * y;
} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/


function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt));
} // https://www.desmos.com/calculator/vcsjnyz7x4


function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
} // http://en.wikipedia.org/wiki/Smoothstep


function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}

function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
} // Random integer from <low, high> interval


function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
} // Random float from <low, high> interval


function randFloat(low, high) {
  return low + Math.random() * (high - low);
} // Random float from <-range/2, range/2> interval


function randFloatSpread(range) {
  return range * (0.5 - Math.random());
} // Deterministic pseudo-random float in the interval [ 0, 1 ]


function seededRandom(s) {
  if (s !== undefined) _seed = s; // Mulberry32 generator

  var t = _seed += 0x6D2B79F5;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}

function degToRad(degrees) {
  return degrees * DEG2RAD;
}

function radToDeg(radians) {
  return radians * RAD2DEG;
}

function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}

function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}

function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}

function setQuaternionFromProperEuler(q, a, b, c, order) {
  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
  // rotations are applied to the axes in the order specified by 'order'
  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  // angles are in radians
  var cos = Math.cos;
  var sin = Math.sin;
  var c2 = cos(b / 2);
  var s2 = sin(b / 2);
  var c13 = cos((a + c) / 2);
  var s13 = sin((a + c) / 2);
  var c1_3 = cos((a - c) / 2);
  var s1_3 = sin((a - c) / 2);
  var c3_1 = cos((c - a) / 2);
  var s3_1 = sin((c - a) / 2);

  switch (order) {
    case 'XYX':
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;

    case 'YZY':
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;

    case 'ZXZ':
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;

    case 'XZX':
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;

    case 'YXY':
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;

    case 'ZYZ':
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;

    default:
      console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
  }
}

function denormalize$1(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;

    case Uint16Array:
      return value / 65535.0;

    case Uint8Array:
      return value / 255.0;

    case Int16Array:
      return Math.max(value / 32767.0, -1.0);

    case Int8Array:
      return Math.max(value / 127.0, -1.0);

    default:
      throw new Error('Invalid component type.');
  }
}

function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;

    case Uint16Array:
      return Math.round(value * 65535.0);

    case Uint8Array:
      return Math.round(value * 255.0);

    case Int16Array:
      return Math.round(value * 32767.0);

    case Int8Array:
      return Math.round(value * 127.0);

    default:
      throw new Error('Invalid component type.');
  }
}

var MathUtils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DEG2RAD: DEG2RAD,
  RAD2DEG: RAD2DEG,
  generateUUID: generateUUID,
  clamp: clamp,
  euclideanModulo: euclideanModulo,
  mapLinear: mapLinear,
  inverseLerp: inverseLerp,
  lerp: lerp,
  damp: damp,
  pingpong: pingpong,
  smoothstep: smoothstep,
  smootherstep: smootherstep,
  randInt: randInt,
  randFloat: randFloat,
  randFloatSpread: randFloatSpread,
  seededRandom: seededRandom,
  degToRad: degToRad,
  radToDeg: radToDeg,
  isPowerOfTwo: isPowerOfTwo,
  ceilPowerOfTwo: ceilPowerOfTwo,
  floorPowerOfTwo: floorPowerOfTwo,
  setQuaternionFromProperEuler: setQuaternionFromProperEuler,
  normalize: normalize,
  denormalize: denormalize$1
});
exports.MathUtils = exports.Math = MathUtils;

var Vector2 = /*#__PURE__*/function (_Symbol$iterator) {
  function Vector2(x = 0, y = 0) {
    _classCallCheck(this, Vector2);

    this.x = x;
    this.y = y;
  }

  _createClass(Vector2, [{
    key: "width",
    get: function get() {
      return this.x;
    },
    set: function set(value) {
      this.x = value;
    }
  }, {
    key: "height",
    get: function get() {
      return this.y;
    },
    set: function set(value) {
      this.y = value;
    }
  }, {
    key: "set",
    value: function set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
  }, {
    key: "setX",
    value: function setX(x) {
      this.x = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(y) {
      this.y = y;
      return this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;

        case 1:
          this.y = value;
          break;

        default:
          throw new Error('index is out of range: ' + index);
      }

      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;

        case 1:
          return this.y;

        default:
          throw new Error('index is out of range: ' + index);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y);
    }
  }, {
    key: "copy",
    value: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    }
  }, {
    key: "add",
    value: function add(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
        return this.addVectors(v, w);
      }

      this.x += v.x;
      this.y += v.y;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.x += s;
      this.y += s;
      return this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
        return this.subVectors(v, w);
      }

      this.x -= v.x;
      this.y -= v.y;
      return this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      return this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
  }, {
    key: "divide",
    value: function divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(m) {
      var x = this.x,
          y = this.y;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6];
      this.y = e[1] * x + e[4] * y + e[7];
      return this;
    }
  }, {
    key: "min",
    value: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    }
  }, {
    key: "max",
    value: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    }
  }, {
    key: "clamp",
    value: function clamp(min, max) {
      // assumes min < max, componentwise
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      return this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
  }, {
    key: "floor",
    value: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
  }, {
    key: "round",
    value: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this.x * v.x + this.y * v.y;
    }
  }, {
    key: "cross",
    value: function cross(v) {
      return this.x * v.y - this.y * v.x;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "angle",
    value: function angle() {
      // computes the angle in radians with respect to the positive x-axis
      var angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(v) {
      var dx = this.x - v.x,
          dy = this.y - v.y;
      return dx * dx + dy * dy;
    }
  }, {
    key: "manhattanDistanceTo",
    value: function manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
  }, {
    key: "setLength",
    value: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
  }, {
    key: "lerp",
    value: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(v) {
      return v.x === this.x && v.y === this.y;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index, offset) {
      if (offset !== undefined) {
        console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
      }

      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    }
  }, {
    key: "rotateAround",
    value: function rotateAround(center, angle) {
      var c = Math.cos(angle),
          s = Math.sin(angle);
      var x = this.x - center.x;
      var y = this.y - center.y;
      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;
      return this;
    }
  }, {
    key: "random",
    value: function random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
  }, {
    key: _Symbol$iterator,
    value: /*#__PURE__*/regeneratorRuntime.mark(function value() {
      return regeneratorRuntime.wrap(function value$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.x;

            case 2:
              _context2.next = 4;
              return this.y;

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, value, this);
    })
  }]);

  return Vector2;
}(Symbol.iterator);

exports.Vector2 = Vector2;
Vector2.prototype.isVector2 = true;

var Matrix3 = /*#__PURE__*/function () {
  function Matrix3() {
    _classCallCheck(this, Matrix3);

    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (arguments.length > 0) {
      console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
  }

  _createClass(Matrix3, [{
    key: "set",
    value: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      var te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
  }, {
    key: "identity",
    value: function identity() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(m) {
      var te = this.elements;
      var me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
  }, {
    key: "extractBasis",
    value: function extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
  }, {
    key: "setFromMatrix4",
    value: function setFromMatrix4(m) {
      var me = m.elements;
      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(m) {
      return this.multiplyMatrices(this, m);
    }
  }, {
    key: "premultiply",
    value: function premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
  }, {
    key: "multiplyMatrices",
    value: function multiplyMatrices(a, b) {
      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;
      var a11 = ae[0],
          a12 = ae[3],
          a13 = ae[6];
      var a21 = ae[1],
          a22 = ae[4],
          a23 = ae[7];
      var a31 = ae[2],
          a32 = ae[5],
          a33 = ae[8];
      var b11 = be[0],
          b12 = be[3],
          b13 = be[6];
      var b21 = be[1],
          b22 = be[4],
          b23 = be[7];
      var b31 = be[2],
          b32 = be[5],
          b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(s) {
      var te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      var te = this.elements;
      var a = te[0],
          b = te[1],
          c = te[2],
          d = te[3],
          e = te[4],
          f = te[5],
          g = te[6],
          h = te[7],
          i = te[8];
      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    }
  }, {
    key: "invert",
    value: function invert() {
      var te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n12 = te[3],
          n22 = te[4],
          n32 = te[5],
          n13 = te[6],
          n23 = te[7],
          n33 = te[8],
          t11 = n33 * n22 - n32 * n23,
          t12 = n32 * n13 - n33 * n12,
          t13 = n23 * n12 - n22 * n13,
          det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      var detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var tmp;
      var m = this.elements;
      tmp = m[1];
      m[1] = m[3];
      m[3] = tmp;
      tmp = m[2];
      m[2] = m[6];
      m[6] = tmp;
      tmp = m[5];
      m[5] = m[7];
      m[7] = tmp;
      return this;
    }
  }, {
    key: "getNormalMatrix",
    value: function getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
  }, {
    key: "transposeIntoArray",
    value: function transposeIntoArray(r) {
      var m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    }
  }, {
    key: "setUvTransform",
    value: function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      var c = Math.cos(rotation);
      var s = Math.sin(rotation);
      this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
      return this;
    }
  }, {
    key: "scale",
    value: function scale(sx, sy) {
      var te = this.elements;
      te[0] *= sx;
      te[3] *= sx;
      te[6] *= sx;
      te[1] *= sy;
      te[4] *= sy;
      te[7] *= sy;
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(theta) {
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var te = this.elements;
      var a11 = te[0],
          a12 = te[3],
          a13 = te[6];
      var a21 = te[1],
          a22 = te[4],
          a23 = te[7];
      te[0] = c * a11 + s * a21;
      te[3] = c * a12 + s * a22;
      te[6] = c * a13 + s * a23;
      te[1] = -s * a11 + c * a21;
      te[4] = -s * a12 + c * a22;
      te[7] = -s * a13 + c * a23;
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      var te = this.elements;
      te[0] += tx * te[2];
      te[3] += tx * te[5];
      te[6] += tx * te[8];
      te[1] += ty * te[2];
      te[4] += ty * te[5];
      te[7] += ty * te[8];
      return this;
    }
  }, {
    key: "equals",
    value: function equals(matrix) {
      var te = this.elements;
      var me = matrix.elements;

      for (var _i = 0; _i < 9; _i++) {
        if (te[_i] !== me[_i]) return false;
      }

      return true;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array, offset = 0) {
      for (var _i2 = 0; _i2 < 9; _i2++) {
        this.elements[_i2] = array[_i2 + offset];
      }

      return this;
    }
  }, {
    key: "toArray",
    value: function toArray(array = [], offset = 0) {
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }]);

  return Matrix3;
}();

exports.Matrix3 = Matrix3;
Matrix3.prototype.isMatrix3 = true;

function arrayNeedsUint32(array) {
  // assumes larger values usually on last
  for (var _i3 = array.length - 1; _i3 >= 0; --_i3) {
    if (array[_i3] > 65535) return true;
  }

  return false;
}

var TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray: Uint8ClampedArray,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};

function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}

function createElementNS(name) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', name);
}

function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}

function LinearToSRGB(c) {
  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
} // JavaScript RGB-to-RGB transforms, defined as
// FN[InputColorSpace][OutputColorSpace] callback functions.


var FN = (_FN = {}, _defineProperty(_FN, SRGBColorSpace, _defineProperty({}, LinearSRGBColorSpace, SRGBToLinear)), _defineProperty(_FN, LinearSRGBColorSpace, _defineProperty({}, SRGBColorSpace, LinearToSRGB)), _FN);
var ColorManagement = {
  legacyMode: true,

  get workingColorSpace() {
    return LinearSRGBColorSpace;
  },

  set workingColorSpace(colorSpace) {
    console.warn('THREE.ColorManagement: .workingColorSpace is readonly.');
  },

  convert: function convert(color, sourceColorSpace, targetColorSpace) {
    if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color;
    }

    if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== undefined) {
      var fn = FN[sourceColorSpace][targetColorSpace];
      color.r = fn(color.r);
      color.g = fn(color.g);
      color.b = fn(color.b);
      return color;
    }

    throw new Error('Unsupported color space conversion.');
  },
  fromWorkingColorSpace: function fromWorkingColorSpace(color, targetColorSpace) {
    return this.convert(color, this.workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function toWorkingColorSpace(color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this.workingColorSpace);
  }
};
exports.ColorManagement = ColorManagement;
var _colorKeywords = {
  'aliceblue': 0xF0F8FF,
  'antiquewhite': 0xFAEBD7,
  'aqua': 0x00FFFF,
  'aquamarine': 0x7FFFD4,
  'azure': 0xF0FFFF,
  'beige': 0xF5F5DC,
  'bisque': 0xFFE4C4,
  'black': 0x000000,
  'blanchedalmond': 0xFFEBCD,
  'blue': 0x0000FF,
  'blueviolet': 0x8A2BE2,
  'brown': 0xA52A2A,
  'burlywood': 0xDEB887,
  'cadetblue': 0x5F9EA0,
  'chartreuse': 0x7FFF00,
  'chocolate': 0xD2691E,
  'coral': 0xFF7F50,
  'cornflowerblue': 0x6495ED,
  'cornsilk': 0xFFF8DC,
  'crimson': 0xDC143C,
  'cyan': 0x00FFFF,
  'darkblue': 0x00008B,
  'darkcyan': 0x008B8B,
  'darkgoldenrod': 0xB8860B,
  'darkgray': 0xA9A9A9,
  'darkgreen': 0x006400,
  'darkgrey': 0xA9A9A9,
  'darkkhaki': 0xBDB76B,
  'darkmagenta': 0x8B008B,
  'darkolivegreen': 0x556B2F,
  'darkorange': 0xFF8C00,
  'darkorchid': 0x9932CC,
  'darkred': 0x8B0000,
  'darksalmon': 0xE9967A,
  'darkseagreen': 0x8FBC8F,
  'darkslateblue': 0x483D8B,
  'darkslategray': 0x2F4F4F,
  'darkslategrey': 0x2F4F4F,
  'darkturquoise': 0x00CED1,
  'darkviolet': 0x9400D3,
  'deeppink': 0xFF1493,
  'deepskyblue': 0x00BFFF,
  'dimgray': 0x696969,
  'dimgrey': 0x696969,
  'dodgerblue': 0x1E90FF,
  'firebrick': 0xB22222,
  'floralwhite': 0xFFFAF0,
  'forestgreen': 0x228B22,
  'fuchsia': 0xFF00FF,
  'gainsboro': 0xDCDCDC,
  'ghostwhite': 0xF8F8FF,
  'gold': 0xFFD700,
  'goldenrod': 0xDAA520,
  'gray': 0x808080,
  'green': 0x008000,
  'greenyellow': 0xADFF2F,
  'grey': 0x808080,
  'honeydew': 0xF0FFF0,
  'hotpink': 0xFF69B4,
  'indianred': 0xCD5C5C,
  'indigo': 0x4B0082,
  'ivory': 0xFFFFF0,
  'khaki': 0xF0E68C,
  'lavender': 0xE6E6FA,
  'lavenderblush': 0xFFF0F5,
  'lawngreen': 0x7CFC00,
  'lemonchiffon': 0xFFFACD,
  'lightblue': 0xADD8E6,
  'lightcoral': 0xF08080,
  'lightcyan': 0xE0FFFF,
  'lightgoldenrodyellow': 0xFAFAD2,
  'lightgray': 0xD3D3D3,
  'lightgreen': 0x90EE90,
  'lightgrey': 0xD3D3D3,
  'lightpink': 0xFFB6C1,
  'lightsalmon': 0xFFA07A,
  'lightseagreen': 0x20B2AA,
  'lightskyblue': 0x87CEFA,
  'lightslategray': 0x778899,
  'lightslategrey': 0x778899,
  'lightsteelblue': 0xB0C4DE,
  'lightyellow': 0xFFFFE0,
  'lime': 0x00FF00,
  'limegreen': 0x32CD32,
  'linen': 0xFAF0E6,
  'magenta': 0xFF00FF,
  'maroon': 0x800000,
  'mediumaquamarine': 0x66CDAA,
  'mediumblue': 0x0000CD,
  'mediumorchid': 0xBA55D3,
  'mediumpurple': 0x9370DB,
  'mediumseagreen': 0x3CB371,
  'mediumslateblue': 0x7B68EE,
  'mediumspringgreen': 0x00FA9A,
  'mediumturquoise': 0x48D1CC,
  'mediumvioletred': 0xC71585,
  'midnightblue': 0x191970,
  'mintcream': 0xF5FFFA,
  'mistyrose': 0xFFE4E1,
  'moccasin': 0xFFE4B5,
  'navajowhite': 0xFFDEAD,
  'navy': 0x000080,
  'oldlace': 0xFDF5E6,
  'olive': 0x808000,
  'olivedrab': 0x6B8E23,
  'orange': 0xFFA500,
  'orangered': 0xFF4500,
  'orchid': 0xDA70D6,
  'palegoldenrod': 0xEEE8AA,
  'palegreen': 0x98FB98,
  'paleturquoise': 0xAFEEEE,
  'palevioletred': 0xDB7093,
  'papayawhip': 0xFFEFD5,
  'peachpuff': 0xFFDAB9,
  'peru': 0xCD853F,
  'pink': 0xFFC0CB,
  'plum': 0xDDA0DD,
  'powderblue': 0xB0E0E6,
  'purple': 0x800080,
  'rebeccapurple': 0x663399,
  'red': 0xFF0000,
  'rosybrown': 0xBC8F8F,
  'royalblue': 0x4169E1,
  'saddlebrown': 0x8B4513,
  'salmon': 0xFA8072,
  'sandybrown': 0xF4A460,
  'seagreen': 0x2E8B57,
  'seashell': 0xFFF5EE,
  'sienna': 0xA0522D,
  'silver': 0xC0C0C0,
  'skyblue': 0x87CEEB,
  'slateblue': 0x6A5ACD,
  'slategray': 0x708090,
  'slategrey': 0x708090,
  'snow': 0xFFFAFA,
  'springgreen': 0x00FF7F,
  'steelblue': 0x4682B4,
  'tan': 0xD2B48C,
  'teal': 0x008080,
  'thistle': 0xD8BFD8,
  'tomato': 0xFF6347,
  'turquoise': 0x40E0D0,
  'violet': 0xEE82EE,
  'wheat': 0xF5DEB3,
  'white': 0xFFFFFF,
  'whitesmoke': 0xF5F5F5,
  'yellow': 0xFFFF00,
  'yellowgreen': 0x9ACD32
};
var _rgb = {
  r: 0,
  g: 0,
  b: 0
};
var _hslA = {
  h: 0,
  s: 0,
  l: 0
};
var _hslB = {
  h: 0,
  s: 0,
  l: 0
};

function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}

function toComponents(source, target) {
  target.r = source.r;
  target.g = source.g;
  target.b = source.b;
  return target;
}

var Color = /*#__PURE__*/function () {
  function Color(r, g, b) {
    _classCallCheck(this, Color);

    if (g === undefined && b === undefined) {
      // r is THREE.Color, hex or string
      return this.set(r);
    }

    return this.setRGB(r, g, b);
  }

  _createClass(Color, [{
    key: "set",
    value: function set(value) {
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === 'number') {
        this.setHex(value);
      } else if (typeof value === 'string') {
        this.setStyle(value);
      }

      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
  }, {
    key: "setHex",
    value: function setHex(hex, colorSpace = SRGBColorSpace) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
  }, {
    key: "setRGB",
    value: function setRGB(r, g, b, colorSpace = LinearSRGBColorSpace) {
      this.r = r;
      this.g = g;
      this.b = b;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
  }, {
    key: "setHSL",
    value: function setHSL(h, s, l, colorSpace = LinearSRGBColorSpace) {
      // h,s,l ranges are in 0.0 - 1.0
      h = euclideanModulo(h, 1);
      s = clamp(s, 0, 1);
      l = clamp(l, 0, 1);

      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        var q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }

      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
  }, {
    key: "setStyle",
    value: function setStyle(style, colorSpace = SRGBColorSpace) {
      function handleAlpha(string) {
        if (string === undefined) return;

        if (parseFloat(string) < 1) {
          console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
        }
      }

      var m;

      if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
        // rgb / hsl
        var color;
        var name = m[1];
        var components = m[2];

        switch (name) {
          case 'rgb':
          case 'rgba':
            if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              // rgb(255,0,0) rgba(255,0,0,0.5)
              this.r = Math.min(255, parseInt(color[1], 10)) / 255;
              this.g = Math.min(255, parseInt(color[2], 10)) / 255;
              this.b = Math.min(255, parseInt(color[3], 10)) / 255;
              ColorManagement.toWorkingColorSpace(this, colorSpace);
              handleAlpha(color[4]);
              return this;
            }

            if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
              this.r = Math.min(100, parseInt(color[1], 10)) / 100;
              this.g = Math.min(100, parseInt(color[2], 10)) / 100;
              this.b = Math.min(100, parseInt(color[3], 10)) / 100;
              ColorManagement.toWorkingColorSpace(this, colorSpace);
              handleAlpha(color[4]);
              return this;
            }

            break;

          case 'hsl':
          case 'hsla':
            if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
              var h = parseFloat(color[1]) / 360;
              var s = parseInt(color[2], 10) / 100;
              var l = parseInt(color[3], 10) / 100;
              handleAlpha(color[4]);
              return this.setHSL(h, s, l, colorSpace);
            }

            break;
        }
      } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
        // hex color
        var hex = m[1];
        var size = hex.length;

        if (size === 3) {
          // #ff0
          this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
          this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
          this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        } else if (size === 6) {
          // #ff0000
          this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
          this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
          this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
          ColorManagement.toWorkingColorSpace(this, colorSpace);
          return this;
        }
      }

      if (style && style.length > 0) {
        return this.setColorName(style, colorSpace);
      }

      return this;
    }
  }, {
    key: "setColorName",
    value: function setColorName(style, colorSpace = SRGBColorSpace) {
      // color keywords
      var hex = _colorKeywords[style.toLowerCase()];

      if (hex !== undefined) {
        // red
        this.setHex(hex, colorSpace);
      } else {
        // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
      }

      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
  }, {
    key: "copy",
    value: function copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
  }, {
    key: "copySRGBToLinear",
    value: function copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
  }, {
    key: "copyLinearToSRGB",
    value: function copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
  }, {
    key: "convertSRGBToLinear",
    value: function convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
  }, {
    key: "convertLinearToSRGB",
    value: function convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
  }, {
    key: "getHex",
    value: function getHex(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
      return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;
    }
  }, {
    key: "getHexString",
    value: function getHexString(colorSpace = SRGBColorSpace) {
      return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6);
    }
  }, {
    key: "getHSL",
    value: function getHSL(target, colorSpace = LinearSRGBColorSpace) {
      // h,s,l ranges are in 0.0 - 1.0
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
      var r = _rgb.r,
          g = _rgb.g,
          b = _rgb.b;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var hue, saturation;
      var lightness = (min + max) / 2.0;

      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        var delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

        switch (max) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;

          case g:
            hue = (b - r) / delta + 2;
            break;

          case b:
            hue = (r - g) / delta + 4;
            break;
        }

        hue /= 6;
      }

      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
  }, {
    key: "getRGB",
    value: function getRGB(target, colorSpace = LinearSRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
      target.r = _rgb.r;
      target.g = _rgb.g;
      target.b = _rgb.b;
      return target;
    }
  }, {
    key: "getStyle",
    value: function getStyle(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);

      if (colorSpace !== SRGBColorSpace) {
        // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
        return "color(".concat(colorSpace, " ").concat(_rgb.r, " ").concat(_rgb.g, " ").concat(_rgb.b, ")");
      }

      return "rgb(".concat(_rgb.r * 255 | 0, ",").concat(_rgb.g * 255 | 0, ",").concat(_rgb.b * 255 | 0, ")");
    }
  }, {
    key: "offsetHSL",
    value: function offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      _hslA.h += h;
      _hslA.s += s;
      _hslA.l += l;
      this.setHSL(_hslA.h, _hslA.s, _hslA.l);
      return this;
    }
  }, {
    key: "add",
    value: function add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
  }, {
    key: "addColors",
    value: function addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
  }, {
    key: "lerp",
    value: function lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
  }, {
    key: "lerpColors",
    value: function lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
  }, {
    key: "lerpHSL",
    value: function lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      var h = lerp(_hslA.h, _hslB.h, alpha);
      var s = lerp(_hslA.s, _hslB.s, alpha);
      var l = lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array, offset = 0) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray(array = [], offset = 0) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);

      if (attribute.normalized === true) {
        // assuming Uint8Array
        this.r /= 255;
        this.g /= 255;
        this.b /= 255;
      }

      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.getHex();
    }
  }]);

  return Color;
}();

exports.Color = Color;
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;

var _canvas;

var ImageUtils = /*#__PURE__*/function () {
  function ImageUtils() {
    _classCallCheck(this, ImageUtils);
  }

  _createClass(ImageUtils, null, [{
    key: "getDataURL",
    value: function getDataURL(image) {
      if (/^data:/i.test(image.src)) {
        return image.src;
      }

      if (typeof HTMLCanvasElement == 'undefined') {
        return image.src;
      }

      var canvas;

      if (image instanceof HTMLCanvasElement) {
        canvas = image;
      } else {
        if (_canvas === undefined) _canvas = createElementNS('canvas');
        _canvas.width = image.width;
        _canvas.height = image.height;

        var context = _canvas.getContext('2d');

        if (image instanceof ImageData) {
          context.putImageData(image, 0, 0);
        } else {
          context.drawImage(image, 0, 0, image.width, image.height);
        }

        canvas = _canvas;
      }

      if (canvas.width > 2048 || canvas.height > 2048) {
        console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
        return canvas.toDataURL('image/jpeg', 0.6);
      } else {
        return canvas.toDataURL('image/png');
      }
    }
  }, {
    key: "sRGBToLinear",
    value: function sRGBToLinear(image) {
      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        var canvas = createElementNS('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, image.width, image.height);
        var imageData = context.getImageData(0, 0, image.width, image.height);
        var data = imageData.data;

        for (var _i4 = 0; _i4 < data.length; _i4++) {
          data[_i4] = SRGBToLinear(data[_i4] / 255) * 255;
        }

        context.putImageData(imageData, 0, 0);
        return canvas;
      } else if (image.data) {
        var _data = image.data.slice(0);

        for (var _i5 = 0; _i5 < _data.length; _i5++) {
          if (_data instanceof Uint8Array || _data instanceof Uint8ClampedArray) {
            _data[_i5] = Math.floor(SRGBToLinear(_data[_i5] / 255) * 255);
          } else {
            // assuming float
            _data[_i5] = SRGBToLinear(_data[_i5]);
          }
        }

        return {
          data: _data,
          width: image.width,
          height: image.height
        };
      } else {
        console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');
        return image;
      }
    }
  }]);

  return ImageUtils;
}();

exports.ImageUtils = ImageUtils;

var Source = /*#__PURE__*/function () {
  function Source(data = null) {
    _classCallCheck(this, Source);

    this.uuid = generateUUID();
    this.data = data;
    this.version = 0;
  }

  _createClass(Source, [{
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var isRootObject = meta === undefined || typeof meta === 'string';

      if (!isRootObject && meta.images[this.uuid] !== undefined) {
        return meta.images[this.uuid];
      }

      var output = {
        uuid: this.uuid,
        url: ''
      };
      var data = this.data;

      if (data !== null) {
        var url;

        if (Array.isArray(data)) {
          // cube texture
          url = [];

          for (var _i6 = 0, l = data.length; _i6 < l; _i6++) {
            if (data[_i6].isDataTexture) {
              url.push(serializeImage(data[_i6].image));
            } else {
              url.push(serializeImage(data[_i6]));
            }
          }
        } else {
          // texture
          url = serializeImage(data);
        }

        output.url = url;
      }

      if (!isRootObject) {
        meta.images[this.uuid] = output;
      }

      return output;
    }
  }]);

  return Source;
}();

exports.Source = Source;

function serializeImage(image) {
  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    // default images
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      // images of DataTexture
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn('THREE.Texture: Unable to serialize Texture.');
      return {};
    }
  }
}

Source.prototype.isSource = true;
var textureId = 0;

var Texture = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Texture, _EventDispatcher);

  var _super = _createSuper(Texture);

  function Texture(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    var _this2;

    _classCallCheck(this, Texture);

    _this2 = _super.call(this);
    Object.defineProperty(_assertThisInitialized(_this2), 'id', {
      value: textureId++
    });
    _this2.uuid = generateUUID();
    _this2.name = '';
    _this2.source = new Source(image);
    _this2.mipmaps = [];
    _this2.mapping = mapping;
    _this2.wrapS = wrapS;
    _this2.wrapT = wrapT;
    _this2.magFilter = magFilter;
    _this2.minFilter = minFilter;
    _this2.anisotropy = anisotropy;
    _this2.format = format;
    _this2.internalFormat = null;
    _this2.type = type;
    _this2.offset = new Vector2(0, 0);
    _this2.repeat = new Vector2(1, 1);
    _this2.center = new Vector2(0, 0);
    _this2.rotation = 0;
    _this2.matrixAutoUpdate = true;
    _this2.matrix = new Matrix3();
    _this2.generateMipmaps = true;
    _this2.premultiplyAlpha = false;
    _this2.flipY = true;
    _this2.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    //
    // Also changing the encoding after already used by a Material will not automatically make the Material
    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

    _this2.encoding = encoding;
    _this2.userData = {};
    _this2.version = 0;
    _this2.onUpdate = null;
    _this2.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not

    _this2.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

    return _this2;
  }

  _createClass(Texture, [{
    key: "image",
    get: function get() {
      return this.source.data;
    },
    set: function set(value) {
      this.source.data = value;
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.name = source.name;
      this.source = source.source;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.encoding = source.encoding;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      this.needsUpdate = true;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var isRootObject = meta === undefined || typeof meta === 'string';

      if (!isRootObject && meta.textures[this.uuid] !== undefined) {
        return meta.textures[this.uuid];
      }

      var output = {
        metadata: {
          version: 4.5,
          type: 'Texture',
          generator: 'Texture.toJSON'
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(meta).uuid,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (JSON.stringify(this.userData) !== '{}') output.userData = this.userData;

      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }

      return output;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }, {
    key: "transformUv",
    value: function transformUv(uv) {
      if (this.mapping !== UVMapping) return uv;
      uv.applyMatrix3(this.matrix);

      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;

          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;

          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }

            break;
        }
      }

      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;

          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;

          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }

            break;
        }
      }

      if (this.flipY) {
        uv.y = 1 - uv.y;
      }

      return uv;
    }
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) {
        this.version++;
        this.source.needsUpdate = true;
      }
    }
  }]);

  return Texture;
}(EventDispatcher);

exports.Texture = Texture;
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;

var Vector4 = /*#__PURE__*/function (_Symbol$iterator2) {
  function Vector4(x = 0, y = 0, z = 0, w = 1) {
    _classCallCheck(this, Vector4);

    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }

  _createClass(Vector4, [{
    key: "width",
    get: function get() {
      return this.z;
    },
    set: function set(value) {
      this.z = value;
    }
  }, {
    key: "height",
    get: function get() {
      return this.w;
    },
    set: function set(value) {
      this.w = value;
    }
  }, {
    key: "set",
    value: function set(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    }
  }, {
    key: "setX",
    value: function setX(x) {
      this.x = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(y) {
      this.y = y;
      return this;
    }
  }, {
    key: "setZ",
    value: function setZ(z) {
      this.z = z;
      return this;
    }
  }, {
    key: "setW",
    value: function setW(w) {
      this.w = w;
      return this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;

        case 1:
          this.y = value;
          break;

        case 2:
          this.z = value;
          break;

        case 3:
          this.w = value;
          break;

        default:
          throw new Error('index is out of range: ' + index);
      }

      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;

        case 1:
          return this.y;

        case 2:
          return this.z;

        case 3:
          return this.w;

        default:
          throw new Error('index is out of range: ' + index);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
  }, {
    key: "copy",
    value: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w !== undefined ? v.w : 1;
      return this;
    }
  }, {
    key: "add",
    value: function add(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
        return this.addVectors(v, w);
      }

      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;
      return this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
        return this.subVectors(v, w);
      }

      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;
      return this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      this.w *= v.w;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
  }, {
    key: "setAxisAngleFromQuaternion",
    value: function setAxisAngleFromQuaternion(q) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
      // q is assumed to be normalized
      this.w = 2 * Math.acos(q.w);
      var s = Math.sqrt(1 - q.w * q.w);

      if (s < 0.0001) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;
      }

      return this;
    }
  }, {
    key: "setAxisAngleFromRotationMatrix",
    value: function setAxisAngleFromRotationMatrix(m) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
      var angle, x, y, z; // variables for result

      var epsilon = 0.01,
          // margin to allow for rounding errors
      epsilon2 = 0.1,
          // margin to distinguish between 0 and 180 degrees
      te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10];

      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        // singularity found
        // first check for identity matrix which must have +1 for all terms
        // in leading diagonal and zero in other terms
        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          // this singularity is identity matrix so angle = 0
          this.set(1, 0, 0, 0);
          return this; // zero angle, arbitrary axis
        } // otherwise this singularity is angle = 180


        angle = Math.PI;
        var xx = (m11 + 1) / 2;
        var yy = (m22 + 1) / 2;
        var zz = (m33 + 1) / 2;
        var xy = (m12 + m21) / 4;
        var xz = (m13 + m31) / 4;
        var yz = (m23 + m32) / 4;

        if (xx > yy && xx > zz) {
          // m11 is the largest diagonal term
          if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
          }
        } else if (yy > zz) {
          // m22 is the largest diagonal term
          if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
          }
        } else {
          // m33 is the largest diagonal term so base result on this
          if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
          }
        }

        this.set(x, y, z, angle);
        return this; // return 180 deg rotation
      } // as we have reached here there are no singularities so we can handle normally


      var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

      if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
      // caught by singularity test above, but I've left it in just in case

      this.x = (m32 - m23) / s;
      this.y = (m13 - m31) / s;
      this.z = (m21 - m12) / s;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    }
  }, {
    key: "min",
    value: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    }
  }, {
    key: "max",
    value: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    }
  }, {
    key: "clamp",
    value: function clamp(min, max) {
      // assumes min < max, componentwise
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      this.w = Math.max(minVal, Math.min(maxVal, this.w));
      return this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
  }, {
    key: "floor",
    value: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    }
  }, {
    key: "round",
    value: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "setLength",
    value: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
  }, {
    key: "lerp",
    value: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      this.w = v1.w + (v2.w - v1.w) * alpha;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index, offset) {
      if (offset !== undefined) {
        console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
      }

      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
  }, {
    key: "random",
    value: function random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      this.w = Math.random();
      return this;
    }
  }, {
    key: _Symbol$iterator2,
    value: /*#__PURE__*/regeneratorRuntime.mark(function value() {
      return regeneratorRuntime.wrap(function value$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.x;

            case 2:
              _context3.next = 4;
              return this.y;

            case 4:
              _context3.next = 6;
              return this.z;

            case 6:
              _context3.next = 8;
              return this.w;

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, value, this);
    })
  }]);

  return Vector4;
}(Symbol.iterator);

exports.Vector4 = Vector4;
Vector4.prototype.isVector4 = true;
/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/

var WebGLRenderTarget = /*#__PURE__*/function (_EventDispatcher2) {
  _inherits(WebGLRenderTarget, _EventDispatcher2);

  var _super2 = _createSuper(WebGLRenderTarget);

  function WebGLRenderTarget(width, height, options = {}) {
    var _this3;

    _classCallCheck(this, WebGLRenderTarget);

    _this3 = _super2.call(this);
    _this3.width = width;
    _this3.height = height;
    _this3.depth = 1;
    _this3.scissor = new Vector4(0, 0, width, height);
    _this3.scissorTest = false;
    _this3.viewport = new Vector4(0, 0, width, height);
    var image = {
      width: width,
      height: height,
      depth: 1
    };
    _this3.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    _this3.texture.isRenderTargetTexture = true;
    _this3.texture.flipY = false;
    _this3.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    _this3.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
    _this3.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    _this3.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    _this3.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
    _this3.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    _this3.samples = options.samples !== undefined ? options.samples : 0;
    return _this3;
  }

  _createClass(WebGLRenderTarget, [{
    key: "setSize",
    value: function setSize(width, height, depth = 1) {
      if (this.width !== width || this.height !== height || this.depth !== depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.texture.image.width = width;
        this.texture.image.height = height;
        this.texture.image.depth = depth;
        this.dispose();
      }

      this.viewport.set(0, 0, width, height);
      this.scissor.set(0, 0, width, height);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.viewport.copy(source.viewport);
      this.texture = source.texture.clone();
      this.texture.isRenderTargetTexture = true; // ensure image object is not shared, see #20328

      this.texture.image = Object.assign({}, source.texture.image);
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
      this.samples = source.samples;
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }]);

  return WebGLRenderTarget;
}(EventDispatcher);

exports.WebGLRenderTarget = WebGLRenderTarget;
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

var DataArrayTexture = /*#__PURE__*/function (_Texture) {
  _inherits(DataArrayTexture, _Texture);

  var _super3 = _createSuper(DataArrayTexture);

  function DataArrayTexture(data = null, width = 1, height = 1, depth = 1) {
    var _this4;

    _classCallCheck(this, DataArrayTexture);

    _this4 = _super3.call(this, null);
    _this4.image = {
      data: data,
      width: width,
      height: height,
      depth: depth
    };
    _this4.magFilter = NearestFilter;
    _this4.minFilter = NearestFilter;
    _this4.wrapR = ClampToEdgeWrapping;
    _this4.generateMipmaps = false;
    _this4.flipY = false;
    _this4.unpackAlignment = 1;
    return _this4;
  }

  return _createClass(DataArrayTexture);
}(Texture);

exports.DataArrayTexture = DataArrayTexture;
DataArrayTexture.prototype.isDataArrayTexture = true;

var WebGLArrayRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget) {
  _inherits(WebGLArrayRenderTarget, _WebGLRenderTarget);

  var _super4 = _createSuper(WebGLArrayRenderTarget);

  function WebGLArrayRenderTarget(width, height, depth) {
    var _this5;

    _classCallCheck(this, WebGLArrayRenderTarget);

    _this5 = _super4.call(this, width, height);
    _this5.depth = depth;
    _this5.texture = new DataArrayTexture(null, width, height, depth);
    _this5.texture.isRenderTargetTexture = true;
    return _this5;
  }

  return _createClass(WebGLArrayRenderTarget);
}(WebGLRenderTarget);

exports.WebGLArrayRenderTarget = WebGLArrayRenderTarget;
WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = true;

var Data3DTexture = /*#__PURE__*/function (_Texture2) {
  _inherits(Data3DTexture, _Texture2);

  var _super5 = _createSuper(Data3DTexture);

  function Data3DTexture(data = null, width = 1, height = 1, depth = 1) {
    var _this6;

    _classCallCheck(this, Data3DTexture);

    // We're going to add .setXXX() methods for setting properties later.
    // Users can still set in DataTexture3D directly.
    //
    //	const texture = new THREE.DataTexture3D( data, width, height, depth );
    // 	texture.anisotropy = 16;
    //
    // See #14839
    _this6 = _super5.call(this, null);
    _this6.image = {
      data: data,
      width: width,
      height: height,
      depth: depth
    };
    _this6.magFilter = NearestFilter;
    _this6.minFilter = NearestFilter;
    _this6.wrapR = ClampToEdgeWrapping;
    _this6.generateMipmaps = false;
    _this6.flipY = false;
    _this6.unpackAlignment = 1;
    return _this6;
  }

  return _createClass(Data3DTexture);
}(Texture);

exports.Data3DTexture = Data3DTexture;
Data3DTexture.prototype.isData3DTexture = true;

var WebGL3DRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget2) {
  _inherits(WebGL3DRenderTarget, _WebGLRenderTarget2);

  var _super6 = _createSuper(WebGL3DRenderTarget);

  function WebGL3DRenderTarget(width, height, depth) {
    var _this7;

    _classCallCheck(this, WebGL3DRenderTarget);

    _this7 = _super6.call(this, width, height);
    _this7.depth = depth;
    _this7.texture = new Data3DTexture(null, width, height, depth);
    _this7.texture.isRenderTargetTexture = true;
    return _this7;
  }

  return _createClass(WebGL3DRenderTarget);
}(WebGLRenderTarget);

exports.WebGL3DRenderTarget = WebGL3DRenderTarget;
WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = true;

var WebGLMultipleRenderTargets = /*#__PURE__*/function (_WebGLRenderTarget3) {
  _inherits(WebGLMultipleRenderTargets, _WebGLRenderTarget3);

  var _super7 = _createSuper(WebGLMultipleRenderTargets);

  function WebGLMultipleRenderTargets(width, height, count, options = {}) {
    var _this8;

    _classCallCheck(this, WebGLMultipleRenderTargets);

    _this8 = _super7.call(this, width, height, options);
    var texture = _this8.texture;
    _this8.texture = [];

    for (var _i7 = 0; _i7 < count; _i7++) {
      _this8.texture[_i7] = texture.clone();
      _this8.texture[_i7].isRenderTargetTexture = true;
    }

    return _this8;
  }

  _createClass(WebGLMultipleRenderTargets, [{
    key: "setSize",
    value: function setSize(width, height, depth = 1) {
      if (this.width !== width || this.height !== height || this.depth !== depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;

        for (var _i8 = 0, il = this.texture.length; _i8 < il; _i8++) {
          this.texture[_i8].image.width = width;
          this.texture[_i8].image.height = height;
          this.texture[_i8].image.depth = depth;
        }

        this.dispose();
      }

      this.viewport.set(0, 0, width, height);
      this.scissor.set(0, 0, width, height);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.dispose();
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.viewport.set(0, 0, this.width, this.height);
      this.scissor.set(0, 0, this.width, this.height);
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.depthTexture = source.depthTexture;
      this.texture.length = 0;

      for (var _i9 = 0, il = source.texture.length; _i9 < il; _i9++) {
        this.texture[_i9] = source.texture[_i9].clone();
      }

      return this;
    }
  }]);

  return WebGLMultipleRenderTargets;
}(WebGLRenderTarget);

exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;

var Quaternion = /*#__PURE__*/function () {
  function Quaternion(x = 0, y = 0, z = 0, w = 1) {
    _classCallCheck(this, Quaternion);

    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }

  _createClass(Quaternion, [{
    key: "x",
    get: function get() {
      return this._x;
    },
    set: function set(value) {
      this._x = value;

      this._onChangeCallback();
    }
  }, {
    key: "y",
    get: function get() {
      return this._y;
    },
    set: function set(value) {
      this._y = value;

      this._onChangeCallback();
    }
  }, {
    key: "z",
    get: function get() {
      return this._z;
    },
    set: function set(value) {
      this._z = value;

      this._onChangeCallback();
    }
  }, {
    key: "w",
    get: function get() {
      return this._w;
    },
    set: function set(value) {
      this._w = value;

      this._onChangeCallback();
    }
  }, {
    key: "set",
    value: function set(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
  }, {
    key: "copy",
    value: function copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "setFromEuler",
    value: function setFromEuler(euler, update) {
      if (!(euler && euler.isEuler)) {
        throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
      }

      var x = euler._x,
          y = euler._y,
          z = euler._z,
          order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
      // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
      //	content/SpinCalc.m

      var cos = Math.cos;
      var sin = Math.sin;
      var c1 = cos(x / 2);
      var c2 = cos(y / 2);
      var c3 = cos(z / 2);
      var s1 = sin(x / 2);
      var s2 = sin(y / 2);
      var s3 = sin(z / 2);

      switch (order) {
        case 'XYZ':
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;

        case 'YXZ':
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;

        case 'ZXY':
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;

        case 'ZYX':
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;

        case 'YZX':
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;

        case 'XZY':
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;

        default:
          console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
      }

      if (update !== false) this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromAxisAngle",
    value: function setFromAxisAngle(axis, angle) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
      // assumes axis is normalized
      var halfAngle = angle / 2,
          s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "setFromRotationMatrix",
    value: function setFromRotationMatrix(m) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
      var te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33;

      if (trace > 0) {
        var s = 0.5 / Math.sqrt(trace + 1.0);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        var _s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

        this._w = (m32 - m23) / _s;
        this._x = 0.25 * _s;
        this._y = (m12 + m21) / _s;
        this._z = (m13 + m31) / _s;
      } else if (m22 > m33) {
        var _s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

        this._w = (m13 - m31) / _s2;
        this._x = (m12 + m21) / _s2;
        this._y = 0.25 * _s2;
        this._z = (m23 + m32) / _s2;
      } else {
        var _s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

        this._w = (m21 - m12) / _s3;
        this._x = (m13 + m31) / _s3;
        this._y = (m23 + m32) / _s3;
        this._z = 0.25 * _s3;
      }

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "setFromUnitVectors",
    value: function setFromUnitVectors(vFrom, vTo) {
      // assumes direction vectors vFrom and vTo are normalized
      var r = vFrom.dot(vTo) + 1;

      if (r < Number.EPSILON) {
        // vFrom and vTo point in opposite directions
        r = 0;

        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }

      return this.normalize();
    }
  }, {
    key: "angleTo",
    value: function angleTo(q) {
      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
    }
  }, {
    key: "rotateTowards",
    value: function rotateTowards(q, step) {
      var angle = this.angleTo(q);
      if (angle === 0) return this;
      var t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.set(0, 0, 0, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      // quaternion is assumed to have unit length
      return this.conjugate();
    }
  }, {
    key: "conjugate",
    value: function conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var l = this.length();

      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(q, p) {
      if (p !== undefined) {
        console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
        return this.multiplyQuaternions(q, p);
      }

      return this.multiplyQuaternions(this, q);
    }
  }, {
    key: "premultiply",
    value: function premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
  }, {
    key: "multiplyQuaternions",
    value: function multiplyQuaternions(a, b) {
      // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
      var qax = a._x,
          qay = a._y,
          qaz = a._z,
          qaw = a._w;
      var qbx = b._x,
          qby = b._y,
          qbz = b._z,
          qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "slerp",
    value: function slerp(qb, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(qb);
      var x = this._x,
          y = this._y,
          z = this._z,
          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

      var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }

      if (cosHalfTheta >= 1.0) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }

      var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

      if (sqrSinHalfTheta <= Number.EPSILON) {
        var s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize();

        this._onChangeCallback();

        return this;
      }

      var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "slerpQuaternions",
    value: function slerpQuaternions(qa, qb, t) {
      return this.copy(qa).slerp(qb, t);
    }
  }, {
    key: "random",
    value: function random() {
      // Derived from http://planning.cs.uiuc.edu/node198.html
      // Note, this source uses w, x, y, z ordering,
      // so we swap the order below.
      var u1 = Math.random();
      var sqrt1u1 = Math.sqrt(1 - u1);
      var sqrtu1 = Math.sqrt(u1);
      var u2 = 2 * Math.PI * Math.random();
      var u3 = 2 * Math.PI * Math.random();
      return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
    }
  }, {
    key: "equals",
    value: function equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "toArray",
    value: function toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      return this;
    }
  }, {
    key: "_onChange",
    value: function _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
  }, {
    key: "_onChangeCallback",
    value: function _onChangeCallback() {}
  }], [{
    key: "slerp",
    value: function slerp(qa, qb, qm, t) {
      console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');
      return qm.slerpQuaternions(qa, qb, t);
    }
  }, {
    key: "slerpFlat",
    value: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      // fuzz-free, array-based Quaternion SLERP operation
      var x0 = src0[srcOffset0 + 0],
          y0 = src0[srcOffset0 + 1],
          z0 = src0[srcOffset0 + 2],
          w0 = src0[srcOffset0 + 3];
      var x1 = src1[srcOffset1 + 0],
          y1 = src1[srcOffset1 + 1],
          z1 = src1[srcOffset1 + 2],
          w1 = src1[srcOffset1 + 3];

      if (t === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }

      if (t === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }

      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        var s = 1 - t;
        var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
            dir = cos >= 0 ? 1 : -1,
            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

        if (sqrSin > Number.EPSILON) {
          var sin = Math.sqrt(sqrSin),
              len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }

        var tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

        if (s === 1 - t) {
          var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }

      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
  }, {
    key: "multiplyQuaternionsFlat",
    value: function multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      var x0 = src0[srcOffset0];
      var y0 = src0[srcOffset0 + 1];
      var z0 = src0[srcOffset0 + 2];
      var w0 = src0[srcOffset0 + 3];
      var x1 = src1[srcOffset1];
      var y1 = src1[srcOffset1 + 1];
      var z1 = src1[srcOffset1 + 2];
      var w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
  }]);

  return Quaternion;
}();

exports.Quaternion = Quaternion;
Quaternion.prototype.isQuaternion = true;

var Vector3 = /*#__PURE__*/function (_Symbol$iterator3) {
  function Vector3(x = 0, y = 0, z = 0) {
    _classCallCheck(this, Vector3);

    this.x = x;
    this.y = y;
    this.z = z;
  }

  _createClass(Vector3, [{
    key: "set",
    value: function set(x, y, z) {
      if (z === undefined) z = this.z; // sprite.scale.set(x,y)

      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
  }, {
    key: "setScalar",
    value: function setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
  }, {
    key: "setX",
    value: function setX(x) {
      this.x = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(y) {
      this.y = y;
      return this;
    }
  }, {
    key: "setZ",
    value: function setZ(z) {
      this.z = z;
      return this;
    }
  }, {
    key: "setComponent",
    value: function setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;

        case 1:
          this.y = value;
          break;

        case 2:
          this.z = value;
          break;

        default:
          throw new Error('index is out of range: ' + index);
      }

      return this;
    }
  }, {
    key: "getComponent",
    value: function getComponent(index) {
      switch (index) {
        case 0:
          return this.x;

        case 1:
          return this.y;

        case 2:
          return this.z;

        default:
          throw new Error('index is out of range: ' + index);
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
  }, {
    key: "copy",
    value: function copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
  }, {
    key: "add",
    value: function add(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
        return this.addVectors(v, w);
      }

      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
  }, {
    key: "addScalar",
    value: function addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
  }, {
    key: "sub",
    value: function sub(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
        return this.subVectors(v, w);
      }

      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
  }, {
    key: "subScalar",
    value: function subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
        return this.multiplyVectors(v, w);
      }

      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
  }, {
    key: "multiplyVectors",
    value: function multiplyVectors(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    }
  }, {
    key: "applyEuler",
    value: function applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
      }

      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
  }, {
    key: "applyAxisAngle",
    value: function applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(m) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var e = m.elements;
      var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(q) {
      var x = this.x,
          y = this.y,
          z = this.z;
      var qx = q.x,
          qy = q.y,
          qz = q.z,
          qw = q.w; // calculate quat * vector

      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    }
  }, {
    key: "project",
    value: function project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
  }, {
    key: "unproject",
    value: function unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(m) {
      // input: THREE.Matrix4 affine matrix
      // vector interpreted as a direction
      var x = this.x,
          y = this.y,
          z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    }
  }, {
    key: "divide",
    value: function divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
  }, {
    key: "min",
    value: function min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
  }, {
    key: "max",
    value: function max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
  }, {
    key: "clamp",
    value: function clamp(min, max) {
      // assumes min < max, componentwise
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      return this;
    }
  }, {
    key: "clampLength",
    value: function clampLength(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
  }, {
    key: "floor",
    value: function floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
  }, {
    key: "ceil",
    value: function ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
  }, {
    key: "round",
    value: function round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
  }, {
    key: "roundToZero",
    value: function roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
  }, {
    key: "dot",
    value: function dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    } // TODO lengthSquared?

  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
  }, {
    key: "manhattanLength",
    value: function manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      return this.divideScalar(this.length() || 1);
    }
  }, {
    key: "setLength",
    value: function setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
  }, {
    key: "lerp",
    value: function lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    }
  }, {
    key: "lerpVectors",
    value: function lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
  }, {
    key: "cross",
    value: function cross(v, w) {
      if (w !== undefined) {
        console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
        return this.crossVectors(v, w);
      }

      return this.crossVectors(this, v);
    }
  }, {
    key: "crossVectors",
    value: function crossVectors(a, b) {
      var ax = a.x,
          ay = a.y,
          az = a.z;
      var bx = b.x,
          by = b.y,
          bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
  }, {
    key: "projectOnVector",
    value: function projectOnVector(v) {
      var denominator = v.lengthSq();
      if (denominator === 0) return this.set(0, 0, 0);
      var scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    }
  }, {
    key: "projectOnPlane",
    value: function projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);

      return this.sub(_vector$c);
    }
  }, {
    key: "reflect",
    value: function reflect(normal) {
      // reflect incident vector off plane orthogonal to normal
      // normal is assumed to have unit length
      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
  }, {
    key: "angleTo",
    value: function angleTo(v) {
      var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      var theta = this.dot(v) / denominator; // clamp, to handle numerical problems

      return Math.acos(clamp(theta, -1, 1));
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(v) {
      var dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
  }, {
    key: "manhattanDistanceTo",
    value: function manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
  }, {
    key: "setFromSpherical",
    value: function setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
  }, {
    key: "setFromSphericalCoords",
    value: function setFromSphericalCoords(radius, phi, theta) {
      var sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
  }, {
    key: "setFromCylindrical",
    value: function setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
  }, {
    key: "setFromCylindricalCoords",
    value: function setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    }
  }, {
    key: "setFromMatrixPosition",
    value: function setFromMatrixPosition(m) {
      var e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
  }, {
    key: "setFromMatrixScale",
    value: function setFromMatrixScale(m) {
      var sx = this.setFromMatrixColumn(m, 0).length();
      var sy = this.setFromMatrixColumn(m, 1).length();
      var sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
  }, {
    key: "setFromMatrixColumn",
    value: function setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
  }, {
    key: "setFromMatrix3Column",
    value: function setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    }
  }, {
    key: "setFromEuler",
    value: function setFromEuler(e) {
      this.x = e._x;
      this.y = e._y;
      this.z = e._z;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
  }, {
    key: "fromBufferAttribute",
    value: function fromBufferAttribute(attribute, index, offset) {
      if (offset !== undefined) {
        console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
      }

      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
  }, {
    key: "random",
    value: function random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
  }, {
    key: "randomDirection",
    value: function randomDirection() {
      // Derived from https://mathworld.wolfram.com/SpherePointPicking.html
      var u = (Math.random() - 0.5) * 2;
      var t = Math.random() * Math.PI * 2;
      var f = Math.sqrt(1 - Math.pow(u, 2));
      this.x = f * Math.cos(t);
      this.y = f * Math.sin(t);
      this.z = u;
      return this;
    }
  }, {
    key: _Symbol$iterator3,
    value: /*#__PURE__*/regeneratorRuntime.mark(function value() {
      return regeneratorRuntime.wrap(function value$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.x;

            case 2:
              _context4.next = 4;
              return this.y;

            case 4:
              _context4.next = 6;
              return this.z;

            case 6:
            case "end":
              return _context4.stop();
          }
        }
      }, value, this);
    })
  }]);

  return Vector3;
}(Symbol.iterator);

exports.Vector3 = Vector3;
Vector3.prototype.isVector3 = true;

var _vector$c = /*@__PURE__*/new Vector3();

var _quaternion$4 = /*@__PURE__*/new Quaternion();

var Box3 = /*#__PURE__*/function () {
  function Box3(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    _classCallCheck(this, Box3);

    this.min = min;
    this.max = max;
  }

  _createClass(Box3, [{
    key: "set",
    value: function set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
  }, {
    key: "setFromArray",
    value: function setFromArray(array) {
      var minX = +Infinity;
      var minY = +Infinity;
      var minZ = +Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      var maxZ = -Infinity;

      for (var _i10 = 0, l = array.length; _i10 < l; _i10 += 3) {
        var x = array[_i10];
        var y = array[_i10 + 1];
        var z = array[_i10 + 2];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (z < minZ) minZ = z;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
        if (z > maxZ) maxZ = z;
      }

      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
  }, {
    key: "setFromBufferAttribute",
    value: function setFromBufferAttribute(attribute) {
      var minX = +Infinity;
      var minY = +Infinity;
      var minZ = +Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      var maxZ = -Infinity;

      for (var _i11 = 0, l = attribute.count; _i11 < l; _i11++) {
        var x = attribute.getX(_i11);
        var y = attribute.getY(_i11);
        var z = attribute.getZ(_i11);
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (z < minZ) minZ = z;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
        if (z > maxZ) maxZ = z;
      }

      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points) {
      this.makeEmpty();

      for (var _i12 = 0, il = points.length; _i12 < il; _i12++) {
        this.expandByPoint(points[_i12]);
      }

      return this;
    }
  }, {
    key: "setFromCenterAndSize",
    value: function setFromCenterAndSize(center, size) {
      var halfSize = _vector$b.copy(size).multiplyScalar(0.5);

      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
  }, {
    key: "setFromObject",
    value: function setFromObject(object, precise = false) {
      this.makeEmpty();
      return this.expandByObject(object, precise);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      this.min.x = this.min.y = this.min.z = +Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
  }, {
    key: "getCenter",
    value: function getCenter(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
  }, {
    key: "getSize",
    value: function getSize(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
  }, {
    key: "expandByVector",
    value: function expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
  }, {
    key: "expandByScalar",
    value: function expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
  }, {
    key: "expandByObject",
    value: function expandByObject(object, precise = false) {
      // Computes the world-axis-aligned bounding box of an object (including its children),
      // accounting for both the object's, and children's, world transforms
      object.updateWorldMatrix(false, false);
      var geometry = object.geometry;

      if (geometry !== undefined) {
        if (precise && geometry.attributes != undefined && geometry.attributes.position !== undefined) {
          var position = geometry.attributes.position;

          for (var _i13 = 0, l = position.count; _i13 < l; _i13++) {
            _vector$b.fromBufferAttribute(position, _i13).applyMatrix4(object.matrixWorld);

            this.expandByPoint(_vector$b);
          }
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }

          _box$3.copy(geometry.boundingBox);

          _box$3.applyMatrix4(object.matrixWorld);

          this.union(_box$3);
        }
      }

      var children = object.children;

      for (var _i14 = 0, _l = children.length; _i14 < _l; _i14++) {
        this.expandByObject(children[_i14], precise);
      }

      return this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
  }, {
    key: "containsBox",
    value: function containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
  }, {
    key: "getParameter",
    value: function getParameter(point, target) {
      // This can potentially have a divide by zero if the box
      // has a size dimension of 0.
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      // using 6 splitting planes to rule out intersections.
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      // Find the point on the AABB closest to the sphere center.
      this.clampPoint(sphere.center, _vector$b); // If that point is inside the sphere, the AABB and sphere intersect.

      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(plane) {
      // We compute the minimum and maximum dot product values. If those values
      // are on the same side (back or front) of the plane, then there is no intersection.
      var min, max;

      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }

      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }

      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }

      return min <= -plane.constant && max >= -plane.constant;
    }
  }, {
    key: "intersectsTriangle",
    value: function intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      } // compute box center and extents


      this.getCenter(_center);

      _extents.subVectors(this.max, _center); // translate triangle to aabb origin


      _v0$2.subVectors(triangle.a, _center);

      _v1$7.subVectors(triangle.b, _center);

      _v2$3.subVectors(triangle.c, _center); // compute edge vectors for triangle


      _f0.subVectors(_v1$7, _v0$2);

      _f1.subVectors(_v2$3, _v1$7);

      _f2.subVectors(_v0$2, _v2$3); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
      // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
      // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


      var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
        return false;
      } // test 3 face normals from the aabb


      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
        return false;
      } // finally testing the face normal of the triangle
      // use already existing triangle edge vectors here


      _triangleNormal.crossVectors(_f0, _f1);

      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      var clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);

      return clampedPoint.sub(point).length();
    }
  }, {
    key: "getBoundingSphere",
    value: function getBoundingSphere(target) {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
      return target;
    }
  }, {
    key: "intersect",
    value: function intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

      if (this.isEmpty()) this.makeEmpty();
      return this;
    }
  }, {
    key: "union",
    value: function union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      // transform of empty box is an empty box.
      if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


      this.setFromPoints(_points);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  }]);

  return Box3;
}();

exports.Box3 = Box3;
Box3.prototype.isBox3 = true;
var _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];

var _vector$b = /*@__PURE__*/new Vector3();

var _box$3 = /*@__PURE__*/new Box3(); // triangle centered vertices


var _v0$2 = /*@__PURE__*/new Vector3();

var _v1$7 = /*@__PURE__*/new Vector3();

var _v2$3 = /*@__PURE__*/new Vector3(); // triangle edge vectors


var _f0 = /*@__PURE__*/new Vector3();

var _f1 = /*@__PURE__*/new Vector3();

var _f2 = /*@__PURE__*/new Vector3();

var _center = /*@__PURE__*/new Vector3();

var _extents = /*@__PURE__*/new Vector3();

var _triangleNormal = /*@__PURE__*/new Vector3();

var _testAxis = /*@__PURE__*/new Vector3();

function satForAxes(axes, v0, v1, v2, extents) {
  for (var _i15 = 0, j = axes.length - 3; _i15 <= j; _i15 += 3) {
    _testAxis.fromArray(axes, _i15); // project the aabb onto the separating axis


    var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the separating axis

    var p0 = v0.dot(_testAxis);
    var p1 = v1.dot(_testAxis);
    var p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is separating and we can exit
      return false;
    }
  }

  return true;
}

var _box$2 = /*@__PURE__*/new Box3();

var _v1$6 = /*@__PURE__*/new Vector3();

var _toFarthestPoint = /*@__PURE__*/new Vector3();

var _toPoint = /*@__PURE__*/new Vector3();

var Sphere = /*#__PURE__*/function () {
  function Sphere(center = new Vector3(), radius = -1) {
    _classCallCheck(this, Sphere);

    this.center = center;
    this.radius = radius;
  }

  _createClass(Sphere, [{
    key: "set",
    value: function set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points, optionalCenter) {
      var center = this.center;

      if (optionalCenter !== undefined) {
        center.copy(optionalCenter);
      } else {
        _box$2.setFromPoints(points).getCenter(center);
      }

      var maxRadiusSq = 0;

      for (var _i16 = 0, il = points.length; _i16 < il; _i16++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[_i16]));
      }

      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.radius < 0;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      this.center.set(0, 0, 0);
      this.radius = -1;
      return this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      var radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return box.intersectsSphere(this);
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(point, target) {
      var deltaLengthSq = this.center.distanceToSquared(point);
      target.copy(point);

      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }

      return target;
    }
  }, {
    key: "getBoundingBox",
    value: function getBoundingBox(target) {
      if (this.isEmpty()) {
        // Empty sphere produces empty bounding box
        target.makeEmpty();
        return target;
      }

      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.center.add(offset);
      return this;
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(point) {
      // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
      _toPoint.subVectors(point, this.center);

      var lengthSq = _toPoint.lengthSq();

      if (lengthSq > this.radius * this.radius) {
        var length = Math.sqrt(lengthSq);
        var missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,
        // and the other half to position. This gives a tighter enclosure, instead of if
        // the whole missing distance were just added to radius.

        this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
        this.radius += missingRadiusHalf;
      }

      return this;
    }
  }, {
    key: "union",
    value: function union(sphere) {
      // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
      // To enclose another sphere into this sphere, we only need to enclose two points:
      // 1) Enclose the farthest point on the other sphere into this sphere.
      // 2) Enclose the opposite point of the farthest point into this sphere.
      if (this.center.equals(sphere.center) === true) {
        _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
      } else {
        _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
      }

      this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
      return this;
    }
  }, {
    key: "equals",
    value: function equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return Sphere;
}();

exports.Sphere = Sphere;

var _vector$a = /*@__PURE__*/new Vector3();

var _segCenter = /*@__PURE__*/new Vector3();

var _segDir = /*@__PURE__*/new Vector3();

var _diff = /*@__PURE__*/new Vector3();

var _edge1 = /*@__PURE__*/new Vector3();

var _edge2 = /*@__PURE__*/new Vector3();

var _normal$1 = /*@__PURE__*/new Vector3();

var Ray = /*#__PURE__*/function () {
  function Ray(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    _classCallCheck(this, Ray);

    this.origin = origin;
    this.direction = direction;
  }

  _createClass(Ray, [{
    key: "set",
    value: function set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
  }, {
    key: "at",
    value: function at(t, target) {
      return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
  }, {
    key: "lookAt",
    value: function lookAt(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    }
  }, {
    key: "recast",
    value: function recast(t) {
      this.origin.copy(this.at(t, _vector$a));
      return this;
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(point, target) {
      target.subVectors(point, this.origin);
      var directionDistance = target.dot(this.direction);

      if (directionDistance < 0) {
        return target.copy(this.origin);
      }

      return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
  }, {
    key: "distanceSqToPoint",
    value: function distanceSqToPoint(point) {
      var directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction); // point behind the ray


      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }

      _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

      return _vector$a.distanceToSquared(point);
    }
  }, {
    key: "distanceSqToSegment",
    value: function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
      // It returns the min distance between the ray and the segment
      // defined by v0 and v1
      // It can also set two optional targets :
      // - The closest point on the ray
      // - The closest point on the segment
      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);

      _segDir.copy(v1).sub(v0).normalize();

      _diff.copy(this.origin).sub(_segCenter);

      var segExtent = v0.distanceTo(v1) * 0.5;
      var a01 = -this.direction.dot(_segDir);

      var b0 = _diff.dot(this.direction);

      var b1 = -_diff.dot(_segDir);

      var c = _diff.lengthSq();

      var det = Math.abs(1 - a01 * a01);
      var s0, s1, sqrDist, extDet;

      if (det > 0) {
        // The ray and segment are not parallel.
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;

        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              // region 0
              // Minimum at interior points of ray and segment.
              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              // region 1
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            // region 5
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            // region 4
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            // region 3
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            // region 2
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        // Ray and segment are parallel.
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }

      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }

      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
      }

      return sqrDist;
    }
  }, {
    key: "intersectSphere",
    value: function intersectSphere(sphere, target) {
      _vector$a.subVectors(sphere.center, this.origin);

      var tca = _vector$a.dot(this.direction);

      var d2 = _vector$a.dot(_vector$a) - tca * tca;
      var radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2) return null;
      var thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

      var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

      var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

      if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.

      if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

      return this.at(t0, target);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
  }, {
    key: "distanceToPlane",
    value: function distanceToPlane(plane) {
      var denominator = plane.normal.dot(this.direction);

      if (denominator === 0) {
        // line is coplanar, return origin
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        } // Null is preferable to undefined since undefined means.... it is undefined


        return null;
      }

      var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

      return t >= 0 ? t : null;
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(plane, target) {
      var t = this.distanceToPlane(plane);

      if (t === null) {
        return null;
      }

      return this.at(t, target);
    }
  }, {
    key: "intersectsPlane",
    value: function intersectsPlane(plane) {
      // check if the ray lies on the plane first
      var distToPoint = plane.distanceToPoint(this.origin);

      if (distToPoint === 0) {
        return true;
      }

      var denominator = plane.normal.dot(this.direction);

      if (denominator * distToPoint < 0) {
        return true;
      } // ray origin is behind the plane (and is pointing behind it)


      return false;
    }
  }, {
    key: "intersectBox",
    value: function intersectBox(box, target) {
      var tmin, tmax, tymin, tymax, tzmin, tzmax;
      var invdirx = 1 / this.direction.x,
          invdiry = 1 / this.direction.y,
          invdirz = 1 / this.direction.z;
      var origin = this.origin;

      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }

      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }

      if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
      // (result of 0 * Infinity). x !== x returns true if x is NaN

      if (tymin > tmin || tmin !== tmin) tmin = tymin;
      if (tymax < tmax || tmax !== tmax) tmax = tymax;

      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }

      if (tmin > tzmax || tzmin > tmax) return null;
      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

      if (tmax < 0) return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return this.intersectBox(box, _vector$a) !== null;
    }
  }, {
    key: "intersectTriangle",
    value: function intersectTriangle(a, b, c, backfaceCulling, target) {
      // Compute the offset origin, edges, and normal.
      // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
      _edge1.subVectors(b, a);

      _edge2.subVectors(c, a);

      _normal$1.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


      var DdN = this.direction.dot(_normal$1);
      var sign;

      if (DdN > 0) {
        if (backfaceCulling) return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }

      _diff.subVectors(this.origin, a);

      var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

      if (DdQxE2 < 0) {
        return null;
      }

      var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

      if (DdE1xQ < 0) {
        return null;
      } // b1+b2 > 1, no intersection


      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      } // Line intersects triangle, check if ray does.


      var QdN = -sign * _diff.dot(_normal$1); // t < 0, no intersection


      if (QdN < 0) {
        return null;
      } // Ray intersects triangle.


      return this.at(QdN / DdN, target);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return Ray;
}();

exports.Ray = Ray;

var Matrix4 = /*#__PURE__*/function () {
  function Matrix4() {
    _classCallCheck(this, Matrix4);

    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

    if (arguments.length > 0) {
      console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
  }

  _createClass(Matrix4, [{
    key: "set",
    value: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      var te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    }
  }, {
    key: "identity",
    value: function identity() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Matrix4().fromArray(this.elements);
    }
  }, {
    key: "copy",
    value: function copy(m) {
      var te = this.elements;
      var me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    }
  }, {
    key: "copyPosition",
    value: function copyPosition(m) {
      var te = this.elements,
          me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    }
  }, {
    key: "setFromMatrix3",
    value: function setFromMatrix3(m) {
      var me = m.elements;
      this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "extractBasis",
    value: function extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
  }, {
    key: "makeBasis",
    value: function makeBasis(xAxis, yAxis, zAxis) {
      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "extractRotation",
    value: function extractRotation(m) {
      // this method does not support reflection matrices
      var te = this.elements;
      var me = m.elements;

      var scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();

      var scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();

      var scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();

      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
  }, {
    key: "makeRotationFromEuler",
    value: function makeRotationFromEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
      }

      var te = this.elements;
      var x = euler.x,
          y = euler.y,
          z = euler.z;
      var a = Math.cos(x),
          b = Math.sin(x);
      var c = Math.cos(y),
          d = Math.sin(y);
      var e = Math.cos(z),
          f = Math.sin(z);

      if (euler.order === 'XYZ') {
        var ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === 'YXZ') {
        var ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler.order === 'ZXY') {
        var _ce = c * e,
            _cf = c * f,
            _de = d * e,
            _df = d * f;

        te[0] = _ce - _df * b;
        te[4] = -a * f;
        te[8] = _de + _cf * b;
        te[1] = _cf + _de * b;
        te[5] = a * e;
        te[9] = _df - _ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler.order === 'ZYX') {
        var _ae = a * e,
            _af = a * f,
            _be = b * e,
            _bf = b * f;

        te[0] = c * e;
        te[4] = _be * d - _af;
        te[8] = _ae * d + _bf;
        te[1] = c * f;
        te[5] = _bf * d + _ae;
        te[9] = _af * d - _be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler.order === 'YZX') {
        var ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === 'XZY') {
        var _ac = a * c,
            _ad = a * d,
            _bc = b * c,
            _bd = b * d;

        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = _ac * f + _bd;
        te[5] = a * e;
        te[9] = _ad * f - _bc;
        te[2] = _bc * f - _ad;
        te[6] = b * e;
        te[10] = _bd * f + _ac;
      } // bottom row


      te[3] = 0;
      te[7] = 0;
      te[11] = 0; // last column

      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
  }, {
    key: "makeRotationFromQuaternion",
    value: function makeRotationFromQuaternion(q) {
      return this.compose(_zero, q, _one);
    }
  }, {
    key: "lookAt",
    value: function lookAt(eye, target, up) {
      var te = this.elements;

      _z.subVectors(eye, target);

      if (_z.lengthSq() === 0) {
        // eye and target are in the same position
        _z.z = 1;
      }

      _z.normalize();

      _x.crossVectors(up, _z);

      if (_x.lengthSq() === 0) {
        // up and z are parallel
        if (Math.abs(up.z) === 1) {
          _z.x += 0.0001;
        } else {
          _z.z += 0.0001;
        }

        _z.normalize();

        _x.crossVectors(up, _z);
      }

      _x.normalize();

      _y.crossVectors(_z, _x);

      te[0] = _x.x;
      te[4] = _y.x;
      te[8] = _z.x;
      te[1] = _x.y;
      te[5] = _y.y;
      te[9] = _z.y;
      te[2] = _x.z;
      te[6] = _y.z;
      te[10] = _z.z;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(m, n) {
      if (n !== undefined) {
        console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
        return this.multiplyMatrices(m, n);
      }

      return this.multiplyMatrices(this, m);
    }
  }, {
    key: "premultiply",
    value: function premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
  }, {
    key: "multiplyMatrices",
    value: function multiplyMatrices(a, b) {
      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;
      var a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
      var a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
      var a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
      var a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
      var b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
      var b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
      var b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
      var b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(s) {
      var te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      var te = this.elements;
      var n11 = te[0],
          n12 = te[4],
          n13 = te[8],
          n14 = te[12];
      var n21 = te[1],
          n22 = te[5],
          n23 = te[9],
          n24 = te[13];
      var n31 = te[2],
          n32 = te[6],
          n33 = te[10],
          n34 = te[14];
      var n41 = te[3],
          n42 = te[7],
          n43 = te[11],
          n44 = te[15]; //TODO: make this more efficient
      //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var te = this.elements;
      var tmp;
      tmp = te[1];
      te[1] = te[4];
      te[4] = tmp;
      tmp = te[2];
      te[2] = te[8];
      te[8] = tmp;
      tmp = te[6];
      te[6] = te[9];
      te[9] = tmp;
      tmp = te[3];
      te[3] = te[12];
      te[12] = tmp;
      tmp = te[7];
      te[7] = te[13];
      te[13] = tmp;
      tmp = te[11];
      te[11] = te[14];
      te[14] = tmp;
      return this;
    }
  }, {
    key: "setPosition",
    value: function setPosition(x, y, z) {
      var te = this.elements;

      if (x.isVector3) {
        te[12] = x.x;
        te[13] = x.y;
        te[14] = x.z;
      } else {
        te[12] = x;
        te[13] = y;
        te[14] = z;
      }

      return this;
    }
  }, {
    key: "invert",
    value: function invert() {
      // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
      var te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n41 = te[3],
          n12 = te[4],
          n22 = te[5],
          n32 = te[6],
          n42 = te[7],
          n13 = te[8],
          n23 = te[9],
          n33 = te[10],
          n43 = te[11],
          n14 = te[12],
          n24 = te[13],
          n34 = te[14],
          n44 = te[15],
          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      var detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
  }, {
    key: "scale",
    value: function scale(v) {
      var te = this.elements;
      var x = v.x,
          y = v.y,
          z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    }
  }, {
    key: "getMaxScaleOnAxis",
    value: function getMaxScaleOnAxis() {
      var te = this.elements;
      var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
  }, {
    key: "makeTranslation",
    value: function makeTranslation(x, y, z) {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeRotationX",
    value: function makeRotationX(theta) {
      var c = Math.cos(theta),
          s = Math.sin(theta);
      this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeRotationY",
    value: function makeRotationY(theta) {
      var c = Math.cos(theta),
          s = Math.sin(theta);
      this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeRotationZ",
    value: function makeRotationZ(theta) {
      var c = Math.cos(theta),
          s = Math.sin(theta);
      this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeRotationAxis",
    value: function makeRotationAxis(axis, angle) {
      // Based on http://www.gamedev.net/reference/articles/article1199.asp
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      var t = 1 - c;
      var x = axis.x,
          y = axis.y,
          z = axis.z;
      var tx = t * x,
          ty = t * y;
      this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeScale",
    value: function makeScale(x, y, z) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "makeShear",
    value: function makeShear(xy, xz, yx, yz, zx, zy) {
      this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
      return this;
    }
  }, {
    key: "compose",
    value: function compose(position, quaternion, scale) {
      var te = this.elements;
      var x = quaternion._x,
          y = quaternion._y,
          z = quaternion._z,
          w = quaternion._w;
      var x2 = x + x,
          y2 = y + y,
          z2 = z + z;
      var xx = x * x2,
          xy = x * y2,
          xz = x * z2;
      var yy = y * y2,
          yz = y * z2,
          zz = z * z2;
      var wx = w * x2,
          wy = w * y2,
          wz = w * z2;
      var sx = scale.x,
          sy = scale.y,
          sz = scale.z;
      te[0] = (1 - (yy + zz)) * sx;
      te[1] = (xy + wz) * sx;
      te[2] = (xz - wy) * sx;
      te[3] = 0;
      te[4] = (xy - wz) * sy;
      te[5] = (1 - (xx + zz)) * sy;
      te[6] = (yz + wx) * sy;
      te[7] = 0;
      te[8] = (xz + wy) * sz;
      te[9] = (yz - wx) * sz;
      te[10] = (1 - (xx + yy)) * sz;
      te[11] = 0;
      te[12] = position.x;
      te[13] = position.y;
      te[14] = position.z;
      te[15] = 1;
      return this;
    }
  }, {
    key: "decompose",
    value: function decompose(position, quaternion, scale) {
      var te = this.elements;

      var sx = _v1$5.set(te[0], te[1], te[2]).length();

      var sy = _v1$5.set(te[4], te[5], te[6]).length();

      var sz = _v1$5.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


      var det = this.determinant();
      if (det < 0) sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14]; // scale the rotation part

      _m1$2.copy(this);

      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      _m1$2.elements[0] *= invSX;
      _m1$2.elements[1] *= invSX;
      _m1$2.elements[2] *= invSX;
      _m1$2.elements[4] *= invSY;
      _m1$2.elements[5] *= invSY;
      _m1$2.elements[6] *= invSY;
      _m1$2.elements[8] *= invSZ;
      _m1$2.elements[9] *= invSZ;
      _m1$2.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1$2);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
  }, {
    key: "makePerspective",
    value: function makePerspective(left, right, top, bottom, near, far) {
      if (far === undefined) {
        console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
      }

      var te = this.elements;
      var x = 2 * near / (right - left);
      var y = 2 * near / (top - bottom);
      var a = (right + left) / (right - left);
      var b = (top + bottom) / (top - bottom);
      var c = -(far + near) / (far - near);
      var d = -2 * far * near / (far - near);
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    }
  }, {
    key: "makeOrthographic",
    value: function makeOrthographic(left, right, top, bottom, near, far) {
      var te = this.elements;
      var w = 1.0 / (right - left);
      var h = 1.0 / (top - bottom);
      var p = 1.0 / (far - near);
      var x = (right + left) * w;
      var y = (top + bottom) * h;
      var z = (far + near) * p;
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = -2 * p;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
  }, {
    key: "equals",
    value: function equals(matrix) {
      var te = this.elements;
      var me = matrix.elements;

      for (var _i17 = 0; _i17 < 16; _i17++) {
        if (te[_i17] !== me[_i17]) return false;
      }

      return true;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array, offset = 0) {
      for (var _i18 = 0; _i18 < 16; _i18++) {
        this.elements[_i18] = array[_i18 + offset];
      }

      return this;
    }
  }, {
    key: "toArray",
    value: function toArray(array = [], offset = 0) {
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  }]);

  return Matrix4;
}();

exports.Matrix4 = Matrix4;
Matrix4.prototype.isMatrix4 = true;

var _v1$5 = /*@__PURE__*/new Vector3();

var _m1$2 = /*@__PURE__*/new Matrix4();

var _zero = /*@__PURE__*/new Vector3(0, 0, 0);

var _one = /*@__PURE__*/new Vector3(1, 1, 1);

var _x = /*@__PURE__*/new Vector3();

var _y = /*@__PURE__*/new Vector3();

var _z = /*@__PURE__*/new Vector3();

var _matrix$1 = /*@__PURE__*/new Matrix4();

var _quaternion$3 = /*@__PURE__*/new Quaternion();

var Euler = /*#__PURE__*/function () {
  function Euler(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    _classCallCheck(this, Euler);

    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }

  _createClass(Euler, [{
    key: "x",
    get: function get() {
      return this._x;
    },
    set: function set(value) {
      this._x = value;

      this._onChangeCallback();
    }
  }, {
    key: "y",
    get: function get() {
      return this._y;
    },
    set: function set(value) {
      this._y = value;

      this._onChangeCallback();
    }
  }, {
    key: "z",
    get: function get() {
      return this._z;
    },
    set: function set(value) {
      this._z = value;

      this._onChangeCallback();
    }
  }, {
    key: "order",
    get: function get() {
      return this._order;
    },
    set: function set(value) {
      this._order = value;

      this._onChangeCallback();
    }
  }, {
    key: "set",
    value: function set(x, y, z, order = this._order) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
  }, {
    key: "copy",
    value: function copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "setFromRotationMatrix",
    value: function setFromRotationMatrix(m, order = this._order, update = true) {
      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
      var te = m.elements;
      var m11 = te[0],
          m12 = te[4],
          m13 = te[8];
      var m21 = te[1],
          m22 = te[5],
          m23 = te[9];
      var m31 = te[2],
          m32 = te[6],
          m33 = te[10];

      switch (order) {
        case 'XYZ':
          this._y = Math.asin(clamp(m13, -1, 1));

          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }

          break;

        case 'YXZ':
          this._x = Math.asin(-clamp(m23, -1, 1));

          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }

          break;

        case 'ZXY':
          this._x = Math.asin(clamp(m32, -1, 1));

          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }

          break;

        case 'ZYX':
          this._y = Math.asin(-clamp(m31, -1, 1));

          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }

          break;

        case 'YZX':
          this._z = Math.asin(clamp(m21, -1, 1));

          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }

          break;

        case 'XZY':
          this._z = Math.asin(-clamp(m12, -1, 1));

          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }

          break;

        default:
          console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
      }

      this._order = order;
      if (update === true) this._onChangeCallback();
      return this;
    }
  }, {
    key: "setFromQuaternion",
    value: function setFromQuaternion(q, order, update) {
      _matrix$1.makeRotationFromQuaternion(q);

      return this.setFromRotationMatrix(_matrix$1, order, update);
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(v, order = this._order) {
      return this.set(v.x, v.y, v.z, order);
    }
  }, {
    key: "reorder",
    value: function reorder(newOrder) {
      // WARNING: this discards revolution information -bhouston
      _quaternion$3.setFromEuler(this);

      return this.setFromQuaternion(_quaternion$3, newOrder);
    }
  }, {
    key: "equals",
    value: function equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== undefined) this._order = array[3];

      this._onChangeCallback();

      return this;
    }
  }, {
    key: "toArray",
    value: function toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    }
  }, {
    key: "_onChange",
    value: function _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
  }, {
    key: "_onChangeCallback",
    value: function _onChangeCallback() {}
  }]);

  return Euler;
}();

exports.Euler = Euler;
Euler.prototype.isEuler = true;
Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

var Layers = /*#__PURE__*/function () {
  function Layers() {
    _classCallCheck(this, Layers);

    this.mask = 1 | 0;
  }

  _createClass(Layers, [{
    key: "set",
    value: function set(channel) {
      this.mask = (1 << channel | 0) >>> 0;
    }
  }, {
    key: "enable",
    value: function enable(channel) {
      this.mask |= 1 << channel | 0;
    }
  }, {
    key: "enableAll",
    value: function enableAll() {
      this.mask = 0xffffffff | 0;
    }
  }, {
    key: "toggle",
    value: function toggle(channel) {
      this.mask ^= 1 << channel | 0;
    }
  }, {
    key: "disable",
    value: function disable(channel) {
      this.mask &= ~(1 << channel | 0);
    }
  }, {
    key: "disableAll",
    value: function disableAll() {
      this.mask = 0;
    }
  }, {
    key: "test",
    value: function test(layers) {
      return (this.mask & layers.mask) !== 0;
    }
  }, {
    key: "isEnabled",
    value: function isEnabled(channel) {
      return (this.mask & (1 << channel | 0)) !== 0;
    }
  }]);

  return Layers;
}();

exports.Layers = Layers;
var _object3DId = 0;

var _v1$4 = /*@__PURE__*/new Vector3();

var _q1 = /*@__PURE__*/new Quaternion();

var _m1$1 = /*@__PURE__*/new Matrix4();

var _target = /*@__PURE__*/new Vector3();

var _position$3 = /*@__PURE__*/new Vector3();

var _scale$2 = /*@__PURE__*/new Vector3();

var _quaternion$2 = /*@__PURE__*/new Quaternion();

var _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);

var _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);

var _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);

var _addedEvent = {
  type: 'added'
};
var _removedEvent = {
  type: 'removed'
};

var Object3D = /*#__PURE__*/function (_EventDispatcher3) {
  _inherits(Object3D, _EventDispatcher3);

  var _super8 = _createSuper(Object3D);

  function Object3D() {
    var _this9;

    _classCallCheck(this, Object3D);

    _this9 = _super8.call(this);
    Object.defineProperty(_assertThisInitialized(_this9), 'id', {
      value: _object3DId++
    });
    _this9.uuid = generateUUID();
    _this9.name = '';
    _this9.type = 'Object3D';
    _this9.parent = null;
    _this9.children = [];
    _this9.up = Object3D.DefaultUp.clone();
    var position = new Vector3();
    var rotation = new Euler();
    var quaternion = new Quaternion();
    var scale = new Vector3(1, 1, 1);

    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }

    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }

    rotation._onChange(onRotationChange);

    quaternion._onChange(onQuaternionChange);

    Object.defineProperties(_assertThisInitialized(_this9), {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    _this9.matrix = new Matrix4();
    _this9.matrixWorld = new Matrix4();
    _this9.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    _this9.matrixWorldNeedsUpdate = false;
    _this9.layers = new Layers();
    _this9.visible = true;
    _this9.castShadow = false;
    _this9.receiveShadow = false;
    _this9.frustumCulled = true;
    _this9.renderOrder = 0;
    _this9.animations = [];
    _this9.userData = {};
    return _this9;
  }

  _createClass(Object3D, [{
    key: "onBeforeRender",
    value: function
      /* renderer, scene, camera, geometry, material, group */
    onBeforeRender() {}
  }, {
    key: "onAfterRender",
    value: function
      /* renderer, scene, camera, geometry, material, group */
    onAfterRender() {}
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      if (this.matrixAutoUpdate) this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(q) {
      this.quaternion.premultiply(q);
      return this;
    }
  }, {
    key: "setRotationFromAxisAngle",
    value: function setRotationFromAxisAngle(axis, angle) {
      // assumes axis is normalized
      this.quaternion.setFromAxisAngle(axis, angle);
    }
  }, {
    key: "setRotationFromEuler",
    value: function setRotationFromEuler(euler) {
      this.quaternion.setFromEuler(euler, true);
    }
  }, {
    key: "setRotationFromMatrix",
    value: function setRotationFromMatrix(m) {
      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
      this.quaternion.setFromRotationMatrix(m);
    }
  }, {
    key: "setRotationFromQuaternion",
    value: function setRotationFromQuaternion(q) {
      // assumes q is normalized
      this.quaternion.copy(q);
    }
  }, {
    key: "rotateOnAxis",
    value: function rotateOnAxis(axis, angle) {
      // rotate object on axis in object space
      // axis is assumed to be normalized
      _q1.setFromAxisAngle(axis, angle);

      this.quaternion.multiply(_q1);
      return this;
    }
  }, {
    key: "rotateOnWorldAxis",
    value: function rotateOnWorldAxis(axis, angle) {
      // rotate object on axis in world space
      // axis is assumed to be normalized
      // method assumes no rotated parent
      _q1.setFromAxisAngle(axis, angle);

      this.quaternion.premultiply(_q1);
      return this;
    }
  }, {
    key: "rotateX",
    value: function rotateX(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    }
  }, {
    key: "rotateY",
    value: function rotateY(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    }
  }, {
    key: "translateOnAxis",
    value: function translateOnAxis(axis, distance) {
      // translate object by distance along axis in object space
      // axis is assumed to be normalized
      _v1$4.copy(axis).applyQuaternion(this.quaternion);

      this.position.add(_v1$4.multiplyScalar(distance));
      return this;
    }
  }, {
    key: "translateX",
    value: function translateX(distance) {
      return this.translateOnAxis(_xAxis, distance);
    }
  }, {
    key: "translateY",
    value: function translateY(distance) {
      return this.translateOnAxis(_yAxis, distance);
    }
  }, {
    key: "translateZ",
    value: function translateZ(distance) {
      return this.translateOnAxis(_zAxis, distance);
    }
  }, {
    key: "localToWorld",
    value: function localToWorld(vector) {
      return vector.applyMatrix4(this.matrixWorld);
    }
  }, {
    key: "worldToLocal",
    value: function worldToLocal(vector) {
      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    }
  }, {
    key: "lookAt",
    value: function lookAt(x, y, z) {
      // This method does not support objects having non-uniformly-scaled parent(s)
      if (x.isVector3) {
        _target.copy(x);
      } else {
        _target.set(x, y, z);
      }

      var parent = this.parent;
      this.updateWorldMatrix(true, false);

      _position$3.setFromMatrixPosition(this.matrixWorld);

      if (this.isCamera || this.isLight) {
        _m1$1.lookAt(_position$3, _target, this.up);
      } else {
        _m1$1.lookAt(_target, _position$3, this.up);
      }

      this.quaternion.setFromRotationMatrix(_m1$1);

      if (parent) {
        _m1$1.extractRotation(parent.matrixWorld);

        _q1.setFromRotationMatrix(_m1$1);

        this.quaternion.premultiply(_q1.invert());
      }
    }
  }, {
    key: "add",
    value: function add(object) {
      if (arguments.length > 1) {
        for (var _i19 = 0; _i19 < arguments.length; _i19++) {
          this.add(arguments[_i19]);
        }

        return this;
      }

      if (object === this) {
        console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
        return this;
      }

      if (object && object.isObject3D) {
        if (object.parent !== null) {
          object.parent.remove(object);
        }

        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
      } else {
        console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
      }

      return this;
    }
  }, {
    key: "remove",
    value: function remove(object) {
      if (arguments.length > 1) {
        for (var _i20 = 0; _i20 < arguments.length; _i20++) {
          this.remove(arguments[_i20]);
        }

        return this;
      }

      var index = this.children.indexOf(object);

      if (index !== -1) {
        object.parent = null;
        this.children.splice(index, 1);
        object.dispatchEvent(_removedEvent);
      }

      return this;
    }
  }, {
    key: "removeFromParent",
    value: function removeFromParent() {
      var parent = this.parent;

      if (parent !== null) {
        parent.remove(this);
      }

      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      for (var _i21 = 0; _i21 < this.children.length; _i21++) {
        var object = this.children[_i21];
        object.parent = null;
        object.dispatchEvent(_removedEvent);
      }

      this.children.length = 0;
      return this;
    }
  }, {
    key: "attach",
    value: function attach(object) {
      // adds object as a child of this, while maintaining the object's world transform
      // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
      this.updateWorldMatrix(true, false);

      _m1$1.copy(this.matrixWorld).invert();

      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);

        _m1$1.multiply(object.parent.matrixWorld);
      }

      object.applyMatrix4(_m1$1);
      this.add(object);
      object.updateWorldMatrix(false, true);
      return this;
    }
  }, {
    key: "getObjectById",
    value: function getObjectById(id) {
      return this.getObjectByProperty('id', id);
    }
  }, {
    key: "getObjectByName",
    value: function getObjectByName(name) {
      return this.getObjectByProperty('name', name);
    }
  }, {
    key: "getObjectByProperty",
    value: function getObjectByProperty(name, value) {
      if (this[name] === value) return this;

      for (var _i22 = 0, l = this.children.length; _i22 < l; _i22++) {
        var child = this.children[_i22];
        var object = child.getObjectByProperty(name, value);

        if (object !== undefined) {
          return object;
        }
      }

      return undefined;
    }
  }, {
    key: "getWorldPosition",
    value: function getWorldPosition(target) {
      this.updateWorldMatrix(true, false);
      return target.setFromMatrixPosition(this.matrixWorld);
    }
  }, {
    key: "getWorldQuaternion",
    value: function getWorldQuaternion(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, target, _scale$2);
      return target;
    }
  }, {
    key: "getWorldScale",
    value: function getWorldScale(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, _quaternion$2, target);
      return target;
    }
  }, {
    key: "getWorldDirection",
    value: function getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      var e = this.matrixWorld.elements;
      return target.set(e[8], e[9], e[10]).normalize();
    }
  }, {
    key: "raycast",
    value: function
      /* raycaster, intersects */
    raycast() {}
  }, {
    key: "traverse",
    value: function traverse(callback) {
      callback(this);
      var children = this.children;

      for (var _i23 = 0, l = children.length; _i23 < l; _i23++) {
        children[_i23].traverse(callback);
      }
    }
  }, {
    key: "traverseVisible",
    value: function traverseVisible(callback) {
      if (this.visible === false) return;
      callback(this);
      var children = this.children;

      for (var _i24 = 0, l = children.length; _i24 < l; _i24++) {
        children[_i24].traverseVisible(callback);
      }
    }
  }, {
    key: "traverseAncestors",
    value: function traverseAncestors(callback) {
      var parent = this.parent;

      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      if (this.matrixAutoUpdate) this.updateMatrix();

      if (this.matrixWorldNeedsUpdate || force) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }

        this.matrixWorldNeedsUpdate = false;
        force = true;
      } // update children


      var children = this.children;

      for (var _i25 = 0, l = children.length; _i25 < l; _i25++) {
        children[_i25].updateMatrixWorld(force);
      }
    }
  }, {
    key: "updateWorldMatrix",
    value: function updateWorldMatrix(updateParents, updateChildren) {
      var parent = this.parent;

      if (updateParents === true && parent !== null) {
        parent.updateWorldMatrix(true, false);
      }

      if (this.matrixAutoUpdate) this.updateMatrix();

      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      } // update children


      if (updateChildren === true) {
        var children = this.children;

        for (var _i26 = 0, l = children.length; _i26 < l; _i26++) {
          children[_i26].updateWorldMatrix(false, true);
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      // meta is a string when called from JSON.stringify
      var isRootObject = meta === undefined || typeof meta === 'string';
      var output = {}; // meta is a hash used to collect geometries, materials.
      // not providing it implies that this is the root object
      // being serialized.

      if (isRootObject) {
        // initialize meta obj
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {}
        };
        output.metadata = {
          version: 4.5,
          type: 'Object',
          generator: 'Object3D.toJSON'
        };
      } // standard Object3D serialization


      var object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== '') object.name = this.name;
      if (this.castShadow === true) object.castShadow = true;
      if (this.receiveShadow === true) object.receiveShadow = true;
      if (this.visible === false) object.visible = false;
      if (this.frustumCulled === false) object.frustumCulled = false;
      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
      if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

      if (this.isInstancedMesh) {
        object.type = 'InstancedMesh';
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
      } //


      function serialize(library, element) {
        if (library[element.uuid] === undefined) {
          library[element.uuid] = element.toJSON(meta);
        }

        return element.uuid;
      }

      if (this.isScene) {
        if (this.background) {
          if (this.background.isColor) {
            object.background = this.background.toJSON();
          } else if (this.background.isTexture) {
            object.background = this.background.toJSON(meta).uuid;
          }
        }

        if (this.environment && this.environment.isTexture) {
          object.environment = this.environment.toJSON(meta).uuid;
        }
      } else if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        var parameters = this.geometry.parameters;

        if (parameters !== undefined && parameters.shapes !== undefined) {
          var shapes = parameters.shapes;

          if (Array.isArray(shapes)) {
            for (var _i27 = 0, l = shapes.length; _i27 < l; _i27++) {
              var shape = shapes[_i27];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }

      if (this.isSkinnedMesh) {
        object.bindMode = this.bindMode;
        object.bindMatrix = this.bindMatrix.toArray();

        if (this.skeleton !== undefined) {
          serialize(meta.skeletons, this.skeleton);
          object.skeleton = this.skeleton.uuid;
        }
      }

      if (this.material !== undefined) {
        if (Array.isArray(this.material)) {
          var uuids = [];

          for (var _i28 = 0, _l2 = this.material.length; _i28 < _l2; _i28++) {
            uuids.push(serialize(meta.materials, this.material[_i28]));
          }

          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      } //


      if (this.children.length > 0) {
        object.children = [];

        for (var _i29 = 0; _i29 < this.children.length; _i29++) {
          object.children.push(this.children[_i29].toJSON(meta).object);
        }
      } //


      if (this.animations.length > 0) {
        object.animations = [];

        for (var _i30 = 0; _i30 < this.animations.length; _i30++) {
          var animation = this.animations[_i30];
          object.animations.push(serialize(meta.animations, animation));
        }
      }

      if (isRootObject) {
        var geometries = extractFromCache(meta.geometries);
        var materials = extractFromCache(meta.materials);
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);

        var _shapes = extractFromCache(meta.shapes);

        var skeletons = extractFromCache(meta.skeletons);
        var animations = extractFromCache(meta.animations);
        var nodes = extractFromCache(meta.nodes);
        if (geometries.length > 0) output.geometries = geometries;
        if (materials.length > 0) output.materials = materials;
        if (textures.length > 0) output.textures = textures;
        if (images.length > 0) output.images = images;
        if (_shapes.length > 0) output.shapes = _shapes;
        if (skeletons.length > 0) output.skeletons = skeletons;
        if (animations.length > 0) output.animations = animations;
        if (nodes.length > 0) output.nodes = nodes;
      }

      output.object = object;
      return output; // extract data from the cache hash
      // remove metadata on each item
      // and return as array

      function extractFromCache(cache) {
        var values = [];

        for (var key in cache) {
          var data = cache[key];
          delete data.metadata;
          values.push(data);
        }

        return values;
      }
    }
  }, {
    key: "clone",
    value: function clone(recursive) {
      return new this.constructor().copy(this, recursive);
    }
  }, {
    key: "copy",
    value: function copy(source, recursive = true) {
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.rotation.order = source.rotation.order;
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.userData = JSON.parse(JSON.stringify(source.userData));

      if (recursive === true) {
        for (var _i31 = 0; _i31 < source.children.length; _i31++) {
          var child = source.children[_i31];
          this.add(child.clone());
        }
      }

      return this;
    }
  }]);

  return Object3D;
}(EventDispatcher);

exports.Object3D = Object3D;
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype.isObject3D = true;

var _v0$1 = /*@__PURE__*/new Vector3();

var _v1$3 = /*@__PURE__*/new Vector3();

var _v2$2 = /*@__PURE__*/new Vector3();

var _v3$1 = /*@__PURE__*/new Vector3();

var _vab = /*@__PURE__*/new Vector3();

var _vac = /*@__PURE__*/new Vector3();

var _vbc = /*@__PURE__*/new Vector3();

var _vap = /*@__PURE__*/new Vector3();

var _vbp = /*@__PURE__*/new Vector3();

var _vcp = /*@__PURE__*/new Vector3();

var Triangle = /*#__PURE__*/function () {
  function Triangle(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    _classCallCheck(this, Triangle);

    this.a = a;
    this.b = b;
    this.c = c;
  }

  _createClass(Triangle, [{
    key: "set",
    value: function set(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    }
  }, {
    key: "setFromPointsAndIndices",
    value: function setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    }
  }, {
    key: "setFromAttributeAndIndices",
    value: function setFromAttributeAndIndices(attribute, i0, i1, i2) {
      this.a.fromBufferAttribute(attribute, i0);
      this.b.fromBufferAttribute(attribute, i1);
      this.c.fromBufferAttribute(attribute, i2);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
  }, {
    key: "getArea",
    value: function getArea() {
      _v0$1.subVectors(this.c, this.b);

      _v1$3.subVectors(this.a, this.b);

      return _v0$1.cross(_v1$3).length() * 0.5;
    }
  }, {
    key: "getMidpoint",
    value: function getMidpoint(target) {
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
  }, {
    key: "getNormal",
    value: function getNormal(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    }
  }, {
    key: "getPlane",
    value: function getPlane(target) {
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
  }, {
    key: "getBarycoord",
    value: function getBarycoord(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
  }, {
    key: "getUV",
    value: function getUV(point, uv1, uv2, uv3, target) {
      return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
  }, {
    key: "isFrontFacing",
    value: function isFrontFacing(direction) {
      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(p, target) {
      var a = this.a,
          b = this.b,
          c = this.c;
      var v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
      // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
      // under the accompanying license; see chapter 5.1.5 for detailed explanation.
      // basically, we're distinguishing which of the voronoi regions of the triangle
      // the point lies in with the minimum amount of redundant computation.

      _vab.subVectors(b, a);

      _vac.subVectors(c, a);

      _vap.subVectors(p, a);

      var d1 = _vab.dot(_vap);

      var d2 = _vac.dot(_vap);

      if (d1 <= 0 && d2 <= 0) {
        // vertex region of A; barycentric coords (1, 0, 0)
        return target.copy(a);
      }

      _vbp.subVectors(p, b);

      var d3 = _vab.dot(_vbp);

      var d4 = _vac.dot(_vbp);

      if (d3 >= 0 && d4 <= d3) {
        // vertex region of B; barycentric coords (0, 1, 0)
        return target.copy(b);
      }

      var vc = d1 * d4 - d3 * d2;

      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

        return target.copy(a).addScaledVector(_vab, v);
      }

      _vcp.subVectors(p, c);

      var d5 = _vab.dot(_vcp);

      var d6 = _vac.dot(_vcp);

      if (d6 >= 0 && d5 <= d6) {
        // vertex region of C; barycentric coords (0, 0, 1)
        return target.copy(c);
      }

      var vb = d5 * d2 - d1 * d6;

      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

        return target.copy(a).addScaledVector(_vac, w);
      }

      var va = d3 * d6 - d5 * d4;

      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c, b);

        w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

        return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
      } // face region


      var denom = 1 / (va + vb + vc); // u = va * denom

      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    }
  }, {
    key: "equals",
    value: function equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  }], [{
    key: "getNormal",
    value: function getNormal(a, b, c, target) {
      target.subVectors(c, b);

      _v0$1.subVectors(a, b);

      target.cross(_v0$1);
      var targetLengthSq = target.lengthSq();

      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }

      return target.set(0, 0, 0);
    } // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html

  }, {
    key: "getBarycoord",
    value: function getBarycoord(point, a, b, c, target) {
      _v0$1.subVectors(c, a);

      _v1$3.subVectors(b, a);

      _v2$2.subVectors(point, a);

      var dot00 = _v0$1.dot(_v0$1);

      var dot01 = _v0$1.dot(_v1$3);

      var dot02 = _v0$1.dot(_v2$2);

      var dot11 = _v1$3.dot(_v1$3);

      var dot12 = _v1$3.dot(_v2$2);

      var denom = dot00 * dot11 - dot01 * dot01; // collinear or singular triangle

      if (denom === 0) {
        // arbitrary location outside of triangle?
        // not sure if this is the best idea, maybe should be returning undefined
        return target.set(-2, -1, -1);
      }

      var invDenom = 1 / denom;
      var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      var v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

      return target.set(1 - u - v, v, u);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point, a, b, c) {
      this.getBarycoord(point, a, b, c, _v3$1);
      return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
    }
  }, {
    key: "getUV",
    value: function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
      this.getBarycoord(point, p1, p2, p3, _v3$1);
      target.set(0, 0);
      target.addScaledVector(uv1, _v3$1.x);
      target.addScaledVector(uv2, _v3$1.y);
      target.addScaledVector(uv3, _v3$1.z);
      return target;
    }
  }, {
    key: "isFrontFacing",
    value: function isFrontFacing(a, b, c, direction) {
      _v0$1.subVectors(c, b);

      _v1$3.subVectors(a, b); // strictly front facing


      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
  }]);

  return Triangle;
}();

exports.Triangle = Triangle;
var materialId = 0;

var Material = /*#__PURE__*/function (_EventDispatcher4) {
  _inherits(Material, _EventDispatcher4);

  var _super9 = _createSuper(Material);

  function Material() {
    var _this10;

    _classCallCheck(this, Material);

    _this10 = _super9.call(this);
    Object.defineProperty(_assertThisInitialized(_this10), 'id', {
      value: materialId++
    });
    _this10.uuid = generateUUID();
    _this10.name = '';
    _this10.type = 'Material';
    _this10.fog = true;
    _this10.blending = NormalBlending;
    _this10.side = FrontSide;
    _this10.vertexColors = false;
    _this10.opacity = 1;
    _this10.transparent = false;
    _this10.blendSrc = SrcAlphaFactor;
    _this10.blendDst = OneMinusSrcAlphaFactor;
    _this10.blendEquation = AddEquation;
    _this10.blendSrcAlpha = null;
    _this10.blendDstAlpha = null;
    _this10.blendEquationAlpha = null;
    _this10.depthFunc = LessEqualDepth;
    _this10.depthTest = true;
    _this10.depthWrite = true;
    _this10.stencilWriteMask = 0xff;
    _this10.stencilFunc = AlwaysStencilFunc;
    _this10.stencilRef = 0;
    _this10.stencilFuncMask = 0xff;
    _this10.stencilFail = KeepStencilOp;
    _this10.stencilZFail = KeepStencilOp;
    _this10.stencilZPass = KeepStencilOp;
    _this10.stencilWrite = false;
    _this10.clippingPlanes = null;
    _this10.clipIntersection = false;
    _this10.clipShadows = false;
    _this10.shadowSide = null;
    _this10.colorWrite = true;
    _this10.precision = null; // override the renderer's default precision for this material

    _this10.polygonOffset = false;
    _this10.polygonOffsetFactor = 0;
    _this10.polygonOffsetUnits = 0;
    _this10.dithering = false;
    _this10.alphaToCoverage = false;
    _this10.premultipliedAlpha = false;
    _this10.visible = true;
    _this10.toneMapped = true;
    _this10.userData = {};
    _this10.version = 0;
    _this10._alphaTest = 0;
    return _this10;
  }

  _createClass(Material, [{
    key: "alphaTest",
    get: function get() {
      return this._alphaTest;
    },
    set: function set(value) {
      if (this._alphaTest > 0 !== value > 0) {
        this.version++;
      }

      this._alphaTest = value;
    }
  }, {
    key: "onBuild",
    value: function
      /* shaderobject, renderer */
    onBuild() {}
  }, {
    key: "onBeforeRender",
    value: function
      /* renderer, scene, camera, geometry, object, group */
    onBeforeRender() {}
  }, {
    key: "onBeforeCompile",
    value: function
      /* shaderobject, renderer */
    onBeforeCompile() {}
  }, {
    key: "customProgramCacheKey",
    value: function customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
  }, {
    key: "setValues",
    value: function setValues(values) {
      if (values === undefined) return;

      for (var key in values) {
        var newValue = values[key];

        if (newValue === undefined) {
          console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
          continue;
        } // for backward compatibility if shading is set in the constructor


        if (key === 'shading') {
          console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
          this.flatShading = newValue === FlatShading ? true : false;
          continue;
        }

        var currentValue = this[key];

        if (currentValue === undefined) {
          console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
          continue;
        }

        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var isRootObject = meta === undefined || typeof meta === 'string';

      if (isRootObject) {
        meta = {
          textures: {},
          images: {}
        };
      }

      var data = {
        metadata: {
          version: 4.5,
          type: 'Material',
          generator: 'Material.toJSON'
        }
      }; // standard Material serialization

      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '') data.name = this.name;
      if (this.color && this.color.isColor) data.color = this.color.getHex();
      if (this.roughness !== undefined) data.roughness = this.roughness;
      if (this.metalness !== undefined) data.metalness = this.metalness;
      if (this.sheen !== undefined) data.sheen = this.sheen;
      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
      if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
      if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
      if (this.shininess !== undefined) data.shininess = this.shininess;
      if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

      if (this.clearcoatMap && this.clearcoatMap.isTexture) {
        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
      }

      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
      }

      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }

      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;

      if (this.lightMap && this.lightMap.isTexture) {
        data.lightMap = this.lightMap.toJSON(meta).uuid;
        data.lightMapIntensity = this.lightMapIntensity;
      }

      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }

      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }

      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }

      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }

      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;

      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        if (this.combine !== undefined) data.combine = this.combine;
      }

      if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
      if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
      if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;

      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }

      if (this.transmission !== undefined) data.transmission = this.transmission;
      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
      if (this.thickness !== undefined) data.thickness = this.thickness;
      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
      if (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;
      if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
      if (this.size !== undefined) data.size = this.size;
      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
      if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending) data.blending = this.blending;
      if (this.side !== FrontSide) data.side = this.side;
      if (this.vertexColors) data.vertexColors = true;
      if (this.opacity < 1) data.opacity = this.opacity;
      if (this.transparent === true) data.transparent = this.transparent;
      data.depthFunc = this.depthFunc;
      data.depthTest = this.depthTest;
      data.depthWrite = this.depthWrite;
      data.colorWrite = this.colorWrite;
      data.stencilWrite = this.stencilWrite;
      data.stencilWriteMask = this.stencilWriteMask;
      data.stencilFunc = this.stencilFunc;
      data.stencilRef = this.stencilRef;
      data.stencilFuncMask = this.stencilFuncMask;
      data.stencilFail = this.stencilFail;
      data.stencilZFail = this.stencilZFail;
      data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

      if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;
      if (this.polygonOffset === true) data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;
      if (this.dashSize !== undefined) data.dashSize = this.dashSize;
      if (this.gapSize !== undefined) data.gapSize = this.gapSize;
      if (this.scale !== undefined) data.scale = this.scale;
      if (this.dithering === true) data.dithering = true;
      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
      if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
      if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
      if (this.wireframe === true) data.wireframe = this.wireframe;
      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.flatShading === true) data.flatShading = this.flatShading;
      if (this.visible === false) data.visible = false;
      if (this.toneMapped === false) data.toneMapped = false;
      if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

      function extractFromCache(cache) {
        var values = [];

        for (var key in cache) {
          var _data2 = cache[key];
          delete _data2.metadata;
          values.push(_data2);
        }

        return values;
      }

      if (isRootObject) {
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);
        if (textures.length > 0) data.textures = textures;
        if (images.length > 0) data.images = images;
      }

      return data;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.name = source.name;
      this.fog = source.fog;
      this.blending = source.blending;
      this.side = source.side;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      var srcPlanes = source.clippingPlanes;
      var dstPlanes = null;

      if (srcPlanes !== null) {
        var n = srcPlanes.length;
        dstPlanes = new Array(n);

        for (var _i32 = 0; _i32 !== n; ++_i32) {
          dstPlanes[_i32] = srcPlanes[_i32].clone();
        }
      }

      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.alphaToCoverage = source.alphaToCoverage;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }]);

  return Material;
}(EventDispatcher);

exports.Material = Material;
Material.prototype.isMaterial = true;

Material.fromType = function
  /*type*/
() {
  // TODO: Behavior added in Materials.js
  return null;
};

var MeshBasicMaterial = /*#__PURE__*/function (_Material) {
  _inherits(MeshBasicMaterial, _Material);

  var _super10 = _createSuper(MeshBasicMaterial);

  function MeshBasicMaterial(parameters) {
    var _this11;

    _classCallCheck(this, MeshBasicMaterial);

    _this11 = _super10.call(this);
    _this11.type = 'MeshBasicMaterial';
    _this11.color = new Color(0xffffff); // emissive

    _this11.map = null;
    _this11.lightMap = null;
    _this11.lightMapIntensity = 1.0;
    _this11.aoMap = null;
    _this11.aoMapIntensity = 1.0;
    _this11.specularMap = null;
    _this11.alphaMap = null;
    _this11.envMap = null;
    _this11.combine = MultiplyOperation;
    _this11.reflectivity = 1;
    _this11.refractionRatio = 0.98;
    _this11.wireframe = false;
    _this11.wireframeLinewidth = 1;
    _this11.wireframeLinecap = 'round';
    _this11.wireframeLinejoin = 'round';

    _this11.setValues(parameters);

    return _this11;
  }

  _createClass(MeshBasicMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(MeshBasicMaterial.prototype), "copy", this).call(this, source);

      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      return this;
    }
  }]);

  return MeshBasicMaterial;
}(Material);

exports.MeshBasicMaterial = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

var _vector$9 = /*@__PURE__*/new Vector3();

var _vector2$1 = /*@__PURE__*/new Vector2();

var BufferAttribute = /*#__PURE__*/function () {
  function BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, BufferAttribute);

    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.version = 0;
  }

  _createClass(BufferAttribute, [{
    key: "onUploadCallback",
    value: function onUploadCallback() {}
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "setUsage",
    value: function setUsage(value) {
      this.usage = value;
      return this;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      return this;
    }
  }, {
    key: "copyAt",
    value: function copyAt(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;

      for (var _i33 = 0, l = this.itemSize; _i33 < l; _i33++) {
        this.array[index1 + _i33] = attribute.array[index2 + _i33];
      }

      return this;
    }
  }, {
    key: "copyArray",
    value: function copyArray(array) {
      this.array.set(array);
      return this;
    }
  }, {
    key: "copyColorsArray",
    value: function copyColorsArray(colors) {
      var array = this.array;
      var offset = 0;

      for (var _i34 = 0, l = colors.length; _i34 < l; _i34++) {
        var color = colors[_i34];

        if (color === undefined) {
          console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', _i34);
          color = new Color();
        }

        array[offset++] = color.r;
        array[offset++] = color.g;
        array[offset++] = color.b;
      }

      return this;
    }
  }, {
    key: "copyVector2sArray",
    value: function copyVector2sArray(vectors) {
      var array = this.array;
      var offset = 0;

      for (var _i35 = 0, l = vectors.length; _i35 < l; _i35++) {
        var vector = vectors[_i35];

        if (vector === undefined) {
          console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', _i35);
          vector = new Vector2();
        }

        array[offset++] = vector.x;
        array[offset++] = vector.y;
      }

      return this;
    }
  }, {
    key: "copyVector3sArray",
    value: function copyVector3sArray(vectors) {
      var array = this.array;
      var offset = 0;

      for (var _i36 = 0, l = vectors.length; _i36 < l; _i36++) {
        var vector = vectors[_i36];

        if (vector === undefined) {
          console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', _i36);
          vector = new Vector3();
        }

        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
      }

      return this;
    }
  }, {
    key: "copyVector4sArray",
    value: function copyVector4sArray(vectors) {
      var array = this.array;
      var offset = 0;

      for (var _i37 = 0, l = vectors.length; _i37 < l; _i37++) {
        var vector = vectors[_i37];

        if (vector === undefined) {
          console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', _i37);
          vector = new Vector4();
        }

        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
        array[offset++] = vector.w;
      }

      return this;
    }
  }, {
    key: "applyMatrix3",
    value: function applyMatrix3(m) {
      if (this.itemSize === 2) {
        for (var _i38 = 0, l = this.count; _i38 < l; _i38++) {
          _vector2$1.fromBufferAttribute(this, _i38);

          _vector2$1.applyMatrix3(m);

          this.setXY(_i38, _vector2$1.x, _vector2$1.y);
        }
      } else if (this.itemSize === 3) {
        for (var _i39 = 0, _l3 = this.count; _i39 < _l3; _i39++) {
          _vector$9.fromBufferAttribute(this, _i39);

          _vector$9.applyMatrix3(m);

          this.setXYZ(_i39, _vector$9.x, _vector$9.y, _vector$9.z);
        }
      }

      return this;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      for (var _i40 = 0, l = this.count; _i40 < l; _i40++) {
        _vector$9.fromBufferAttribute(this, _i40);

        _vector$9.applyMatrix4(m);

        this.setXYZ(_i40, _vector$9.x, _vector$9.y, _vector$9.z);
      }

      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(m) {
      for (var _i41 = 0, l = this.count; _i41 < l; _i41++) {
        _vector$9.fromBufferAttribute(this, _i41);

        _vector$9.applyNormalMatrix(m);

        this.setXYZ(_i41, _vector$9.x, _vector$9.y, _vector$9.z);
      }

      return this;
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(m) {
      for (var _i42 = 0, l = this.count; _i42 < l; _i42++) {
        _vector$9.fromBufferAttribute(this, _i42);

        _vector$9.transformDirection(m);

        this.setXYZ(_i42, _vector$9.x, _vector$9.y, _vector$9.z);
      }

      return this;
    }
  }, {
    key: "set",
    value: function set(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    }
  }, {
    key: "getX",
    value: function getX(index) {
      return this.array[index * this.itemSize];
    }
  }, {
    key: "setX",
    value: function setX(index, x) {
      this.array[index * this.itemSize] = x;
      return this;
    }
  }, {
    key: "getY",
    value: function getY(index) {
      return this.array[index * this.itemSize + 1];
    }
  }, {
    key: "setY",
    value: function setY(index, y) {
      this.array[index * this.itemSize + 1] = y;
      return this;
    }
  }, {
    key: "getZ",
    value: function getZ(index) {
      return this.array[index * this.itemSize + 2];
    }
  }, {
    key: "setZ",
    value: function setZ(index, z) {
      this.array[index * this.itemSize + 2] = z;
      return this;
    }
  }, {
    key: "getW",
    value: function getW(index) {
      return this.array[index * this.itemSize + 3];
    }
  }, {
    key: "setW",
    value: function setW(index, w) {
      this.array[index * this.itemSize + 3] = w;
      return this;
    }
  }, {
    key: "setXY",
    value: function setXY(index, x, y) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(index, x, y, z) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(index, x, y, z, w) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    }
  }, {
    key: "onUpload",
    value: function onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized
      };
      if (this.name !== '') data.name = this.name;
      if (this.usage !== StaticDrawUsage) data.usage = this.usage;
      if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
      return data;
    }
  }]);

  return BufferAttribute;
}();

exports.BufferAttribute = BufferAttribute;
BufferAttribute.prototype.isBufferAttribute = true; //

var Int8BufferAttribute = /*#__PURE__*/function (_BufferAttribute) {
  _inherits(Int8BufferAttribute, _BufferAttribute);

  var _super11 = _createSuper(Int8BufferAttribute);

  function Int8BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Int8BufferAttribute);

    return _super11.call(this, new Int8Array(array), itemSize, normalized);
  }

  return _createClass(Int8BufferAttribute);
}(BufferAttribute);

exports.Int8BufferAttribute = Int8BufferAttribute;

var Uint8BufferAttribute = /*#__PURE__*/function (_BufferAttribute2) {
  _inherits(Uint8BufferAttribute, _BufferAttribute2);

  var _super12 = _createSuper(Uint8BufferAttribute);

  function Uint8BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Uint8BufferAttribute);

    return _super12.call(this, new Uint8Array(array), itemSize, normalized);
  }

  return _createClass(Uint8BufferAttribute);
}(BufferAttribute);

exports.Uint8BufferAttribute = Uint8BufferAttribute;

var Uint8ClampedBufferAttribute = /*#__PURE__*/function (_BufferAttribute3) {
  _inherits(Uint8ClampedBufferAttribute, _BufferAttribute3);

  var _super13 = _createSuper(Uint8ClampedBufferAttribute);

  function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Uint8ClampedBufferAttribute);

    return _super13.call(this, new Uint8ClampedArray(array), itemSize, normalized);
  }

  return _createClass(Uint8ClampedBufferAttribute);
}(BufferAttribute);

exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;

var Int16BufferAttribute = /*#__PURE__*/function (_BufferAttribute4) {
  _inherits(Int16BufferAttribute, _BufferAttribute4);

  var _super14 = _createSuper(Int16BufferAttribute);

  function Int16BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Int16BufferAttribute);

    return _super14.call(this, new Int16Array(array), itemSize, normalized);
  }

  return _createClass(Int16BufferAttribute);
}(BufferAttribute);

exports.Int16BufferAttribute = Int16BufferAttribute;

var Uint16BufferAttribute = /*#__PURE__*/function (_BufferAttribute5) {
  _inherits(Uint16BufferAttribute, _BufferAttribute5);

  var _super15 = _createSuper(Uint16BufferAttribute);

  function Uint16BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Uint16BufferAttribute);

    return _super15.call(this, new Uint16Array(array), itemSize, normalized);
  }

  return _createClass(Uint16BufferAttribute);
}(BufferAttribute);

exports.Uint16BufferAttribute = Uint16BufferAttribute;

var Int32BufferAttribute = /*#__PURE__*/function (_BufferAttribute6) {
  _inherits(Int32BufferAttribute, _BufferAttribute6);

  var _super16 = _createSuper(Int32BufferAttribute);

  function Int32BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Int32BufferAttribute);

    return _super16.call(this, new Int32Array(array), itemSize, normalized);
  }

  return _createClass(Int32BufferAttribute);
}(BufferAttribute);

exports.Int32BufferAttribute = Int32BufferAttribute;

var Uint32BufferAttribute = /*#__PURE__*/function (_BufferAttribute7) {
  _inherits(Uint32BufferAttribute, _BufferAttribute7);

  var _super17 = _createSuper(Uint32BufferAttribute);

  function Uint32BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Uint32BufferAttribute);

    return _super17.call(this, new Uint32Array(array), itemSize, normalized);
  }

  return _createClass(Uint32BufferAttribute);
}(BufferAttribute);

exports.Uint32BufferAttribute = Uint32BufferAttribute;

var Float16BufferAttribute = /*#__PURE__*/function (_BufferAttribute8) {
  _inherits(Float16BufferAttribute, _BufferAttribute8);

  var _super18 = _createSuper(Float16BufferAttribute);

  function Float16BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Float16BufferAttribute);

    return _super18.call(this, new Uint16Array(array), itemSize, normalized);
  }

  return _createClass(Float16BufferAttribute);
}(BufferAttribute);

exports.Float16BufferAttribute = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

var Float32BufferAttribute = /*#__PURE__*/function (_BufferAttribute9) {
  _inherits(Float32BufferAttribute, _BufferAttribute9);

  var _super19 = _createSuper(Float32BufferAttribute);

  function Float32BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Float32BufferAttribute);

    return _super19.call(this, new Float32Array(array), itemSize, normalized);
  }

  return _createClass(Float32BufferAttribute);
}(BufferAttribute);

exports.Float32BufferAttribute = Float32BufferAttribute;

var Float64BufferAttribute = /*#__PURE__*/function (_BufferAttribute10) {
  _inherits(Float64BufferAttribute, _BufferAttribute10);

  var _super20 = _createSuper(Float64BufferAttribute);

  function Float64BufferAttribute(array, itemSize, normalized) {
    _classCallCheck(this, Float64BufferAttribute);

    return _super20.call(this, new Float64Array(array), itemSize, normalized);
  }

  return _createClass(Float64BufferAttribute);
}(BufferAttribute);

exports.Float64BufferAttribute = Float64BufferAttribute;
var _id$1 = 0;

var _m1 = /*@__PURE__*/new Matrix4();

var _obj = /*@__PURE__*/new Object3D();

var _offset = /*@__PURE__*/new Vector3();

var _box$1 = /*@__PURE__*/new Box3();

var _boxMorphTargets = /*@__PURE__*/new Box3();

var _vector$8 = /*@__PURE__*/new Vector3();

var BufferGeometry = /*#__PURE__*/function (_EventDispatcher5) {
  _inherits(BufferGeometry, _EventDispatcher5);

  var _super21 = _createSuper(BufferGeometry);

  function BufferGeometry() {
    var _this12;

    _classCallCheck(this, BufferGeometry);

    _this12 = _super21.call(this);
    Object.defineProperty(_assertThisInitialized(_this12), 'id', {
      value: _id$1++
    });
    _this12.uuid = generateUUID();
    _this12.name = '';
    _this12.type = 'BufferGeometry';
    _this12.index = null;
    _this12.attributes = {};
    _this12.morphAttributes = {};
    _this12.morphTargetsRelative = false;
    _this12.groups = [];
    _this12.boundingBox = null;
    _this12.boundingSphere = null;
    _this12.drawRange = {
      start: 0,
      count: Infinity
    };
    _this12.userData = {};
    return _this12;
  }

  _createClass(BufferGeometry, [{
    key: "getIndex",
    value: function getIndex() {
      return this.index;
    }
  }, {
    key: "setIndex",
    value: function setIndex(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }

      return this;
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      return this.attributes[name];
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    }
  }, {
    key: "deleteAttribute",
    value: function deleteAttribute(name) {
      delete this.attributes[name];
      return this;
    }
  }, {
    key: "hasAttribute",
    value: function hasAttribute(name) {
      return this.attributes[name] !== undefined;
    }
  }, {
    key: "addGroup",
    value: function addGroup(start, count, materialIndex = 0) {
      this.groups.push({
        start: start,
        count: count,
        materialIndex: materialIndex
      });
    }
  }, {
    key: "clearGroups",
    value: function clearGroups() {
      this.groups = [];
    }
  }, {
    key: "setDrawRange",
    value: function setDrawRange(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      var position = this.attributes.position;

      if (position !== undefined) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }

      var normal = this.attributes.normal;

      if (normal !== undefined) {
        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }

      var tangent = this.attributes.tangent;

      if (tangent !== undefined) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }

      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }

      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }

      return this;
    }
  }, {
    key: "applyQuaternion",
    value: function applyQuaternion(q) {
      _m1.makeRotationFromQuaternion(q);

      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "rotateX",
    value: function rotateX(angle) {
      // rotate geometry around world x-axis
      _m1.makeRotationX(angle);

      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "rotateY",
    value: function rotateY(angle) {
      // rotate geometry around world y-axis
      _m1.makeRotationY(angle);

      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(angle) {
      // rotate geometry around world z-axis
      _m1.makeRotationZ(angle);

      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(x, y, z) {
      // translate geometry
      _m1.makeTranslation(x, y, z);

      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "scale",
    value: function scale(x, y, z) {
      // scale geometry
      _m1.makeScale(x, y, z);

      this.applyMatrix4(_m1);
      return this;
    }
  }, {
    key: "lookAt",
    value: function lookAt(vector) {
      _obj.lookAt(vector);

      _obj.updateMatrix();

      this.applyMatrix4(_obj.matrix);
      return this;
    }
  }, {
    key: "center",
    value: function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points) {
      var position = [];

      for (var _i43 = 0, l = points.length; _i43 < l; _i43++) {
        var point = points[_i43];
        position.push(point.x, point.y, point.z || 0);
      }

      this.setAttribute('position', new Float32BufferAttribute(position, 3));
      return this;
    }
  }, {
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }

      var position = this.attributes.position;
      var morphAttributesPosition = this.morphAttributes.position;

      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
        return;
      }

      if (position !== undefined) {
        this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

        if (morphAttributesPosition) {
          for (var _i44 = 0, il = morphAttributesPosition.length; _i44 < il; _i44++) {
            var morphAttribute = morphAttributesPosition[_i44];

            _box$1.setFromBufferAttribute(morphAttribute);

            if (this.morphTargetsRelative) {
              _vector$8.addVectors(this.boundingBox.min, _box$1.min);

              this.boundingBox.expandByPoint(_vector$8);

              _vector$8.addVectors(this.boundingBox.max, _box$1.max);

              this.boundingBox.expandByPoint(_vector$8);
            } else {
              this.boundingBox.expandByPoint(_box$1.min);
              this.boundingBox.expandByPoint(_box$1.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }

      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }

      var position = this.attributes.position;
      var morphAttributesPosition = this.morphAttributes.position;

      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingSphere.set(new Vector3(), Infinity);
        return;
      }

      if (position) {
        // first, find the center of the bounding sphere
        var center = this.boundingSphere.center;

        _box$1.setFromBufferAttribute(position); // process morph attributes if present


        if (morphAttributesPosition) {
          for (var _i45 = 0, il = morphAttributesPosition.length; _i45 < il; _i45++) {
            var morphAttribute = morphAttributesPosition[_i45];

            _boxMorphTargets.setFromBufferAttribute(morphAttribute);

            if (this.morphTargetsRelative) {
              _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);

              _box$1.expandByPoint(_vector$8);

              _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);

              _box$1.expandByPoint(_vector$8);
            } else {
              _box$1.expandByPoint(_boxMorphTargets.min);

              _box$1.expandByPoint(_boxMorphTargets.max);
            }
          }
        }

        _box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case


        var maxRadiusSq = 0;

        for (var _i46 = 0, _il = position.count; _i46 < _il; _i46++) {
          _vector$8.fromBufferAttribute(position, _i46);

          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
        } // process morph attributes if present


        if (morphAttributesPosition) {
          for (var _i47 = 0, _il2 = morphAttributesPosition.length; _i47 < _il2; _i47++) {
            var _morphAttribute = morphAttributesPosition[_i47];
            var morphTargetsRelative = this.morphTargetsRelative;

            for (var j = 0, jl = _morphAttribute.count; j < jl; j++) {
              _vector$8.fromBufferAttribute(_morphAttribute, j);

              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j);

                _vector$8.add(_offset);
              }

              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
          }
        }

        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    }
  }, {
    key: "computeTangents",
    value: function computeTangents() {
      var index = this.index;
      var attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
      // (per vertex tangents)

      if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
        console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
        return;
      }

      var indices = index.array;
      var positions = attributes.position.array;
      var normals = attributes.normal.array;
      var uvs = attributes.uv.array;
      var nVertices = positions.length / 3;

      if (this.hasAttribute('tangent') === false) {
        this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
      }

      var tangents = this.getAttribute('tangent').array;
      var tan1 = [],
          tan2 = [];

      for (var _i48 = 0; _i48 < nVertices; _i48++) {
        tan1[_i48] = new Vector3();
        tan2[_i48] = new Vector3();
      }

      var vA = new Vector3(),
          vB = new Vector3(),
          vC = new Vector3(),
          uvA = new Vector2(),
          uvB = new Vector2(),
          uvC = new Vector2(),
          sdir = new Vector3(),
          tdir = new Vector3();

      function handleTriangle(a, b, c) {
        vA.fromArray(positions, a * 3);
        vB.fromArray(positions, b * 3);
        vC.fromArray(positions, c * 3);
        uvA.fromArray(uvs, a * 2);
        uvB.fromArray(uvs, b * 2);
        uvC.fromArray(uvs, c * 2);
        vB.sub(vA);
        vC.sub(vA);
        uvB.sub(uvA);
        uvC.sub(uvA);
        var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

        if (!isFinite(r)) return;
        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
        tan1[a].add(sdir);
        tan1[b].add(sdir);
        tan1[c].add(sdir);
        tan2[a].add(tdir);
        tan2[b].add(tdir);
        tan2[c].add(tdir);
      }

      var groups = this.groups;

      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.length
        }];
      }

      for (var _i49 = 0, il = groups.length; _i49 < il; ++_i49) {
        var group = groups[_i49];
        var start = group.start;
        var count = group.count;

        for (var j = start, jl = start + count; j < jl; j += 3) {
          handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
        }
      }

      var tmp = new Vector3(),
          tmp2 = new Vector3();
      var n = new Vector3(),
          n2 = new Vector3();

      function handleVertex(v) {
        n.fromArray(normals, v * 3);
        n2.copy(n);
        var t = tan1[v]; // Gram-Schmidt orthogonalize

        tmp.copy(t);
        tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

        tmp2.crossVectors(n2, t);
        var test = tmp2.dot(tan2[v]);
        var w = test < 0.0 ? -1.0 : 1.0;
        tangents[v * 4] = tmp.x;
        tangents[v * 4 + 1] = tmp.y;
        tangents[v * 4 + 2] = tmp.z;
        tangents[v * 4 + 3] = w;
      }

      for (var _i50 = 0, _il3 = groups.length; _i50 < _il3; ++_i50) {
        var _group = groups[_i50];
        var _start2 = _group.start;
        var _count = _group.count;

        for (var _j = _start2, _jl = _start2 + _count; _j < _jl; _j += 3) {
          handleVertex(indices[_j + 0]);
          handleVertex(indices[_j + 1]);
          handleVertex(indices[_j + 2]);
        }
      }
    }
  }, {
    key: "computeVertexNormals",
    value: function computeVertexNormals() {
      var index = this.index;
      var positionAttribute = this.getAttribute('position');

      if (positionAttribute !== undefined) {
        var normalAttribute = this.getAttribute('normal');

        if (normalAttribute === undefined) {
          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
          this.setAttribute('normal', normalAttribute);
        } else {
          // reset existing normals to zero
          for (var _i51 = 0, il = normalAttribute.count; _i51 < il; _i51++) {
            normalAttribute.setXYZ(_i51, 0, 0, 0);
          }
        }

        var pA = new Vector3(),
            pB = new Vector3(),
            pC = new Vector3();
        var nA = new Vector3(),
            nB = new Vector3(),
            nC = new Vector3();
        var cb = new Vector3(),
            ab = new Vector3(); // indexed elements

        if (index) {
          for (var _i52 = 0, _il4 = index.count; _i52 < _il4; _i52 += 3) {
            var vA = index.getX(_i52 + 0);
            var vB = index.getX(_i52 + 1);
            var vC = index.getX(_i52 + 2);
            pA.fromBufferAttribute(positionAttribute, vA);
            pB.fromBufferAttribute(positionAttribute, vB);
            pC.fromBufferAttribute(positionAttribute, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            nA.fromBufferAttribute(normalAttribute, vA);
            nB.fromBufferAttribute(normalAttribute, vB);
            nC.fromBufferAttribute(normalAttribute, vC);
            nA.add(cb);
            nB.add(cb);
            nC.add(cb);
            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
          }
        } else {
          // non-indexed elements (unconnected triangle soup)
          for (var _i53 = 0, _il5 = positionAttribute.count; _i53 < _il5; _i53 += 3) {
            pA.fromBufferAttribute(positionAttribute, _i53 + 0);
            pB.fromBufferAttribute(positionAttribute, _i53 + 1);
            pC.fromBufferAttribute(positionAttribute, _i53 + 2);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normalAttribute.setXYZ(_i53 + 0, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(_i53 + 1, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(_i53 + 2, cb.x, cb.y, cb.z);
          }
        }

        this.normalizeNormals();
        normalAttribute.needsUpdate = true;
      }
    }
  }, {
    key: "merge",
    value: function merge(geometry, offset) {
      if (!(geometry && geometry.isBufferGeometry)) {
        console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
        return;
      }

      if (offset === undefined) {
        offset = 0;
        console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
      }

      var attributes = this.attributes;

      for (var key in attributes) {
        if (geometry.attributes[key] === undefined) continue;
        var attribute1 = attributes[key];
        var attributeArray1 = attribute1.array;
        var attribute2 = geometry.attributes[key];
        var attributeArray2 = attribute2.array;
        var attributeOffset = attribute2.itemSize * offset;
        var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

        for (var _i54 = 0, j = attributeOffset; _i54 < length; _i54++, j++) {
          attributeArray1[j] = attributeArray2[_i54];
        }
      }

      return this;
    }
  }, {
    key: "normalizeNormals",
    value: function normalizeNormals() {
      var normals = this.attributes.normal;

      for (var _i55 = 0, il = normals.count; _i55 < il; _i55++) {
        _vector$8.fromBufferAttribute(normals, _i55);

        _vector$8.normalize();

        normals.setXYZ(_i55, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
  }, {
    key: "toNonIndexed",
    value: function toNonIndexed() {
      function convertBufferAttribute(attribute, indices) {
        var array = attribute.array;
        var itemSize = attribute.itemSize;
        var normalized = attribute.normalized;
        var array2 = new array.constructor(indices.length * itemSize);
        var index = 0,
            index2 = 0;

        for (var _i56 = 0, l = indices.length; _i56 < l; _i56++) {
          if (attribute.isInterleavedBufferAttribute) {
            index = indices[_i56] * attribute.data.stride + attribute.offset;
          } else {
            index = indices[_i56] * itemSize;
          }

          for (var j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }

        return new BufferAttribute(array2, itemSize, normalized);
      } //


      if (this.index === null) {
        console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
        return this;
      }

      var geometry2 = new BufferGeometry();
      var indices = this.index.array;
      var attributes = this.attributes; // attributes

      for (var name in attributes) {
        var attribute = attributes[name];
        var newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      } // morph attributes


      var morphAttributes = this.morphAttributes;

      for (var _name in morphAttributes) {
        var morphArray = [];
        var morphAttribute = morphAttributes[_name]; // morphAttribute: array of Float32BufferAttributes

        for (var _i57 = 0, il = morphAttribute.length; _i57 < il; _i57++) {
          var _attribute = morphAttribute[_i57];

          var _newAttribute = convertBufferAttribute(_attribute, indices);

          morphArray.push(_newAttribute);
        }

        geometry2.morphAttributes[_name] = morphArray;
      }

      geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

      var groups = this.groups;

      for (var _i58 = 0, l = groups.length; _i58 < l; _i58++) {
        var group = groups[_i58];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }

      return geometry2;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = {
        metadata: {
          version: 4.5,
          type: 'BufferGeometry',
          generator: 'BufferGeometry.toJSON'
        }
      }; // standard BufferGeometry serialization

      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== '') data.name = this.name;
      if (Object.keys(this.userData).length > 0) data.userData = this.userData;

      if (this.parameters !== undefined) {
        var parameters = this.parameters;

        for (var key in parameters) {
          if (parameters[key] !== undefined) data[key] = parameters[key];
        }

        return data;
      } // for simplicity the code assumes attributes are not shared across geometries, see #15811


      data.data = {
        attributes: {}
      };
      var index = this.index;

      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }

      var attributes = this.attributes;

      for (var _key in attributes) {
        var attribute = attributes[_key];
        data.data.attributes[_key] = attribute.toJSON(data.data);
      }

      var morphAttributes = {};
      var hasMorphAttributes = false;

      for (var _key2 in this.morphAttributes) {
        var attributeArray = this.morphAttributes[_key2];
        var array = [];

        for (var _i59 = 0, il = attributeArray.length; _i59 < il; _i59++) {
          var _attribute2 = attributeArray[_i59];
          array.push(_attribute2.toJSON(data.data));
        }

        if (array.length > 0) {
          morphAttributes[_key2] = array;
          hasMorphAttributes = true;
        }
      }

      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }

      var groups = this.groups;

      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }

      var boundingSphere = this.boundingSphere;

      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }

      return data;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      // reset
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null; // used for storing cloned, shared data

      var data = {}; // name

      this.name = source.name; // index

      var index = source.index;

      if (index !== null) {
        this.setIndex(index.clone(data));
      } // attributes


      var attributes = source.attributes;

      for (var name in attributes) {
        var attribute = attributes[name];
        this.setAttribute(name, attribute.clone(data));
      } // morph attributes


      var morphAttributes = source.morphAttributes;

      for (var _name2 in morphAttributes) {
        var array = [];
        var morphAttribute = morphAttributes[_name2]; // morphAttribute: array of Float32BufferAttributes

        for (var _i60 = 0, l = morphAttribute.length; _i60 < l; _i60++) {
          array.push(morphAttribute[_i60].clone(data));
        }

        this.morphAttributes[_name2] = array;
      }

      this.morphTargetsRelative = source.morphTargetsRelative; // groups

      var groups = source.groups;

      for (var _i61 = 0, _l4 = groups.length; _i61 < _l4; _i61++) {
        var group = groups[_i61];
        this.addGroup(group.start, group.count, group.materialIndex);
      } // bounding box


      var boundingBox = source.boundingBox;

      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      } // bounding sphere


      var boundingSphere = source.boundingSphere;

      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      } // draw range


      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count; // user data

      this.userData = source.userData; // geometry generator parameters

      if (source.parameters !== undefined) this.parameters = Object.assign({}, source.parameters);
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }]);

  return BufferGeometry;
}(EventDispatcher);

exports.BufferGeometry = BufferGeometry;
BufferGeometry.prototype.isBufferGeometry = true;

var _inverseMatrix$2 = /*@__PURE__*/new Matrix4();

var _ray$2 = /*@__PURE__*/new Ray();

var _sphere$3 = /*@__PURE__*/new Sphere();

var _vA$1 = /*@__PURE__*/new Vector3();

var _vB$1 = /*@__PURE__*/new Vector3();

var _vC$1 = /*@__PURE__*/new Vector3();

var _tempA = /*@__PURE__*/new Vector3();

var _tempB = /*@__PURE__*/new Vector3();

var _tempC = /*@__PURE__*/new Vector3();

var _morphA = /*@__PURE__*/new Vector3();

var _morphB = /*@__PURE__*/new Vector3();

var _morphC = /*@__PURE__*/new Vector3();

var _uvA$1 = /*@__PURE__*/new Vector2();

var _uvB$1 = /*@__PURE__*/new Vector2();

var _uvC$1 = /*@__PURE__*/new Vector2();

var _intersectionPoint = /*@__PURE__*/new Vector3();

var _intersectionPointWorld = /*@__PURE__*/new Vector3();

var Mesh = /*#__PURE__*/function (_Object3D) {
  _inherits(Mesh, _Object3D);

  var _super22 = _createSuper(Mesh);

  function Mesh(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    var _this13;

    _classCallCheck(this, Mesh);

    _this13 = _super22.call(this);
    _this13.type = 'Mesh';
    _this13.geometry = geometry;
    _this13.material = material;

    _this13.updateMorphTargets();

    return _this13;
  }

  _createClass(Mesh, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(Mesh.prototype), "copy", this).call(this, source);

      if (source.morphTargetInfluences !== undefined) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }

      if (source.morphTargetDictionary !== undefined) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }

      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {
        var morphAttributes = geometry.morphAttributes;
        var keys = Object.keys(morphAttributes);

        if (keys.length > 0) {
          var morphAttribute = morphAttributes[keys[0]];

          if (morphAttribute !== undefined) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};

            for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
              var name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        var morphTargets = geometry.morphTargets;

        if (morphTargets !== undefined && morphTargets.length > 0) {
          console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
      }
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var material = this.material;
      var matrixWorld = this.matrixWorld;
      if (material === undefined) return; // Checking boundingSphere distance to ray

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

      _sphere$3.copy(geometry.boundingSphere);

      _sphere$3.applyMatrix4(matrixWorld);

      if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //

      _inverseMatrix$2.copy(matrixWorld).invert();

      _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2); // Check boundingBox before continuing


      if (geometry.boundingBox !== null) {
        if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;
      }

      var intersection;

      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        var position = geometry.attributes.position;
        var morphPosition = geometry.morphAttributes.position;
        var morphTargetsRelative = geometry.morphTargetsRelative;
        var uv = geometry.attributes.uv;
        var uv2 = geometry.attributes.uv2;
        var groups = geometry.groups;
        var drawRange = geometry.drawRange;

        if (index !== null) {
          // indexed buffer geometry
          if (Array.isArray(material)) {
            for (var _i62 = 0, il = groups.length; _i62 < il; _i62++) {
              var group = groups[_i62];
              var groupMaterial = material[group.materialIndex];
              var start = Math.max(group.start, drawRange.start);
              var end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));

              for (var j = start, jl = end; j < jl; j += 3) {
                var a = index.getX(j);
                var b = index.getX(j + 1);
                var c = index.getX(j + 2);
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

                  intersection.face.materialIndex = group.materialIndex;
                  intersects.push(intersection);
                }
              }
            }
          } else {
            var _start3 = Math.max(0, drawRange.start);

            var _end2 = Math.min(index.count, drawRange.start + drawRange.count);

            for (var _i63 = _start3, _il6 = _end2; _i63 < _il6; _i63 += 3) {
              var _a = index.getX(_i63);

              var _b = index.getX(_i63 + 1);

              var _c = index.getX(_i63 + 2);

              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, _a, _b, _c);

              if (intersection) {
                intersection.faceIndex = Math.floor(_i63 / 3); // triangle number in indexed buffer semantics

                intersects.push(intersection);
              }
            }
          }
        } else if (position !== undefined) {
          // non-indexed buffer geometry
          if (Array.isArray(material)) {
            for (var _i64 = 0, _il7 = groups.length; _i64 < _il7; _i64++) {
              var _group2 = groups[_i64];
              var _groupMaterial = material[_group2.materialIndex];

              var _start4 = Math.max(_group2.start, drawRange.start);

              var _end3 = Math.min(position.count, Math.min(_group2.start + _group2.count, drawRange.start + drawRange.count));

              for (var _j2 = _start4, _jl2 = _end3; _j2 < _jl2; _j2 += 3) {
                var _a2 = _j2;

                var _b2 = _j2 + 1;

                var _c2 = _j2 + 2;

                intersection = checkBufferGeometryIntersection(this, _groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, _a2, _b2, _c2);

                if (intersection) {
                  intersection.faceIndex = Math.floor(_j2 / 3); // triangle number in non-indexed buffer semantics

                  intersection.face.materialIndex = _group2.materialIndex;
                  intersects.push(intersection);
                }
              }
            }
          } else {
            var _start5 = Math.max(0, drawRange.start);

            var _end4 = Math.min(position.count, drawRange.start + drawRange.count);

            for (var _i65 = _start5, _il8 = _end4; _i65 < _il8; _i65 += 3) {
              var _a3 = _i65;

              var _b3 = _i65 + 1;

              var _c3 = _i65 + 2;

              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, _a3, _b3, _c3);

              if (intersection) {
                intersection.faceIndex = Math.floor(_i65 / 3); // triangle number in non-indexed buffer semantics

                intersects.push(intersection);
              }
            }
          }
        }
      } else if (geometry.isGeometry) {
        console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }]);

  return Mesh;
}(Object3D);

exports.Mesh = Mesh;
Mesh.prototype.isMesh = true;

function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  var intersect;

  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }

  if (intersect === null) return null;

  _intersectionPointWorld.copy(point);

  _intersectionPointWorld.applyMatrix4(object.matrixWorld);

  var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance: distance,
    point: _intersectionPointWorld.clone(),
    object: object
  };
}

function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
  _vA$1.fromBufferAttribute(position, a);

  _vB$1.fromBufferAttribute(position, b);

  _vC$1.fromBufferAttribute(position, c);

  var morphInfluences = object.morphTargetInfluences;

  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);

    _morphB.set(0, 0, 0);

    _morphC.set(0, 0, 0);

    for (var _i66 = 0, il = morphPosition.length; _i66 < il; _i66++) {
      var influence = morphInfluences[_i66];
      var morphAttribute = morphPosition[_i66];
      if (influence === 0) continue;

      _tempA.fromBufferAttribute(morphAttribute, a);

      _tempB.fromBufferAttribute(morphAttribute, b);

      _tempC.fromBufferAttribute(morphAttribute, c);

      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);

        _morphB.addScaledVector(_tempB, influence);

        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);

        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);

        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }

    _vA$1.add(_morphA);

    _vB$1.add(_morphB);

    _vC$1.add(_morphC);
  }

  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA$1);
    object.boneTransform(b, _vB$1);
    object.boneTransform(c, _vC$1);
  }

  var intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);

  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);

      _uvB$1.fromBufferAttribute(uv, b);

      _uvC$1.fromBufferAttribute(uv, c);

      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }

    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a);

      _uvB$1.fromBufferAttribute(uv2, b);

      _uvC$1.fromBufferAttribute(uv2, c);

      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }

    var face = {
      a: a,
      b: b,
      c: c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }

  return intersection;
}

var BoxGeometry = /*#__PURE__*/function (_BufferGeometry) {
  _inherits(BoxGeometry, _BufferGeometry);

  var _super23 = _createSuper(BoxGeometry);

  function BoxGeometry(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    var _this14;

    _classCallCheck(this, BoxGeometry);

    _this14 = _super23.call(this);
    _this14.type = 'BoxGeometry';
    _this14.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };

    var scope = _assertThisInitialized(_this14); // segments


    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments); // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // helper variables

    var numberOfVertices = 0;
    var groupStart = 0; // build each side of the box geometry

    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
    // build geometry

    _this14.setIndex(indices);

    _this14.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this14.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this14.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
      var segmentWidth = width / gridX;
      var segmentHeight = height / gridY;
      var widthHalf = width / 2;
      var heightHalf = height / 2;
      var depthHalf = depth / 2;
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var vertexCounter = 0;
      var groupCount = 0;
      var vector = new Vector3(); // generate vertices, normals and uvs

      for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segmentHeight - heightHalf;

        for (var ix = 0; ix < gridX1; ix++) {
          var x = ix * segmentWidth - widthHalf; // set values to correct vector component

          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf; // now apply vector to vertex buffer

          vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

          normals.push(vector.x, vector.y, vector.z); // uvs

          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY); // counters

          vertexCounter += 1;
        }
      } // indices
      // 1. you need three indices to draw a single face
      // 2. a single segment consists of two faces
      // 3. so we need to generate six (2*3) indices per segment


      for (var _iy = 0; _iy < gridY; _iy++) {
        for (var _ix = 0; _ix < gridX; _ix++) {
          var a = numberOfVertices + _ix + gridX1 * _iy;
          var b = numberOfVertices + _ix + gridX1 * (_iy + 1);
          var c = numberOfVertices + (_ix + 1) + gridX1 * (_iy + 1);
          var d = numberOfVertices + (_ix + 1) + gridX1 * _iy; // faces

          indices.push(a, b, d);
          indices.push(b, c, d); // increase counter

          groupCount += 6;
        }
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

      groupStart += groupCount; // update total number of vertices

      numberOfVertices += vertexCounter;
    }

    return _this14;
  }

  _createClass(BoxGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
    }
  }]);

  return BoxGeometry;
}(BufferGeometry);
/**
 * Uniform Utilities
 */


exports.BoxGeometry = exports.BoxBufferGeometry = BoxGeometry;

function cloneUniforms(src) {
  var dst = {};

  for (var u in src) {
    dst[u] = {};

    for (var p in src[u]) {
      var property = src[u][p];

      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }

  return dst;
}

function mergeUniforms(uniforms) {
  var merged = {};

  for (var u = 0; u < uniforms.length; u++) {
    var _tmp = cloneUniforms(uniforms[u]);

    for (var p in _tmp) {
      merged[p] = _tmp[p];
    }
  }

  return merged;
} // Legacy


var UniformsUtils = {
  clone: cloneUniforms,
  merge: mergeUniforms
};
exports.UniformsUtils = UniformsUtils;
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

var ShaderMaterial = /*#__PURE__*/function (_Material2) {
  _inherits(ShaderMaterial, _Material2);

  var _super24 = _createSuper(ShaderMaterial);

  function ShaderMaterial(parameters) {
    var _this15;

    _classCallCheck(this, ShaderMaterial);

    _this15 = _super24.call(this);
    _this15.type = 'ShaderMaterial';
    _this15.defines = {};
    _this15.uniforms = {};
    _this15.vertexShader = default_vertex;
    _this15.fragmentShader = default_fragment;
    _this15.linewidth = 1;
    _this15.wireframe = false;
    _this15.wireframeLinewidth = 1;
    _this15.fog = false; // set to use scene fog

    _this15.lights = false; // set to use scene lights

    _this15.clipping = false; // set to use user-defined clipping planes

    _this15.extensions = {
      derivatives: false,
      // set to use derivatives
      fragDepth: false,
      // set to use fragment depth values
      drawBuffers: false,
      // set to use draw buffers
      shaderTextureLOD: false // set to use shader texture LOD

    }; // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.

    _this15.defaultAttributeValues = {
      'color': [1, 1, 1],
      'uv': [0, 0],
      'uv2': [0, 0]
    };
    _this15.index0AttributeName = undefined;
    _this15.uniformsNeedUpdate = false;
    _this15.glslVersion = null;

    if (parameters !== undefined) {
      if (parameters.attributes !== undefined) {
        console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
      }

      _this15.setValues(parameters);
    }

    return _this15;
  }

  _createClass(ShaderMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(ShaderMaterial.prototype), "copy", this).call(this, source);

      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms(source.uniforms);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.extensions = Object.assign({}, source.extensions);
      this.glslVersion = source.glslVersion;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(ShaderMaterial.prototype), "toJSON", this).call(this, meta);

      data.glslVersion = this.glslVersion;
      data.uniforms = {};

      for (var name in this.uniforms) {
        var uniform = this.uniforms[name];
        var _value = uniform.value;

        if (_value && _value.isTexture) {
          data.uniforms[name] = {
            type: 't',
            value: _value.toJSON(meta).uuid
          };
        } else if (_value && _value.isColor) {
          data.uniforms[name] = {
            type: 'c',
            value: _value.getHex()
          };
        } else if (_value && _value.isVector2) {
          data.uniforms[name] = {
            type: 'v2',
            value: _value.toArray()
          };
        } else if (_value && _value.isVector3) {
          data.uniforms[name] = {
            type: 'v3',
            value: _value.toArray()
          };
        } else if (_value && _value.isVector4) {
          data.uniforms[name] = {
            type: 'v4',
            value: _value.toArray()
          };
        } else if (_value && _value.isMatrix3) {
          data.uniforms[name] = {
            type: 'm3',
            value: _value.toArray()
          };
        } else if (_value && _value.isMatrix4) {
          data.uniforms[name] = {
            type: 'm4',
            value: _value.toArray()
          };
        } else {
          data.uniforms[name] = {
            value: _value
          }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
        }
      }

      if (Object.keys(this.defines).length > 0) data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      var extensions = {};

      for (var key in this.extensions) {
        if (this.extensions[key] === true) extensions[key] = true;
      }

      if (Object.keys(extensions).length > 0) data.extensions = extensions;
      return data;
    }
  }]);

  return ShaderMaterial;
}(Material);

exports.ShaderMaterial = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;

var Camera = /*#__PURE__*/function (_Object3D2) {
  _inherits(Camera, _Object3D2);

  var _super25 = _createSuper(Camera);

  function Camera() {
    var _this16;

    _classCallCheck(this, Camera);

    _this16 = _super25.call(this);
    _this16.type = 'Camera';
    _this16.matrixWorldInverse = new Matrix4();
    _this16.projectionMatrix = new Matrix4();
    _this16.projectionMatrixInverse = new Matrix4();
    return _this16;
  }

  _createClass(Camera, [{
    key: "copy",
    value: function copy(source, recursive) {
      _get(_getPrototypeOf(Camera.prototype), "copy", this).call(this, source, recursive);

      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      return this;
    }
  }, {
    key: "getWorldDirection",
    value: function getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      var e = this.matrixWorld.elements;
      return target.set(-e[8], -e[9], -e[10]).normalize();
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      _get(_getPrototypeOf(Camera.prototype), "updateMatrixWorld", this).call(this, force);

      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }, {
    key: "updateWorldMatrix",
    value: function updateWorldMatrix(updateParents, updateChildren) {
      _get(_getPrototypeOf(Camera.prototype), "updateWorldMatrix", this).call(this, updateParents, updateChildren);

      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return Camera;
}(Object3D);

exports.Camera = Camera;
Camera.prototype.isCamera = true;

var PerspectiveCamera = /*#__PURE__*/function (_Camera) {
  _inherits(PerspectiveCamera, _Camera);

  var _super26 = _createSuper(PerspectiveCamera);

  function PerspectiveCamera(fov = 50, aspect = 1, near = 0.1, far = 2000) {
    var _this17;

    _classCallCheck(this, PerspectiveCamera);

    _this17 = _super26.call(this);
    _this17.type = 'PerspectiveCamera';
    _this17.fov = fov;
    _this17.zoom = 1;
    _this17.near = near;
    _this17.far = far;
    _this17.focus = 10;
    _this17.aspect = aspect;
    _this17.view = null;
    _this17.filmGauge = 35; // width of the film (default in millimeters)

    _this17.filmOffset = 0; // horizontal film offset (same unit as gauge)

    _this17.updateProjectionMatrix();

    return _this17;
  }

  _createClass(PerspectiveCamera, [{
    key: "copy",
    value: function copy(source, recursive) {
      _get(_getPrototypeOf(PerspectiveCamera.prototype), "copy", this).call(this, source, recursive);

      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    }
    /**
     * Sets the FOV by focal length in respect to the current .filmGauge.
     *
     * The default film gauge is 35, so that the focal length can be specified for
     * a 35mm (full frame) camera.
     *
     * Values for focal length and film gauge must have the same unit.
     */

  }, {
    key: "setFocalLength",
    value: function setFocalLength(focalLength) {
      /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
      var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    }
    /**
     * Calculates the focal length from the current .fov and .filmGauge.
     */

  }, {
    key: "getFocalLength",
    value: function getFocalLength() {
      var vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
  }, {
    key: "getEffectiveFOV",
    value: function getEffectiveFOV() {
      return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
    }
  }, {
    key: "getFilmWidth",
    value: function getFilmWidth() {
      // film not completely covered in portrait format (aspect < 1)
      return this.filmGauge * Math.min(this.aspect, 1);
    }
  }, {
    key: "getFilmHeight",
    value: function getFilmHeight() {
      // film not completely covered in landscape format (aspect > 1)
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    /**
     * Sets an offset in a larger frustum. This is useful for multi-window or
     * multi-monitor/multi-machine setups.
     *
     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
     * the monitors are in grid like this
     *
     *   +---+---+---+
     *   | A | B | C |
     *   +---+---+---+
     *   | D | E | F |
     *   +---+---+---+
     *
     * then for each monitor you would call it like this
     *
     *   const w = 1920;
     *   const h = 1080;
     *   const fullWidth = w * 3;
     *   const fullHeight = h * 2;
     *
     *   --A--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
     *   --B--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
     *   --C--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
     *   --D--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
     *   --E--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
     *   --F--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
     *
     *   Note there is no reason monitors have to be the same size or in a grid.
     */

  }, {
    key: "setViewOffset",
    value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      this.aspect = fullWidth / fullHeight;

      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }

      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }

      this.updateProjectionMatrix();
    }
  }, {
    key: "updateProjectionMatrix",
    value: function updateProjectionMatrix() {
      var near = this.near;
      var top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
      var height = 2 * top;
      var width = this.aspect * height;
      var left = -0.5 * width;
      var view = this.view;

      if (this.view !== null && this.view.enabled) {
        var fullWidth = view.fullWidth,
            fullHeight = view.fullHeight;
        left += view.offsetX * width / fullWidth;
        top -= view.offsetY * height / fullHeight;
        width *= view.width / fullWidth;
        height *= view.height / fullHeight;
      }

      var skew = this.filmOffset;
      if (skew !== 0) left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(PerspectiveCamera.prototype), "toJSON", this).call(this, meta);

      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null) data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  }]);

  return PerspectiveCamera;
}(Camera);

exports.PerspectiveCamera = PerspectiveCamera;
PerspectiveCamera.prototype.isPerspectiveCamera = true;
var fov = 90,
    aspect = 1;

var CubeCamera = /*#__PURE__*/function (_Object3D3) {
  _inherits(CubeCamera, _Object3D3);

  var _super27 = _createSuper(CubeCamera);

  function CubeCamera(near, far, renderTarget) {
    var _this18;

    _classCallCheck(this, CubeCamera);

    _this18 = _super27.call(this);
    _this18.type = 'CubeCamera';

    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
      return _possibleConstructorReturn(_this18);
    }

    _this18.renderTarget = renderTarget;
    var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = _this18.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));

    _this18.add(cameraPX);

    var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = _this18.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));

    _this18.add(cameraNX);

    var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = _this18.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));

    _this18.add(cameraPY);

    var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = _this18.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));

    _this18.add(cameraNY);

    var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = _this18.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));

    _this18.add(cameraPZ);

    var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = _this18.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));

    _this18.add(cameraNZ);

    return _this18;
  }

  _createClass(CubeCamera, [{
    key: "update",
    value: function update(renderer, scene) {
      if (this.parent === null) this.updateMatrixWorld();
      var renderTarget = this.renderTarget;

      var _this$children = _slicedToArray(this.children, 6),
          cameraPX = _this$children[0],
          cameraNX = _this$children[1],
          cameraPY = _this$children[2],
          cameraNY = _this$children[3],
          cameraPZ = _this$children[4],
          cameraNZ = _this$children[5];

      var currentRenderTarget = renderer.getRenderTarget();
      var currentOutputEncoding = renderer.outputEncoding;
      var currentToneMapping = renderer.toneMapping;
      var currentXrEnabled = renderer.xr.enabled;
      renderer.outputEncoding = LinearEncoding;
      renderer.toneMapping = NoToneMapping;
      renderer.xr.enabled = false;
      var generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderer.setRenderTarget(renderTarget, 0);
      renderer.render(scene, cameraPX);
      renderer.setRenderTarget(renderTarget, 1);
      renderer.render(scene, cameraNX);
      renderer.setRenderTarget(renderTarget, 2);
      renderer.render(scene, cameraPY);
      renderer.setRenderTarget(renderTarget, 3);
      renderer.render(scene, cameraNY);
      renderer.setRenderTarget(renderTarget, 4);
      renderer.render(scene, cameraPZ);
      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderer.setRenderTarget(renderTarget, 5);
      renderer.render(scene, cameraNZ);
      renderer.setRenderTarget(currentRenderTarget);
      renderer.outputEncoding = currentOutputEncoding;
      renderer.toneMapping = currentToneMapping;
      renderer.xr.enabled = currentXrEnabled;
      renderTarget.texture.needsPMREMUpdate = true;
    }
  }]);

  return CubeCamera;
}(Object3D);

exports.CubeCamera = CubeCamera;

var CubeTexture = /*#__PURE__*/function (_Texture3) {
  _inherits(CubeTexture, _Texture3);

  var _super28 = _createSuper(CubeTexture);

  function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    var _this19;

    _classCallCheck(this, CubeTexture);

    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    _this19 = _super28.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    _this19.flipY = false;
    return _this19;
  }

  _createClass(CubeTexture, [{
    key: "images",
    get: function get() {
      return this.image;
    },
    set: function set(value) {
      this.image = value;
    }
  }]);

  return CubeTexture;
}(Texture);

exports.CubeTexture = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;

var WebGLCubeRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget4) {
  _inherits(WebGLCubeRenderTarget, _WebGLRenderTarget4);

  var _super29 = _createSuper(WebGLCubeRenderTarget);

  function WebGLCubeRenderTarget(size, options = {}) {
    var _this20;

    _classCallCheck(this, WebGLCubeRenderTarget);

    _this20 = _super29.call(this, size, size, options);
    var image = {
      width: size,
      height: size,
      depth: 1
    };
    var images = [image, image, image, image, image, image];
    _this20.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding); // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
    // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
    // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

    _this20.texture.isRenderTargetTexture = true;
    _this20.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    _this20.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    return _this20;
  }

  _createClass(WebGLCubeRenderTarget, [{
    key: "fromEquirectangularTexture",
    value: function fromEquirectangularTexture(renderer, texture) {
      this.texture.type = texture.type;
      this.texture.encoding = texture.encoding;
      this.texture.generateMipmaps = texture.generateMipmaps;
      this.texture.minFilter = texture.minFilter;
      this.texture.magFilter = texture.magFilter;
      var shader = {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader:
        /* glsl */
        "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
        fragmentShader:
        /* glsl */
        "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
      };
      var geometry = new BoxGeometry(5, 5, 5);
      var material = new ShaderMaterial({
        name: 'CubemapFromEquirect',
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
      });
      material.uniforms.tEquirect.value = texture;
      var mesh = new Mesh(geometry, material);
      var currentMinFilter = texture.minFilter; // Avoid blurred poles

      if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
      var camera = new CubeCamera(1, 10, this);
      camera.update(renderer, mesh);
      texture.minFilter = currentMinFilter;
      mesh.geometry.dispose();
      mesh.material.dispose();
      return this;
    }
  }, {
    key: "clear",
    value: function clear(renderer, color, depth, stencil) {
      var currentRenderTarget = renderer.getRenderTarget();

      for (var _i67 = 0; _i67 < 6; _i67++) {
        renderer.setRenderTarget(this, _i67);
        renderer.clear(color, depth, stencil);
      }

      renderer.setRenderTarget(currentRenderTarget);
    }
  }]);

  return WebGLCubeRenderTarget;
}(WebGLRenderTarget);

exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

var _vector1 = /*@__PURE__*/new Vector3();

var _vector2 = /*@__PURE__*/new Vector3();

var _normalMatrix = /*@__PURE__*/new Matrix3();

var Plane = /*#__PURE__*/function () {
  function Plane(normal = new Vector3(1, 0, 0), constant = 0) {
    _classCallCheck(this, Plane);

    // normal is assumed to be normalized
    this.normal = normal;
    this.constant = constant;
  }

  _createClass(Plane, [{
    key: "set",
    value: function set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    }
  }, {
    key: "setComponents",
    value: function setComponents(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    }
  }, {
    key: "setFromNormalAndCoplanarPoint",
    value: function setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    }
  }, {
    key: "setFromCoplanarPoints",
    value: function setFromCoplanarPoints(a, b, c) {
      var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    }
  }, {
    key: "normalize",
    value: function normalize() {
      // Note: will lead to a divide by zero if the plane is invalid.
      var inverseNormalLength = 1.0 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    }
  }, {
    key: "negate",
    value: function negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    }
  }, {
    key: "distanceToSphere",
    value: function distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    }
  }, {
    key: "projectPoint",
    value: function projectPoint(point, target) {
      return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
  }, {
    key: "intersectLine",
    value: function intersectLine(line, target) {
      var direction = line.delta(_vector1);
      var denominator = this.normal.dot(direction);

      if (denominator === 0) {
        // line is coplanar, return origin
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        } // Unsure if this is the correct method to handle this case.


        return null;
      }

      var t = -(line.start.dot(this.normal) + this.constant) / denominator;

      if (t < 0 || t > 1) {
        return null;
      }

      return target.copy(direction).multiplyScalar(t).add(line.start);
    }
  }, {
    key: "intersectsLine",
    value: function intersectsLine(line) {
      // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
      var startSign = this.distanceToPoint(line.start);
      var endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      return box.intersectsPlane(this);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    }
  }, {
    key: "coplanarPoint",
    value: function coplanarPoint(target) {
      return target.copy(this.normal).multiplyScalar(-this.constant);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix, optionalNormalMatrix) {
      var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

      var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
      var normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return Plane;
}();

exports.Plane = Plane;
Plane.prototype.isPlane = true;

var _sphere$2 = /*@__PURE__*/new Sphere();

var _vector$7 = /*@__PURE__*/new Vector3();

var Frustum = /*#__PURE__*/function () {
  function Frustum(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    _classCallCheck(this, Frustum);

    this.planes = [p0, p1, p2, p3, p4, p5];
  }

  _createClass(Frustum, [{
    key: "set",
    value: function set(p0, p1, p2, p3, p4, p5) {
      var planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(frustum) {
      var planes = this.planes;

      for (var _i68 = 0; _i68 < 6; _i68++) {
        planes[_i68].copy(frustum.planes[_i68]);
      }

      return this;
    }
  }, {
    key: "setFromProjectionMatrix",
    value: function setFromProjectionMatrix(m) {
      var planes = this.planes;
      var me = m.elements;
      var me0 = me[0],
          me1 = me[1],
          me2 = me[2],
          me3 = me[3];
      var me4 = me[4],
          me5 = me[5],
          me6 = me[6],
          me7 = me[7];
      var me8 = me[8],
          me9 = me[9],
          me10 = me[10],
          me11 = me[11];
      var me12 = me[12],
          me13 = me[13],
          me14 = me[14],
          me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      return this;
    }
  }, {
    key: "intersectsObject",
    value: function intersectsObject(object) {
      var geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

      _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

      return this.intersectsSphere(_sphere$2);
    }
  }, {
    key: "intersectsSprite",
    value: function intersectsSprite(sprite) {
      _sphere$2.center.set(0, 0, 0);

      _sphere$2.radius = 0.7071067811865476;

      _sphere$2.applyMatrix4(sprite.matrixWorld);

      return this.intersectsSphere(_sphere$2);
    }
  }, {
    key: "intersectsSphere",
    value: function intersectsSphere(sphere) {
      var planes = this.planes;
      var center = sphere.center;
      var negRadius = -sphere.radius;

      for (var _i69 = 0; _i69 < 6; _i69++) {
        var distance = planes[_i69].distanceToPoint(center);

        if (distance < negRadius) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      var planes = this.planes;

      for (var _i70 = 0; _i70 < 6; _i70++) {
        var plane = planes[_i70]; // corner at max distance

        _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

        if (plane.distanceToPoint(_vector$7) < 0) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      var planes = this.planes;

      for (var _i71 = 0; _i71 < 6; _i71++) {
        if (planes[_i71].distanceToPoint(point) < 0) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return Frustum;
}();

exports.Frustum = Frustum;

function WebGLAnimation() {
  var context = null;
  var isAnimating = false;
  var animationLoop = null;
  var requestId = null;

  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }

  return {
    start: function start() {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function stop() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function setAnimationLoop(callback) {
      animationLoop = callback;
    },
    setContext: function setContext(value) {
      context = value;
    }
  };
}

function WebGLAttributes(gl, capabilities) {
  var isWebGL2 = capabilities.isWebGL2;
  var buffers = new WeakMap();

  function createBuffer(attribute, bufferType) {
    var array = attribute.array;
    var usage = attribute.usage;
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    var type;

    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          throw new Error('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    } else if (array instanceof Uint8ClampedArray) {
      type = 5121;
    } else {
      throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + array);
    }

    return {
      buffer: buffer,
      type: type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }

  function updateBuffer(buffer, attribute, bufferType) {
    var array = attribute.array;
    var updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);

    if (updateRange.count === -1) {
      // Not using update ranges
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }

      updateRange.count = -1; // reset range
    }
  } //


  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }

  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    var data = buffers.get(attribute);

    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }

  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      var cached = buffers.get(attribute);

      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }

      return;
    }

    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    var data = buffers.get(attribute);

    if (data === undefined) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }

  return {
    get: get,
    remove: remove,
    update: update
  };
}

var PlaneGeometry = /*#__PURE__*/function (_BufferGeometry2) {
  _inherits(PlaneGeometry, _BufferGeometry2);

  var _super30 = _createSuper(PlaneGeometry);

  function PlaneGeometry(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    var _this21;

    _classCallCheck(this, PlaneGeometry);

    _this21 = _super30.call(this);
    _this21.type = 'PlaneGeometry';
    _this21.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    var width_half = width / 2;
    var height_half = height / 2;
    var gridX = Math.floor(widthSegments);
    var gridY = Math.floor(heightSegments);
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var segment_width = width / gridX;
    var segment_height = height / gridY; //

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];

    for (var iy = 0; iy < gridY1; iy++) {
      var y = iy * segment_height - height_half;

      for (var ix = 0; ix < gridX1; ix++) {
        var x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }

    for (var _iy2 = 0; _iy2 < gridY; _iy2++) {
      for (var _ix2 = 0; _ix2 < gridX; _ix2++) {
        var a = _ix2 + gridX1 * _iy2;
        var b = _ix2 + gridX1 * (_iy2 + 1);
        var c = _ix2 + 1 + gridX1 * (_iy2 + 1);
        var d = _ix2 + 1 + gridX1 * _iy2;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    _this21.setIndex(indices);

    _this21.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this21.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this21.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    return _this21;
  }

  _createClass(PlaneGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
    }
  }]);

  return PlaneGeometry;
}(BufferGeometry);

exports.PlaneGeometry = exports.PlaneBufferGeometry = PlaneGeometry;
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
var fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";
var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var ShaderChunk = {
  alphamap_fragment: alphamap_fragment,
  alphamap_pars_fragment: alphamap_pars_fragment,
  alphatest_fragment: alphatest_fragment,
  alphatest_pars_fragment: alphatest_pars_fragment,
  aomap_fragment: aomap_fragment,
  aomap_pars_fragment: aomap_pars_fragment,
  begin_vertex: begin_vertex,
  beginnormal_vertex: beginnormal_vertex,
  bsdfs: bsdfs,
  bumpmap_pars_fragment: bumpmap_pars_fragment,
  clipping_planes_fragment: clipping_planes_fragment,
  clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  clipping_planes_vertex: clipping_planes_vertex,
  color_fragment: color_fragment,
  color_pars_fragment: color_pars_fragment,
  color_pars_vertex: color_pars_vertex,
  color_vertex: color_vertex,
  common: common,
  cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  defaultnormal_vertex: defaultnormal_vertex,
  displacementmap_pars_vertex: displacementmap_pars_vertex,
  displacementmap_vertex: displacementmap_vertex,
  emissivemap_fragment: emissivemap_fragment,
  emissivemap_pars_fragment: emissivemap_pars_fragment,
  encodings_fragment: encodings_fragment,
  encodings_pars_fragment: encodings_pars_fragment,
  envmap_fragment: envmap_fragment,
  envmap_common_pars_fragment: envmap_common_pars_fragment,
  envmap_pars_fragment: envmap_pars_fragment,
  envmap_pars_vertex: envmap_pars_vertex,
  envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  envmap_vertex: envmap_vertex,
  fog_vertex: fog_vertex,
  fog_pars_vertex: fog_pars_vertex,
  fog_fragment: fog_fragment,
  fog_pars_fragment: fog_pars_fragment,
  gradientmap_pars_fragment: gradientmap_pars_fragment,
  lightmap_fragment: lightmap_fragment,
  lightmap_pars_fragment: lightmap_pars_fragment,
  lights_lambert_vertex: lights_lambert_vertex,
  lights_pars_begin: lights_pars_begin,
  lights_toon_fragment: lights_toon_fragment,
  lights_toon_pars_fragment: lights_toon_pars_fragment,
  lights_phong_fragment: lights_phong_fragment,
  lights_phong_pars_fragment: lights_phong_pars_fragment,
  lights_physical_fragment: lights_physical_fragment,
  lights_physical_pars_fragment: lights_physical_pars_fragment,
  lights_fragment_begin: lights_fragment_begin,
  lights_fragment_maps: lights_fragment_maps,
  lights_fragment_end: lights_fragment_end,
  logdepthbuf_fragment: logdepthbuf_fragment,
  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  logdepthbuf_vertex: logdepthbuf_vertex,
  map_fragment: map_fragment,
  map_pars_fragment: map_pars_fragment,
  map_particle_fragment: map_particle_fragment,
  map_particle_pars_fragment: map_particle_pars_fragment,
  metalnessmap_fragment: metalnessmap_fragment,
  metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  morphcolor_vertex: morphcolor_vertex,
  morphnormal_vertex: morphnormal_vertex,
  morphtarget_pars_vertex: morphtarget_pars_vertex,
  morphtarget_vertex: morphtarget_vertex,
  normal_fragment_begin: normal_fragment_begin,
  normal_fragment_maps: normal_fragment_maps,
  normal_pars_fragment: normal_pars_fragment,
  normal_pars_vertex: normal_pars_vertex,
  normal_vertex: normal_vertex,
  normalmap_pars_fragment: normalmap_pars_fragment,
  clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment: clearcoat_pars_fragment,
  output_fragment: output_fragment,
  packing: packing,
  premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  project_vertex: project_vertex,
  dithering_fragment: dithering_fragment,
  dithering_pars_fragment: dithering_pars_fragment,
  roughnessmap_fragment: roughnessmap_fragment,
  roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  shadowmap_pars_fragment: shadowmap_pars_fragment,
  shadowmap_pars_vertex: shadowmap_pars_vertex,
  shadowmap_vertex: shadowmap_vertex,
  shadowmask_pars_fragment: shadowmask_pars_fragment,
  skinbase_vertex: skinbase_vertex,
  skinning_pars_vertex: skinning_pars_vertex,
  skinning_vertex: skinning_vertex,
  skinnormal_vertex: skinnormal_vertex,
  specularmap_fragment: specularmap_fragment,
  specularmap_pars_fragment: specularmap_pars_fragment,
  tonemapping_fragment: tonemapping_fragment,
  tonemapping_pars_fragment: tonemapping_pars_fragment,
  transmission_fragment: transmission_fragment,
  transmission_pars_fragment: transmission_pars_fragment,
  uv_pars_fragment: uv_pars_fragment,
  uv_pars_vertex: uv_pars_vertex,
  uv_vertex: uv_vertex,
  uv2_pars_fragment: uv2_pars_fragment,
  uv2_pars_vertex: uv2_pars_vertex,
  uv2_vertex: uv2_vertex,
  worldpos_vertex: worldpos_vertex,
  background_vert: vertex$g,
  background_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
/**
 * Uniforms library for shared webgl shaders
 */

exports.ShaderChunk = ShaderChunk;
var UniformsLib = {
  common: {
    diffuse: {
      value: new Color(0xffffff)
    },
    opacity: {
      value: 1.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    },
    uv2Transform: {
      value: new Matrix3()
    },
    alphaMap: {
      value: null
    },
    alphaTest: {
      value: 0
    }
  },
  specularmap: {
    specularMap: {
      value: null
    }
  },
  envmap: {
    envMap: {
      value: null
    },
    flipEnvMap: {
      value: -1
    },
    reflectivity: {
      value: 1.0
    },
    // basic, lambert, phong
    ior: {
      value: 1.5
    },
    // physical
    refractionRatio: {
      value: 0.98
    } // basic, lambert, phong

  },
  aomap: {
    aoMap: {
      value: null
    },
    aoMapIntensity: {
      value: 1
    }
  },
  lightmap: {
    lightMap: {
      value: null
    },
    lightMapIntensity: {
      value: 1
    }
  },
  emissivemap: {
    emissiveMap: {
      value: null
    }
  },
  bumpmap: {
    bumpMap: {
      value: null
    },
    bumpScale: {
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      value: null
    },
    normalScale: {
      value: new Vector2(1, 1)
    }
  },
  displacementmap: {
    displacementMap: {
      value: null
    },
    displacementScale: {
      value: 1
    },
    displacementBias: {
      value: 0
    }
  },
  roughnessmap: {
    roughnessMap: {
      value: null
    }
  },
  metalnessmap: {
    metalnessMap: {
      value: null
    }
  },
  gradientmap: {
    gradientMap: {
      value: null
    }
  },
  fog: {
    fogDensity: {
      value: 0.00025
    },
    fogNear: {
      value: 1
    },
    fogFar: {
      value: 2000
    },
    fogColor: {
      value: new Color(0xffffff)
    }
  },
  lights: {
    ambientLightColor: {
      value: []
    },
    lightProbe: {
      value: []
    },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {}
      }
    },
    directionalLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    directionalShadowMap: {
      value: []
    },
    directionalShadowMatrix: {
      value: []
    },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      }
    },
    spotLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    spotShadowMap: {
      value: []
    },
    spotShadowMatrix: {
      value: []
    },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      }
    },
    pointLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }
    },
    pointShadowMap: {
      value: []
    },
    pointShadowMatrix: {
      value: []
    },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }
    },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }
    },
    ltc_1: {
      value: null
    },
    ltc_2: {
      value: null
    }
  },
  points: {
    diffuse: {
      value: new Color(0xffffff)
    },
    opacity: {
      value: 1.0
    },
    size: {
      value: 1.0
    },
    scale: {
      value: 1.0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    alphaTest: {
      value: 0
    },
    uvTransform: {
      value: new Matrix3()
    }
  },
  sprite: {
    diffuse: {
      value: new Color(0xffffff)
    },
    opacity: {
      value: 1.0
    },
    center: {
      value: new Vector2(0.5, 0.5)
    },
    rotation: {
      value: 0.0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    alphaTest: {
      value: 0
    },
    uvTransform: {
      value: new Matrix3()
    }
  }
};
exports.UniformsLib = UniformsLib;
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      specular: {
        value: new Color(0x111111)
      },
      shininess: {
        value: 30
      }
    }]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      roughness: {
        value: 1.0
      },
      metalness: {
        value: 0.0
      },
      envMapIntensity: {
        value: 1
      } // temporary

    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
      matcap: {
        value: null
      }
    }]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
      scale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      totalSize: {
        value: 2
      }
    }]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {
        value: new Matrix3()
      },
      t2D: {
        value: null
      }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },

  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: mergeUniforms([UniformsLib.envmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
      referencePosition: {
        value: new Vector3()
      },
      nearDistance: {
        value: 1
      },
      farDistance: {
        value: 1000
      }
    }]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
      color: {
        value: new Color(0x00000)
      },
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
exports.ShaderLib = ShaderLib;
ShaderLib.physical = {
  uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
    clearcoat: {
      value: 0
    },
    clearcoatMap: {
      value: null
    },
    clearcoatRoughness: {
      value: 0
    },
    clearcoatRoughnessMap: {
      value: null
    },
    clearcoatNormalScale: {
      value: new Vector2(1, 1)
    },
    clearcoatNormalMap: {
      value: null
    },
    sheen: {
      value: 0
    },
    sheenColor: {
      value: new Color(0x000000)
    },
    sheenColorMap: {
      value: null
    },
    sheenRoughness: {
      value: 1
    },
    sheenRoughnessMap: {
      value: null
    },
    transmission: {
      value: 0
    },
    transmissionMap: {
      value: null
    },
    transmissionSamplerSize: {
      value: new Vector2()
    },
    transmissionSamplerMap: {
      value: null
    },
    thickness: {
      value: 0
    },
    thicknessMap: {
      value: null
    },
    attenuationDistance: {
      value: 0
    },
    attenuationColor: {
      value: new Color(0x000000)
    },
    specularIntensity: {
      value: 1
    },
    specularIntensityMap: {
      value: null
    },
    specularColor: {
      value: new Color(1, 1, 1)
    },
    specularColorMap: {
      value: null
    }
  }]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};

function WebGLBackground(renderer, cubemaps, state, objects, alpha, premultipliedAlpha) {
  var clearColor = new Color(0x000000);
  var clearAlpha = alpha === true ? 0 : 1;
  var planeMesh;
  var boxMesh;
  var currentBackground = null;
  var currentBackgroundVersion = 0;
  var currentTonemapping = null;

  function render(renderList, scene) {
    var forceClear = false;
    var background = scene.isScene === true ? scene.background : null;

    if (background && background.isTexture) {
      background = cubemaps.get(background);
    } // Ignore background in AR
    // TODO: Reconsider this.


    var xr = renderer.xr;
    var session = xr.getSession && xr.getSession();

    if (session && session.environmentBlendMode === 'additive') {
      background = null;
    }

    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }

    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }

    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === undefined) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: 'BackgroundCubeMaterial',
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute('normal');
        boxMesh.geometry.deleteAttribute('uv');

        boxMesh.onBeforeRender = function (renderer, scene, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        }; // enable code injection for non-built-in material


        Object.defineProperty(boxMesh.material, 'envMap', {
          get: function get() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }

      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;

      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      } // push to the pre-sorted opaque render list


      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === undefined) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: 'BackgroundMaterial',
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material

        Object.defineProperty(planeMesh.material, 'map', {
          get: function get() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }

      planeMesh.material.uniforms.t2D.value = background;

      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }

      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      } // push to the pre-sorted opaque render list


      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }

  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }

  return {
    getClearColor: function getClearColor() {
      return clearColor;
    },
    setClearColor: function setClearColor(color, alpha = 1) {
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function getClearAlpha() {
      return clearAlpha;
    },
    setClearAlpha: function setClearAlpha(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render
  };
}

function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  var maxVertexAttributes = gl.getParameter(34921);
  var extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
  var vaoAvailable = capabilities.isWebGL2 || extension !== null;
  var bindingStates = {};
  var defaultState = createBindingState(null);
  var currentState = defaultState;
  var forceUpdate = false;

  function setup(object, material, program, geometry, index) {
    var updateBuffers = false;

    if (vaoAvailable) {
      var state = getBindingState(geometry, program, material);

      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }

      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers) saveCache(geometry, index);
    } else {
      var wireframe = material.wireframe === true;

      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }

    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }

    if (index !== null) {
      attributes.update(index, 34963);
    }

    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);

      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }

  function createVertexArrayObject() {
    if (capabilities.isWebGL2) return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }

  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }

  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }

  function getBindingState(geometry, program, material) {
    var wireframe = material.wireframe === true;
    var programMap = bindingStates[geometry.id];

    if (programMap === undefined) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }

    var stateMap = programMap[program.id];

    if (stateMap === undefined) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }

    var state = stateMap[wireframe];

    if (state === undefined) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }

    return state;
  }

  function createBindingState(vao) {
    var newAttributes = [];
    var enabledAttributes = [];
    var attributeDivisors = [];

    for (var _i72 = 0; _i72 < maxVertexAttributes; _i72++) {
      newAttributes[_i72] = 0;
      enabledAttributes[_i72] = 0;
      attributeDivisors[_i72] = 0;
    }

    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes: newAttributes,
      enabledAttributes: enabledAttributes,
      attributeDivisors: attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }

  function needsUpdate(geometry, index) {
    var cachedAttributes = currentState.attributes;
    var geometryAttributes = geometry.attributes;
    var attributesNum = 0;

    for (var key in geometryAttributes) {
      var cachedAttribute = cachedAttributes[key];
      var geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === undefined) return true;
      if (cachedAttribute.attribute !== geometryAttribute) return true;
      if (cachedAttribute.data !== geometryAttribute.data) return true;
      attributesNum++;
    }

    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }

  function saveCache(geometry, index) {
    var cache = {};
    var attributes = geometry.attributes;
    var attributesNum = 0;

    for (var key in attributes) {
      var attribute = attributes[key];
      var data = {};
      data.attribute = attribute;

      if (attribute.data) {
        data.data = attribute.data;
      }

      cache[key] = data;
      attributesNum++;
    }

    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }

  function initAttributes() {
    var newAttributes = currentState.newAttributes;

    for (var _i73 = 0, il = newAttributes.length; _i73 < il; _i73++) {
      newAttributes[_i73] = 0;
    }
  }

  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }

  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    var newAttributes = currentState.newAttributes;
    var enabledAttributes = currentState.enabledAttributes;
    var attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;

    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }

    if (attributeDivisors[attribute] !== meshPerAttribute) {
      var _extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');

      _extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);

      attributeDivisors[attribute] = meshPerAttribute;
    }
  }

  function disableUnusedAttributes() {
    var newAttributes = currentState.newAttributes;
    var enabledAttributes = currentState.enabledAttributes;

    for (var _i74 = 0, il = enabledAttributes.length; _i74 < il; _i74++) {
      if (enabledAttributes[_i74] !== newAttributes[_i74]) {
        gl.disableVertexAttribArray(_i74);
        enabledAttributes[_i74] = 0;
      }
    }
  }

  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }

  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get('ANGLE_instanced_arrays') === null) return;
    }

    initAttributes();
    var geometryAttributes = geometry.attributes;
    var programAttributes = program.getAttributes();
    var materialDefaultAttributeValues = material.defaultAttributeValues;

    for (var name in programAttributes) {
      var programAttribute = programAttributes[name];

      if (programAttribute.location >= 0) {
        var geometryAttribute = geometryAttributes[name];

        if (geometryAttribute === undefined) {
          if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;
        }

        if (geometryAttribute !== undefined) {
          var normalized = geometryAttribute.normalized;
          var size = geometryAttribute.itemSize;
          var attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          var buffer = attribute.buffer;
          var type = attribute.type;
          var bytesPerElement = attribute.bytesPerElement;

          if (geometryAttribute.isInterleavedBufferAttribute) {
            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;

            if (data.isInstancedInterleavedBuffer) {
              for (var _i75 = 0; _i75 < programAttribute.locationSize; _i75++) {
                enableAttributeAndDivisor(programAttribute.location + _i75, data.meshPerAttribute);
              }

              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (var _i76 = 0; _i76 < programAttribute.locationSize; _i76++) {
                enableAttribute(programAttribute.location + _i76);
              }
            }

            gl.bindBuffer(34962, buffer);

            for (var _i77 = 0; _i77 < programAttribute.locationSize; _i77++) {
              vertexAttribPointer(programAttribute.location + _i77, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * _i77) * bytesPerElement);
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (var _i78 = 0; _i78 < programAttribute.locationSize; _i78++) {
                enableAttributeAndDivisor(programAttribute.location + _i78, geometryAttribute.meshPerAttribute);
              }

              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (var _i79 = 0; _i79 < programAttribute.locationSize; _i79++) {
                enableAttribute(programAttribute.location + _i79);
              }
            }

            gl.bindBuffer(34962, buffer);

            for (var _i80 = 0; _i80 < programAttribute.locationSize; _i80++) {
              vertexAttribPointer(programAttribute.location + _i80, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * _i80 * bytesPerElement);
            }
          }
        } else if (materialDefaultAttributeValues !== undefined) {
          var _value2 = materialDefaultAttributeValues[name];

          if (_value2 !== undefined) {
            switch (_value2.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, _value2);
                break;

              case 3:
                gl.vertexAttrib3fv(programAttribute.location, _value2);
                break;

              case 4:
                gl.vertexAttrib4fv(programAttribute.location, _value2);
                break;

              default:
                gl.vertexAttrib1fv(programAttribute.location, _value2);
            }
          }
        }
      }
    }

    disableUnusedAttributes();
  }

  function dispose() {
    reset();

    for (var geometryId in bindingStates) {
      var programMap = bindingStates[geometryId];

      for (var programId in programMap) {
        var stateMap = programMap[programId];

        for (var wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }

        delete programMap[programId];
      }

      delete bindingStates[geometryId];
    }
  }

  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === undefined) return;
    var programMap = bindingStates[geometry.id];

    for (var programId in programMap) {
      var stateMap = programMap[programId];

      for (var wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }

      delete programMap[programId];
    }

    delete bindingStates[geometry.id];
  }

  function releaseStatesOfProgram(program) {
    for (var geometryId in bindingStates) {
      var programMap = bindingStates[geometryId];
      if (programMap[program.id] === undefined) continue;
      var stateMap = programMap[program.id];

      for (var wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }

      delete programMap[program.id];
    }
  }

  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  } // for backward-compatibility


  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }

  return {
    setup: setup,
    reset: reset,
    resetDefaultState: resetDefaultState,
    dispose: dispose,
    releaseStatesOfGeometry: releaseStatesOfGeometry,
    releaseStatesOfProgram: releaseStatesOfProgram,
    initAttributes: initAttributes,
    enableAttribute: enableAttribute,
    disableUnusedAttributes: disableUnusedAttributes
  };
}

function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  var isWebGL2 = capabilities.isWebGL2;
  var mode;

  function setMode(value) {
    mode = value;
  }

  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }

  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    var extension, methodName;

    if (isWebGL2) {
      extension = gl;
      methodName = 'drawArraysInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawArraysInstancedANGLE';

      if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  } //


  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}

function WebGLCapabilities(gl, extensions, parameters) {
  var maxAnisotropy;

  function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined) return maxAnisotropy;

    if (extensions.has('EXT_texture_filter_anisotropic') === true) {
      var extension = extensions.get('EXT_texture_filter_anisotropic');
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }

    return maxAnisotropy;
  }

  function getMaxPrecision(precision) {
    if (precision === 'highp') {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return 'highp';
      }

      precision = 'mediump';
    }

    if (precision === 'mediump') {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return 'mediump';
      }
    }

    return 'lowp';
  }

  var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
  var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  var maxPrecision = getMaxPrecision(precision);

  if (maxPrecision !== precision) {
    console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
    precision = maxPrecision;
  }

  var drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
  var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  var maxTextures = gl.getParameter(34930);
  var maxVertexTextures = gl.getParameter(35660);
  var maxTextureSize = gl.getParameter(3379);
  var maxCubemapSize = gl.getParameter(34076);
  var maxAttributes = gl.getParameter(34921);
  var maxVertexUniforms = gl.getParameter(36347);
  var maxVaryings = gl.getParameter(36348);
  var maxFragmentUniforms = gl.getParameter(36349);
  var vertexTextures = maxVertexTextures > 0;
  var floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
  var floatVertexTextures = vertexTextures && floatFragmentTextures;
  var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2: isWebGL2,
    drawBuffers: drawBuffers,
    getMaxAnisotropy: getMaxAnisotropy,
    getMaxPrecision: getMaxPrecision,
    precision: precision,
    logarithmicDepthBuffer: logarithmicDepthBuffer,
    maxTextures: maxTextures,
    maxVertexTextures: maxVertexTextures,
    maxTextureSize: maxTextureSize,
    maxCubemapSize: maxCubemapSize,
    maxAttributes: maxAttributes,
    maxVertexUniforms: maxVertexUniforms,
    maxVaryings: maxVaryings,
    maxFragmentUniforms: maxFragmentUniforms,
    vertexTextures: vertexTextures,
    floatFragmentTextures: floatFragmentTextures,
    floatVertexTextures: floatVertexTextures,
    maxSamples: maxSamples
  };
}

function WebGLClipping(properties) {
  var scope = this;
  var globalState = null,
      numGlobalPlanes = 0,
      localClippingEnabled = false,
      renderingShadows = false;
  var plane = new Plane(),
      viewNormalMatrix = new Matrix3(),
      uniform = {
    value: null,
    needsUpdate: false
  };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;

  this.init = function (planes, enableLocalClipping, camera) {
    var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };

  this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
  };

  this.endShadows = function () {
    renderingShadows = false;
    resetGlobalState();
  };

  this.setState = function (material, camera, useCache) {
    var planes = material.clippingPlanes,
        clipIntersection = material.clipIntersection,
        clipShadows = material.clipShadows;
    var materialProperties = properties.get(material);

    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      // there's no local clipping
      if (renderingShadows) {
        // there's no global clipping
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
          lGlobal = nGlobal * 4;
      var dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray; // ensure unique state

      dstArray = projectPlanes(planes, camera, lGlobal, useCache);

      for (var _i81 = 0; _i81 !== lGlobal; ++_i81) {
        dstArray[_i81] = globalState[_i81];
      }

      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };

  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }

    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }

  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    var nPlanes = planes !== null ? planes.length : 0;
    var dstArray = null;

    if (nPlanes !== 0) {
      dstArray = uniform.value;

      if (skipTransform !== true || dstArray === null) {
        var flatSize = dstOffset + nPlanes * 4,
            viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);

        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }

        for (var _i82 = 0, i4 = dstOffset; _i82 !== nPlanes; ++_i82, i4 += 4) {
          plane.copy(planes[_i82]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }

      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }

    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}

function WebGLCubeMaps(renderer) {
  var cubemaps = new WeakMap();

  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }

    return texture;
  }

  function get(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      var mapping = texture.mapping;

      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          var cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          var image = texture.image;

          if (image && image.height > 0) {
            var renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener('dispose', onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            // image not yet ready. try the conversion next frame
            return null;
          }
        }
      }
    }

    return texture;
  }

  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    var cubemap = cubemaps.get(texture);

    if (cubemap !== undefined) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }

  function dispose() {
    cubemaps = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}

var OrthographicCamera = /*#__PURE__*/function (_Camera2) {
  _inherits(OrthographicCamera, _Camera2);

  var _super31 = _createSuper(OrthographicCamera);

  function OrthographicCamera(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
    var _this22;

    _classCallCheck(this, OrthographicCamera);

    _this22 = _super31.call(this);
    _this22.type = 'OrthographicCamera';
    _this22.zoom = 1;
    _this22.view = null;
    _this22.left = left;
    _this22.right = right;
    _this22.top = top;
    _this22.bottom = bottom;
    _this22.near = near;
    _this22.far = far;

    _this22.updateProjectionMatrix();

    return _this22;
  }

  _createClass(OrthographicCamera, [{
    key: "copy",
    value: function copy(source, recursive) {
      _get(_getPrototypeOf(OrthographicCamera.prototype), "copy", this).call(this, source, recursive);

      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    }
  }, {
    key: "setViewOffset",
    value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }

      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
  }, {
    key: "clearViewOffset",
    value: function clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }

      this.updateProjectionMatrix();
    }
  }, {
    key: "updateProjectionMatrix",
    value: function updateProjectionMatrix() {
      var dx = (this.right - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.right + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      var left = cx - dx;
      var right = cx + dx;
      var top = cy + dy;
      var bottom = cy - dy;

      if (this.view !== null && this.view.enabled) {
        var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }

      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(OrthographicCamera.prototype), "toJSON", this).call(this, meta);

      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      if (this.view !== null) data.object.view = Object.assign({}, this.view);
      return data;
    }
  }]);

  return OrthographicCamera;
}(Camera);

exports.OrthographicCamera = OrthographicCamera;
OrthographicCamera.prototype.isOrthographicCamera = true;
var LOD_MIN = 4; // The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.

var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582]; // The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.

var MAX_SAMPLES = 20;

var _flatCamera = /*@__PURE__*/new OrthographicCamera();

var _clearColor = /*@__PURE__*/new Color();

var _oldTarget = null; // Golden Ratio

var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.

var _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];
/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

var PMREMGenerator = /*#__PURE__*/function () {
  function PMREMGenerator(renderer) {
    _classCallCheck(this, PMREMGenerator);

    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;

    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */


  _createClass(PMREMGenerator, [{
    key: "fromScene",
    value: function fromScene(scene, sigma = 0, near = 0.1, far = 100) {
      _oldTarget = this._renderer.getRenderTarget();

      this._setSize(256);

      var cubeUVRenderTarget = this._allocateTargets();

      cubeUVRenderTarget.depthBuffer = true;

      this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);

      if (sigma > 0) {
        this._blur(cubeUVRenderTarget, 0, 0, sigma);
      }

      this._applyPMREM(cubeUVRenderTarget);

      this._cleanup(cubeUVRenderTarget);

      return cubeUVRenderTarget;
    }
    /**
     * Generates a PMREM from an equirectangular texture, which can be either LDR
     * or HDR. The ideal input image size is 1k (1024 x 512),
     * as this matches best with the 256 x 256 cubemap output.
     */

  }, {
    key: "fromEquirectangular",
    value: function fromEquirectangular(equirectangular, renderTarget = null) {
      return this._fromTexture(equirectangular, renderTarget);
    }
    /**
     * Generates a PMREM from an cubemap texture, which can be either LDR
     * or HDR. The ideal input cube size is 256 x 256,
     * as this matches best with the 256 x 256 cubemap output.
     */

  }, {
    key: "fromCubemap",
    value: function fromCubemap(cubemap, renderTarget = null) {
      return this._fromTexture(cubemap, renderTarget);
    }
    /**
     * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */

  }, {
    key: "compileCubemapShader",
    value: function compileCubemapShader() {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();

        this._compileMaterial(this._cubemapMaterial);
      }
    }
    /**
     * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */

  }, {
    key: "compileEquirectangularShader",
    value: function compileEquirectangularShader() {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();

        this._compileMaterial(this._equirectMaterial);
      }
    }
    /**
     * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
     * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
     * one of them will cause any others to also become unusable.
     */

  }, {
    key: "dispose",
    value: function dispose() {
      this._dispose();

      if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
      if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
    } // private interface

  }, {
    key: "_setSize",
    value: function _setSize(cubeSize) {
      this._lodMax = Math.floor(Math.log2(cubeSize));
      this._cubeSize = Math.pow(2, this._lodMax);
    }
  }, {
    key: "_dispose",
    value: function _dispose() {
      if (this._blurMaterial !== null) this._blurMaterial.dispose();
      if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();

      for (var _i83 = 0; _i83 < this._lodPlanes.length; _i83++) {
        this._lodPlanes[_i83].dispose();
      }
    }
  }, {
    key: "_cleanup",
    value: function _cleanup(outputTarget) {
      this._renderer.setRenderTarget(_oldTarget);

      outputTarget.scissorTest = false;

      _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
  }, {
    key: "_fromTexture",
    value: function _fromTexture(texture, renderTarget) {
      if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
        this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
      } else {
        // Equirectangular
        this._setSize(texture.image.width / 4);
      }

      _oldTarget = this._renderer.getRenderTarget();

      var cubeUVRenderTarget = renderTarget || this._allocateTargets();

      this._textureToCubeUV(texture, cubeUVRenderTarget);

      this._applyPMREM(cubeUVRenderTarget);

      this._cleanup(cubeUVRenderTarget);

      return cubeUVRenderTarget;
    }
  }, {
    key: "_allocateTargets",
    value: function _allocateTargets() {
      var width = 3 * Math.max(this._cubeSize, 16 * 7);
      var height = 4 * this._cubeSize - 32;
      var params = {
        magFilter: LinearFilter,
        minFilter: LinearFilter,
        generateMipmaps: false,
        type: HalfFloatType,
        format: RGBAFormat,
        encoding: LinearEncoding,
        depthBuffer: false
      };

      var cubeUVRenderTarget = _createRenderTarget(width, height, params);

      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {
        if (this._pingPongRenderTarget !== null) {
          this._dispose();
        }

        this._pingPongRenderTarget = _createRenderTarget(width, height, params);
        var _lodMax = this._lodMax;

        var _createPlanes2 = _createPlanes(_lodMax);

        this._sizeLods = _createPlanes2.sizeLods;
        this._lodPlanes = _createPlanes2.lodPlanes;
        this._sigmas = _createPlanes2.sigmas;
        this._blurMaterial = _getBlurShader(_lodMax, width, height);
      }

      return cubeUVRenderTarget;
    }
  }, {
    key: "_compileMaterial",
    value: function _compileMaterial(material) {
      var tmpMesh = new Mesh(this._lodPlanes[0], material);

      this._renderer.compile(tmpMesh, _flatCamera);
    }
  }, {
    key: "_sceneToCubeUV",
    value: function _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
      var fov = 90;
      var aspect = 1;
      var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
      var upSign = [1, -1, 1, 1, 1, 1];
      var forwardSign = [1, 1, 1, -1, -1, -1];
      var renderer = this._renderer;
      var originalAutoClear = renderer.autoClear;
      var toneMapping = renderer.toneMapping;
      renderer.getClearColor(_clearColor);
      renderer.toneMapping = NoToneMapping;
      renderer.autoClear = false;
      var backgroundMaterial = new MeshBasicMaterial({
        name: 'PMREM.Background',
        side: BackSide,
        depthWrite: false,
        depthTest: false
      });
      var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
      var useSolidColor = false;
      var background = scene.background;

      if (background) {
        if (background.isColor) {
          backgroundMaterial.color.copy(background);
          scene.background = null;
          useSolidColor = true;
        }
      } else {
        backgroundMaterial.color.copy(_clearColor);
        useSolidColor = true;
      }

      for (var _i84 = 0; _i84 < 6; _i84++) {
        var col = _i84 % 3;

        if (col === 0) {
          cubeCamera.up.set(0, upSign[_i84], 0);
          cubeCamera.lookAt(forwardSign[_i84], 0, 0);
        } else if (col === 1) {
          cubeCamera.up.set(0, 0, upSign[_i84]);
          cubeCamera.lookAt(0, forwardSign[_i84], 0);
        } else {
          cubeCamera.up.set(0, upSign[_i84], 0);
          cubeCamera.lookAt(0, 0, forwardSign[_i84]);
        }

        var size = this._cubeSize;

        _setViewport(cubeUVRenderTarget, col * size, _i84 > 2 ? size : 0, size, size);

        renderer.setRenderTarget(cubeUVRenderTarget);

        if (useSolidColor) {
          renderer.render(backgroundBox, cubeCamera);
        }

        renderer.render(scene, cubeCamera);
      }

      backgroundBox.geometry.dispose();
      backgroundBox.material.dispose();
      renderer.toneMapping = toneMapping;
      renderer.autoClear = originalAutoClear;
      scene.background = background;
    }
  }, {
    key: "_textureToCubeUV",
    value: function _textureToCubeUV(texture, cubeUVRenderTarget) {
      var renderer = this._renderer;
      var isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;

      if (isCubeTexture) {
        if (this._cubemapMaterial === null) {
          this._cubemapMaterial = _getCubemapMaterial();
        }

        this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
      } else {
        if (this._equirectMaterial === null) {
          this._equirectMaterial = _getEquirectMaterial();
        }
      }

      var material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
      var mesh = new Mesh(this._lodPlanes[0], material);
      var uniforms = material.uniforms;
      uniforms['envMap'].value = texture;
      var size = this._cubeSize;

      _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);

      renderer.setRenderTarget(cubeUVRenderTarget);
      renderer.render(mesh, _flatCamera);
    }
  }, {
    key: "_applyPMREM",
    value: function _applyPMREM(cubeUVRenderTarget) {
      var renderer = this._renderer;
      var autoClear = renderer.autoClear;
      renderer.autoClear = false;

      for (var _i85 = 1; _i85 < this._lodPlanes.length; _i85++) {
        var sigma = Math.sqrt(this._sigmas[_i85] * this._sigmas[_i85] - this._sigmas[_i85 - 1] * this._sigmas[_i85 - 1]);
        var poleAxis = _axisDirections[(_i85 - 1) % _axisDirections.length];

        this._blur(cubeUVRenderTarget, _i85 - 1, _i85, sigma, poleAxis);
      }

      renderer.autoClear = autoClear;
    }
    /**
     * This is a two-pass Gaussian blur for a cubemap. Normally this is done
     * vertically and horizontally, but this breaks down on a cube. Here we apply
     * the blur latitudinally (around the poles), and then longitudinally (towards
     * the poles) to approximate the orthogonally-separable blur. It is least
     * accurate at the poles, but still does a decent job.
     */

  }, {
    key: "_blur",
    value: function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
      var pingPongRenderTarget = this._pingPongRenderTarget;

      this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);

      this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
    }
  }, {
    key: "_halfBlur",
    value: function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
      var renderer = this._renderer;
      var blurMaterial = this._blurMaterial;

      if (direction !== 'latitudinal' && direction !== 'longitudinal') {
        console.error('blur direction must be either latitudinal or longitudinal!');
      } // Number of standard deviations at which to cut off the discrete approximation.


      var STANDARD_DEVIATIONS = 3;
      var blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
      var blurUniforms = blurMaterial.uniforms;
      var pixels = this._sizeLods[lodIn] - 1;
      var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
      var sigmaPixels = sigmaRadians / radiansPerPixel;
      var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

      if (samples > MAX_SAMPLES) {
        console.warn("sigmaRadians, ".concat(sigmaRadians, ", is too large and will clip, as it requested ").concat(samples, " samples when the maximum is set to ").concat(MAX_SAMPLES));
      }

      var weights = [];
      var sum = 0;

      for (var _i86 = 0; _i86 < MAX_SAMPLES; ++_i86) {
        var _x2 = _i86 / sigmaPixels;

        var weight = Math.exp(-_x2 * _x2 / 2);
        weights.push(weight);

        if (_i86 === 0) {
          sum += weight;
        } else if (_i86 < samples) {
          sum += 2 * weight;
        }
      }

      for (var _i87 = 0; _i87 < weights.length; _i87++) {
        weights[_i87] = weights[_i87] / sum;
      }

      blurUniforms['envMap'].value = targetIn.texture;
      blurUniforms['samples'].value = samples;
      blurUniforms['weights'].value = weights;
      blurUniforms['latitudinal'].value = direction === 'latitudinal';

      if (poleAxis) {
        blurUniforms['poleAxis'].value = poleAxis;
      }

      var _lodMax = this._lodMax;
      blurUniforms['dTheta'].value = radiansPerPixel;
      blurUniforms['mipInt'].value = _lodMax - lodIn;
      var outputSize = this._sizeLods[lodOut];
      var x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
      var y = 4 * (this._cubeSize - outputSize);

      _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);

      renderer.setRenderTarget(targetOut);
      renderer.render(blurMesh, _flatCamera);
    }
  }]);

  return PMREMGenerator;
}();

exports.PMREMGenerator = PMREMGenerator;

function _createPlanes(lodMax) {
  var lodPlanes = [];
  var sizeLods = [];
  var sigmas = [];
  var lod = lodMax;
  var totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

  for (var _i88 = 0; _i88 < totalLods; _i88++) {
    var sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    var sigma = 1.0 / sizeLod;

    if (_i88 > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[_i88 - lodMax + LOD_MIN - 1];
    } else if (_i88 === 0) {
      sigma = 0;
    }

    sigmas.push(sigma);
    var texelSize = 1.0 / (sizeLod - 1);
    var min = -texelSize / 2;
    var max = 1 + texelSize / 2;
    var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    var cubeFaces = 6;
    var vertices = 6;
    var positionSize = 3;
    var uvSize = 2;
    var faceIndexSize = 1;
    var position = new Float32Array(positionSize * vertices * cubeFaces);
    var uv = new Float32Array(uvSize * vertices * cubeFaces);
    var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

    for (var face = 0; face < cubeFaces; face++) {
      var x = face % 3 * 2 / 3 - 1;
      var y = face > 2 ? 0 : -1;
      var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      var fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }

    var planes = new BufferGeometry();
    planes.setAttribute('position', new BufferAttribute(position, positionSize));
    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);

    if (lod > LOD_MIN) {
      lod--;
    }
  }

  return {
    lodPlanes: lodPlanes,
    sizeLods: sizeLods,
    sigmas: sigmas
  };
}

function _createRenderTarget(width, height, params) {
  var cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}

function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}

function _getBlurShader(lodMax, width, height) {
  var weights = new Float32Array(MAX_SAMPLES);
  var poleAxis = new Vector3(0, 1, 0);
  var shaderMaterial = new ShaderMaterial({
    name: 'SphericalGaussianBlur',
    defines: {
      'n': MAX_SAMPLES,
      'CUBEUV_TEXEL_WIDTH': 1.0 / width,
      'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
      'CUBEUV_MAX_MIP': "".concat(lodMax, ".0")
    },
    uniforms: {
      'envMap': {
        value: null
      },
      'samples': {
        value: 1
      },
      'weights': {
        value: weights
      },
      'latitudinal': {
        value: false
      },
      'dTheta': {
        value: 0
      },
      'mipInt': {
        value: 0
      },
      'poleAxis': {
        value: poleAxis
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
    /* glsl */
    "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}

function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: 'EquirectangularToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
    /* glsl */
    "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}

function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: 'CubemapToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      },
      'flipEnvMap': {
        value: -1
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
    /* glsl */
    "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}

function _getCommonVertexShader() {
  return (
    /* glsl */
    "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
  );
}

function WebGLCubeUVMaps(renderer) {
  var cubeUVmaps = new WeakMap();
  var pmremGenerator = null;

  function get(texture) {
    if (texture && texture.isTexture) {
      var mapping = texture.mapping;
      var isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      var isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping; // equirect/cube map to cubeUV conversion

      if (isEquirectMap || isCubeMap) {
        if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
          texture.needsPMREMUpdate = false;
          var renderTarget = cubeUVmaps.get(texture);
          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (cubeUVmaps.has(texture)) {
            return cubeUVmaps.get(texture).texture;
          } else {
            var image = texture.image;

            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);

              var _renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);

              cubeUVmaps.set(texture, _renderTarget);
              texture.addEventListener('dispose', onTextureDispose);
              return _renderTarget.texture;
            } else {
              // image not yet ready. try the conversion next frame
              return null;
            }
          }
        }
      }
    }

    return texture;
  }

  function isCubeTextureComplete(image) {
    var count = 0;
    var length = 6;

    for (var _i89 = 0; _i89 < length; _i89++) {
      if (image[_i89] !== undefined) count++;
    }

    return count === length;
  }

  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    var cubemapUV = cubeUVmaps.get(texture);

    if (cubemapUV !== undefined) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }

  function dispose() {
    cubeUVmaps = new WeakMap();

    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }

  return {
    get: get,
    dispose: dispose
  };
}

function WebGLExtensions(gl) {
  var extensions = {};

  function getExtension(name) {
    if (extensions[name] !== undefined) {
      return extensions[name];
    }

    var extension;

    switch (name) {
      case 'WEBGL_depth_texture':
        extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
        break;

      case 'EXT_texture_filter_anisotropic':
        extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        break;

      case 'WEBGL_compressed_texture_s3tc':
        extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        break;

      case 'WEBGL_compressed_texture_pvrtc':
        extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        break;

      default:
        extension = gl.getExtension(name);
    }

    extensions[name] = extension;
    return extension;
  }

  return {
    has: function has(name) {
      return getExtension(name) !== null;
    },
    init: function init(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension('EXT_color_buffer_float');
      } else {
        getExtension('WEBGL_depth_texture');
        getExtension('OES_texture_float');
        getExtension('OES_texture_half_float');
        getExtension('OES_texture_half_float_linear');
        getExtension('OES_standard_derivatives');
        getExtension('OES_element_index_uint');
        getExtension('OES_vertex_array_object');
        getExtension('ANGLE_instanced_arrays');
      }

      getExtension('OES_texture_float_linear');
      getExtension('EXT_color_buffer_half_float');
      getExtension('WEBGL_multisampled_render_to_texture');
    },
    get: function get(name) {
      var extension = getExtension(name);

      if (extension === null) {
        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
      }

      return extension;
    }
  };
}

function WebGLGeometries(gl, attributes, info, bindingStates) {
  var geometries = {};
  var wireframeAttributes = new WeakMap();

  function onGeometryDispose(event) {
    var geometry = event.target;

    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }

    for (var name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }

    geometry.removeEventListener('dispose', onGeometryDispose);
    delete geometries[geometry.id];
    var attribute = wireframeAttributes.get(geometry);

    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }

    bindingStates.releaseStatesOfGeometry(geometry);

    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    } //


    info.memory.geometries--;
  }

  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener('dispose', onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }

  function update(geometry) {
    var geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.

    for (var name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    } // morph targets


    var morphAttributes = geometry.morphAttributes;

    for (var _name3 in morphAttributes) {
      var array = morphAttributes[_name3];

      for (var _i90 = 0, l = array.length; _i90 < l; _i90++) {
        attributes.update(array[_i90], 34962);
      }
    }
  }

  function updateWireframeAttribute(geometry) {
    var indices = [];
    var geometryIndex = geometry.index;
    var geometryPosition = geometry.attributes.position;
    var version = 0;

    if (geometryIndex !== null) {
      var array = geometryIndex.array;
      version = geometryIndex.version;

      for (var _i91 = 0, l = array.length; _i91 < l; _i91 += 3) {
        var a = array[_i91 + 0];
        var b = array[_i91 + 1];
        var c = array[_i91 + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      var _array = geometryPosition.array;
      version = geometryPosition.version;

      for (var _i92 = 0, _l5 = _array.length / 3 - 1; _i92 < _l5; _i92 += 3) {
        var _a4 = _i92 + 0;

        var _b4 = _i92 + 1;

        var _c4 = _i92 + 2;

        indices.push(_a4, _b4, _b4, _c4, _c4, _a4);
      }
    }

    var attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
    //

    var previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute); //

    wireframeAttributes.set(geometry, attribute);
  }

  function getWireframeAttribute(geometry) {
    var currentAttribute = wireframeAttributes.get(geometry);

    if (currentAttribute) {
      var geometryIndex = geometry.index;

      if (geometryIndex !== null) {
        // if the attribute is obsolete, create a new one
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }

    return wireframeAttributes.get(geometry);
  }

  return {
    get: get,
    update: update,
    getWireframeAttribute: getWireframeAttribute
  };
}

function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  var isWebGL2 = capabilities.isWebGL2;
  var mode;

  function setMode(value) {
    mode = value;
  }

  var type, bytesPerElement;

  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }

  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }

  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    var extension, methodName;

    if (isWebGL2) {
      extension = gl;
      methodName = 'drawElementsInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawElementsInstancedANGLE';

      if (extension === null) {
        console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  } //


  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}

function WebGLInfo(gl) {
  var memory = {
    geometries: 0,
    textures: 0
  };
  var render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };

  function update(count, mode, instanceCount) {
    render.calls++;

    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;

      case 1:
        render.lines += instanceCount * (count / 2);
        break;

      case 3:
        render.lines += instanceCount * (count - 1);
        break;

      case 2:
        render.lines += instanceCount * count;
        break;

      case 0:
        render.points += instanceCount * count;
        break;

      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
        break;
    }
  }

  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }

  return {
    memory: memory,
    render: render,
    programs: null,
    autoReset: true,
    reset: reset,
    update: update
  };
}

function numericalSort(a, b) {
  return a[0] - b[0];
}

function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}

function denormalize(morph, attribute) {
  var denominator = 1;
  var array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
  if (array instanceof Int8Array) denominator = 127;else if (array instanceof Int16Array) denominator = 32767;else if (array instanceof Int32Array) denominator = 2147483647;else console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array);
  morph.divideScalar(denominator);
}

function WebGLMorphtargets(gl, capabilities, textures) {
  var influencesList = {};
  var morphInfluences = new Float32Array(8);
  var morphTextures = new WeakMap();
  var morph = new Vector4();
  var workInfluences = [];

  for (var _i93 = 0; _i93 < 8; _i93++) {
    workInfluences[_i93] = [_i93, 0];
  }

  function update(object, geometry, material, program) {
    var objectInfluences = object.morphTargetInfluences;

    if (capabilities.isWebGL2 === true) {
      // instead of using attributes, the WebGL 2 code path encodes morph targets
      // into an array of data textures. Each layer represents a single morph target.
      var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
      var entry = morphTextures.get(geometry);

      if (entry === undefined || entry.count !== morphTargetsCount) {
        var disposeTexture = function disposeTexture() {
          texture.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener('dispose', disposeTexture);
        };

        if (entry !== undefined) entry.texture.dispose();
        var hasMorphPosition = geometry.morphAttributes.position !== undefined;
        var hasMorphNormals = geometry.morphAttributes.normal !== undefined;
        var hasMorphColors = geometry.morphAttributes.color !== undefined;
        var morphTargets = geometry.morphAttributes.position || [];
        var morphNormals = geometry.morphAttributes.normal || [];
        var morphColors = geometry.morphAttributes.color || [];
        var vertexDataCount = 0;
        if (hasMorphPosition === true) vertexDataCount = 1;
        if (hasMorphNormals === true) vertexDataCount = 2;
        if (hasMorphColors === true) vertexDataCount = 3;
        var width = geometry.attributes.position.count * vertexDataCount;
        var height = 1;

        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }

        var buffer = new Float32Array(width * height * 4 * morphTargetsCount);
        var texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
        texture.type = FloatType;
        texture.needsUpdate = true; // fill buffer

        var vertexDataStride = vertexDataCount * 4;

        for (var _i94 = 0; _i94 < morphTargetsCount; _i94++) {
          var morphTarget = morphTargets[_i94];
          var morphNormal = morphNormals[_i94];
          var morphColor = morphColors[_i94];
          var offset = width * height * 4 * _i94;

          for (var j = 0; j < morphTarget.count; j++) {
            var stride = j * vertexDataStride;

            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j);
              if (morphTarget.normalized === true) denormalize(morph, morphTarget);
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
            }

            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j);
              if (morphNormal.normalized === true) denormalize(morph, morphNormal);
              buffer[offset + stride + 4] = morph.x;
              buffer[offset + stride + 5] = morph.y;
              buffer[offset + stride + 6] = morph.z;
              buffer[offset + stride + 7] = 0;
            }

            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j);
              if (morphColor.normalized === true) denormalize(morph, morphColor);
              buffer[offset + stride + 8] = morph.x;
              buffer[offset + stride + 9] = morph.y;
              buffer[offset + stride + 10] = morph.z;
              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }

        entry = {
          count: morphTargetsCount,
          texture: texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener('dispose', disposeTexture);
      } //


      var morphInfluencesSum = 0;

      for (var _i95 = 0; _i95 < objectInfluences.length; _i95++) {
        morphInfluencesSum += objectInfluences[_i95];
      }

      var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
      program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);
      program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);
      program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);
    } else {
      // When object doesn't have morph target influences defined, we treat it as a 0-length array
      // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
      var length = objectInfluences === undefined ? 0 : objectInfluences.length;
      var influences = influencesList[geometry.id];

      if (influences === undefined || influences.length !== length) {
        // initialise list
        influences = [];

        for (var _i96 = 0; _i96 < length; _i96++) {
          influences[_i96] = [_i96, 0];
        }

        influencesList[geometry.id] = influences;
      } // Collect influences


      for (var _i97 = 0; _i97 < length; _i97++) {
        var influence = influences[_i97];
        influence[0] = _i97;
        influence[1] = objectInfluences[_i97];
      }

      influences.sort(absNumericalSort);

      for (var _i98 = 0; _i98 < 8; _i98++) {
        if (_i98 < length && influences[_i98][1]) {
          workInfluences[_i98][0] = influences[_i98][0];
          workInfluences[_i98][1] = influences[_i98][1];
        } else {
          workInfluences[_i98][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[_i98][1] = 0;
        }
      }

      workInfluences.sort(numericalSort);
      var _morphTargets = geometry.morphAttributes.position;
      var _morphNormals = geometry.morphAttributes.normal;
      var _morphInfluencesSum = 0;

      for (var _i99 = 0; _i99 < 8; _i99++) {
        var _influence = workInfluences[_i99];
        var index = _influence[0];
        var _value3 = _influence[1];

        if (index !== Number.MAX_SAFE_INTEGER && _value3) {
          if (_morphTargets && geometry.getAttribute('morphTarget' + _i99) !== _morphTargets[index]) {
            geometry.setAttribute('morphTarget' + _i99, _morphTargets[index]);
          }

          if (_morphNormals && geometry.getAttribute('morphNormal' + _i99) !== _morphNormals[index]) {
            geometry.setAttribute('morphNormal' + _i99, _morphNormals[index]);
          }

          morphInfluences[_i99] = _value3;
          _morphInfluencesSum += _value3;
        } else {
          if (_morphTargets && geometry.hasAttribute('morphTarget' + _i99) === true) {
            geometry.deleteAttribute('morphTarget' + _i99);
          }

          if (_morphNormals && geometry.hasAttribute('morphNormal' + _i99) === true) {
            geometry.deleteAttribute('morphNormal' + _i99);
          }

          morphInfluences[_i99] = 0;
        }
      } // GLSL shader uses formula baseinfluence * base + sum(target * influence)
      // This allows us to switch between absolute morphs and relative morphs without changing shader code
      // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


      var _morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - _morphInfluencesSum;

      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', _morphBaseInfluence);
      program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
    }
  }

  return {
    update: update
  };
}

function WebGLObjects(gl, geometries, attributes, info) {
  var updateMap = new WeakMap();

  function update(object) {
    var frame = info.render.frame;
    var geometry = object.geometry;
    var buffergeometry = geometries.get(object, geometry); // Update once per frame

    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }

    if (object.isInstancedMesh) {
      if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
        object.addEventListener('dispose', onInstancedMeshDispose);
      }

      attributes.update(object.instanceMatrix, 34962);

      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }

    return buffergeometry;
  }

  function dispose() {
    updateMap = new WeakMap();
  }

  function onInstancedMeshDispose(event) {
    var instancedMesh = event.target;
    instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }

  return {
    update: update,
    dispose: dispose
  };
}
/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */


var emptyTexture = new Texture();
var emptyArrayTexture = new DataArrayTexture();
var empty3dTexture = new Data3DTexture();
var emptyCubeTexture = new CubeTexture(); // --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)

var arrayCacheF32 = [];
var arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

function flatten(array, nBlocks, blockSize) {
  var firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983

  var n = nBlocks * blockSize;
  var r = arrayCacheF32[n];

  if (r === undefined) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }

  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);

    for (var _i100 = 1, offset = 0; _i100 !== nBlocks; ++_i100) {
      offset += blockSize;

      array[_i100].toArray(r, offset);
    }
  }

  return r;
}

function arraysEqual(a, b) {
  if (a.length !== b.length) return false;

  for (var _i101 = 0, l = a.length; _i101 < l; _i101++) {
    if (a[_i101] !== b[_i101]) return false;
  }

  return true;
}

function copyArray(a, b) {
  for (var _i102 = 0, l = b.length; _i102 < l; _i102++) {
    a[_i102] = b[_i102];
  }
} // Texture unit allocation


function allocTexUnits(textures, n) {
  var r = arrayCacheI32[n];

  if (r === undefined) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }

  for (var _i103 = 0; _i103 !== n; ++_i103) {
    r[_i103] = textures.allocateTextureUnit();
  }

  return r;
} // --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar


function setValueV1f(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
} // Single float vector (from flat array or THREE.VectorN)


function setValueV2f(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValueV3f(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== undefined) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValueV4f(gl, v) {
  var cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
} // Single matrix (from flat array or THREE.MatrixN)


function setValueM2(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}

function setValueM3(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}

function setValueM4(gl, v) {
  var cache = this.cache;
  var elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
} // Single integer / boolean


function setValueV1i(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
} // Single integer / boolean vector (from flat array)


function setValueV2i(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}

function setValueV3i(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}

function setValueV4i(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
} // Single unsigned integer


function setValueV1ui(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
} // Single unsigned integer vector (from flat array)


function setValueV2ui(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform2uiv(this.addr, v);
  copyArray(cache, v);
}

function setValueV3ui(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform3uiv(this.addr, v);
  copyArray(cache, v);
}

function setValueV4ui(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform4uiv(this.addr, v);
  copyArray(cache, v);
} // Single texture (2D / Cube)


function setValueT1(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTexture2D(v || emptyTexture, unit);
}

function setValueT3D1(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTexture3D(v || empty3dTexture, unit);
}

function setValueT6(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTextureCube(v || emptyCubeTexture, unit);
}

function setValueT2DArray1(gl, v, textures) {
  var cache = this.cache;
  var unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTexture2DArray(v || emptyArrayTexture, unit);
} // Helper to pick the right setter for the singular case


function getSingularSetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1f;
    // FLOAT

    case 0x8b50:
      return setValueV2f;
    // _VEC2

    case 0x8b51:
      return setValueV3f;
    // _VEC3

    case 0x8b52:
      return setValueV4f;
    // _VEC4

    case 0x8b5a:
      return setValueM2;
    // _MAT2

    case 0x8b5b:
      return setValueM3;
    // _MAT3

    case 0x8b5c:
      return setValueM4;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1i;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValueV2i;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValueV3i;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValueV4i;
    // _VEC4

    case 0x1405:
      return setValueV1ui;
    // UINT

    case 0x8dc6:
      return setValueV2ui;
    // _VEC2

    case 0x8dc7:
      return setValueV3ui;
    // _VEC3

    case 0x8dc8:
      return setValueV4ui;
    // _VEC4

    case 0x8b5e: // SAMPLER_2D

    case 0x8d66: // SAMPLER_EXTERNAL_OES

    case 0x8dca: // INT_SAMPLER_2D

    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1;

    case 0x8b5f: // SAMPLER_3D

    case 0x8dcb: // INT_SAMPLER_3D

    case 0x8dd3:
      // UNSIGNED_INT_SAMPLER_3D
      return setValueT3D1;

    case 0x8b60: // SAMPLER_CUBE

    case 0x8dcc: // INT_SAMPLER_CUBE

    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6;

    case 0x8dc1: // SAMPLER_2D_ARRAY

    case 0x8dcf: // INT_SAMPLER_2D_ARRAY

    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

    case 0x8dc4:
      // SAMPLER_2D_ARRAY_SHADOW
      return setValueT2DArray1;
  }
} // Array of scalars


function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
} // Array of vectors (from flat array or array of THREE.VectorN)


function setValueV2fArray(gl, v) {
  var data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}

function setValueV3fArray(gl, v) {
  var data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}

function setValueV4fArray(gl, v) {
  var data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
} // Array of matrices (from flat array or array of THREE.MatrixN)


function setValueM2Array(gl, v) {
  var data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}

function setValueM3Array(gl, v) {
  var data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}

function setValueM4Array(gl, v) {
  var data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
} // Array of integer / boolean


function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
} // Array of integer / boolean vectors (from flat array)


function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}

function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}

function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
} // Array of unsigned integer


function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
} // Array of unsigned integer vectors (from flat array)


function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}

function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}

function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
} // Array of textures (2D / 3D / Cube / 2DArray)


function setValueT1Array(gl, v, textures) {
  var n = v.length;
  var units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (var _i104 = 0; _i104 !== n; ++_i104) {
    textures.setTexture2D(v[_i104] || emptyTexture, units[_i104]);
  }
}

function setValueT3DArray(gl, v, textures) {
  var n = v.length;
  var units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (var _i105 = 0; _i105 !== n; ++_i105) {
    textures.setTexture3D(v[_i105] || empty3dTexture, units[_i105]);
  }
}

function setValueT6Array(gl, v, textures) {
  var n = v.length;
  var units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (var _i106 = 0; _i106 !== n; ++_i106) {
    textures.setTextureCube(v[_i106] || emptyCubeTexture, units[_i106]);
  }
}

function setValueT2DArrayArray(gl, v, textures) {
  var n = v.length;
  var units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (var _i107 = 0; _i107 !== n; ++_i107) {
    textures.setTexture2DArray(v[_i107] || emptyArrayTexture, units[_i107]);
  }
} // Helper to pick the right setter for a pure (bottom-level) array


function getPureArraySetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1fArray;
    // FLOAT

    case 0x8b50:
      return setValueV2fArray;
    // _VEC2

    case 0x8b51:
      return setValueV3fArray;
    // _VEC3

    case 0x8b52:
      return setValueV4fArray;
    // _VEC4

    case 0x8b5a:
      return setValueM2Array;
    // _MAT2

    case 0x8b5b:
      return setValueM3Array;
    // _MAT3

    case 0x8b5c:
      return setValueM4Array;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1iArray;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValueV2iArray;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValueV3iArray;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValueV4iArray;
    // _VEC4

    case 0x1405:
      return setValueV1uiArray;
    // UINT

    case 0x8dc6:
      return setValueV2uiArray;
    // _VEC2

    case 0x8dc7:
      return setValueV3uiArray;
    // _VEC3

    case 0x8dc8:
      return setValueV4uiArray;
    // _VEC4

    case 0x8b5e: // SAMPLER_2D

    case 0x8d66: // SAMPLER_EXTERNAL_OES

    case 0x8dca: // INT_SAMPLER_2D

    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1Array;

    case 0x8b5f: // SAMPLER_3D

    case 0x8dcb: // INT_SAMPLER_3D

    case 0x8dd3:
      // UNSIGNED_INT_SAMPLER_3D
      return setValueT3DArray;

    case 0x8b60: // SAMPLER_CUBE

    case 0x8dcc: // INT_SAMPLER_CUBE

    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6Array;

    case 0x8dc1: // SAMPLER_2D_ARRAY

    case 0x8dcf: // INT_SAMPLER_2D_ARRAY

    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

    case 0x8dc4:
      // SAMPLER_2D_ARRAY_SHADOW
      return setValueT2DArrayArray;
  }
} // --- Uniform Classes ---


function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

PureArrayUniform.prototype.updateCache = function (data) {
  var cache = this.cache;

  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }

  copyArray(cache, data);
};

function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}

StructuredUniform.prototype.setValue = function (gl, value, textures) {
  var seq = this.seq;

  for (var _i108 = 0, n = seq.length; _i108 !== n; ++_i108) {
    var u = seq[_i108];
    u.setValue(gl, value[u.id], textures);
  }
}; // --- Top-level ---
// Parser - builds up the property tree from the path strings


var RePathPart = /(\w+)(\])?(\[|\.)?/g; // extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}

function parseUniform(activeInfo, addr, container) {
  var path = activeInfo.name,
      pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

  RePathPart.lastIndex = 0;

  while (true) {
    var match = RePathPart.exec(path),
        matchEnd = RePathPart.lastIndex;
    var id = match[1];
    var idIsIndex = match[2] === ']',
        subscript = match[3];
    if (idIsIndex) id = id | 0; // convert to integer

    if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
      // bare name or "pure" bottom-level array "[0]" suffix
      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      // step into inner node / create it in case it doesn't exist
      var map = container.map;
      var next = map[id];

      if (next === undefined) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }

      container = next;
    }
  }
} // Root Container


function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  var n = gl.getProgramParameter(program, 35718);

  for (var _i109 = 0; _i109 < n; ++_i109) {
    var info = gl.getActiveUniform(program, _i109),
        addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}

WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
  var u = this.map[name];
  if (u !== undefined) u.setValue(gl, value, textures);
};

WebGLUniforms.prototype.setOptional = function (gl, object, name) {
  var v = object[name];
  if (v !== undefined) this.setValue(gl, name, v);
}; // Static interface


WebGLUniforms.upload = function (gl, seq, values, textures) {
  for (var _i110 = 0, n = seq.length; _i110 !== n; ++_i110) {
    var u = seq[_i110],
        v = values[u.id];

    if (v.needsUpdate !== false) {
      // note: always updating when .needsUpdate is undefined
      u.setValue(gl, v.value, textures);
    }
  }
};

WebGLUniforms.seqWithValue = function (seq, values) {
  var r = [];

  for (var _i111 = 0, n = seq.length; _i111 !== n; ++_i111) {
    var u = seq[_i111];
    if (u.id in values) r.push(u);
  }

  return r;
};

function WebGLShader(gl, type, string) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}

var programIdCount = 0;

function handleSource(string, errorLine) {
  var lines = string.split('\n');
  var lines2 = [];
  var from = Math.max(errorLine - 6, 0);
  var to = Math.min(errorLine + 6, lines.length);

  for (var _i112 = from; _i112 < to; _i112++) {
    lines2.push(_i112 + 1 + ': ' + lines[_i112]);
  }

  return lines2.join('\n');
}

function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ['Linear', '( value )'];

    case sRGBEncoding:
      return ['sRGB', '( value )'];

    default:
      console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
      return ['Linear', '( value )'];
  }
}

function getShaderErrors(gl, shader, type) {
  var status = gl.getShaderParameter(shader, 35713);
  var errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === '') return '';
  var errorLine = parseInt(/ERROR: 0:(\d+)/.exec(errors)[1]); // --enable-privileged-webgl-extension
  // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource(gl.getShaderSource(shader), errorLine);
}

function getTexelEncodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}

function getToneMappingFunction(functionName, toneMapping) {
  var toneMappingName;

  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = 'Linear';
      break;

    case ReinhardToneMapping:
      toneMappingName = 'Reinhard';
      break;

    case CineonToneMapping:
      toneMappingName = 'OptimizedCineon';
      break;

    case ACESFilmicToneMapping:
      toneMappingName = 'ACESFilmic';
      break;

    case CustomToneMapping:
      toneMappingName = 'Custom';
      break;

    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
      toneMappingName = 'Linear';
  }

  return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}

function generateExtensions(parameters) {
  var chunks = [parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
  return chunks.filter(filterEmptyLine).join('\n');
}

function generateDefines(defines) {
  var chunks = [];

  for (var name in defines) {
    var _value4 = defines[name];
    if (_value4 === false) continue;
    chunks.push('#define ' + name + ' ' + _value4);
  }

  return chunks.join('\n');
}

function fetchAttributeLocations(gl, program) {
  var attributes = {};
  var n = gl.getProgramParameter(program, 35721);

  for (var _i113 = 0; _i113 < n; _i113++) {
    var info = gl.getActiveAttrib(program, _i113);
    var name = info.name;
    var locationSize = 1;
    if (info.type === 35674) locationSize = 2;
    if (info.type === 35675) locationSize = 3;
    if (info.type === 35676) locationSize = 4; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize: locationSize
    };
  }

  return attributes;
}

function filterEmptyLine(string) {
  return string !== '';
}

function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}

function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
} // Resolve Includes


var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}

function includeReplacer(match, include) {
  var string = ShaderChunk[include];

  if (string === undefined) {
    throw new Error('Can not resolve #include <' + include + '>');
  }

  return resolveIncludes(string);
} // Unroll Loops


var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}

function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
  return loopReplacer(match, start, end, snippet);
}

function loopReplacer(match, start, end, snippet) {
  var string = '';

  for (var _i114 = parseInt(start); _i114 < parseInt(end); _i114++) {
    string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + _i114 + ' ]').replace(/UNROLLED_LOOP_INDEX/g, _i114);
  }

  return string;
} //


function generatePrecision(parameters) {
  var precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

  if (parameters.precision === 'highp') {
    precisionstring += '\n#define HIGH_PRECISION';
  } else if (parameters.precision === 'mediump') {
    precisionstring += '\n#define MEDIUM_PRECISION';
  } else if (parameters.precision === 'lowp') {
    precisionstring += '\n#define LOW_PRECISION';
  }

  return precisionstring;
}

function generateShadowMapTypeDefine(parameters) {
  var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
  }

  return shadowMapTypeDefine;
}

function generateEnvMapTypeDefine(parameters) {
  var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;

      case CubeUVReflectionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;
    }
  }

  return envMapTypeDefine;
}

function generateEnvMapModeDefine(parameters) {
  var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
    }
  }

  return envMapModeDefine;
}

function generateEnvMapBlendingDefine(parameters) {
  var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;

      case MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;

      case AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
    }
  }

  return envMapBlendingDefine;
}

function generateCubeUVSize(parameters) {
  var imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null) return null;
  var maxMip = Math.log2(imageHeight / 32 + 1) + 3;
  var texelHeight = 1.0 / imageHeight;
  var texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return {
    texelWidth: texelWidth,
    texelHeight: texelHeight,
    maxMip: maxMip
  };
}

function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  // TODO Send this event to Three.js DevTools
  // console.log( 'WebGLProgram', cacheKey );
  var gl = renderer.getContext();
  var defines = parameters.defines;
  var vertexShader = parameters.vertexShader;
  var fragmentShader = parameters.fragmentShader;
  var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  var envMapModeDefine = generateEnvMapModeDefine(parameters);
  var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  var envMapCubeUVSize = generateCubeUVSize(parameters);
  var customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
  var customDefines = generateDefines(defines);
  var program = gl.createProgram();
  var prefixVertex, prefixFragment;
  var versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

  if (parameters.isRawShaderMaterial) {
    prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

    if (prefixVertex.length > 0) {
      prefixVertex += '\n';
    }

    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

    if (prefixFragment.length > 0) {
      prefixFragment += '\n';
    }
  } else {
    prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.morphColors && parameters.isWebGL2 ? '#define USE_MORPHCOLORS' : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_TEXTURE' : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
    prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '', envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoat ? '#define USE_CLEARCOAT' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaTest ? '#define USE_ALPHATEST' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.opaque ? '#define OPAQUE' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
    getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
  }

  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);

  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    // GLSL 3.0 conversion for built-in materials and ShaderMaterial
    versionString = '#version 300 es\n';
    prefixVertex = ['precision mediump sampler2DArray;', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
    prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
  }

  var vertexGlsl = versionString + prefixVertex + vertexShader;
  var fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );

  var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

  if (parameters.index0AttributeName !== undefined) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
  }

  gl.linkProgram(program); // check for link errors

  if (renderer.debug.checkShaderErrors) {
    var programLog = gl.getProgramInfoLog(program).trim();
    var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    var runnable = true;
    var haveDiagnostics = true;

    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
      var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
      console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(program, 35715) + '\n\n' + 'Program Info Log: ' + programLog + '\n' + vertexErrors + '\n' + fragmentErrors);
    } else if (programLog !== '') {
      console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
    } else if (vertexLog === '' || fragmentLog === '') {
      haveDiagnostics = false;
    }

    if (haveDiagnostics) {
      this.diagnostics = {
        runnable: runnable,
        programLog: programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  } // Clean up
  // Crashes in iOS9 and iOS10. #18402
  // gl.detachShader( program, glVertexShader );
  // gl.detachShader( program, glFragmentShader );


  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader); // set up caching for uniform locations

  var cachedUniforms;

  this.getUniforms = function () {
    if (cachedUniforms === undefined) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }

    return cachedUniforms;
  }; // set up caching for attribute locations


  var cachedAttributes;

  this.getAttributes = function () {
    if (cachedAttributes === undefined) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }

    return cachedAttributes;
  }; // free resource


  this.destroy = function () {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = undefined;
  }; //


  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}

var _id = 0;

var WebGLShaderCache = /*#__PURE__*/function () {
  function WebGLShaderCache() {
    _classCallCheck(this, WebGLShaderCache);

    this.shaderCache = new Map();
    this.materialCache = new Map();
  }

  _createClass(WebGLShaderCache, [{
    key: "update",
    value: function update(material) {
      var vertexShader = material.vertexShader;
      var fragmentShader = material.fragmentShader;

      var vertexShaderStage = this._getShaderStage(vertexShader);

      var fragmentShaderStage = this._getShaderStage(fragmentShader);

      var materialShaders = this._getShaderCacheForMaterial(material);

      if (materialShaders.has(vertexShaderStage) === false) {
        materialShaders.add(vertexShaderStage);
        vertexShaderStage.usedTimes++;
      }

      if (materialShaders.has(fragmentShaderStage) === false) {
        materialShaders.add(fragmentShaderStage);
        fragmentShaderStage.usedTimes++;
      }

      return this;
    }
  }, {
    key: "remove",
    value: function remove(material) {
      var materialShaders = this.materialCache.get(material);

      var _iterator = _createForOfIteratorHelper(materialShaders),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var shaderStage = _step.value;
          shaderStage.usedTimes--;
          if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.materialCache.delete(material);
      return this;
    }
  }, {
    key: "getVertexShaderID",
    value: function getVertexShaderID(material) {
      return this._getShaderStage(material.vertexShader).id;
    }
  }, {
    key: "getFragmentShaderID",
    value: function getFragmentShaderID(material) {
      return this._getShaderStage(material.fragmentShader).id;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shaderCache.clear();
      this.materialCache.clear();
    }
  }, {
    key: "_getShaderCacheForMaterial",
    value: function _getShaderCacheForMaterial(material) {
      var cache = this.materialCache;

      if (cache.has(material) === false) {
        cache.set(material, new Set());
      }

      return cache.get(material);
    }
  }, {
    key: "_getShaderStage",
    value: function _getShaderStage(code) {
      var cache = this.shaderCache;

      if (cache.has(code) === false) {
        var stage = new WebGLShaderStage(code);
        cache.set(code, stage);
      }

      return cache.get(code);
    }
  }]);

  return WebGLShaderCache;
}();

var WebGLShaderStage = /*#__PURE__*/_createClass(function WebGLShaderStage(code) {
  _classCallCheck(this, WebGLShaderStage);

  this.id = _id++;
  this.code = code;
  this.usedTimes = 0;
});

function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  var _programLayers = new Layers();

  var _customShaders = new WebGLShaderCache();

  var programs = [];
  var isWebGL2 = capabilities.isWebGL2;
  var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  var floatVertexTextures = capabilities.floatVertexTextures;
  var maxVertexUniforms = capabilities.maxVertexUniforms;
  var vertexTextures = capabilities.vertexTextures;
  var precision = capabilities.precision;
  var shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };

  function getMaxBones(object) {
    var skeleton = object.skeleton;
    var bones = skeleton.bones;

    if (floatVertexTextures) {
      return 1024;
    } else {
      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)
      var nVertexUniforms = maxVertexUniforms;
      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      var maxBones = Math.min(nVertexMatrices, bones.length);

      if (maxBones < bones.length) {
        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
        return 0;
      }

      return maxBones;
    }
  }

  function getParameters(material, lights, shadows, scene, object) {
    var fog = scene.fog;
    var geometry = object.geometry;
    var environment = material.isMeshStandardMaterial ? scene.environment : null;
    var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    var envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    var shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    var maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;

    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);

      if (precision !== material.precision) {
        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
      }
    } //


    var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
    var morphTextureStride = 0;
    if (geometry.morphAttributes.position !== undefined) morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== undefined) morphTextureStride = 2;
    if (geometry.morphAttributes.color !== undefined) morphTextureStride = 3; //

    var vertexShader, fragmentShader;
    var customVertexShaderID, customFragmentShaderID;

    if (shaderID) {
      var shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;

      _customShaders.update(material);

      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }

    var currentRenderTarget = renderer.getRenderTarget();
    var useAlphaTest = material.alphaTest > 0;
    var useClearcoat = material.clearcoat > 0;
    var parameters = {
      isWebGL2: isWebGL2,
      shaderID: shaderID,
      shaderName: material.type,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      defines: material.defines,
      customVertexShaderID: customVertexShaderID,
      customFragmentShaderID: customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision: precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
      map: !!material.map,
      matcap: !!material.matcap,
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapCubeUVHeight: envMapCubeUVHeight,
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
      clearcoat: useClearcoat,
      clearcoatMap: useClearcoat && !!material.clearcoatMap,
      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      specularIntensityMap: !!material.specularIntensityMap,
      specularColorMap: !!material.specularColorMap,
      opaque: material.transparent === false && material.blending === NormalBlending,
      alphaMap: !!material.alphaMap,
      alphaTest: useAlphaTest,
      gradientMap: !!material.gradientMap,
      sheen: material.sheen > 0,
      sheenColorMap: !!material.sheenColorMap,
      sheenRoughnessMap: !!material.sheenRoughnessMap,
      transmission: material.transmission > 0,
      transmissionMap: !!material.transmissionMap,
      thicknessMap: !!material.thicknessMap,
      combine: material.combine,
      vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true && maxBones > 0,
      maxBones: maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: geometry.morphAttributes.position !== undefined,
      morphNormals: geometry.morphAttributes.normal !== undefined,
      morphColors: geometry.morphAttributes.color !== undefined,
      morphTargetsCount: morphTargetsCount,
      morphTextureStride: morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }

  function getProgramCacheKey(parameters) {
    var array = [];

    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }

    if (parameters.defines !== undefined) {
      for (var name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }

    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputEncoding);
    }

    array.push(parameters.customProgramCacheKey);
    return array.join();
  }

  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputEncoding);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.combine);
    array.push(parameters.vertexUvs);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.maxBones);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
  }

  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();

    if (parameters.isWebGL2) _programLayers.enable(0);
    if (parameters.supportsVertexTextures) _programLayers.enable(1);
    if (parameters.instancing) _programLayers.enable(2);
    if (parameters.instancingColor) _programLayers.enable(3);
    if (parameters.map) _programLayers.enable(4);
    if (parameters.matcap) _programLayers.enable(5);
    if (parameters.envMap) _programLayers.enable(6);
    if (parameters.lightMap) _programLayers.enable(7);
    if (parameters.aoMap) _programLayers.enable(8);
    if (parameters.emissiveMap) _programLayers.enable(9);
    if (parameters.bumpMap) _programLayers.enable(10);
    if (parameters.normalMap) _programLayers.enable(11);
    if (parameters.objectSpaceNormalMap) _programLayers.enable(12);
    if (parameters.tangentSpaceNormalMap) _programLayers.enable(13);
    if (parameters.clearcoat) _programLayers.enable(14);
    if (parameters.clearcoatMap) _programLayers.enable(15);
    if (parameters.clearcoatRoughnessMap) _programLayers.enable(16);
    if (parameters.clearcoatNormalMap) _programLayers.enable(17);
    if (parameters.displacementMap) _programLayers.enable(18);
    if (parameters.specularMap) _programLayers.enable(19);
    if (parameters.roughnessMap) _programLayers.enable(20);
    if (parameters.metalnessMap) _programLayers.enable(21);
    if (parameters.gradientMap) _programLayers.enable(22);
    if (parameters.alphaMap) _programLayers.enable(23);
    if (parameters.alphaTest) _programLayers.enable(24);
    if (parameters.vertexColors) _programLayers.enable(25);
    if (parameters.vertexAlphas) _programLayers.enable(26);
    if (parameters.vertexUvs) _programLayers.enable(27);
    if (parameters.vertexTangents) _programLayers.enable(28);
    if (parameters.uvsVertexOnly) _programLayers.enable(29);
    if (parameters.fog) _programLayers.enable(30);
    array.push(_programLayers.mask);

    _programLayers.disableAll();

    if (parameters.useFog) _programLayers.enable(0);
    if (parameters.flatShading) _programLayers.enable(1);
    if (parameters.logarithmicDepthBuffer) _programLayers.enable(2);
    if (parameters.skinning) _programLayers.enable(3);
    if (parameters.useVertexTexture) _programLayers.enable(4);
    if (parameters.morphTargets) _programLayers.enable(5);
    if (parameters.morphNormals) _programLayers.enable(6);
    if (parameters.morphColors) _programLayers.enable(7);
    if (parameters.premultipliedAlpha) _programLayers.enable(8);
    if (parameters.shadowMapEnabled) _programLayers.enable(9);
    if (parameters.physicallyCorrectLights) _programLayers.enable(10);
    if (parameters.doubleSided) _programLayers.enable(11);
    if (parameters.flipSided) _programLayers.enable(12);
    if (parameters.depthPacking) _programLayers.enable(13);
    if (parameters.dithering) _programLayers.enable(14);
    if (parameters.specularIntensityMap) _programLayers.enable(15);
    if (parameters.specularColorMap) _programLayers.enable(16);
    if (parameters.transmission) _programLayers.enable(17);
    if (parameters.transmissionMap) _programLayers.enable(18);
    if (parameters.thicknessMap) _programLayers.enable(19);
    if (parameters.sheen) _programLayers.enable(20);
    if (parameters.sheenColorMap) _programLayers.enable(21);
    if (parameters.sheenRoughnessMap) _programLayers.enable(22);
    if (parameters.decodeVideoTexture) _programLayers.enable(23);
    if (parameters.opaque) _programLayers.enable(24);
    array.push(_programLayers.mask);
  }

  function getUniforms(material) {
    var shaderID = shaderIDs[material.type];
    var uniforms;

    if (shaderID) {
      var shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }

    return uniforms;
  }

  function acquireProgram(parameters, cacheKey) {
    var program; // Check if code has been already compiled

    for (var p = 0, pl = programs.length; p < pl; p++) {
      var preexistingProgram = programs[p];

      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }

    if (program === undefined) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }

    return program;
  }

  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      // Remove from unordered set
      var _i115 = programs.indexOf(program);

      programs[_i115] = programs[programs.length - 1];
      programs.pop(); // Free WebGL resources

      program.destroy();
    }
  }

  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }

  function dispose() {
    _customShaders.dispose();
  }

  return {
    getParameters: getParameters,
    getProgramCacheKey: getProgramCacheKey,
    getUniforms: getUniforms,
    acquireProgram: acquireProgram,
    releaseProgram: releaseProgram,
    releaseShaderCache: releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: programs,
    dispose: dispose
  };
}

function WebGLProperties() {
  var properties = new WeakMap();

  function get(object) {
    var map = properties.get(object);

    if (map === undefined) {
      map = {};
      properties.set(object, map);
    }

    return map;
  }

  function remove(object) {
    properties.delete(object);
  }

  function update(object, key, value) {
    properties.get(object)[key] = value;
  }

  function dispose() {
    properties = new WeakMap();
  }

  return {
    get: get,
    remove: remove,
    update: update,
    dispose: dispose
  };
}

function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}

function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}

function WebGLRenderList() {
  var renderItems = [];
  var renderItemsIndex = 0;
  var opaque = [];
  var transmissive = [];
  var transparent = [];

  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }

  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    var renderItem = renderItems[renderItemsIndex];

    if (renderItem === undefined) {
      renderItem = {
        id: object.id,
        object: object,
        geometry: geometry,
        material: material,
        groupOrder: groupOrder,
        renderOrder: object.renderOrder,
        z: z,
        group: group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }

    renderItemsIndex++;
    return renderItem;
  }

  function push(object, geometry, material, groupOrder, z, group) {
    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

    if (material.transmission > 0.0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }

  function unshift(object, geometry, material, groupOrder, z, group) {
    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

    if (material.transmission > 0.0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }

  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }

  function finish() {
    // Clear references from inactive renderItems in the list
    for (var _i116 = renderItemsIndex, il = renderItems.length; _i116 < il; _i116++) {
      var renderItem = renderItems[_i116];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }

  return {
    opaque: opaque,
    transmissive: transmissive,
    transparent: transparent,
    init: init,
    push: push,
    unshift: unshift,
    finish: finish,
    sort: sort
  };
}

function WebGLRenderLists() {
  var lists = new WeakMap();

  function get(scene, renderCallDepth) {
    var list;

    if (lists.has(scene) === false) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList();
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }

    return list;
  }

  function dispose() {
    lists = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}

function UniformsCache() {
  var lights = {};
  return {
    get: function get(light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      var uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;

        case 'SpotLight':
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;

        case 'PointLight':
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;

        case 'HemisphereLight':
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;

        case 'RectAreaLight':
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

function ShadowUniformsCache() {
  var lights = {};
  return {
    get: function get(light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      var uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'SpotLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'PointLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1000
          };
          break;
        // TODO (abelnation): set RectAreaLight shadow uniforms
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

var nextVersion = 0;

function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}

function WebGLLights(extensions, capabilities) {
  var cache = new UniformsCache();
  var shadowCache = ShadowUniformsCache();
  var state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };

  for (var _i117 = 0; _i117 < 9; _i117++) {
    state.probe.push(new Vector3());
  }

  var vector3 = new Vector3();
  var matrix4 = new Matrix4();
  var matrix42 = new Matrix4();

  function setup(lights, physicallyCorrectLights) {
    var r = 0,
        g = 0,
        b = 0;

    for (var _i118 = 0; _i118 < 9; _i118++) {
      state.probe[_i118].set(0, 0, 0);
    }

    var directionalLength = 0;
    var pointLength = 0;
    var spotLength = 0;
    var rectAreaLength = 0;
    var hemiLength = 0;
    var numDirectionalShadows = 0;
    var numPointShadows = 0;
    var numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst); // artist-friendly light intensity scaling factor

    var scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;

    for (var _i119 = 0, l = lights.length; _i119 < l; _i119++) {
      var light = lights[_i119];
      var color = light.color;
      var intensity = light.intensity;
      var distance = light.distance;
      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

      if (light.isAmbientLight) {
        r += color.r * intensity * scaleFactor;
        g += color.g * intensity * scaleFactor;
        b += color.b * intensity * scaleFactor;
      } else if (light.isLightProbe) {
        for (var j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        var uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);

        if (light.castShadow) {
          var shadow = light.shadow;
          var shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }

        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        var _uniforms = cache.get(light);

        _uniforms.position.setFromMatrixPosition(light.matrixWorld);

        _uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);

        _uniforms.distance = distance;
        _uniforms.coneCos = Math.cos(light.angle);
        _uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        _uniforms.decay = light.decay;

        if (light.castShadow) {
          var _shadow = light.shadow;

          var _shadowUniforms = shadowCache.get(light);

          _shadowUniforms.shadowBias = _shadow.bias;
          _shadowUniforms.shadowNormalBias = _shadow.normalBias;
          _shadowUniforms.shadowRadius = _shadow.radius;
          _shadowUniforms.shadowMapSize = _shadow.mapSize;
          state.spotShadow[spotLength] = _shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }

        state.spot[spotLength] = _uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        var _uniforms2 = cache.get(light); // (a) intensity is the total visible light emitted
        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
        // (b) intensity is the brightness of the light


        _uniforms2.color.copy(color).multiplyScalar(intensity);

        _uniforms2.halfWidth.set(light.width * 0.5, 0.0, 0.0);

        _uniforms2.halfHeight.set(0.0, light.height * 0.5, 0.0);

        state.rectArea[rectAreaLength] = _uniforms2;
        rectAreaLength++;
      } else if (light.isPointLight) {
        var _uniforms3 = cache.get(light);

        _uniforms3.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);

        _uniforms3.distance = light.distance;
        _uniforms3.decay = light.decay;

        if (light.castShadow) {
          var _shadow2 = light.shadow;

          var _shadowUniforms2 = shadowCache.get(light);

          _shadowUniforms2.shadowBias = _shadow2.bias;
          _shadowUniforms2.shadowNormalBias = _shadow2.normalBias;
          _shadowUniforms2.shadowRadius = _shadow2.radius;
          _shadowUniforms2.shadowMapSize = _shadow2.mapSize;
          _shadowUniforms2.shadowCameraNear = _shadow2.camera.near;
          _shadowUniforms2.shadowCameraFar = _shadow2.camera.far;
          state.pointShadow[pointLength] = _shadowUniforms2;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }

        state.point[pointLength] = _uniforms3;
        pointLength++;
      } else if (light.isHemisphereLight) {
        var _uniforms4 = cache.get(light);

        _uniforms4.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);

        _uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);

        state.hemi[hemiLength] = _uniforms4;
        hemiLength++;
      }
    }

    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        // WebGL 2
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        // WebGL 1
        if (extensions.has('OES_texture_float_linear') === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has('OES_texture_half_float_linear') === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
        }
      }
    }

    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    var hash = state.hash;

    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }

  function setupView(lights, camera) {
    var directionalLength = 0;
    var pointLength = 0;
    var spotLength = 0;
    var rectAreaLength = 0;
    var hemiLength = 0;
    var viewMatrix = camera.matrixWorldInverse;

    for (var _i120 = 0, l = lights.length; _i120 < l; _i120++) {
      var light = lights[_i120];

      if (light.isDirectionalLight) {
        var uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        var _uniforms5 = state.spot[spotLength];

        _uniforms5.position.setFromMatrixPosition(light.matrixWorld);

        _uniforms5.position.applyMatrix4(viewMatrix);

        _uniforms5.direction.setFromMatrixPosition(light.matrixWorld);

        vector3.setFromMatrixPosition(light.target.matrixWorld);

        _uniforms5.direction.sub(vector3);

        _uniforms5.direction.transformDirection(viewMatrix);

        spotLength++;
      } else if (light.isRectAreaLight) {
        var _uniforms6 = state.rectArea[rectAreaLength];

        _uniforms6.position.setFromMatrixPosition(light.matrixWorld);

        _uniforms6.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors


        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);

        _uniforms6.halfWidth.set(light.width * 0.5, 0.0, 0.0);

        _uniforms6.halfHeight.set(0.0, light.height * 0.5, 0.0);

        _uniforms6.halfWidth.applyMatrix4(matrix42);

        _uniforms6.halfHeight.applyMatrix4(matrix42);

        rectAreaLength++;
      } else if (light.isPointLight) {
        var _uniforms7 = state.point[pointLength];

        _uniforms7.position.setFromMatrixPosition(light.matrixWorld);

        _uniforms7.position.applyMatrix4(viewMatrix);

        pointLength++;
      } else if (light.isHemisphereLight) {
        var _uniforms8 = state.hemi[hemiLength];

        _uniforms8.direction.setFromMatrixPosition(light.matrixWorld);

        _uniforms8.direction.transformDirection(viewMatrix);

        _uniforms8.direction.normalize();

        hemiLength++;
      }
    }
  }

  return {
    setup: setup,
    setupView: setupView,
    state: state
  };
}

function WebGLRenderState(extensions, capabilities) {
  var lights = new WebGLLights(extensions, capabilities);
  var lightsArray = [];
  var shadowsArray = [];

  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }

  function pushLight(light) {
    lightsArray.push(light);
  }

  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }

  function setupLights(physicallyCorrectLights) {
    lights.setup(lightsArray, physicallyCorrectLights);
  }

  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }

  var state = {
    lightsArray: lightsArray,
    shadowsArray: shadowsArray,
    lights: lights
  };
  return {
    init: init,
    state: state,
    setupLights: setupLights,
    setupLightsView: setupLightsView,
    pushLight: pushLight,
    pushShadow: pushShadow
  };
}

function WebGLRenderStates(extensions, capabilities) {
  var renderStates = new WeakMap();

  function get(scene, renderCallDepth = 0) {
    var renderState;

    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }

    return renderState;
  }

  function dispose() {
    renderStates = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}

var MeshDepthMaterial = /*#__PURE__*/function (_Material3) {
  _inherits(MeshDepthMaterial, _Material3);

  var _super32 = _createSuper(MeshDepthMaterial);

  function MeshDepthMaterial(parameters) {
    var _this23;

    _classCallCheck(this, MeshDepthMaterial);

    _this23 = _super32.call(this);
    _this23.type = 'MeshDepthMaterial';
    _this23.depthPacking = BasicDepthPacking;
    _this23.map = null;
    _this23.alphaMap = null;
    _this23.displacementMap = null;
    _this23.displacementScale = 1;
    _this23.displacementBias = 0;
    _this23.wireframe = false;
    _this23.wireframeLinewidth = 1;
    _this23.fog = false;

    _this23.setValues(parameters);

    return _this23;
  }

  _createClass(MeshDepthMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(MeshDepthMaterial.prototype), "copy", this).call(this, source);

      this.depthPacking = source.depthPacking;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    }
  }]);

  return MeshDepthMaterial;
}(Material);

exports.MeshDepthMaterial = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

var MeshDistanceMaterial = /*#__PURE__*/function (_Material4) {
  _inherits(MeshDistanceMaterial, _Material4);

  var _super33 = _createSuper(MeshDistanceMaterial);

  function MeshDistanceMaterial(parameters) {
    var _this24;

    _classCallCheck(this, MeshDistanceMaterial);

    _this24 = _super33.call(this);
    _this24.type = 'MeshDistanceMaterial';
    _this24.referencePosition = new Vector3();
    _this24.nearDistance = 1;
    _this24.farDistance = 1000;
    _this24.map = null;
    _this24.alphaMap = null;
    _this24.displacementMap = null;
    _this24.displacementScale = 1;
    _this24.displacementBias = 0;
    _this24.fog = false;

    _this24.setValues(parameters);

    return _this24;
  }

  _createClass(MeshDistanceMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(MeshDistanceMaterial.prototype), "copy", this).call(this, source);

      this.referencePosition.copy(source.referencePosition);
      this.nearDistance = source.nearDistance;
      this.farDistance = source.farDistance;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      return this;
    }
  }]);

  return MeshDistanceMaterial;
}(Material);

exports.MeshDistanceMaterial = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

function WebGLShadowMap(_renderer, _objects, _capabilities) {
  var _frustum = new Frustum();

  var _shadowMapSize = new Vector2(),
      _viewportSize = new Vector2(),
      _viewport = new Vector4(),
      _depthMaterial = new MeshDepthMaterial({
    depthPacking: RGBADepthPacking
  }),
      _distanceMaterial = new MeshDistanceMaterial(),
      _materialCache = {},
      _maxTextureSize = _capabilities.maxTextureSize;

  var shadowSide = {
    0: BackSide,
    1: FrontSide,
    2: DoubleSide
  };
  var shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: {
        value: null
      },
      resolution: {
        value: new Vector2()
      },
      radius: {
        value: 4.0
      }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  var shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  var fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  var scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;

  this.render = function (lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;

    var currentRenderTarget = _renderer.getRenderTarget();

    var activeCubeFace = _renderer.getActiveCubeFace();

    var activeMipmapLevel = _renderer.getActiveMipmapLevel();

    var _state = _renderer.state; // Set GL state for depth map.

    _state.setBlending(NoBlending);

    _state.buffers.color.setClear(1, 1, 1, 1);

    _state.buffers.depth.setTest(true);

    _state.setScissorTest(false); // render depth map


    for (var _i121 = 0, il = lights.length; _i121 < il; _i121++) {
      var light = lights[_i121];
      var shadow = light.shadow;

      if (shadow === undefined) {
        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
        continue;
      }

      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

      _shadowMapSize.copy(shadow.mapSize);

      var shadowFrameExtents = shadow.getFrameExtents();

      _shadowMapSize.multiply(shadowFrameExtents);

      _viewportSize.copy(shadow.mapSize);

      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }

        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }

      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
        shadow.map.texture.name = light.name + '.shadowMap';
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
        shadow.camera.updateProjectionMatrix();
      }

      if (shadow.map === null) {
        var pars = {
          minFilter: NearestFilter,
          magFilter: NearestFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + '.shadowMap';
        shadow.camera.updateProjectionMatrix();
      }

      _renderer.setRenderTarget(shadow.map);

      _renderer.clear();

      var viewportCount = shadow.getViewportCount();

      for (var vp = 0; vp < viewportCount; vp++) {
        var viewport = shadow.getViewport(vp);

        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

        _state.viewport(_viewport);

        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      } // do blur pass for VSM


      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }

      shadow.needsUpdate = false;
    }

    scope.needsUpdate = false;

    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };

  function VSMPass(shadow, camera) {
    var geometry = _objects.update(fullScreenMesh);

    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    } // vertical pass


    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;

    _renderer.setRenderTarget(shadow.mapPass);

    _renderer.clear();

    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass


    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;

    _renderer.setRenderTarget(shadow.map);

    _renderer.clear();

    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }

  function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
    var result = null;
    var customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;

    if (customMaterial !== undefined) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
    }

    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
      // in this case we need a unique material instance reflecting the
      // appropriate state
      var keyA = result.uuid,
          keyB = material.uuid;
      var materialsForVariant = _materialCache[keyA];

      if (materialsForVariant === undefined) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }

      var cachedMaterial = materialsForVariant[keyB];

      if (cachedMaterial === undefined) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }

      result = cachedMaterial;
    }

    result.visible = material.visible;
    result.wireframe = material.wireframe;

    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }

    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;

    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }

    return result;
  }

  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    var visible = object.layers.test(camera.layers);

    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

        var geometry = _objects.update(object);

        var material = object.material;

        if (Array.isArray(material)) {
          var groups = geometry.groups;

          for (var k = 0, kl = groups.length; k < kl; k++) {
            var group = groups[k];
            var groupMaterial = material[group.materialIndex];

            if (groupMaterial && groupMaterial.visible) {
              var depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          var _depthMaterial2 = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);

          _renderer.renderBufferDirect(shadowCamera, null, geometry, _depthMaterial2, object, null);
        }
      }
    }

    var children = object.children;

    for (var _i122 = 0, l = children.length; _i122 < l; _i122++) {
      renderObject(children[_i122], camera, shadowCamera, light, type);
    }
  }
}

function WebGLState(gl, extensions, capabilities) {
  var _equationToGL, _factorToGL;

  var isWebGL2 = capabilities.isWebGL2;

  function ColorBuffer() {
    var locked = false;
    var color = new Vector4();
    var currentColorMask = null;
    var currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function setMask(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function setLocked(lock) {
        locked = lock;
      },
      setClear: function setClear(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }

        color.set(r, g, b, a);

        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function reset() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0); // set to invalid state
      }
    };
  }

  function DepthBuffer() {
    var locked = false;
    var currentDepthMask = null;
    var currentDepthFunc = null;
    var currentDepthClear = null;
    return {
      setTest: function setTest(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function setMask(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function setFunc(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;

              case AlwaysDepth:
                gl.depthFunc(519);
                break;

              case LessDepth:
                gl.depthFunc(513);
                break;

              case LessEqualDepth:
                gl.depthFunc(515);
                break;

              case EqualDepth:
                gl.depthFunc(514);
                break;

              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;

              case GreaterDepth:
                gl.depthFunc(516);
                break;

              case NotEqualDepth:
                gl.depthFunc(517);
                break;

              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }

          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function setLocked(lock) {
        locked = lock;
      },
      setClear: function setClear(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function reset() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }

  function StencilBuffer() {
    var locked = false;
    var currentStencilMask = null;
    var currentStencilFunc = null;
    var currentStencilRef = null;
    var currentStencilFuncMask = null;
    var currentStencilFail = null;
    var currentStencilZFail = null;
    var currentStencilZPass = null;
    var currentStencilClear = null;
    return {
      setTest: function setTest(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function setMask(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function setLocked(lock) {
        locked = lock;
      },
      setClear: function setClear(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function reset() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  } //


  var colorBuffer = new ColorBuffer();
  var depthBuffer = new DepthBuffer();
  var stencilBuffer = new StencilBuffer();
  var enabledCapabilities = {};
  var currentBoundFramebuffers = {};
  var currentDrawbuffers = new WeakMap();
  var defaultDrawbuffers = [];
  var currentProgram = null;
  var currentBlendingEnabled = false;
  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;
  var currentPremultipledAlpha = false;
  var currentFlipSided = null;
  var currentCullFace = null;
  var currentLineWidth = null;
  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;
  var maxTextures = gl.getParameter(35661);
  var lineWidthAvailable = false;
  var version = 0;
  var glVersion = gl.getParameter(7938);

  if (glVersion.indexOf('WebGL') !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1.0;
  } else if (glVersion.indexOf('OpenGL ES') !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2.0;
  }

  var currentTextureSlot = null;
  var currentBoundTextures = {};
  var scissorParam = gl.getParameter(3088);
  var viewportParam = gl.getParameter(2978);
  var currentScissor = new Vector4().fromArray(scissorParam);
  var currentViewport = new Vector4().fromArray(viewportParam);

  function createTexture(type, target, count) {
    var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

    var texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);

    for (var _i123 = 0; _i123 < count; _i123++) {
      gl.texImage2D(target + _i123, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }

    return texture;
  }

  var emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6); // init

  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending); //

  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }

  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }

  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;

      if (isWebGL2) {
        // 36009 is equivalent to 36160
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer;
        }

        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer;
        }
      }

      return true;
    }

    return false;
  }

  function drawBuffers(renderTarget, framebuffer) {
    var drawBuffers = defaultDrawbuffers;
    var needsUpdate = false;

    if (renderTarget) {
      drawBuffers = currentDrawbuffers.get(framebuffer);

      if (drawBuffers === undefined) {
        drawBuffers = [];
        currentDrawbuffers.set(framebuffer, drawBuffers);
      }

      if (renderTarget.isWebGLMultipleRenderTargets) {
        var textures = renderTarget.texture;

        if (drawBuffers.length !== textures.length || drawBuffers[0] !== 36064) {
          for (var _i124 = 0, il = textures.length; _i124 < il; _i124++) {
            drawBuffers[_i124] = 36064 + _i124;
          }

          drawBuffers.length = textures.length;
          needsUpdate = true;
        }
      } else {
        if (drawBuffers[0] !== 36064) {
          drawBuffers[0] = 36064;
          needsUpdate = true;
        }
      }
    } else {
      if (drawBuffers[0] !== 1029) {
        drawBuffers[0] = 1029;
        needsUpdate = true;
      }
    }

    if (needsUpdate) {
      if (capabilities.isWebGL2) {
        gl.drawBuffers(drawBuffers);
      } else {
        extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(drawBuffers);
      }
    }
  }

  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }

    return false;
  }

  var equationToGL = (_equationToGL = {}, _defineProperty(_equationToGL, AddEquation, 32774), _defineProperty(_equationToGL, SubtractEquation, 32778), _defineProperty(_equationToGL, ReverseSubtractEquation, 32779), _equationToGL);

  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    var extension = extensions.get('EXT_blend_minmax');

    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }

  var factorToGL = (_factorToGL = {}, _defineProperty(_factorToGL, ZeroFactor, 0), _defineProperty(_factorToGL, OneFactor, 1), _defineProperty(_factorToGL, SrcColorFactor, 768), _defineProperty(_factorToGL, SrcAlphaFactor, 770), _defineProperty(_factorToGL, SrcAlphaSaturateFactor, 776), _defineProperty(_factorToGL, DstColorFactor, 774), _defineProperty(_factorToGL, DstAlphaFactor, 772), _defineProperty(_factorToGL, OneMinusSrcColorFactor, 769), _defineProperty(_factorToGL, OneMinusSrcAlphaFactor, 771), _defineProperty(_factorToGL, OneMinusDstColorFactor, 775), _defineProperty(_factorToGL, OneMinusDstAlphaFactor, 773), _factorToGL);

  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }

      return;
    }

    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }

    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }

        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;

            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1);
              break;

            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;

            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1);
              break;

            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        }

        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }

      return;
    } // custom blending


    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;

    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }

    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }

    currentBlending = blending;
    currentPremultipledAlpha = null;
  }

  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    var flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    var stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);

    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }

    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  } //


  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }

      currentFlipSided = flipSided;
    }
  }

  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);

      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }

    currentCullFace = cullFace;
  }

  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }

  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);

      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }

  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  } // texture


  function activeTexture(webglSlot) {
    if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;

    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }

  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }

    var boundTexture = currentBoundTextures[currentTextureSlot];

    if (boundTexture === undefined) {
      boundTexture = {
        type: undefined,
        texture: undefined
      };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }

    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }

  function unbindTexture() {
    var boundTexture = currentBoundTextures[currentTextureSlot];

    if (boundTexture !== undefined && boundTexture.type !== undefined) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = undefined;
      boundTexture.texture = undefined;
    }
  }

  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  } //


  function scissor(scissor) {
    if (currentScissor.equals(scissor) === false) {
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      currentScissor.copy(scissor);
    }
  }

  function viewport(viewport) {
    if (currentViewport.equals(viewport) === false) {
      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
      currentViewport.copy(viewport);
    }
  } //


  function reset() {
    // reset state
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.disable(32926);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(0xffffffff);
    gl.stencilFunc(519, 0, 0xffffffff);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.bindFramebuffer(36160, null);

    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null);
      gl.bindFramebuffer(36008, null);
    }

    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals

    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }

  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable: enable,
    disable: disable,
    bindFramebuffer: bindFramebuffer,
    drawBuffers: drawBuffers,
    useProgram: useProgram,
    setBlending: setBlending,
    setMaterial: setMaterial,
    setFlipSided: setFlipSided,
    setCullFace: setCullFace,
    setLineWidth: setLineWidth,
    setPolygonOffset: setPolygonOffset,
    setScissorTest: setScissorTest,
    activeTexture: activeTexture,
    bindTexture: bindTexture,
    unbindTexture: unbindTexture,
    compressedTexImage2D: compressedTexImage2D,
    texImage2D: texImage2D,
    texImage3D: texImage3D,
    texStorage2D: texStorage2D,
    texStorage3D: texStorage3D,
    texSubImage2D: texSubImage2D,
    texSubImage3D: texSubImage3D,
    compressedTexSubImage2D: compressedTexSubImage2D,
    scissor: scissor,
    viewport: viewport,
    reset: reset
  };
}

function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  var _wrappingToGL, _filterToGL;

  var isWebGL2 = capabilities.isWebGL2;
  var maxTextures = capabilities.maxTextures;
  var maxCubemapSize = capabilities.maxCubemapSize;
  var maxTextureSize = capabilities.maxTextureSize;
  var maxSamples = capabilities.maxSamples;
  var multisampledRTTExt = extensions.has('WEBGL_multisampled_render_to_texture') ? extensions.get('WEBGL_multisampled_render_to_texture') : null;
  var supportsInvalidateFramebuffer = /OculusBrowser/g.test(navigator.userAgent);

  var _videoTextures = new WeakMap();

  var _canvas;

  var _sources = new WeakMap(); // maps WebglTexture objects to instances of Source
  // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).


  var useOffscreenCanvas = false;

  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' // eslint-disable-next-line compat/compat
    && new OffscreenCanvas(1, 1).getContext('2d') !== null;
  } catch (err) {// Ignore any errors
  }

  function createCanvas(width, height) {
    // Use OffscreenCanvas when available. Specially needed in web workers
    return useOffscreenCanvas ? // eslint-disable-next-line compat/compat
    new OffscreenCanvas(width, height) : createElementNS('canvas');
  }

  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    var scale = 1; // handle case if texture exceeds max size

    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    } // only perform resize if necessary


    if (scale < 1 || needsPowerOfTwo === true) {
      // only perform resize for certain image types
      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        var floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        var width = floor(scale * image.width);
        var height = floor(scale * image.height);
        if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

        var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height);
        console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
        return canvas;
      } else {
        if ('data' in image) {
          console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
        }

        return image;
      }
    }

    return image;
  }

  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }

  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2) return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }

  function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
    if (isWebGL2 === false) return glFormat;

    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
      console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
    }

    var internalFormat = glFormat;

    if (glFormat === 6403) {
      if (glType === 5126) internalFormat = 33326;
      if (glType === 5131) internalFormat = 33325;
      if (glType === 5121) internalFormat = 33321;
    }

    if (glFormat === 33319) {
      if (glType === 5126) internalFormat = 33328;
      if (glType === 5131) internalFormat = 33327;
      if (glType === 5121) internalFormat = 33323;
    }

    if (glFormat === 6408) {
      if (glType === 5126) internalFormat = 34836;
      if (glType === 5131) internalFormat = 34842;
      if (glType === 5121) internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? 35907 : 32856;
      if (glType === 32819) internalFormat = 32854;
      if (glType === 32820) internalFormat = 32855;
    }

    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get('EXT_color_buffer_float');
    }

    return internalFormat;
  }

  function getMipLevels(texture, image, supportsMips) {
    if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== undefined && texture.mipmaps.length > 0) {
      // user-defined mipmaps
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      // texture without mipmaps (only base level)
      return 1;
    }
  } // Fallback filters for non-power-of-2 textures


  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }

    return 9729;
  } //


  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);

    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }

  function onRenderTargetDispose(event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  } //


  function deallocateTexture(texture) {
    var textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === undefined) return; // check if it's necessary to remove the WebGLTexture object

    var source = texture.source;

    var webglTextures = _sources.get(source);

    if (webglTextures) {
      var webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--; // the WebGLTexture object is not used anymore, remove it

      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      } // remove the weak map entry if no WebGLTexture uses the source anymore


      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }

    properties.remove(texture);
  }

  function deleteTexture(texture) {
    var textureProperties = properties.get(texture);

    _gl.deleteTexture(textureProperties.__webglTexture);

    var source = texture.source;

    var webglTextures = _sources.get(source);

    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }

  function deallocateRenderTarget(renderTarget) {
    var texture = renderTarget.texture;
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(texture);

    if (textureProperties.__webglTexture !== undefined) {
      _gl.deleteTexture(textureProperties.__webglTexture);

      info.memory.textures--;
    }

    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }

    if (renderTarget.isWebGLCubeRenderTarget) {
      for (var _i125 = 0; _i125 < 6; _i125++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[_i125]);

        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[_i125]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }

    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (var _i126 = 0, il = texture.length; _i126 < il; _i126++) {
        var attachmentProperties = properties.get(texture[_i126]);

        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);

          info.memory.textures--;
        }

        properties.remove(texture[_i126]);
      }
    }

    properties.remove(texture);
    properties.remove(renderTarget);
  } //


  var textureUnits = 0;

  function resetTextureUnits() {
    textureUnits = 0;
  }

  function allocateTextureUnit() {
    var textureUnit = textureUnits;

    if (textureUnit >= maxTextures) {
      console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
    }

    textureUnits += 1;
    return textureUnit;
  }

  function getTextureCacheKey(texture) {
    var array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.encoding);
    return array.join();
  } //


  function setTexture2D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);

    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      var image = texture.image;

      if (image === null) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');
      } else if (image.complete === false) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }

  function setTexture2DArray(texture, slot) {
    var textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }

  function setTexture3D(texture, slot) {
    var textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }

  function setTextureCube(texture, slot) {
    var textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }

  var wrappingToGL = (_wrappingToGL = {}, _defineProperty(_wrappingToGL, RepeatWrapping, 10497), _defineProperty(_wrappingToGL, ClampToEdgeWrapping, 33071), _defineProperty(_wrappingToGL, MirroredRepeatWrapping, 33648), _wrappingToGL);
  var filterToGL = (_filterToGL = {}, _defineProperty(_filterToGL, NearestFilter, 9728), _defineProperty(_filterToGL, NearestMipmapNearestFilter, 9984), _defineProperty(_filterToGL, NearestMipmapLinearFilter, 9986), _defineProperty(_filterToGL, LinearFilter, 9729), _defineProperty(_filterToGL, LinearMipmapNearestFilter, 9985), _defineProperty(_filterToGL, LinearMipmapLinearFilter, 9987), _filterToGL);

  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);

      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);

      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }

      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);

      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);

      _gl.texParameteri(textureType, 10243, 33071);

      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }

      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
      }

      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));

      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));

      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
      }
    }

    if (extensions.has('EXT_texture_filter_anisotropic') === true) {
      var extension = extensions.get('EXT_texture_filter_anisotropic');
      if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2

      if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only

      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }

  function initTexture(textureProperties, texture) {
    var forceUpload = false;

    if (textureProperties.__webglInit === undefined) {
      textureProperties.__webglInit = true;
      texture.addEventListener('dispose', onTextureDispose);
    } // create Source <-> WebGLTextures mapping if necessary


    var source = texture.source;

    var webglTextures = _sources.get(source);

    if (webglTextures === undefined) {
      webglTextures = {};

      _sources.set(source, webglTextures);
    } // check if there is already a WebGLTexture object for the given texture parameters


    var textureCacheKey = getTextureCacheKey(texture);

    if (textureCacheKey !== textureProperties.__cacheKey) {
      // if not, create a new instance of WebGLTexture
      if (webglTextures[textureCacheKey] === undefined) {
        // create new entry
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++; // when a new instance of WebGLTexture was created, a texture upload is required
        // even if the image contents are identical

        forceUpload = true;
      }

      webglTextures[textureCacheKey].usedTimes++; // every time the texture cache key changes, it's necessary to check if an instance of
      // WebGLTexture can be deleted in order to avoid a memory leak.

      var webglTexture = webglTextures[textureProperties.__cacheKey];

      if (webglTexture !== undefined) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;

        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      } // store references to cache key and WebGLTexture object


      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }

    return forceUpload;
  }

  function uploadTexture(textureProperties, texture, slot) {
    var textureType = 3553;
    if (texture.isDataArrayTexture) textureType = 35866;
    if (texture.isData3DTexture) textureType = 32879;
    var forceUpload = initTexture(textureProperties, texture);
    var source = texture.source;
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);

    if (source.version !== source.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture.flipY);

      _gl.pixelStorei(37441, texture.premultiplyAlpha);

      _gl.pixelStorei(3317, texture.unpackAlignment);

      _gl.pixelStorei(37443, 0);

      var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
      var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      image = verifyColorSpace(texture, image);
      var supportsMips = isPowerOfTwo$1(image) || isWebGL2,
          glFormat = utils.convert(texture.format, texture.encoding);
      var glType = utils.convert(texture.type),
          glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
      setTextureParameters(textureType, texture, supportsMips);
      var mipmap;
      var mipmaps = texture.mipmaps;
      var useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      var allocateMemory = textureProperties.__version === undefined;
      var levels = getMipLevels(texture, image, supportsMips);

      if (texture.isDepthTexture) {
        // populate depth texture with dummy data
        glInternalFormat = 6402;

        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = 35056;
          } else {
            glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
          }
        } else {
          if (texture.type === FloatType) {
            console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
          }
        } // validation checks for WebGL 1


        if (texture.format === DepthFormat && glInternalFormat === 6402) {
          // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
          // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
          // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
            texture.type = UnsignedShortType;
            glType = utils.convert(texture.type);
          }
        }

        if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
          // Depth stencil textures need the DEPTH_STENCIL internal format
          // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
          glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
          // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
          // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

          if (texture.type !== UnsignedInt248Type) {
            console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        } //


        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, 1, glInternalFormat, image.width, image.height);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        }
      } else if (texture.isDataTexture) {
        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }

          for (var _i127 = 0, il = mipmaps.length; _i127 < il; _i127++) {
            mipmap = mipmaps[_i127];

            if (useTexStorage) {
              state.texSubImage2D(3553, _i127, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, _i127, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }

          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            }

            state.texSubImage2D(3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
        }

        for (var _i128 = 0, _il9 = mipmaps.length; _i128 < _il9; _i128++) {
          mipmap = mipmaps[_i128];

          if (texture.format !== RGBAFormat) {
            if (glFormat !== null) {
              if (useTexStorage) {
                state.compressedTexSubImage2D(3553, _i128, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
              } else {
                state.compressedTexImage2D(3553, _i128, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              }
            } else {
              console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(3553, _i128, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, _i128, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(35866, levels, glInternalFormat, image.width, image.height, image.depth);
          }

          state.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(32879, levels, glInternalFormat, image.width, image.height, image.depth);
          }

          state.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        }
      } else {
        // regular Texture (image, video, canvas)
        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }

          for (var _i129 = 0, _il10 = mipmaps.length; _i129 < _il10; _i129++) {
            mipmap = mipmaps[_i129];

            if (useTexStorage) {
              state.texSubImage2D(3553, _i129, 0, 0, glFormat, glType, mipmap);
            } else {
              state.texImage2D(3553, _i129, glInternalFormat, glFormat, glType, mipmap);
            }
          }

          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            }

            state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType);
      }

      source.__currentVersion = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }

    textureProperties.__version = texture.version;
  }

  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    var forceUpload = initTexture(textureProperties, texture);
    var source = texture.source;
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);

    if (source.version !== source.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture.flipY);

      _gl.pixelStorei(37441, texture.premultiplyAlpha);

      _gl.pixelStorei(3317, texture.unpackAlignment);

      _gl.pixelStorei(37443, 0);

      var isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      var cubeImage = [];

      for (var _i130 = 0; _i130 < 6; _i130++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[_i130] = resizeImage(texture.image[_i130], false, true, maxCubemapSize);
        } else {
          cubeImage[_i130] = isDataTexture ? texture.image[_i130].image : texture.image[_i130];
        }

        cubeImage[_i130] = verifyColorSpace(texture, cubeImage[_i130]);
      }

      var image = cubeImage[0],
          supportsMips = isPowerOfTwo$1(image) || isWebGL2,
          glFormat = utils.convert(texture.format, texture.encoding),
          glType = utils.convert(texture.type),
          glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      var useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      var allocateMemory = textureProperties.__version === undefined;
      var levels = getMipLevels(texture, image, supportsMips);
      setTextureParameters(34067, texture, supportsMips);
      var mipmaps;

      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(34067, levels, glInternalFormat, image.width, image.height);
        }

        for (var _i131 = 0; _i131 < 6; _i131++) {
          mipmaps = cubeImage[_i131].mipmaps;

          for (var j = 0; j < mipmaps.length; j++) {
            var mipmap = mipmaps[j];

            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(34069 + _i131, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(34069 + _i131, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(34069 + _i131, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(34069 + _i131, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;

        if (useTexStorage && allocateMemory) {
          // TODO: Uniformly handle mipmap definitions
          // Normal textures and compressed cube textures define base level + mips with their mipmap array
          // Uncompressed cube textures use their mipmap array only for mips (no base level)
          if (mipmaps.length > 0) levels++;
          state.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
        }

        for (var _i132 = 0; _i132 < 6; _i132++) {
          if (isDataTexture) {
            if (useTexStorage) {
              state.texSubImage2D(34069 + _i132, 0, 0, 0, cubeImage[_i132].width, cubeImage[_i132].height, glFormat, glType, cubeImage[_i132].data);
            } else {
              state.texImage2D(34069 + _i132, 0, glInternalFormat, cubeImage[_i132].width, cubeImage[_i132].height, 0, glFormat, glType, cubeImage[_i132].data);
            }

            for (var _j3 = 0; _j3 < mipmaps.length; _j3++) {
              var _mipmap = mipmaps[_j3];
              var mipmapImage = _mipmap.image[_i132].image;

              if (useTexStorage) {
                state.texSubImage2D(34069 + _i132, _j3 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
              } else {
                state.texImage2D(34069 + _i132, _j3 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(34069 + _i132, 0, 0, 0, glFormat, glType, cubeImage[_i132]);
            } else {
              state.texImage2D(34069 + _i132, 0, glInternalFormat, glFormat, glType, cubeImage[_i132]);
            }

            for (var _j4 = 0; _j4 < mipmaps.length; _j4++) {
              var _mipmap2 = mipmaps[_j4];

              if (useTexStorage) {
                state.texSubImage2D(34069 + _i132, _j4 + 1, 0, 0, glFormat, glType, _mipmap2.image[_i132]);
              } else {
                state.texImage2D(34069 + _i132, _j4 + 1, glInternalFormat, glFormat, glType, _mipmap2.image[_i132]);
              }
            }
          }
        }
      }

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        // We assume images for cube map have the same size.
        generateMipmap(34067);
      }

      source.__currentVersion = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }

    textureProperties.__version = texture.version;
  } // Render targets
  // Setup storage for target texture and bind it to correct framebuffer


  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
    var glFormat = utils.convert(texture.format, texture.encoding);
    var glType = utils.convert(texture.type);
    var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    var renderTargetProperties = properties.get(renderTarget);

    if (!renderTargetProperties.__hasExternalTextures) {
      if (textureTarget === 32879 || textureTarget === 35866) {
        state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      }
    }

    state.bindFramebuffer(36160, framebuffer);

    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else {
      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    }

    state.bindFramebuffer(36160, null);
  } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);

    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      var glInternalFormat = 33189;

      if (isMultisample || useMultisampledRTT(renderTarget)) {
        var depthTexture = renderTarget.depthTexture;

        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }

        var samples = getRenderTargetSamples(renderTarget);

        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      var _samples = getRenderTargetSamples(renderTarget);

      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(36161, _samples, 35056, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, _samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      // Use the first texture for MRT so far
      var texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
      var glFormat = utils.convert(texture.format, texture.encoding);
      var glType = utils.convert(texture.type);

      var _glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);

      var _samples2 = getRenderTargetSamples(renderTarget);

      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(36161, _samples2, _glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, _samples2, _glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, _glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }

    _gl.bindRenderbuffer(36161, null);
  } // Setup resources for a Depth Texture for a FBO (needs an extension)


  function setupDepthTexture(framebuffer, renderTarget) {
    var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
    state.bindFramebuffer(36160, framebuffer);

    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    } // upload an empty depth texture with framebuffer size


    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }

    setTexture2D(renderTarget.depthTexture, 0);

    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

    var samples = getRenderTargetSamples(renderTarget);

    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      }
    } else {
      throw new Error('Unknown depthTexture format');
    }
  } // Setup GL resources for a non-texture depth buffer


  function setupDepthRenderbuffer(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var isCube = renderTarget.isWebGLCubeRenderTarget === true;

    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];

        for (var _i133 = 0; _i133 < 6; _i133++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[_i133]);
          renderTargetProperties.__webglDepthbuffer[_i133] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[_i133], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }

    state.bindFramebuffer(36160, null);
  } // rebind framebuffer with external textures


  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    var renderTargetProperties = properties.get(renderTarget);

    if (colorTexture !== undefined) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
    }

    if (depthTexture !== undefined) {
      setupDepthRenderbuffer(renderTarget);
    }
  } // Set up GL resources for the render target


  function setupRenderTarget(renderTarget) {
    var texture = renderTarget.texture;
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(texture);
    renderTarget.addEventListener('dispose', onRenderTargetDispose);

    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === undefined) {
        textureProperties.__webglTexture = _gl.createTexture();
      }

      textureProperties.__version = texture.version;
      info.memory.textures++;
    }

    var isCube = renderTarget.isWebGLCubeRenderTarget === true;
    var isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    var supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Setup framebuffer

    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];

      for (var _i134 = 0; _i134 < 6; _i134++) {
        renderTargetProperties.__webglFramebuffer[_i134] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          var textures = renderTarget.texture;

          for (var _i135 = 0, il = textures.length; _i135 < il; _i135++) {
            var attachmentProperties = properties.get(textures[_i135]);

            if (attachmentProperties.__webglTexture === undefined) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
        }
      } else if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

        _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);

        var glFormat = utils.convert(texture.format, texture.encoding);
        var glType = utils.convert(texture.type);
        var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        var samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);

        state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);

        _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);

        _gl.bindRenderbuffer(36161, null);

        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }

        state.bindFramebuffer(36160, null);
      }
    } // Setup color buffer


    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);

      for (var _i136 = 0; _i136 < 6; _i136++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i136], renderTarget, texture, 36064, 34069 + _i136);
      }

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067);
      }

      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      var _textures = renderTarget.texture;

      for (var _i137 = 0, _il11 = _textures.length; _i137 < _il11; _i137++) {
        var attachment = _textures[_i137];

        var _attachmentProperties = properties.get(attachment);

        state.bindTexture(3553, _attachmentProperties.__webglTexture);
        setTextureParameters(3553, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + _i137, 3553);

        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553);
        }
      }

      state.unbindTexture();
    } else {
      var glTextureType = 3553;

      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        if (isWebGL2) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;
        } else {
          console.error('THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.');
        }
      }

      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType);
      }

      state.unbindTexture();
    } // Setup depth and stencil buffers


    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }

  function updateRenderTargetMipmap(renderTarget) {
    var supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    var textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];

    for (var _i138 = 0, il = textures.length; _i138 < il; _i138++) {
      var texture = textures[_i138];

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;

        var webglTexture = properties.get(texture).__webglTexture;

        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }

  function updateMultisampleRenderTarget(renderTarget) {
    if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
      var width = renderTarget.width;
      var height = renderTarget.height;
      var mask = 16384;
      var invalidationArray = [36064];
      var depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;

      if (renderTarget.depthBuffer) {
        invalidationArray.push(depthStyle);
      }

      var renderTargetProperties = properties.get(renderTarget);
      var ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== undefined ? renderTargetProperties.__ignoreDepthValues : false;

      if (ignoreDepthValues === false) {
        if (renderTarget.depthBuffer) mask |= 256;
        if (renderTarget.stencilBuffer) mask |= 1024;
      }

      state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
      state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);

      if (ignoreDepthValues === true) {
        _gl.invalidateFramebuffer(36008, [depthStyle]);

        _gl.invalidateFramebuffer(36009, [depthStyle]);
      }

      _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);

      if (supportsInvalidateFramebuffer) {
        _gl.invalidateFramebuffer(36008, invalidationArray);
      }

      state.bindFramebuffer(36008, null);
      state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
    }
  }

  function getRenderTargetSamples(renderTarget) {
    return Math.min(maxSamples, renderTarget.samples);
  }

  function useMultisampledRTT(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    return isWebGL2 && renderTarget.samples > 0 && extensions.has('WEBGL_multisampled_render_to_texture') === true && renderTargetProperties.__useRenderToTexture !== false;
  }

  function updateVideoTexture(texture) {
    var frame = info.render.frame; // Check the last frame we updated the VideoTexture

    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);

      texture.update();
    }
  }

  function verifyColorSpace(texture, image) {
    var encoding = texture.encoding;
    var format = texture.format;
    var type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat) return image;

    if (encoding !== LinearEncoding) {
      // sRGB
      if (encoding === sRGBEncoding) {
        if (isWebGL2 === false) {
          // in WebGL 1, try to use EXT_sRGB extension and unsized formats
          if (extensions.has('EXT_sRGB') === true && format === RGBAFormat) {
            texture.format = _SRGBAFormat; // it's not possible to generate mips in WebGL 1 with this extension

            texture.minFilter = LinearFilter;
            texture.generateMipmaps = false;
          } else {
            // slow fallback (CPU decode)
            image = ImageUtils.sRGBToLinear(image);
          }
        } else {
          // in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format
          if (format !== RGBAFormat || type !== UnsignedByteType) {
            console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.');
          }
        }
      } else {
        console.error('THREE.WebGLTextures: Unsupported texture encoding:', encoding);
      }
    }

    return image;
  } //


  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}

function WebGLUtils(gl, extensions, capabilities) {
  var isWebGL2 = capabilities.isWebGL2;

  function convert(p, encoding = null) {
    var extension;
    if (p === UnsignedByteType) return 5121;
    if (p === UnsignedShort4444Type) return 32819;
    if (p === UnsignedShort5551Type) return 32820;
    if (p === ByteType) return 5120;
    if (p === ShortType) return 5122;
    if (p === UnsignedShortType) return 5123;
    if (p === IntType) return 5124;
    if (p === UnsignedIntType) return 5125;
    if (p === FloatType) return 5126;

    if (p === HalfFloatType) {
      if (isWebGL2) return 5131;
      extension = extensions.get('OES_texture_half_float');

      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }

    if (p === AlphaFormat) return 6406;
    if (p === RGBAFormat) return 6408;
    if (p === LuminanceFormat) return 6409;
    if (p === LuminanceAlphaFormat) return 6410;
    if (p === DepthFormat) return 6402;
    if (p === DepthStencilFormat) return 34041;
    if (p === RedFormat) return 6403;

    if (p === RGBFormat) {
      console.warn('THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228');
      return 6408;
    } // WebGL 1 sRGB fallback


    if (p === _SRGBAFormat) {
      extension = extensions.get('EXT_sRGB');

      if (extension !== null) {
        return extension.SRGB_ALPHA_EXT;
      } else {
        return null;
      }
    } // WebGL2 formats.


    if (p === RedIntegerFormat) return 36244;
    if (p === RGFormat) return 33319;
    if (p === RGIntegerFormat) return 33320;
    if (p === RGBAIntegerFormat) return 36249; // S3TC

    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (encoding === sRGBEncoding) {
        extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');

        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get('WEBGL_compressed_texture_s3tc');

        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    } // PVRTC


    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_pvrtc');

      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    } // ETC1


    if (p === RGB_ETC1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc1');

      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    } // ETC2


    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc');

      if (extension !== null) {
        if (p === RGB_ETC2_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    } // ASTC


    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get('WEBGL_compressed_texture_astc');

      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    } // BPTC


    if (p === RGBA_BPTC_Format) {
      extension = extensions.get('EXT_texture_compression_bptc');

      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else {
        return null;
      }
    } //


    if (p === UnsignedInt248Type) {
      if (isWebGL2) return 34042;
      extension = extensions.get('WEBGL_depth_texture');

      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }

  return {
    convert: convert
  };
}

var ArrayCamera = /*#__PURE__*/function (_PerspectiveCamera) {
  _inherits(ArrayCamera, _PerspectiveCamera);

  var _super34 = _createSuper(ArrayCamera);

  function ArrayCamera(array = []) {
    var _this25;

    _classCallCheck(this, ArrayCamera);

    _this25 = _super34.call(this);
    _this25.cameras = array;
    return _this25;
  }

  return _createClass(ArrayCamera);
}(PerspectiveCamera);

exports.ArrayCamera = ArrayCamera;
ArrayCamera.prototype.isArrayCamera = true;

var Group = /*#__PURE__*/function (_Object3D4) {
  _inherits(Group, _Object3D4);

  var _super35 = _createSuper(Group);

  function Group() {
    var _this26;

    _classCallCheck(this, Group);

    _this26 = _super35.call(this);
    _this26.type = 'Group';
    return _this26;
  }

  return _createClass(Group);
}(Object3D);

exports.Group = Group;
Group.prototype.isGroup = true;
var _moveEvent = {
  type: 'move'
};

var WebXRController = /*#__PURE__*/function () {
  function WebXRController() {
    _classCallCheck(this, WebXRController);

    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }

  _createClass(WebXRController, [{
    key: "getHandSpace",
    value: function getHandSpace() {
      if (this._hand === null) {
        this._hand = new Group();
        this._hand.matrixAutoUpdate = false;
        this._hand.visible = false;
        this._hand.joints = {};
        this._hand.inputState = {
          pinching: false
        };
      }

      return this._hand;
    }
  }, {
    key: "getTargetRaySpace",
    value: function getTargetRaySpace() {
      if (this._targetRay === null) {
        this._targetRay = new Group();
        this._targetRay.matrixAutoUpdate = false;
        this._targetRay.visible = false;
        this._targetRay.hasLinearVelocity = false;
        this._targetRay.linearVelocity = new Vector3();
        this._targetRay.hasAngularVelocity = false;
        this._targetRay.angularVelocity = new Vector3();
      }

      return this._targetRay;
    }
  }, {
    key: "getGripSpace",
    value: function getGripSpace() {
      if (this._grip === null) {
        this._grip = new Group();
        this._grip.matrixAutoUpdate = false;
        this._grip.visible = false;
        this._grip.hasLinearVelocity = false;
        this._grip.linearVelocity = new Vector3();
        this._grip.hasAngularVelocity = false;
        this._grip.angularVelocity = new Vector3();
      }

      return this._grip;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (this._targetRay !== null) {
        this._targetRay.dispatchEvent(event);
      }

      if (this._grip !== null) {
        this._grip.dispatchEvent(event);
      }

      if (this._hand !== null) {
        this._hand.dispatchEvent(event);
      }

      return this;
    }
  }, {
    key: "disconnect",
    value: function disconnect(inputSource) {
      this.dispatchEvent({
        type: 'disconnected',
        data: inputSource
      });

      if (this._targetRay !== null) {
        this._targetRay.visible = false;
      }

      if (this._grip !== null) {
        this._grip.visible = false;
      }

      if (this._hand !== null) {
        this._hand.visible = false;
      }

      return this;
    }
  }, {
    key: "update",
    value: function update(inputSource, frame, referenceSpace) {
      var inputPose = null;
      var gripPose = null;
      var handPose = null;
      var targetRay = this._targetRay;
      var grip = this._grip;
      var hand = this._hand;

      if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);

            if (inputPose.linearVelocity) {
              targetRay.hasLinearVelocity = true;
              targetRay.linearVelocity.copy(inputPose.linearVelocity);
            } else {
              targetRay.hasLinearVelocity = false;
            }

            if (inputPose.angularVelocity) {
              targetRay.hasAngularVelocity = true;
              targetRay.angularVelocity.copy(inputPose.angularVelocity);
            } else {
              targetRay.hasAngularVelocity = false;
            }

            this.dispatchEvent(_moveEvent);
          }
        }

        if (hand && inputSource.hand) {
          handPose = true;

          var _iterator2 = _createForOfIteratorHelper(inputSource.hand.values()),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var inputjoint = _step2.value;
              // Update the joints groups with the XRJoint poses
              var jointPose = frame.getJointPose(inputjoint, referenceSpace);

              if (hand.joints[inputjoint.jointName] === undefined) {
                // The transform of this joint will be updated with the joint pose on each frame
                var _joint = new Group();

                _joint.matrixAutoUpdate = false;
                _joint.visible = false;
                hand.joints[inputjoint.jointName] = _joint; // ??

                hand.add(_joint);
              }

              var joint = hand.joints[inputjoint.jointName];

              if (jointPose !== null) {
                joint.matrix.fromArray(jointPose.transform.matrix);
                joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                joint.jointRadius = jointPose.radius;
              }

              joint.visible = jointPose !== null;
            } // Custom events
            // Check pinchz

          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          var indexTip = hand.joints['index-finger-tip'];
          var thumbTip = hand.joints['thumb-tip'];
          var distance = indexTip.position.distanceTo(thumbTip.position);
          var distanceToPinch = 0.02;
          var threshold = 0.005;

          if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
            hand.inputState.pinching = false;
            this.dispatchEvent({
              type: 'pinchend',
              handedness: inputSource.handedness,
              target: this
            });
          } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
            hand.inputState.pinching = true;
            this.dispatchEvent({
              type: 'pinchstart',
              handedness: inputSource.handedness,
              target: this
            });
          }
        } else {
          if (grip !== null && inputSource.gripSpace) {
            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

            if (gripPose !== null) {
              grip.matrix.fromArray(gripPose.transform.matrix);
              grip.matrix.decompose(grip.position, grip.rotation, grip.scale);

              if (gripPose.linearVelocity) {
                grip.hasLinearVelocity = true;
                grip.linearVelocity.copy(gripPose.linearVelocity);
              } else {
                grip.hasLinearVelocity = false;
              }

              if (gripPose.angularVelocity) {
                grip.hasAngularVelocity = true;
                grip.angularVelocity.copy(gripPose.angularVelocity);
              } else {
                grip.hasAngularVelocity = false;
              }
            }
          }
        }
      }

      if (targetRay !== null) {
        targetRay.visible = inputPose !== null;
      }

      if (grip !== null) {
        grip.visible = gripPose !== null;
      }

      if (hand !== null) {
        hand.visible = handPose !== null;
      }

      return this;
    }
  }]);

  return WebXRController;
}();

var DepthTexture = /*#__PURE__*/function (_Texture4) {
  _inherits(DepthTexture, _Texture4);

  var _super36 = _createSuper(DepthTexture);

  function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    var _this27;

    _classCallCheck(this, DepthTexture);

    format = format !== undefined ? format : DepthFormat;

    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
    }

    if (type === undefined && format === DepthFormat) type = UnsignedShortType;
    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
    _this27 = _super36.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    _this27.image = {
      width: width,
      height: height
    };
    _this27.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    _this27.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    _this27.flipY = false;
    _this27.generateMipmaps = false;
    return _this27;
  }

  return _createClass(DepthTexture);
}(Texture);

exports.DepthTexture = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;

var WebXRManager = /*#__PURE__*/function (_EventDispatcher6) {
  _inherits(WebXRManager, _EventDispatcher6);

  var _super37 = _createSuper(WebXRManager);

  function WebXRManager(renderer, gl) {
    var _this28;

    _classCallCheck(this, WebXRManager);

    _this28 = _super37.call(this);

    var scope = _assertThisInitialized(_this28);

    var session = null;
    var framebufferScaleFactor = 1.0;
    var referenceSpace = null;
    var referenceSpaceType = 'local-floor';
    var pose = null;
    var glBinding = null;
    var glProjLayer = null;
    var glBaseLayer = null;
    var xrFrame = null;
    var attributes = gl.getContextAttributes();
    var initialRenderTarget = null;
    var newRenderTarget = null;
    var controllers = [];
    var inputSourcesMap = new Map(); //

    var cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    var cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    var cameras = [cameraL, cameraR];
    var cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    var _currentDepthNear = null;
    var _currentDepthFar = null; //

    _this28.cameraAutoUpdate = true;
    _this28.enabled = false;
    _this28.isPresenting = false;

    _this28.getController = function (index) {
      var controller = controllers[index];

      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }

      return controller.getTargetRaySpace();
    };

    _this28.getControllerGrip = function (index) {
      var controller = controllers[index];

      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }

      return controller.getGripSpace();
    };

    _this28.getHand = function (index) {
      var controller = controllers[index];

      if (controller === undefined) {
        controller = new WebXRController();
        controllers[index] = controller;
      }

      return controller.getHandSpace();
    }; //


    function onSessionEvent(event) {
      var controller = inputSourcesMap.get(event.inputSource);

      if (controller) {
        controller.dispatchEvent({
          type: event.type,
          data: event.inputSource
        });
      }
    }

    function onSessionEnd() {
      inputSourcesMap.forEach(function (controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      _currentDepthNear = null;
      _currentDepthFar = null; // restore framebuffer/rendering state

      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null; //

      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({
        type: 'sessionend'
      });
    }

    _this28.setFramebufferScaleFactor = function (value) {
      framebufferScaleFactor = value;

      if (scope.isPresenting === true) {
        console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
      }
    };

    _this28.setReferenceSpaceType = function (value) {
      referenceSpaceType = value;

      if (scope.isPresenting === true) {
        console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
      }
    };

    _this28.getReferenceSpace = function () {
      return referenceSpace;
    };

    _this28.getBaseLayer = function () {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };

    _this28.getBinding = function () {
      return glBinding;
    };

    _this28.getFrame = function () {
      return xrFrame;
    };

    _this28.getSession = function () {
      return session;
    };

    _this28.setSession = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(value) {
        var layerInit, depthFormat, depthType, glDepthFormat, projectionlayerInit, renderTargetProperties;
        return regeneratorRuntime.wrap(function _callee$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                session = value;

                if (!(session !== null)) {
                  _context5.next = 24;
                  break;
                }

                initialRenderTarget = renderer.getRenderTarget();
                session.addEventListener('select', onSessionEvent);
                session.addEventListener('selectstart', onSessionEvent);
                session.addEventListener('selectend', onSessionEvent);
                session.addEventListener('squeeze', onSessionEvent);
                session.addEventListener('squeezestart', onSessionEvent);
                session.addEventListener('squeezeend', onSessionEvent);
                session.addEventListener('end', onSessionEnd);
                session.addEventListener('inputsourceschange', onInputSourcesChange);

                if (!(attributes.xrCompatible !== true)) {
                  _context5.next = 14;
                  break;
                }

                _context5.next = 14;
                return gl.makeXRCompatible();

              case 14:
                if (session.renderState.layers === undefined || renderer.capabilities.isWebGL2 === false) {
                  layerInit = {
                    antialias: session.renderState.layers === undefined ? attributes.antialias : true,
                    alpha: attributes.alpha,
                    depth: attributes.depth,
                    stencil: attributes.stencil,
                    framebufferScaleFactor: framebufferScaleFactor
                  };
                  glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                  session.updateRenderState({
                    baseLayer: glBaseLayer
                  });
                  newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    encoding: renderer.outputEncoding
                  });
                } else {
                  depthFormat = null;
                  depthType = null;
                  glDepthFormat = null;

                  if (attributes.depth) {
                    glDepthFormat = attributes.stencil ? 35056 : 33190;
                    depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                    depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
                  }

                  projectionlayerInit = {
                    colorFormat: renderer.outputEncoding === sRGBEncoding ? 35907 : 32856,
                    depthFormat: glDepthFormat,
                    scaleFactor: framebufferScaleFactor
                  };
                  glBinding = new XRWebGLBinding(session, gl);
                  glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                  session.updateRenderState({
                    layers: [glProjLayer]
                  });
                  newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                    format: RGBAFormat,
                    type: UnsignedByteType,
                    depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
                    stencilBuffer: attributes.stencil,
                    encoding: renderer.outputEncoding,
                    samples: attributes.antialias ? 4 : 0
                  });
                  renderTargetProperties = renderer.properties.get(newRenderTarget);
                  renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
                }

                newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278
                // Set foveation to maximum.

                this.setFoveation(1.0);
                _context5.next = 19;
                return session.requestReferenceSpace(referenceSpaceType);

              case 19:
                referenceSpace = _context5.sent;
                animation.setContext(session);
                animation.start();
                scope.isPresenting = true;
                scope.dispatchEvent({
                  type: 'sessionstart'
                });

              case 24:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee, this);
      }));

      return function (_x3) {
        return _ref.apply(this, arguments);
      };
    }();

    function onInputSourcesChange(event) {
      var inputSources = session.inputSources; // Assign inputSources to available controllers

      for (var _i139 = 0; _i139 < controllers.length; _i139++) {
        inputSourcesMap.set(inputSources[_i139], controllers[_i139]);
      } // Notify disconnected


      for (var _i140 = 0; _i140 < event.removed.length; _i140++) {
        var inputSource = event.removed[_i140];
        var controller = inputSourcesMap.get(inputSource);

        if (controller) {
          controller.dispatchEvent({
            type: 'disconnected',
            data: inputSource
          });
          inputSourcesMap.delete(inputSource);
        }
      } // Notify connected


      for (var _i141 = 0; _i141 < event.added.length; _i141++) {
        var _inputSource = event.added[_i141];

        var _controller = inputSourcesMap.get(_inputSource);

        if (_controller) {
          _controller.dispatchEvent({
            type: 'connected',
            data: _inputSource
          });
        }
      }
    } //


    var cameraLPos = new Vector3();
    var cameraRPos = new Vector3();
    /**
     * Assumes 2 cameras that are parallel and share an X-axis, and that
     * the cameras' projection and world matrices have already been set.
     * And that near and far planes are identical for both cameras.
     * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
     */

    function setProjectionFromUnion(camera, cameraL, cameraR) {
      cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
      var ipd = cameraLPos.distanceTo(cameraRPos);
      var projL = cameraL.projectionMatrix.elements;
      var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
      // most likely identical top and bottom frustum extents.
      // Use the left camera for these values.

      var near = projL[14] / (projL[10] - 1);
      var far = projL[14] / (projL[10] + 1);
      var topFov = (projL[9] + 1) / projL[5];
      var bottomFov = (projL[9] - 1) / projL[5];
      var leftFov = (projL[8] - 1) / projL[0];
      var rightFov = (projR[8] + 1) / projR[0];
      var left = near * leftFov;
      var right = near * rightFov; // Calculate the new camera's position offset from the
      // left camera. xOffset should be roughly half `ipd`.

      var zOffset = ipd / (-leftFov + rightFov);
      var xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

      cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale
      // the values so that the near plane's position does not change in world space,
      // although must now be relative to the new union camera.

      var near2 = near + zOffset;
      var far2 = far + zOffset;
      var left2 = left - xOffset;
      var right2 = right + (ipd - xOffset);
      var top2 = topFov * far / far2 * near2;
      var bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }

    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }

      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }

    _this28.updateCamera = function (camera) {
      if (session === null) return;
      cameraVR.near = cameraR.near = cameraL.near = camera.near;
      cameraVR.far = cameraR.far = cameraL.far = camera.far;

      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        // Note that the new renderState won't apply until the next frame. See #18320
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }

      var parent = camera.parent;
      var cameras = cameraVR.cameras;
      updateCamera(cameraVR, parent);

      for (var _i142 = 0; _i142 < cameras.length; _i142++) {
        updateCamera(cameras[_i142], parent);
      }

      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale); // update user camera and its children

      camera.position.copy(cameraVR.position);
      camera.quaternion.copy(cameraVR.quaternion);
      camera.scale.copy(cameraVR.scale);
      camera.matrix.copy(cameraVR.matrix);
      camera.matrixWorld.copy(cameraVR.matrixWorld);
      var children = camera.children;

      for (var _i143 = 0, l = children.length; _i143 < l; _i143++) {
        children[_i143].updateMatrixWorld(true);
      } // update projection matrix for proper view frustum culling


      if (cameras.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        // assume single camera setup (AR)
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
    };

    _this28.getCamera = function () {
      return cameraVR;
    };

    _this28.getFoveation = function () {
      if (glProjLayer !== null) {
        return glProjLayer.fixedFoveation;
      }

      if (glBaseLayer !== null) {
        return glBaseLayer.fixedFoveation;
      }

      return undefined;
    };

    _this28.setFoveation = function (foveation) {
      // 0 = no foveation = full resolution
      // 1 = maximum foveation = the edges render at lower resolution
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = foveation;
      }

      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
        glBaseLayer.fixedFoveation = foveation;
      }
    }; // Animation Loop


    var onAnimationFrameCallback = null;

    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);
      xrFrame = frame;

      if (pose !== null) {
        var views = pose.views;

        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }

        var cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list

        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }

        for (var _i144 = 0; _i144 < views.length; _i144++) {
          var view = views[_i144];
          var viewport = null;

          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            var glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport; // For side-by-side projection, we only produce a single texture for both eyes.

            if (_i144 === 0) {
              renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);
              renderer.setRenderTarget(newRenderTarget);
            }
          }

          var camera = cameras[_i144];
          camera.matrix.fromArray(view.transform.matrix);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

          if (_i144 === 0) {
            cameraVR.matrix.copy(camera.matrix);
          }

          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera);
          }
        }
      } //


      var inputSources = session.inputSources;

      for (var _i145 = 0; _i145 < controllers.length; _i145++) {
        var controller = controllers[_i145];
        var inputSource = inputSources[_i145];
        controller.update(inputSource, frame, referenceSpace);
      }

      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
      xrFrame = null;
    }

    var animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);

    _this28.setAnimationLoop = function (callback) {
      onAnimationFrameCallback = callback;
    };

    _this28.dispose = function () {};

    return _this28;
  }

  return _createClass(WebXRManager);
}(EventDispatcher);

function WebGLMaterials(renderer, properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);

    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }

  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);

      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);

      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false; // #15581
    }
  }

  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;

    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }

    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }

    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }

    var envMap = properties.get(material).envMap;

    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }

    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap; // artist-friendly light intensity scaling factor

      var scaleFactor = renderer.physicallyCorrectLights !== true ? Math.PI : 1;
      uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
    }

    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. displacementMap map
    // 4. normal map
    // 5. bump map
    // 6. roughnessMap map
    // 7. metalnessMap map
    // 8. alphaMap map
    // 9. emissiveMap map
    // 10. clearcoat map
    // 11. clearcoat normal map
    // 12. clearcoat roughnessMap map
    // 13. specular intensity map
    // 14. specular tint map
    // 15. transmission map
    // 16. thickness map


    var uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    } else if (material.specularIntensityMap) {
      uvScaleMap = material.specularIntensityMap;
    } else if (material.specularColorMap) {
      uvScaleMap = material.specularColorMap;
    } else if (material.transmissionMap) {
      uvScaleMap = material.transmissionMap;
    } else if (material.thicknessMap) {
      uvScaleMap = material.thicknessMap;
    } else if (material.sheenColorMap) {
      uvScaleMap = material.sheenColorMap;
    } else if (material.sheenRoughnessMap) {
      uvScaleMap = material.sheenRoughnessMap;
    }

    if (uvScaleMap !== undefined) {
      // backwards compatibility
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }

      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    } // uv repeat and offset setting priorities for uv2
    // 1. ao map
    // 2. light map


    var uv2ScaleMap;

    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }

    if (uv2ScaleMap !== undefined) {
      // backwards compatibility
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }

      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }

      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }

  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }

  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }

  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map


    var uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }

    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map


    var uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }

    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
  }

  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }

  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;

    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }

    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }

    var envMap = properties.get(material).envMap;

    if (envMap) {
      //uniforms.envMap.value = material.envMap; // part of uniforms common
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }

  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior; // also part of uniforms common

    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;

      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
      }

      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
      }
    }

    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
      }

      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
      }

      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }

    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);

      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
      }

      uniforms.thickness.value = material.thickness;

      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
      }

      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }

    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);

    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
    }

    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
    }
  }

  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }

  function refreshUniformsDistance(uniforms, material) {
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }

  return {
    refreshFogUniforms: refreshFogUniforms,
    refreshMaterialUniforms: refreshMaterialUniforms
  };
}

function createCanvasElement() {
  var canvas = createElementNS('canvas');
  canvas.style.display = 'block';
  return canvas;
}

function WebGLRenderer(parameters = {}) {
  var _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
      _context = parameters.context !== undefined ? parameters.context : null,
      _depth = parameters.depth !== undefined ? parameters.depth : true,
      _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
      _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
      _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
      _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
      _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
      _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

  var _alpha;

  if (parameters.context !== undefined) {
    _alpha = _context.getContextAttributes().alpha;
  } else {
    _alpha = parameters.alpha !== undefined ? parameters.alpha : false;
  }

  var currentRenderList = null;
  var currentRenderState = null; // render() can be called from within a callback triggered by another render.
  // We track this so that the nested render call gets its list and state isolated from the parent render call.

  var renderListStack = [];
  var renderStateStack = []; // public properties

  this.domElement = _canvas; // Debug configuration container

  this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: true
  }; // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true; // scene graph

  this.sortObjects = true; // user-defined clipping

  this.clippingPlanes = [];
  this.localClippingEnabled = false; // physically based shading

  this.outputEncoding = LinearEncoding; // physical lights

  this.physicallyCorrectLights = false; // tone mapping

  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1.0; // internal properties

  var _this = this;

  var _isContextLost = false; // internal state cache

  var _currentActiveCubeFace = 0;
  var _currentActiveMipmapLevel = 0;
  var _currentRenderTarget = null;

  var _currentMaterialId = -1;

  var _currentCamera = null;

  var _currentViewport = new Vector4();

  var _currentScissor = new Vector4();

  var _currentScissorTest = null; //

  var _width = _canvas.width;
  var _height = _canvas.height;
  var _pixelRatio = 1;
  var _opaqueSort = null;
  var _transparentSort = null;

  var _viewport = new Vector4(0, 0, _width, _height);

  var _scissor = new Vector4(0, 0, _width, _height);

  var _scissorTest = false; // frustum

  var _frustum = new Frustum(); // clipping


  var _clippingEnabled = false;
  var _localClippingEnabled = false; // transmission

  var _transmissionRenderTarget = null; // camera matrices cache

  var _projScreenMatrix = new Matrix4();

  var _vector2 = new Vector2();

  var _vector3 = new Vector3();

  var _emptyScene = {
    background: null,
    fog: null,
    environment: null,
    overrideMaterial: null,
    isScene: true
  };

  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  } // initialize


  var _gl = _context;

  function getContext(contextNames, contextAttributes) {
    for (var _i146 = 0; _i146 < contextNames.length; _i146++) {
      var contextName = contextNames[_i146];

      var context = _canvas.getContext(contextName, contextAttributes);

      if (context !== null) return context;
    }

    return null;
  }

  try {
    var contextAttributes = {
      alpha: true,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    }; // OffscreenCanvas does not have setAttribute, see #22811

    if ('setAttribute' in _canvas) _canvas.setAttribute('data-engine', "three.js r".concat(REVISION)); // event listeners must be registered before WebGL context is created, see #12753

    _canvas.addEventListener('webglcontextlost', onContextLost, false);

    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

    if (_gl === null) {
      var contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }

      _gl = getContext(contextNames, contextAttributes);

      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error('Error creating WebGL context with your selected attributes.');
        } else {
          throw new Error('Error creating WebGL context.');
        }
      }
    } // Some experimental-webgl implementations do not have getShaderPrecisionFormat


    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function () {
        return {
          'rangeMin': 1,
          'rangeMax': 1,
          'precision': 1
        };
      };
    }
  } catch (error) {
    console.error('THREE.WebGLRenderer: ' + error.message);
    throw error;
  }

  var extensions, capabilities, state, info;
  var properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
  var programCache, materials, renderLists, renderStates, clipping, shadowMap;
  var background, morphtargets, bufferRenderer, indexedBufferRenderer;
  var utils, bindingStates;

  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    cubeuvmaps = new WebGLCubeUVMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(_this, properties);
    renderLists = new WebGLRenderLists();
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }

  initGLContext(); // xr

  var xr = new WebXRManager(_this, _gl);
  this.xr = xr; // API

  this.getContext = function () {
    return _gl;
  };

  this.getContextAttributes = function () {
    return _gl.getContextAttributes();
  };

  this.forceContextLoss = function () {
    var extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.loseContext();
  };

  this.forceContextRestore = function () {
    var extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.restoreContext();
  };

  this.getPixelRatio = function () {
    return _pixelRatio;
  };

  this.setPixelRatio = function (value) {
    if (value === undefined) return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };

  this.getSize = function (target) {
    return target.set(_width, _height);
  };

  this.setSize = function (width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
      return;
    }

    _width = width;
    _height = height;
    _canvas.width = Math.floor(width * _pixelRatio);
    _canvas.height = Math.floor(height * _pixelRatio);

    if (updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }

    this.setViewport(0, 0, width, height);
  };

  this.getDrawingBufferSize = function (target) {
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };

  this.setDrawingBufferSize = function (width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas.width = Math.floor(width * pixelRatio);
    _canvas.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };

  this.getCurrentViewport = function (target) {
    return target.copy(_currentViewport);
  };

  this.getViewport = function (target) {
    return target.copy(_viewport);
  };

  this.setViewport = function (x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width, height);
    }

    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };

  this.getScissor = function (target) {
    return target.copy(_scissor);
  };

  this.setScissor = function (x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width, height);
    }

    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };

  this.getScissorTest = function () {
    return _scissorTest;
  };

  this.setScissorTest = function (boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };

  this.setOpaqueSort = function (method) {
    _opaqueSort = method;
  };

  this.setTransparentSort = function (method) {
    _transparentSort = method;
  }; // Clearing


  this.getClearColor = function (target) {
    return target.copy(background.getClearColor());
  };

  this.setClearColor = function () {
    background.setClearColor.apply(background, arguments);
  };

  this.getClearAlpha = function () {
    return background.getClearAlpha();
  };

  this.setClearAlpha = function () {
    background.setClearAlpha.apply(background, arguments);
  };

  this.clear = function (color = true, depth = true, stencil = true) {
    var bits = 0;
    if (color) bits |= 16384;
    if (depth) bits |= 256;
    if (stencil) bits |= 1024;

    _gl.clear(bits);
  };

  this.clearColor = function () {
    this.clear(true, false, false);
  };

  this.clearDepth = function () {
    this.clear(false, true, false);
  };

  this.clearStencil = function () {
    this.clear(false, false, true);
  }; //


  this.dispose = function () {
    _canvas.removeEventListener('webglcontextlost', onContextLost, false);

    _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    cubeuvmaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    programCache.dispose();
    xr.dispose();
    xr.removeEventListener('sessionstart', onXRSessionStart);
    xr.removeEventListener('sessionend', onXRSessionEnd);

    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose();

      _transmissionRenderTarget = null;
    }

    animation.stop();
  }; // Events


  function onContextLost(event) {
    event.preventDefault();
    console.log('THREE.WebGLRenderer: Context Lost.');
    _isContextLost = true;
  }

  function
    /* event */
  onContextRestore() {
    console.log('THREE.WebGLRenderer: Context Restored.');
    _isContextLost = false;
    var infoAutoReset = info.autoReset;
    var shadowMapEnabled = shadowMap.enabled;
    var shadowMapAutoUpdate = shadowMap.autoUpdate;
    var shadowMapNeedsUpdate = shadowMap.needsUpdate;
    var shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }

  function onMaterialDispose(event) {
    var material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
  } // Buffer deallocation


  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }

  function releaseMaterialProgramReferences(material) {
    var programs = properties.get(material).programs;

    if (programs !== undefined) {
      programs.forEach(function (program) {
        programCache.releaseProgram(program);
      });

      if (material.isShaderMaterial) {
        programCache.releaseShaderCache(material);
      }
    }
  } // Buffer rendering


  this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
    if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

    var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    var program = setProgram(camera, scene, geometry, material, object);
    state.setMaterial(material, frontFaceCW); //

    var index = geometry.index;
    var position = geometry.attributes.position; //

    if (index === null) {
      if (position === undefined || position.count === 0) return;
    } else if (index.count === 0) {
      return;
    } //


    var rangeFactor = 1;

    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }

    bindingStates.setup(object, material, program, geometry, index);
    var attribute;
    var renderer = bufferRenderer;

    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    } //


    var dataCount = index !== null ? index.count : position.count;
    var rangeStart = geometry.drawRange.start * rangeFactor;
    var rangeCount = geometry.drawRange.count * rangeFactor;
    var groupStart = group !== null ? group.start * rangeFactor : 0;
    var groupCount = group !== null ? group.count * rangeFactor : Infinity;
    var drawStart = Math.max(rangeStart, groupStart);
    var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    var drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0) return; //

    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      var lineWidth = material.linewidth;
      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

      state.setLineWidth(lineWidth * getTargetPixelRatio());

      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }

    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      var instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  }; // Compile


  this.compile = function (scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    scene.traverseVisible(function (object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    scene.traverse(function (object) {
      var material = object.material;

      if (material) {
        if (Array.isArray(material)) {
          for (var _i147 = 0; _i147 < material.length; _i147++) {
            var material2 = material[_i147];
            getProgram(material2, scene, object);
          }
        } else {
          getProgram(material, scene, object);
        }
      }
    });
    renderStateStack.pop();
    currentRenderState = null;
  }; // Animation Loop


  var onAnimationFrameCallback = null;

  function onAnimationFrame(time) {
    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }

  function onXRSessionStart() {
    animation.stop();
  }

  function onXRSessionEnd() {
    animation.start();
  }

  var animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof self !== 'undefined') animation.setContext(self);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };

  xr.addEventListener('sessionstart', onXRSessionStart);
  xr.addEventListener('sessionend', onXRSessionEnd); // Rendering

  this.render = function (scene, camera) {
    if (camera !== undefined && camera.isCamera !== true) {
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }

    if (_isContextLost === true) return; // update scene graph

    if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

    if (camera.parent === null) camera.updateMatrixWorld();

    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
      camera = xr.getCamera(); // use XR camera for rendering
    } //


    if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);

    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    _frustum.setFromProjectionMatrix(_projScreenMatrix);

    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();

    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    } //


    if (_clippingEnabled === true) clipping.beginShadows();
    var shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    if (_clippingEnabled === true) clipping.endShadows(); //

    if (this.info.autoReset === true) this.info.reset(); //

    background.render(currentRenderList, scene); // render scene

    currentRenderState.setupLights(_this.physicallyCorrectLights);

    if (camera.isArrayCamera) {
      var cameras = camera.cameras;

      for (var _i148 = 0, l = cameras.length; _i148 < l; _i148++) {
        var camera2 = cameras[_i148];
        renderScene(currentRenderList, scene, camera2, camera2.viewport);
      }
    } else {
      renderScene(currentRenderList, scene, camera);
    } //


    if (_currentRenderTarget !== null) {
      // resolve multisample renderbuffers to a single-sample texture if necessary
      textures.updateMultisampleRenderTarget(_currentRenderTarget); // Generate mipmap if we're using any kind of mipmap filtering

      textures.updateRenderTargetMipmap(_currentRenderTarget);
    } //


    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // _gl.finish();

    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();

    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }

    renderListStack.pop();

    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };

  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false) return;
    var visible = object.layers.test(camera.layers);

    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true) object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          var geometry = objects.update(object);
          var material = object.material;

          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          // update skeleton only once in a frame
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }

        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          var _geometry2 = objects.update(object);

          var _material = object.material;

          if (Array.isArray(_material)) {
            var groups = _geometry2.groups;

            for (var _i149 = 0, l = groups.length; _i149 < l; _i149++) {
              var group = groups[_i149];
              var groupMaterial = _material[group.materialIndex];

              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, _geometry2, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (_material.visible) {
            currentRenderList.push(object, _geometry2, _material, groupOrder, _vector3.z, null);
          }
        }
      }
    }

    var children = object.children;

    for (var _i150 = 0, _l6 = children.length; _i150 < _l6; _i150++) {
      projectObject(children[_i150], camera, groupOrder, sortObjects);
    }
  }

  function renderScene(currentRenderList, scene, camera, viewport) {
    var opaqueObjects = currentRenderList.opaque;
    var transmissiveObjects = currentRenderList.transmissive;
    var transparentObjects = currentRenderList.transparent;
    currentRenderState.setupLightsView(camera);
    if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, scene, camera);
    if (viewport) state.viewport(_currentViewport.copy(viewport));
    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
    if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
    if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render

    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
  }

  function renderTransmissionPass(opaqueObjects, scene, camera) {
    var isWebGL2 = capabilities.isWebGL2;

    if (_transmissionRenderTarget === null) {
      _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
        generateMipmaps: true,
        type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        samples: isWebGL2 && _antialias === true ? 4 : 0
      });
    }

    _this.getDrawingBufferSize(_vector2);

    if (isWebGL2) {
      _transmissionRenderTarget.setSize(_vector2.x, _vector2.y);
    } else {
      _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector2.x), floorPowerOfTwo(_vector2.y));
    } //


    var currentRenderTarget = _this.getRenderTarget();

    _this.setRenderTarget(_transmissionRenderTarget);

    _this.clear(); // Turn off the features which can affect the frag color for opaque objects pass.
    // Otherwise they are applied twice in opaque objects pass and transmission objects pass.


    var currentToneMapping = _this.toneMapping;
    _this.toneMapping = NoToneMapping;
    renderObjects(opaqueObjects, scene, camera);
    _this.toneMapping = currentToneMapping;
    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
    textures.updateRenderTargetMipmap(_transmissionRenderTarget);

    _this.setRenderTarget(currentRenderTarget);
  }

  function renderObjects(renderList, scene, camera) {
    var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

    for (var _i151 = 0, l = renderList.length; _i151 < l; _i151++) {
      var renderItem = renderList[_i151];
      var object = renderItem.object;
      var geometry = renderItem.geometry;
      var material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      var group = renderItem.group;

      if (object.layers.test(camera.layers)) {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }

  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    material.onBeforeRender(_this, scene, camera, geometry, object, group);

    if (material.transparent === true && material.side === DoubleSide) {
      material.side = BackSide;
      material.needsUpdate = true;

      _this.renderBufferDirect(camera, scene, geometry, material, object, group);

      material.side = FrontSide;
      material.needsUpdate = true;

      _this.renderBufferDirect(camera, scene, geometry, material, object, group);

      material.side = DoubleSide;
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }

    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }

  function getProgram(material, scene, object) {
    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;
    var shadowsArray = currentRenderState.state.shadowsArray;
    var lightsStateVersion = lights.state.version;
    var parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    var programCacheKey = programCache.getProgramCacheKey(parameters);
    var programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);

    if (programs === undefined) {
      // new material
      material.addEventListener('dispose', onMaterialDispose);
      programs = new Map();
      materialProperties.programs = programs;
    }

    var program = programs.get(programCacheKey);

    if (program !== undefined) {
      // early out if program and light state is identical
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters);
        return program;
      }
    } else {
      parameters.uniforms = programCache.getUniforms(material);
      material.onBuild(object, parameters, _this);
      material.onBeforeCompile(parameters, _this);
      program = programCache.acquireProgram(parameters, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters.uniforms;
    }

    var uniforms = materialProperties.uniforms;

    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }

    updateCommonMaterialProperties(material, parameters); // store the light setup it was created for

    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;

    if (materialProperties.needsLights) {
      // wire up the material to this renderer's lighting state
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
    }

    var progUniforms = program.getUniforms();
    var uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }

  function updateCommonMaterialProperties(material, parameters) {
    var materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters.outputEncoding;
    materialProperties.instancing = parameters.instancing;
    materialProperties.skinning = parameters.skinning;
    materialProperties.morphTargets = parameters.morphTargets;
    materialProperties.morphNormals = parameters.morphNormals;
    materialProperties.morphColors = parameters.morphColors;
    materialProperties.morphTargetsCount = parameters.morphTargetsCount;
    materialProperties.numClippingPlanes = parameters.numClippingPlanes;
    materialProperties.numIntersection = parameters.numClipIntersection;
    materialProperties.vertexAlphas = parameters.vertexAlphas;
    materialProperties.vertexTangents = parameters.vertexTangents;
    materialProperties.toneMapping = parameters.toneMapping;
  }

  function setProgram(camera, scene, geometry, material, object) {
    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    textures.resetTextureUnits();
    var fog = scene.fog;
    var environment = material.isMeshStandardMaterial ? scene.environment : null;
    var encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
    var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    var vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
    var vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
    var morphTargets = !!geometry.morphAttributes.position;
    var morphNormals = !!geometry.morphAttributes.normal;
    var morphColors = !!geometry.morphAttributes.color;
    var toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
    var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;

    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
        // object instead of the material, once it becomes feasible
        // (#8465, #8379)

        clipping.setState(material, camera, useCache);
      }
    } //


    var needsProgramChange = false;

    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
        needsProgramChange = true;
      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      } else if (materialProperties.vertexTangents !== vertexTangents) {
        needsProgramChange = true;
      } else if (materialProperties.morphTargets !== morphTargets) {
        needsProgramChange = true;
      } else if (materialProperties.morphNormals !== morphNormals) {
        needsProgramChange = true;
      } else if (materialProperties.morphColors !== morphColors) {
        needsProgramChange = true;
      } else if (materialProperties.toneMapping !== toneMapping) {
        needsProgramChange = true;
      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    } //


    var program = materialProperties.currentProgram;

    if (needsProgramChange === true) {
      program = getProgram(material, scene, object);
    }

    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;
    var p_uniforms = program.getUniforms(),
        m_uniforms = materialProperties.uniforms;

    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }

    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }

    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
      }

      if (_currentCamera !== camera) {
        _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
        // now, in case this material supports lights - or later, when
        // the next material that does gets activated:

        refreshMaterial = true; // set to true on material change

        refreshLights = true; // remains set until update done
      } // load material specific uniforms
      // (shader material also gets them for the sake of genericity)


      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        var uCamPos = p_uniforms.map.cameraPosition;

        if (uCamPos !== undefined) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }

      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
      }

      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
      }
    } // skinning and morph target uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone and morph texture must go before other textures
    // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures


    if (object.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object, 'bindMatrix');
      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
      var skeleton = object.skeleton;

      if (skeleton) {
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
        }
      }
    }

    var morphAttributes = geometry.morphAttributes;

    if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || morphAttributes.color !== undefined && capabilities.isWebGL2 === true) {
      morphtargets.update(object, geometry, material, program);
    }

    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
    }

    if (refreshMaterial) {
      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);

      if (materialProperties.needsLights) {
        // the current material requires lighting info
        // note: all lighting uniforms are always set correctly
        // they simply reference the renderer's state for their
        // values
        //
        // use the current material's .needsUpdate flags to set
        // the GL state when required
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      } // refresh uniforms common to several materials


      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }

      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }

    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }

    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, 'center', object.center);
    } // common matrices


    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
    return program;
  } // If uniforms are marked as clean, they don't need to be loaded to the GPU.


  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }

  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }

  this.getActiveCubeFace = function () {
    return _currentActiveCubeFace;
  };

  this.getActiveMipmapLevel = function () {
    return _currentActiveMipmapLevel;
  };

  this.getRenderTarget = function () {
    return _currentRenderTarget;
  };

  this.setRenderTargetTextures = function (renderTarget, colorTexture, depthTexture) {
    properties.get(renderTarget.texture).__webglTexture = colorTexture;
    properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
    var renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__hasExternalTextures = true;

    if (renderTargetProperties.__hasExternalTextures) {
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        // The multisample_render_to_texture extension doesn't work properly if there
        // are midframe flushes and an external depth buffer. Disable use of the extension.
        if (extensions.has('WEBGL_multisampled_render_to_texture') === true) {
          console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');
          renderTargetProperties.__useRenderToTexture = false;
        }
      }
    }
  };

  this.setRenderTargetFramebuffer = function (renderTarget, defaultFramebuffer) {
    var renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
    renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;
  };

  this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    var useDefaultFramebuffer = true;

    if (renderTarget) {
      var renderTargetProperties = properties.get(renderTarget);

      if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {
        // We need to make sure to rebind the framebuffer.
        state.bindFramebuffer(36160, null);
        useDefaultFramebuffer = false;
      } else if (renderTargetProperties.__webglFramebuffer === undefined) {
        textures.setupRenderTarget(renderTarget);
      } else if (renderTargetProperties.__hasExternalTextures) {
        // Color and depth texture must be rebound in order for the swapchain to update.
        textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
      }
    }

    var framebuffer = null;
    var isCube = false;
    var isRenderTarget3D = false;

    if (renderTarget) {
      var texture = renderTarget.texture;

      if (texture.isData3DTexture || texture.isDataArrayTexture) {
        isRenderTarget3D = true;
      }

      var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }

      _currentViewport.copy(renderTarget.viewport);

      _currentScissor.copy(renderTarget.scissor);

      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

      _currentScissorTest = _scissorTest;
    }

    var framebufferBound = state.bindFramebuffer(36160, framebuffer);

    if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
      state.drawBuffers(renderTarget, framebuffer);
    }

    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);

    if (isCube) {
      var textureProperties = properties.get(renderTarget.texture);

      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      var _textureProperties = properties.get(renderTarget.texture);

      var layer = activeCubeFace || 0;

      _gl.framebufferTextureLayer(36160, 36064, _textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }

    _currentMaterialId = -1; // reset current material to ensure correct uniform bindings
  };

  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
      return;
    }

    var framebuffer = properties.get(renderTarget).__webglFramebuffer;

    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }

    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);

      try {
        var texture = renderTarget.texture;
        var textureFormat = texture.format;
        var textureType = texture.type;

        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
          return;
        }

        var halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));

        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
        !halfFloatSupportedByExt) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
          return;
        } // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)


        if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
          _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
        }
      } finally {
        // restore framebuffer of current render target if necessary
        var _framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;

        state.bindFramebuffer(36160, _framebuffer);
      }
    }
  };

  this.copyFramebufferToTexture = function (position, texture, level = 0) {
    if (texture.isFramebufferTexture !== true) {
      console.error('THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.');
      return;
    }

    var levelScale = Math.pow(2, -level);
    var width = Math.floor(texture.image.width * levelScale);
    var height = Math.floor(texture.image.height * levelScale);
    textures.setTexture2D(texture, 0);

    _gl.copyTexSubImage2D(3553, level, 0, 0, position.x, position.y, width, height);

    state.unbindTexture();
  };

  this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {
    var width = srcTexture.image.width;
    var height = srcTexture.image.height;
    var glFormat = utils.convert(dstTexture.format);
    var glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei
    // parameters, make sure they are correct for the dstTexture

    _gl.pixelStorei(37440, dstTexture.flipY);

    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);

    _gl.pixelStorei(3317, dstTexture.unpackAlignment);

    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    } // Generate mipmaps only when copying level 0


    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
    state.unbindTexture();
  };

  this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
      return;
    }

    var width = sourceBox.max.x - sourceBox.min.x + 1;
    var height = sourceBox.max.y - sourceBox.min.y + 1;
    var depth = sourceBox.max.z - sourceBox.min.z + 1;
    var glFormat = utils.convert(dstTexture.format);
    var glType = utils.convert(dstTexture.type);
    var glTarget;

    if (dstTexture.isData3DTexture) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataArrayTexture) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
      return;
    }

    _gl.pixelStorei(37440, dstTexture.flipY);

    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);

    _gl.pixelStorei(3317, dstTexture.unpackAlignment);

    var unpackRowLen = _gl.getParameter(3314);

    var unpackImageHeight = _gl.getParameter(32878);

    var unpackSkipPixels = _gl.getParameter(3316);

    var unpackSkipRows = _gl.getParameter(3315);

    var unpackSkipImages = _gl.getParameter(32877);

    var image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;

    _gl.pixelStorei(3314, image.width);

    _gl.pixelStorei(32878, image.height);

    _gl.pixelStorei(3316, sourceBox.min.x);

    _gl.pixelStorei(3315, sourceBox.min.y);

    _gl.pixelStorei(32877, sourceBox.min.z);

    if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');

        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
      } else {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
      }
    }

    _gl.pixelStorei(3314, unpackRowLen);

    _gl.pixelStorei(32878, unpackImageHeight);

    _gl.pixelStorei(3316, unpackSkipPixels);

    _gl.pixelStorei(3315, unpackSkipRows);

    _gl.pixelStorei(32877, unpackSkipImages); // Generate mipmaps only when copying level 0


    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };

  this.initTexture = function (texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };

  this.resetState = function () {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };

  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
      detail: this
    }));
  }
}

WebGLRenderer.prototype.isWebGLRenderer = true;

var WebGL1Renderer = /*#__PURE__*/function (_WebGLRenderer) {
  _inherits(WebGL1Renderer, _WebGLRenderer);

  var _super38 = _createSuper(WebGL1Renderer);

  function WebGL1Renderer() {
    _classCallCheck(this, WebGL1Renderer);

    return _super38.apply(this, arguments);
  }

  return _createClass(WebGL1Renderer);
}(WebGLRenderer);

exports.WebGL1Renderer = WebGL1Renderer;
WebGL1Renderer.prototype.isWebGL1Renderer = true;

var FogExp2 = /*#__PURE__*/function () {
  function FogExp2(color, density = 0.00025) {
    _classCallCheck(this, FogExp2);

    this.name = '';
    this.color = new Color(color);
    this.density = density;
  }

  _createClass(FogExp2, [{
    key: "clone",
    value: function clone() {
      return new FogExp2(this.color, this.density);
    }
  }, {
    key: "toJSON",
    value: function
      /* meta */
    toJSON() {
      return {
        type: 'FogExp2',
        color: this.color.getHex(),
        density: this.density
      };
    }
  }]);

  return FogExp2;
}();

exports.FogExp2 = FogExp2;
FogExp2.prototype.isFogExp2 = true;

var Fog = /*#__PURE__*/function () {
  function Fog(color, near = 1, far = 1000) {
    _classCallCheck(this, Fog);

    this.name = '';
    this.color = new Color(color);
    this.near = near;
    this.far = far;
  }

  _createClass(Fog, [{
    key: "clone",
    value: function clone() {
      return new Fog(this.color, this.near, this.far);
    }
  }, {
    key: "toJSON",
    value: function
      /* meta */
    toJSON() {
      return {
        type: 'Fog',
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      };
    }
  }]);

  return Fog;
}();

exports.Fog = Fog;
Fog.prototype.isFog = true;

var Scene = /*#__PURE__*/function (_Object3D5) {
  _inherits(Scene, _Object3D5);

  var _super39 = _createSuper(Scene);

  function Scene() {
    var _this29;

    _classCallCheck(this, Scene);

    _this29 = _super39.call(this);
    _this29.type = 'Scene';
    _this29.background = null;
    _this29.environment = null;
    _this29.fog = null;
    _this29.overrideMaterial = null;
    _this29.autoUpdate = true; // checked by the renderer

    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: _assertThisInitialized(_this29)
      }));
    }

    return _this29;
  }

  _createClass(Scene, [{
    key: "copy",
    value: function copy(source, recursive) {
      _get(_getPrototypeOf(Scene.prototype), "copy", this).call(this, source, recursive);

      if (source.background !== null) this.background = source.background.clone();
      if (source.environment !== null) this.environment = source.environment.clone();
      if (source.fog !== null) this.fog = source.fog.clone();
      if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
      this.autoUpdate = source.autoUpdate;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(Scene.prototype), "toJSON", this).call(this, meta);

      if (this.fog !== null) data.object.fog = this.fog.toJSON();
      return data;
    }
  }]);

  return Scene;
}(Object3D);

exports.Scene = Scene;
Scene.prototype.isScene = true;

var InterleavedBuffer = /*#__PURE__*/function () {
  function InterleavedBuffer(array, stride) {
    _classCallCheck(this, InterleavedBuffer);

    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.version = 0;
    this.uuid = generateUUID();
  }

  _createClass(InterleavedBuffer, [{
    key: "onUploadCallback",
    value: function onUploadCallback() {}
  }, {
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "setUsage",
    value: function setUsage(value) {
      this.usage = value;
      return this;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.array = new source.array.constructor(source.array);
      this.count = source.count;
      this.stride = source.stride;
      this.usage = source.usage;
      return this;
    }
  }, {
    key: "copyAt",
    value: function copyAt(index1, attribute, index2) {
      index1 *= this.stride;
      index2 *= attribute.stride;

      for (var _i152 = 0, l = this.stride; _i152 < l; _i152++) {
        this.array[index1 + _i152] = attribute.array[index2 + _i152];
      }

      return this;
    }
  }, {
    key: "set",
    value: function set(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    }
  }, {
    key: "clone",
    value: function clone(data) {
      if (data.arrayBuffers === undefined) {
        data.arrayBuffers = {};
      }

      if (this.array.buffer._uuid === undefined) {
        this.array.buffer._uuid = generateUUID();
      }

      if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
        data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
      }

      var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
      var ib = new this.constructor(array, this.stride);
      ib.setUsage(this.usage);
      return ib;
    }
  }, {
    key: "onUpload",
    value: function onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(data) {
      if (data.arrayBuffers === undefined) {
        data.arrayBuffers = {};
      } // generate UUID for array buffer if necessary


      if (this.array.buffer._uuid === undefined) {
        this.array.buffer._uuid = generateUUID();
      }

      if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
        data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
      } //


      return {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  }]);

  return InterleavedBuffer;
}();

exports.InterleavedBuffer = InterleavedBuffer;
InterleavedBuffer.prototype.isInterleavedBuffer = true;

var _vector$6 = /*@__PURE__*/new Vector3();

var InterleavedBufferAttribute = /*#__PURE__*/function () {
  function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized = false) {
    _classCallCheck(this, InterleavedBufferAttribute);

    this.name = '';
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }

  _createClass(InterleavedBufferAttribute, [{
    key: "count",
    get: function get() {
      return this.data.count;
    }
  }, {
    key: "array",
    get: function get() {
      return this.data.array;
    }
  }, {
    key: "needsUpdate",
    set: function set(value) {
      this.data.needsUpdate = value;
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      for (var _i153 = 0, l = this.data.count; _i153 < l; _i153++) {
        _vector$6.fromBufferAttribute(this, _i153);

        _vector$6.applyMatrix4(m);

        this.setXYZ(_i153, _vector$6.x, _vector$6.y, _vector$6.z);
      }

      return this;
    }
  }, {
    key: "applyNormalMatrix",
    value: function applyNormalMatrix(m) {
      for (var _i154 = 0, l = this.count; _i154 < l; _i154++) {
        _vector$6.fromBufferAttribute(this, _i154);

        _vector$6.applyNormalMatrix(m);

        this.setXYZ(_i154, _vector$6.x, _vector$6.y, _vector$6.z);
      }

      return this;
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(m) {
      for (var _i155 = 0, l = this.count; _i155 < l; _i155++) {
        _vector$6.fromBufferAttribute(this, _i155);

        _vector$6.transformDirection(m);

        this.setXYZ(_i155, _vector$6.x, _vector$6.y, _vector$6.z);
      }

      return this;
    }
  }, {
    key: "setX",
    value: function setX(index, x) {
      this.data.array[index * this.data.stride + this.offset] = x;
      return this;
    }
  }, {
    key: "setY",
    value: function setY(index, y) {
      this.data.array[index * this.data.stride + this.offset + 1] = y;
      return this;
    }
  }, {
    key: "setZ",
    value: function setZ(index, z) {
      this.data.array[index * this.data.stride + this.offset + 2] = z;
      return this;
    }
  }, {
    key: "setW",
    value: function setW(index, w) {
      this.data.array[index * this.data.stride + this.offset + 3] = w;
      return this;
    }
  }, {
    key: "getX",
    value: function getX(index) {
      return this.data.array[index * this.data.stride + this.offset];
    }
  }, {
    key: "getY",
    value: function getY(index) {
      return this.data.array[index * this.data.stride + this.offset + 1];
    }
  }, {
    key: "getZ",
    value: function getZ(index) {
      return this.data.array[index * this.data.stride + this.offset + 2];
    }
  }, {
    key: "getW",
    value: function getW(index) {
      return this.data.array[index * this.data.stride + this.offset + 3];
    }
  }, {
    key: "setXY",
    value: function setXY(index, x, y) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      return this;
    }
  }, {
    key: "setXYZ",
    value: function setXYZ(index, x, y, z) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      return this;
    }
  }, {
    key: "setXYZW",
    value: function setXYZW(index, x, y, z, w) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      this.data.array[index + 3] = w;
      return this;
    }
  }, {
    key: "clone",
    value: function clone(data) {
      if (data === undefined) {
        console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
        var array = [];

        for (var _i156 = 0; _i156 < this.count; _i156++) {
          var index = _i156 * this.data.stride + this.offset;

          for (var j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        }

        return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
      } else {
        if (data.interleavedBuffers === undefined) {
          data.interleavedBuffers = {};
        }

        if (data.interleavedBuffers[this.data.uuid] === undefined) {
          data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
        }

        return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(data) {
      if (data === undefined) {
        console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
        var array = [];

        for (var _i157 = 0; _i157 < this.count; _i157++) {
          var index = _i157 * this.data.stride + this.offset;

          for (var j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        } // deinterleave data and save it as an ordinary buffer attribute for now


        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: array,
          normalized: this.normalized
        };
      } else {
        // save as true interlaved attribtue
        if (data.interleavedBuffers === undefined) {
          data.interleavedBuffers = {};
        }

        if (data.interleavedBuffers[this.data.uuid] === undefined) {
          data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
        }

        return {
          isInterleavedBufferAttribute: true,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        };
      }
    }
  }]);

  return InterleavedBufferAttribute;
}();

exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;

var SpriteMaterial = /*#__PURE__*/function (_Material5) {
  _inherits(SpriteMaterial, _Material5);

  var _super40 = _createSuper(SpriteMaterial);

  function SpriteMaterial(parameters) {
    var _this30;

    _classCallCheck(this, SpriteMaterial);

    _this30 = _super40.call(this);
    _this30.type = 'SpriteMaterial';
    _this30.color = new Color(0xffffff);
    _this30.map = null;
    _this30.alphaMap = null;
    _this30.rotation = 0;
    _this30.sizeAttenuation = true;
    _this30.transparent = true;

    _this30.setValues(parameters);

    return _this30;
  }

  _createClass(SpriteMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(SpriteMaterial.prototype), "copy", this).call(this, source);

      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.rotation = source.rotation;
      this.sizeAttenuation = source.sizeAttenuation;
      return this;
    }
  }]);

  return SpriteMaterial;
}(Material);

exports.SpriteMaterial = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;

var _geometry;

var _intersectPoint = /*@__PURE__*/new Vector3();

var _worldScale = /*@__PURE__*/new Vector3();

var _mvPosition = /*@__PURE__*/new Vector3();

var _alignedPosition = /*@__PURE__*/new Vector2();

var _rotatedPosition = /*@__PURE__*/new Vector2();

var _viewWorldMatrix = /*@__PURE__*/new Matrix4();

var _vA = /*@__PURE__*/new Vector3();

var _vB = /*@__PURE__*/new Vector3();

var _vC = /*@__PURE__*/new Vector3();

var _uvA = /*@__PURE__*/new Vector2();

var _uvB = /*@__PURE__*/new Vector2();

var _uvC = /*@__PURE__*/new Vector2();

var Sprite = /*#__PURE__*/function (_Object3D6) {
  _inherits(Sprite, _Object3D6);

  var _super41 = _createSuper(Sprite);

  function Sprite(material) {
    var _this31;

    _classCallCheck(this, Sprite);

    _this31 = _super41.call(this);
    _this31.type = 'Sprite';

    if (_geometry === undefined) {
      _geometry = new BufferGeometry();
      var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
      var interleavedBuffer = new InterleavedBuffer(float32Array, 5);

      _geometry.setIndex([0, 1, 2, 0, 2, 3]);

      _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

      _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }

    _this31.geometry = _geometry;
    _this31.material = material !== undefined ? material : new SpriteMaterial();
    _this31.center = new Vector2(0.5, 0.5);
    return _this31;
  }

  _createClass(Sprite, [{
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      if (raycaster.camera === null) {
        console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
      }

      _worldScale.setFromMatrixScale(this.matrixWorld);

      _viewWorldMatrix.copy(raycaster.camera.matrixWorld);

      this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

      _mvPosition.setFromMatrixPosition(this.modelViewMatrix);

      if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
        _worldScale.multiplyScalar(-_mvPosition.z);
      }

      var rotation = this.material.rotation;
      var sin, cos;

      if (rotation !== 0) {
        cos = Math.cos(rotation);
        sin = Math.sin(rotation);
      }

      var center = this.center;
      transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

      _uvA.set(0, 0);

      _uvB.set(1, 0);

      _uvC.set(1, 1); // check first triangle


      var intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);

      if (intersect === null) {
        // check second triangle
        transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

        _uvB.set(0, 1);

        intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);

        if (intersect === null) {
          return;
        }
      }

      var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far) return;
      intersects.push({
        distance: distance,
        point: _intersectPoint.clone(),
        uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
        face: null,
        object: this
      });
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(Sprite.prototype), "copy", this).call(this, source);

      if (source.center !== undefined) this.center.copy(source.center);
      this.material = source.material;
      return this;
    }
  }]);

  return Sprite;
}(Object3D);

exports.Sprite = Sprite;
Sprite.prototype.isSprite = true;

function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  // compute position in camera space
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


  if (sin !== undefined) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }

  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y; // transform to world space

  vertexPosition.applyMatrix4(_viewWorldMatrix);
}

var _v1$2 = /*@__PURE__*/new Vector3();

var _v2$1 = /*@__PURE__*/new Vector3();

var LOD = /*#__PURE__*/function (_Object3D7) {
  _inherits(LOD, _Object3D7);

  var _super42 = _createSuper(LOD);

  function LOD() {
    var _this32;

    _classCallCheck(this, LOD);

    _this32 = _super42.call(this);
    _this32._currentLevel = 0;
    _this32.type = 'LOD';
    Object.defineProperties(_assertThisInitialized(_this32), {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    _this32.autoUpdate = true;
    return _this32;
  }

  _createClass(LOD, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(LOD.prototype), "copy", this).call(this, source, false);

      var levels = source.levels;

      for (var _i158 = 0, l = levels.length; _i158 < l; _i158++) {
        var level = levels[_i158];
        this.addLevel(level.object.clone(), level.distance);
      }

      this.autoUpdate = source.autoUpdate;
      return this;
    }
  }, {
    key: "addLevel",
    value: function addLevel(object, distance = 0) {
      distance = Math.abs(distance);
      var levels = this.levels;
      var l;

      for (l = 0; l < levels.length; l++) {
        if (distance < levels[l].distance) {
          break;
        }
      }

      levels.splice(l, 0, {
        distance: distance,
        object: object
      });
      this.add(object);
      return this;
    }
  }, {
    key: "getCurrentLevel",
    value: function getCurrentLevel() {
      return this._currentLevel;
    }
  }, {
    key: "getObjectForDistance",
    value: function getObjectForDistance(distance) {
      var levels = this.levels;

      if (levels.length > 0) {
        var _i159, l;

        for (_i159 = 1, l = levels.length; _i159 < l; _i159++) {
          if (distance < levels[_i159].distance) {
            break;
          }
        }

        return levels[_i159 - 1].object;
      }

      return null;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var levels = this.levels;

      if (levels.length > 0) {
        _v1$2.setFromMatrixPosition(this.matrixWorld);

        var distance = raycaster.ray.origin.distanceTo(_v1$2);
        this.getObjectForDistance(distance).raycast(raycaster, intersects);
      }
    }
  }, {
    key: "update",
    value: function update(camera) {
      var levels = this.levels;

      if (levels.length > 1) {
        _v1$2.setFromMatrixPosition(camera.matrixWorld);

        _v2$1.setFromMatrixPosition(this.matrixWorld);

        var distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
        levels[0].object.visible = true;

        var _i160, l;

        for (_i160 = 1, l = levels.length; _i160 < l; _i160++) {
          if (distance >= levels[_i160].distance) {
            levels[_i160 - 1].object.visible = false;
            levels[_i160].object.visible = true;
          } else {
            break;
          }
        }

        this._currentLevel = _i160 - 1;

        for (; _i160 < l; _i160++) {
          levels[_i160].object.visible = false;
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(LOD.prototype), "toJSON", this).call(this, meta);

      if (this.autoUpdate === false) data.object.autoUpdate = false;
      data.object.levels = [];
      var levels = this.levels;

      for (var _i161 = 0, l = levels.length; _i161 < l; _i161++) {
        var level = levels[_i161];
        data.object.levels.push({
          object: level.object.uuid,
          distance: level.distance
        });
      }

      return data;
    }
  }]);

  return LOD;
}(Object3D);

exports.LOD = LOD;

var _basePosition = /*@__PURE__*/new Vector3();

var _skinIndex = /*@__PURE__*/new Vector4();

var _skinWeight = /*@__PURE__*/new Vector4();

var _vector$5 = /*@__PURE__*/new Vector3();

var _matrix = /*@__PURE__*/new Matrix4();

var SkinnedMesh = /*#__PURE__*/function (_Mesh) {
  _inherits(SkinnedMesh, _Mesh);

  var _super43 = _createSuper(SkinnedMesh);

  function SkinnedMesh(geometry, material) {
    var _this33;

    _classCallCheck(this, SkinnedMesh);

    _this33 = _super43.call(this, geometry, material);
    _this33.type = 'SkinnedMesh';
    _this33.bindMode = 'attached';
    _this33.bindMatrix = new Matrix4();
    _this33.bindMatrixInverse = new Matrix4();
    return _this33;
  }

  _createClass(SkinnedMesh, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(SkinnedMesh.prototype), "copy", this).call(this, source);

      this.bindMode = source.bindMode;
      this.bindMatrix.copy(source.bindMatrix);
      this.bindMatrixInverse.copy(source.bindMatrixInverse);
      this.skeleton = source.skeleton;
      return this;
    }
  }, {
    key: "bind",
    value: function bind(skeleton, bindMatrix) {
      this.skeleton = skeleton;

      if (bindMatrix === undefined) {
        this.updateMatrixWorld(true);
        this.skeleton.calculateInverses();
        bindMatrix = this.matrixWorld;
      }

      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.copy(bindMatrix).invert();
    }
  }, {
    key: "pose",
    value: function pose() {
      this.skeleton.pose();
    }
  }, {
    key: "normalizeSkinWeights",
    value: function normalizeSkinWeights() {
      var vector = new Vector4();
      var skinWeight = this.geometry.attributes.skinWeight;

      for (var _i162 = 0, l = skinWeight.count; _i162 < l; _i162++) {
        vector.fromBufferAttribute(skinWeight, _i162);
        var scale = 1.0 / vector.manhattanLength();

        if (scale !== Infinity) {
          vector.multiplyScalar(scale);
        } else {
          vector.set(1, 0, 0, 0); // do something reasonable
        }

        skinWeight.setXYZW(_i162, vector.x, vector.y, vector.z, vector.w);
      }
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      _get(_getPrototypeOf(SkinnedMesh.prototype), "updateMatrixWorld", this).call(this, force);

      if (this.bindMode === 'attached') {
        this.bindMatrixInverse.copy(this.matrixWorld).invert();
      } else if (this.bindMode === 'detached') {
        this.bindMatrixInverse.copy(this.bindMatrix).invert();
      } else {
        console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
      }
    }
  }, {
    key: "boneTransform",
    value: function boneTransform(index, target) {
      var skeleton = this.skeleton;
      var geometry = this.geometry;

      _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);

      _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);

      _basePosition.copy(target).applyMatrix4(this.bindMatrix);

      target.set(0, 0, 0);

      for (var _i163 = 0; _i163 < 4; _i163++) {
        var weight = _skinWeight.getComponent(_i163);

        if (weight !== 0) {
          var boneIndex = _skinIndex.getComponent(_i163);

          _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);

          target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
        }
      }

      return target.applyMatrix4(this.bindMatrixInverse);
    }
  }]);

  return SkinnedMesh;
}(Mesh);

exports.SkinnedMesh = SkinnedMesh;
SkinnedMesh.prototype.isSkinnedMesh = true;

var Bone = /*#__PURE__*/function (_Object3D8) {
  _inherits(Bone, _Object3D8);

  var _super44 = _createSuper(Bone);

  function Bone() {
    var _this34;

    _classCallCheck(this, Bone);

    _this34 = _super44.call(this);
    _this34.type = 'Bone';
    return _this34;
  }

  return _createClass(Bone);
}(Object3D);

exports.Bone = Bone;
Bone.prototype.isBone = true;

var DataTexture = /*#__PURE__*/function (_Texture5) {
  _inherits(DataTexture, _Texture5);

  var _super45 = _createSuper(DataTexture);

  function DataTexture(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
    var _this35;

    _classCallCheck(this, DataTexture);

    _this35 = _super45.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    _this35.image = {
      data: data,
      width: width,
      height: height
    };
    _this35.generateMipmaps = false;
    _this35.flipY = false;
    _this35.unpackAlignment = 1;
    return _this35;
  }

  return _createClass(DataTexture);
}(Texture);

exports.DataTexture = DataTexture;
DataTexture.prototype.isDataTexture = true;

var _offsetMatrix = /*@__PURE__*/new Matrix4();

var _identityMatrix = /*@__PURE__*/new Matrix4();

var Skeleton = /*#__PURE__*/function () {
  function Skeleton(bones = [], boneInverses = []) {
    _classCallCheck(this, Skeleton);

    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }

  _createClass(Skeleton, [{
    key: "init",
    value: function init() {
      var bones = this.bones;
      var boneInverses = this.boneInverses;
      this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary

      if (boneInverses.length === 0) {
        this.calculateInverses();
      } else {
        // handle special case
        if (bones.length !== boneInverses.length) {
          console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
          this.boneInverses = [];

          for (var _i164 = 0, il = this.bones.length; _i164 < il; _i164++) {
            this.boneInverses.push(new Matrix4());
          }
        }
      }
    }
  }, {
    key: "calculateInverses",
    value: function calculateInverses() {
      this.boneInverses.length = 0;

      for (var _i165 = 0, il = this.bones.length; _i165 < il; _i165++) {
        var inverse = new Matrix4();

        if (this.bones[_i165]) {
          inverse.copy(this.bones[_i165].matrixWorld).invert();
        }

        this.boneInverses.push(inverse);
      }
    }
  }, {
    key: "pose",
    value: function pose() {
      // recover the bind-time world matrices
      for (var _i166 = 0, il = this.bones.length; _i166 < il; _i166++) {
        var bone = this.bones[_i166];

        if (bone) {
          bone.matrixWorld.copy(this.boneInverses[_i166]).invert();
        }
      } // compute the local matrices, positions, rotations and scales


      for (var _i167 = 0, _il12 = this.bones.length; _i167 < _il12; _i167++) {
        var _bone = this.bones[_i167];

        if (_bone) {
          if (_bone.parent && _bone.parent.isBone) {
            _bone.matrix.copy(_bone.parent.matrixWorld).invert();

            _bone.matrix.multiply(_bone.matrixWorld);
          } else {
            _bone.matrix.copy(_bone.matrixWorld);
          }

          _bone.matrix.decompose(_bone.position, _bone.quaternion, _bone.scale);
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      var bones = this.bones;
      var boneInverses = this.boneInverses;
      var boneMatrices = this.boneMatrices;
      var boneTexture = this.boneTexture; // flatten bone matrices to array

      for (var _i168 = 0, il = bones.length; _i168 < il; _i168++) {
        // compute the offset between the current and the original transform
        var matrix = bones[_i168] ? bones[_i168].matrixWorld : _identityMatrix;

        _offsetMatrix.multiplyMatrices(matrix, boneInverses[_i168]);

        _offsetMatrix.toArray(boneMatrices, _i168 * 16);
      }

      if (boneTexture !== null) {
        boneTexture.needsUpdate = true;
      }
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Skeleton(this.bones, this.boneInverses);
    }
  }, {
    key: "computeBoneTexture",
    value: function computeBoneTexture() {
      // layout (1 matrix = 4 pixels)
      //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
      //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
      //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
      //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
      //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
      var size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix

      size = ceilPowerOfTwo(size);
      size = Math.max(size, 4);
      var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

      boneMatrices.set(this.boneMatrices); // copy current values

      var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
      boneTexture.needsUpdate = true;
      this.boneMatrices = boneMatrices;
      this.boneTexture = boneTexture;
      this.boneTextureSize = size;
      return this;
    }
  }, {
    key: "getBoneByName",
    value: function getBoneByName(name) {
      for (var _i169 = 0, il = this.bones.length; _i169 < il; _i169++) {
        var bone = this.bones[_i169];

        if (bone.name === name) {
          return bone;
        }
      }

      return undefined;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.boneTexture !== null) {
        this.boneTexture.dispose();
        this.boneTexture = null;
      }
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json, bones) {
      this.uuid = json.uuid;

      for (var _i170 = 0, l = json.bones.length; _i170 < l; _i170++) {
        var uuid = json.bones[_i170];
        var bone = bones[uuid];

        if (bone === undefined) {
          console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
          bone = new Bone();
        }

        this.bones.push(bone);
        this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[_i170]));
      }

      this.init();
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = {
        metadata: {
          version: 4.5,
          type: 'Skeleton',
          generator: 'Skeleton.toJSON'
        },
        bones: [],
        boneInverses: []
      };
      data.uuid = this.uuid;
      var bones = this.bones;
      var boneInverses = this.boneInverses;

      for (var _i171 = 0, l = bones.length; _i171 < l; _i171++) {
        var bone = bones[_i171];
        data.bones.push(bone.uuid);
        var boneInverse = boneInverses[_i171];
        data.boneInverses.push(boneInverse.toArray());
      }

      return data;
    }
  }]);

  return Skeleton;
}();

exports.Skeleton = Skeleton;

var InstancedBufferAttribute = /*#__PURE__*/function (_BufferAttribute11) {
  _inherits(InstancedBufferAttribute, _BufferAttribute11);

  var _super46 = _createSuper(InstancedBufferAttribute);

  function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute = 1) {
    var _this36;

    _classCallCheck(this, InstancedBufferAttribute);

    if (typeof normalized === 'number') {
      meshPerAttribute = normalized;
      normalized = false;
      console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
    }

    _this36 = _super46.call(this, array, itemSize, normalized);
    _this36.meshPerAttribute = meshPerAttribute;
    return _this36;
  }

  _createClass(InstancedBufferAttribute, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(InstancedBufferAttribute.prototype), "copy", this).call(this, source);

      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(InstancedBufferAttribute.prototype), "toJSON", this).call(this);

      data.meshPerAttribute = this.meshPerAttribute;
      data.isInstancedBufferAttribute = true;
      return data;
    }
  }]);

  return InstancedBufferAttribute;
}(BufferAttribute);

exports.InstancedBufferAttribute = InstancedBufferAttribute;
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

var _instanceLocalMatrix = /*@__PURE__*/new Matrix4();

var _instanceWorldMatrix = /*@__PURE__*/new Matrix4();

var _instanceIntersects = [];

var _mesh = /*@__PURE__*/new Mesh();

var InstancedMesh = /*#__PURE__*/function (_Mesh2) {
  _inherits(InstancedMesh, _Mesh2);

  var _super47 = _createSuper(InstancedMesh);

  function InstancedMesh(geometry, material, count) {
    var _this37;

    _classCallCheck(this, InstancedMesh);

    _this37 = _super47.call(this, geometry, material);
    _this37.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    _this37.instanceColor = null;
    _this37.count = count;
    _this37.frustumCulled = false;
    return _this37;
  }

  _createClass(InstancedMesh, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(InstancedMesh.prototype), "copy", this).call(this, source);

      this.instanceMatrix.copy(source.instanceMatrix);
      if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
      this.count = source.count;
      return this;
    }
  }, {
    key: "getColorAt",
    value: function getColorAt(index, color) {
      color.fromArray(this.instanceColor.array, index * 3);
    }
  }, {
    key: "getMatrixAt",
    value: function getMatrixAt(index, matrix) {
      matrix.fromArray(this.instanceMatrix.array, index * 16);
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var matrixWorld = this.matrixWorld;
      var raycastTimes = this.count;
      _mesh.geometry = this.geometry;
      _mesh.material = this.material;
      if (_mesh.material === undefined) return;

      for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
        // calculate the world matrix for each instance
        this.getMatrixAt(instanceId, _instanceLocalMatrix);

        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance


        _mesh.matrixWorld = _instanceWorldMatrix;

        _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast


        for (var _i172 = 0, l = _instanceIntersects.length; _i172 < l; _i172++) {
          var intersect = _instanceIntersects[_i172];
          intersect.instanceId = instanceId;
          intersect.object = this;
          intersects.push(intersect);
        }

        _instanceIntersects.length = 0;
      }
    }
  }, {
    key: "setColorAt",
    value: function setColorAt(index, color) {
      if (this.instanceColor === null) {
        this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
      }

      color.toArray(this.instanceColor.array, index * 3);
    }
  }, {
    key: "setMatrixAt",
    value: function setMatrixAt(index, matrix) {
      matrix.toArray(this.instanceMatrix.array, index * 16);
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {}
  }, {
    key: "dispose",
    value: function dispose() {
      this.dispatchEvent({
        type: 'dispose'
      });
    }
  }]);

  return InstancedMesh;
}(Mesh);

exports.InstancedMesh = InstancedMesh;
InstancedMesh.prototype.isInstancedMesh = true;

var LineBasicMaterial = /*#__PURE__*/function (_Material6) {
  _inherits(LineBasicMaterial, _Material6);

  var _super48 = _createSuper(LineBasicMaterial);

  function LineBasicMaterial(parameters) {
    var _this38;

    _classCallCheck(this, LineBasicMaterial);

    _this38 = _super48.call(this);
    _this38.type = 'LineBasicMaterial';
    _this38.color = new Color(0xffffff);
    _this38.linewidth = 1;
    _this38.linecap = 'round';
    _this38.linejoin = 'round';

    _this38.setValues(parameters);

    return _this38;
  }

  _createClass(LineBasicMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(LineBasicMaterial.prototype), "copy", this).call(this, source);

      this.color.copy(source.color);
      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;
      return this;
    }
  }]);

  return LineBasicMaterial;
}(Material);

exports.LineBasicMaterial = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;

var _start$1 = /*@__PURE__*/new Vector3();

var _end$1 = /*@__PURE__*/new Vector3();

var _inverseMatrix$1 = /*@__PURE__*/new Matrix4();

var _ray$1 = /*@__PURE__*/new Ray();

var _sphere$1 = /*@__PURE__*/new Sphere();

var Line = /*#__PURE__*/function (_Object3D9) {
  _inherits(Line, _Object3D9);

  var _super49 = _createSuper(Line);

  function Line(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    var _this39;

    _classCallCheck(this, Line);

    _this39 = _super49.call(this);
    _this39.type = 'Line';
    _this39.geometry = geometry;
    _this39.material = material;

    _this39.updateMorphTargets();

    return _this39;
  }

  _createClass(Line, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(Line.prototype), "copy", this).call(this, source);

      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    }
  }, {
    key: "computeLineDistances",
    value: function computeLineDistances() {
      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {
        // we assume non-indexed geometry
        if (geometry.index === null) {
          var positionAttribute = geometry.attributes.position;
          var lineDistances = [0];

          for (var _i173 = 1, l = positionAttribute.count; _i173 < l; _i173++) {
            _start$1.fromBufferAttribute(positionAttribute, _i173 - 1);

            _end$1.fromBufferAttribute(positionAttribute, _i173);

            lineDistances[_i173] = lineDistances[_i173 - 1];
            lineDistances[_i173] += _start$1.distanceTo(_end$1);
          }

          geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        }
      } else if (geometry.isGeometry) {
        console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }

      return this;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld;
      var threshold = raycaster.params.Line.threshold;
      var drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

      _sphere$1.copy(geometry.boundingSphere);

      _sphere$1.applyMatrix4(matrixWorld);

      _sphere$1.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //

      _inverseMatrix$1.copy(matrixWorld).invert();

      _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localThresholdSq = localThreshold * localThreshold;
      var vStart = new Vector3();
      var vEnd = new Vector3();
      var interSegment = new Vector3();
      var interRay = new Vector3();
      var step = this.isLineSegments ? 2 : 1;

      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positionAttribute = attributes.position;

        if (index !== null) {
          var start = Math.max(0, drawRange.start);
          var end = Math.min(index.count, drawRange.start + drawRange.count);

          for (var _i174 = start, l = end - 1; _i174 < l; _i174 += step) {
            var a = index.getX(_i174);
            var b = index.getX(_i174 + 1);
            vStart.fromBufferAttribute(positionAttribute, a);
            vEnd.fromBufferAttribute(positionAttribute, b);

            var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

            if (distSq > localThresholdSq) continue;
            interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far) continue;
            intersects.push({
              distance: distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: _i174,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          var _start6 = Math.max(0, drawRange.start);

          var _end5 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

          for (var _i175 = _start6, _l7 = _end5 - 1; _i175 < _l7; _i175 += step) {
            vStart.fromBufferAttribute(positionAttribute, _i175);
            vEnd.fromBufferAttribute(positionAttribute, _i175 + 1);

            var _distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

            if (_distSq > localThresholdSq) continue;
            interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

            var _distance = raycaster.ray.origin.distanceTo(interRay);

            if (_distance < raycaster.near || _distance > raycaster.far) continue;
            intersects.push({
              distance: _distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: _i175,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else if (geometry.isGeometry) {
        console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {
        var morphAttributes = geometry.morphAttributes;
        var keys = Object.keys(morphAttributes);

        if (keys.length > 0) {
          var morphAttribute = morphAttributes[keys[0]];

          if (morphAttribute !== undefined) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};

            for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
              var name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        var morphTargets = geometry.morphTargets;

        if (morphTargets !== undefined && morphTargets.length > 0) {
          console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
      }
    }
  }]);

  return Line;
}(Object3D);

exports.Line = Line;
Line.prototype.isLine = true;

var _start = /*@__PURE__*/new Vector3();

var _end = /*@__PURE__*/new Vector3();

var LineSegments = /*#__PURE__*/function (_Line) {
  _inherits(LineSegments, _Line);

  var _super50 = _createSuper(LineSegments);

  function LineSegments(geometry, material) {
    var _this40;

    _classCallCheck(this, LineSegments);

    _this40 = _super50.call(this, geometry, material);
    _this40.type = 'LineSegments';
    return _this40;
  }

  _createClass(LineSegments, [{
    key: "computeLineDistances",
    value: function computeLineDistances() {
      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {
        // we assume non-indexed geometry
        if (geometry.index === null) {
          var positionAttribute = geometry.attributes.position;
          var lineDistances = [];

          for (var _i176 = 0, l = positionAttribute.count; _i176 < l; _i176 += 2) {
            _start.fromBufferAttribute(positionAttribute, _i176);

            _end.fromBufferAttribute(positionAttribute, _i176 + 1);

            lineDistances[_i176] = _i176 === 0 ? 0 : lineDistances[_i176 - 1];
            lineDistances[_i176 + 1] = lineDistances[_i176] + _start.distanceTo(_end);
          }

          geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        }
      } else if (geometry.isGeometry) {
        console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }

      return this;
    }
  }]);

  return LineSegments;
}(Line);

exports.LineSegments = LineSegments;
LineSegments.prototype.isLineSegments = true;

var LineLoop = /*#__PURE__*/function (_Line2) {
  _inherits(LineLoop, _Line2);

  var _super51 = _createSuper(LineLoop);

  function LineLoop(geometry, material) {
    var _this41;

    _classCallCheck(this, LineLoop);

    _this41 = _super51.call(this, geometry, material);
    _this41.type = 'LineLoop';
    return _this41;
  }

  return _createClass(LineLoop);
}(Line);

exports.LineLoop = LineLoop;
LineLoop.prototype.isLineLoop = true;

var PointsMaterial = /*#__PURE__*/function (_Material7) {
  _inherits(PointsMaterial, _Material7);

  var _super52 = _createSuper(PointsMaterial);

  function PointsMaterial(parameters) {
    var _this42;

    _classCallCheck(this, PointsMaterial);

    _this42 = _super52.call(this);
    _this42.type = 'PointsMaterial';
    _this42.color = new Color(0xffffff);
    _this42.map = null;
    _this42.alphaMap = null;
    _this42.size = 1;
    _this42.sizeAttenuation = true;

    _this42.setValues(parameters);

    return _this42;
  }

  _createClass(PointsMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(PointsMaterial.prototype), "copy", this).call(this, source);

      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;
      return this;
    }
  }]);

  return PointsMaterial;
}(Material);

exports.PointsMaterial = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;

var _inverseMatrix = /*@__PURE__*/new Matrix4();

var _ray = /*@__PURE__*/new Ray();

var _sphere = /*@__PURE__*/new Sphere();

var _position$2 = /*@__PURE__*/new Vector3();

var Points = /*#__PURE__*/function (_Object3D10) {
  _inherits(Points, _Object3D10);

  var _super53 = _createSuper(Points);

  function Points(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    var _this43;

    _classCallCheck(this, Points);

    _this43 = _super53.call(this);
    _this43.type = 'Points';
    _this43.geometry = geometry;
    _this43.material = material;

    _this43.updateMorphTargets();

    return _this43;
  }

  _createClass(Points, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(Points.prototype), "copy", this).call(this, source);

      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    }
  }, {
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var geometry = this.geometry;
      var matrixWorld = this.matrixWorld;
      var threshold = raycaster.params.Points.threshold;
      var drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

      _sphere.copy(geometry.boundingSphere);

      _sphere.applyMatrix4(matrixWorld);

      _sphere.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

      _inverseMatrix.copy(matrixWorld).invert();

      _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localThresholdSq = localThreshold * localThreshold;

      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positionAttribute = attributes.position;

        if (index !== null) {
          var start = Math.max(0, drawRange.start);
          var end = Math.min(index.count, drawRange.start + drawRange.count);

          for (var _i177 = start, il = end; _i177 < il; _i177++) {
            var a = index.getX(_i177);

            _position$2.fromBufferAttribute(positionAttribute, a);

            testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
          }
        } else {
          var _start7 = Math.max(0, drawRange.start);

          var _end6 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

          for (var _i178 = _start7, l = _end6; _i178 < l; _i178++) {
            _position$2.fromBufferAttribute(positionAttribute, _i178);

            testPoint(_position$2, _i178, localThresholdSq, matrixWorld, raycaster, intersects, this);
          }
        }
      } else {
        console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }, {
    key: "updateMorphTargets",
    value: function updateMorphTargets() {
      var geometry = this.geometry;

      if (geometry.isBufferGeometry) {
        var morphAttributes = geometry.morphAttributes;
        var keys = Object.keys(morphAttributes);

        if (keys.length > 0) {
          var morphAttribute = morphAttributes[keys[0]];

          if (morphAttribute !== undefined) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};

            for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
              var name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        var morphTargets = geometry.morphTargets;

        if (morphTargets !== undefined && morphTargets.length > 0) {
          console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
      }
    }
  }]);

  return Points;
}(Object3D);

exports.Points = Points;
Points.prototype.isPoints = true;

function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
  var rayPointDistanceSq = _ray.distanceSqToPoint(point);

  if (rayPointDistanceSq < localThresholdSq) {
    var intersectPoint = new Vector3();

    _ray.closestPointToPoint(point, intersectPoint);

    intersectPoint.applyMatrix4(matrixWorld);
    var distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index,
      face: null,
      object: object
    });
  }
}

var VideoTexture = /*#__PURE__*/function (_Texture6) {
  _inherits(VideoTexture, _Texture6);

  var _super54 = _createSuper(VideoTexture);

  function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    var _this44;

    _classCallCheck(this, VideoTexture);

    _this44 = _super54.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    _this44.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
    _this44.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    _this44.generateMipmaps = false;

    var scope = _assertThisInitialized(_this44);

    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }

    if ('requestVideoFrameCallback' in video) {
      video.requestVideoFrameCallback(updateVideo);
    }

    return _this44;
  }

  _createClass(VideoTexture, [{
    key: "clone",
    value: function clone() {
      return new this.constructor(this.image).copy(this);
    }
  }, {
    key: "update",
    value: function update() {
      var video = this.image;
      var hasVideoFrameCallback = ('requestVideoFrameCallback' in video);

      if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
        this.needsUpdate = true;
      }
    }
  }]);

  return VideoTexture;
}(Texture);

exports.VideoTexture = VideoTexture;
VideoTexture.prototype.isVideoTexture = true;

var FramebufferTexture = /*#__PURE__*/function (_Texture7) {
  _inherits(FramebufferTexture, _Texture7);

  var _super55 = _createSuper(FramebufferTexture);

  function FramebufferTexture(width, height, format) {
    var _this45;

    _classCallCheck(this, FramebufferTexture);

    _this45 = _super55.call(this, {
      width: width,
      height: height
    });
    _this45.format = format;
    _this45.magFilter = NearestFilter;
    _this45.minFilter = NearestFilter;
    _this45.generateMipmaps = false;
    _this45.needsUpdate = true;
    return _this45;
  }

  return _createClass(FramebufferTexture);
}(Texture);

exports.FramebufferTexture = FramebufferTexture;
FramebufferTexture.prototype.isFramebufferTexture = true;

var CompressedTexture = /*#__PURE__*/function (_Texture8) {
  _inherits(CompressedTexture, _Texture8);

  var _super56 = _createSuper(CompressedTexture);

  function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    var _this46;

    _classCallCheck(this, CompressedTexture);

    _this46 = _super56.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    _this46.image = {
      width: width,
      height: height
    };
    _this46.mipmaps = mipmaps; // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )

    _this46.flipY = false; // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files

    _this46.generateMipmaps = false;
    return _this46;
  }

  return _createClass(CompressedTexture);
}(Texture);

exports.CompressedTexture = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;

var CanvasTexture = /*#__PURE__*/function (_Texture9) {
  _inherits(CanvasTexture, _Texture9);

  var _super57 = _createSuper(CanvasTexture);

  function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    var _this47;

    _classCallCheck(this, CanvasTexture);

    _this47 = _super57.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    _this47.needsUpdate = true;
    return _this47;
  }

  return _createClass(CanvasTexture);
}(Texture);

exports.CanvasTexture = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

var Curve = /*#__PURE__*/function () {
  function Curve() {
    _classCallCheck(this, Curve);

    this.type = 'Curve';
    this.arcLengthDivisions = 200;
  } // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]


  _createClass(Curve, [{
    key: "getPoint",
    value: function
      /* t, optionalTarget */
    getPoint() {
      console.warn('THREE.Curve: .getPoint() not implemented.');
      return null;
    } // Get point at relative position in curve according to arc length
    // - u [0 .. 1]

  }, {
    key: "getPointAt",
    value: function getPointAt(u, optionalTarget) {
      var t = this.getUtoTmapping(u);
      return this.getPoint(t, optionalTarget);
    } // Get sequence of points using getPoint( t )

  }, {
    key: "getPoints",
    value: function getPoints(divisions = 5) {
      var points = [];

      for (var d = 0; d <= divisions; d++) {
        points.push(this.getPoint(d / divisions));
      }

      return points;
    } // Get sequence of points using getPointAt( u )

  }, {
    key: "getSpacedPoints",
    value: function getSpacedPoints(divisions = 5) {
      var points = [];

      for (var d = 0; d <= divisions; d++) {
        points.push(this.getPointAt(d / divisions));
      }

      return points;
    } // Get total curve arc length

  }, {
    key: "getLength",
    value: function getLength() {
      var lengths = this.getLengths();
      return lengths[lengths.length - 1];
    } // Get list of cumulative segment lengths

  }, {
    key: "getLengths",
    value: function getLengths(divisions = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
        return this.cacheArcLengths;
      }

      this.needsUpdate = false;
      var cache = [];
      var current,
          last = this.getPoint(0);
      var sum = 0;
      cache.push(0);

      for (var p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
      }

      this.cacheArcLengths = cache;
      return cache; // { sums: cache, sum: sum }; Sum is in the last element.
    }
  }, {
    key: "updateArcLengths",
    value: function updateArcLengths() {
      this.needsUpdate = true;
      this.getLengths();
    } // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

  }, {
    key: "getUtoTmapping",
    value: function getUtoTmapping(u, distance) {
      var arcLengths = this.getLengths();
      var i = 0;
      var il = arcLengths.length;
      var targetArcLength; // The targeted u distance value to get

      if (distance) {
        targetArcLength = distance;
      } else {
        targetArcLength = u * arcLengths[il - 1];
      } // binary search for the index with largest value smaller than target u distance


      var low = 0,
          high = il - 1,
          comparison;

      while (low <= high) {
        i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

        comparison = arcLengths[i] - targetArcLength;

        if (comparison < 0) {
          low = i + 1;
        } else if (comparison > 0) {
          high = i - 1;
        } else {
          high = i;
          break; // DONE
        }
      }

      i = high;

      if (arcLengths[i] === targetArcLength) {
        return i / (il - 1);
      } // we could get finer grain at lengths, or use simple interpolation between two points


      var lengthBefore = arcLengths[i];
      var lengthAfter = arcLengths[i + 1];
      var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

      var t = (i + segmentFraction) / (il - 1);
      return t;
    } // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation

  }, {
    key: "getTangent",
    value: function getTangent(t, optionalTarget) {
      var delta = 0.0001;
      var t1 = t - delta;
      var t2 = t + delta; // Capping in case of danger

      if (t1 < 0) t1 = 0;
      if (t2 > 1) t2 = 1;
      var pt1 = this.getPoint(t1);
      var pt2 = this.getPoint(t2);
      var tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
      tangent.copy(pt2).sub(pt1).normalize();
      return tangent;
    }
  }, {
    key: "getTangentAt",
    value: function getTangentAt(u, optionalTarget) {
      var t = this.getUtoTmapping(u);
      return this.getTangent(t, optionalTarget);
    }
  }, {
    key: "computeFrenetFrames",
    value: function computeFrenetFrames(segments, closed) {
      // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
      var normal = new Vector3();
      var tangents = [];
      var normals = [];
      var binormals = [];
      var vec = new Vector3();
      var mat = new Matrix4(); // compute the tangent vectors for each segment on the curve

      for (var _i179 = 0; _i179 <= segments; _i179++) {
        var u = _i179 / segments;
        tangents[_i179] = this.getTangentAt(u, new Vector3());
      } // select an initial normal vector perpendicular to the first tangent vector,
      // and in the direction of the minimum tangent xyz component


      normals[0] = new Vector3();
      binormals[0] = new Vector3();
      var min = Number.MAX_VALUE;
      var tx = Math.abs(tangents[0].x);
      var ty = Math.abs(tangents[0].y);
      var tz = Math.abs(tangents[0].z);

      if (tx <= min) {
        min = tx;
        normal.set(1, 0, 0);
      }

      if (ty <= min) {
        min = ty;
        normal.set(0, 1, 0);
      }

      if (tz <= min) {
        normal.set(0, 0, 1);
      }

      vec.crossVectors(tangents[0], normal).normalize();
      normals[0].crossVectors(tangents[0], vec);
      binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

      for (var _i180 = 1; _i180 <= segments; _i180++) {
        normals[_i180] = normals[_i180 - 1].clone();
        binormals[_i180] = binormals[_i180 - 1].clone();
        vec.crossVectors(tangents[_i180 - 1], tangents[_i180]);

        if (vec.length() > Number.EPSILON) {
          vec.normalize();
          var theta = Math.acos(clamp(tangents[_i180 - 1].dot(tangents[_i180]), -1, 1)); // clamp for floating pt errors

          normals[_i180].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }

        binormals[_i180].crossVectors(tangents[_i180], normals[_i180]);
      } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


      if (closed === true) {
        var _theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));

        _theta /= segments;

        if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
          _theta = -_theta;
        }

        for (var _i181 = 1; _i181 <= segments; _i181++) {
          // twist a little...
          normals[_i181].applyMatrix4(mat.makeRotationAxis(tangents[_i181], _theta * _i181));

          binormals[_i181].crossVectors(tangents[_i181], normals[_i181]);
        }
      }

      return {
        tangents: tangents,
        normals: normals,
        binormals: binormals
      };
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.arcLengthDivisions = source.arcLengthDivisions;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = {
        metadata: {
          version: 4.5,
          type: 'Curve',
          generator: 'Curve.toJSON'
        }
      };
      data.arcLengthDivisions = this.arcLengthDivisions;
      data.type = this.type;
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      this.arcLengthDivisions = json.arcLengthDivisions;
      return this;
    }
  }]);

  return Curve;
}();

exports.Curve = Curve;

var EllipseCurve = /*#__PURE__*/function (_Curve) {
  _inherits(EllipseCurve, _Curve);

  var _super58 = _createSuper(EllipseCurve);

  function EllipseCurve(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    var _this48;

    _classCallCheck(this, EllipseCurve);

    _this48 = _super58.call(this);
    _this48.type = 'EllipseCurve';
    _this48.aX = aX;
    _this48.aY = aY;
    _this48.xRadius = xRadius;
    _this48.yRadius = yRadius;
    _this48.aStartAngle = aStartAngle;
    _this48.aEndAngle = aEndAngle;
    _this48.aClockwise = aClockwise;
    _this48.aRotation = aRotation;
    return _this48;
  }

  _createClass(EllipseCurve, [{
    key: "getPoint",
    value: function getPoint(t, optionalTarget) {
      var point = optionalTarget || new Vector2();
      var twoPi = Math.PI * 2;
      var deltaAngle = this.aEndAngle - this.aStartAngle;
      var samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

      while (deltaAngle < 0) {
        deltaAngle += twoPi;
      }

      while (deltaAngle > twoPi) {
        deltaAngle -= twoPi;
      }

      if (deltaAngle < Number.EPSILON) {
        if (samePoints) {
          deltaAngle = 0;
        } else {
          deltaAngle = twoPi;
        }
      }

      if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) {
          deltaAngle = -twoPi;
        } else {
          deltaAngle = deltaAngle - twoPi;
        }
      }

      var angle = this.aStartAngle + t * deltaAngle;
      var x = this.aX + this.xRadius * Math.cos(angle);
      var y = this.aY + this.yRadius * Math.sin(angle);

      if (this.aRotation !== 0) {
        var cos = Math.cos(this.aRotation);
        var sin = Math.sin(this.aRotation);
        var tx = x - this.aX;
        var ty = y - this.aY; // Rotate the point about the center of the ellipse.

        x = tx * cos - ty * sin + this.aX;
        y = tx * sin + ty * cos + this.aY;
      }

      return point.set(x, y);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(EllipseCurve.prototype), "copy", this).call(this, source);

      this.aX = source.aX;
      this.aY = source.aY;
      this.xRadius = source.xRadius;
      this.yRadius = source.yRadius;
      this.aStartAngle = source.aStartAngle;
      this.aEndAngle = source.aEndAngle;
      this.aClockwise = source.aClockwise;
      this.aRotation = source.aRotation;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(EllipseCurve.prototype), "toJSON", this).call(this);

      data.aX = this.aX;
      data.aY = this.aY;
      data.xRadius = this.xRadius;
      data.yRadius = this.yRadius;
      data.aStartAngle = this.aStartAngle;
      data.aEndAngle = this.aEndAngle;
      data.aClockwise = this.aClockwise;
      data.aRotation = this.aRotation;
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(EllipseCurve.prototype), "fromJSON", this).call(this, json);

      this.aX = json.aX;
      this.aY = json.aY;
      this.xRadius = json.xRadius;
      this.yRadius = json.yRadius;
      this.aStartAngle = json.aStartAngle;
      this.aEndAngle = json.aEndAngle;
      this.aClockwise = json.aClockwise;
      this.aRotation = json.aRotation;
      return this;
    }
  }]);

  return EllipseCurve;
}(Curve);

exports.EllipseCurve = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;

var ArcCurve = /*#__PURE__*/function (_EllipseCurve) {
  _inherits(ArcCurve, _EllipseCurve);

  var _super59 = _createSuper(ArcCurve);

  function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    var _this49;

    _classCallCheck(this, ArcCurve);

    _this49 = _super59.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    _this49.type = 'ArcCurve';
    return _this49;
  }

  return _createClass(ArcCurve);
}(EllipseCurve);

exports.ArcCurve = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {
  var c0 = 0,
      c1 = 0,
      c2 = 0,
      c3 = 0;
  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */

  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }

  return {
    initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
      // compute tangents when parameterized in [t1,t2]
      var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function calc(t) {
      var t2 = t * t;
      var t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
} //


var tmp = new Vector3();
var px = new CubicPoly(),
    py = new CubicPoly(),
    pz = new CubicPoly();

var CatmullRomCurve3 = /*#__PURE__*/function (_Curve2) {
  _inherits(CatmullRomCurve3, _Curve2);

  var _super60 = _createSuper(CatmullRomCurve3);

  function CatmullRomCurve3(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
    var _this50;

    _classCallCheck(this, CatmullRomCurve3);

    _this50 = _super60.call(this);
    _this50.type = 'CatmullRomCurve3';
    _this50.points = points;
    _this50.closed = closed;
    _this50.curveType = curveType;
    _this50.tension = tension;
    return _this50;
  }

  _createClass(CatmullRomCurve3, [{
    key: "getPoint",
    value: function getPoint(t, optionalTarget = new Vector3()) {
      var point = optionalTarget;
      var points = this.points;
      var l = points.length;
      var p = (l - (this.closed ? 0 : 1)) * t;
      var intPoint = Math.floor(p);
      var weight = p - intPoint;

      if (this.closed) {
        intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
      } else if (weight === 0 && intPoint === l - 1) {
        intPoint = l - 2;
        weight = 1;
      }

      var p0, p3; // 4 points (p1 & p2 defined below)

      if (this.closed || intPoint > 0) {
        p0 = points[(intPoint - 1) % l];
      } else {
        // extrapolate first point
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
      }

      var p1 = points[intPoint % l];
      var p2 = points[(intPoint + 1) % l];

      if (this.closed || intPoint + 2 < l) {
        p3 = points[(intPoint + 2) % l];
      } else {
        // extrapolate last point
        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
        p3 = tmp;
      }

      if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
        // init Centripetal / Chordal Catmull-Rom
        var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
        var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        var dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

        if (dt1 < 1e-4) dt1 = 1.0;
        if (dt0 < 1e-4) dt0 = dt1;
        if (dt2 < 1e-4) dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
      } else if (this.curveType === 'catmullrom') {
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
      }

      point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(CatmullRomCurve3.prototype), "copy", this).call(this, source);

      this.points = [];

      for (var _i182 = 0, l = source.points.length; _i182 < l; _i182++) {
        var point = source.points[_i182];
        this.points.push(point.clone());
      }

      this.closed = source.closed;
      this.curveType = source.curveType;
      this.tension = source.tension;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(CatmullRomCurve3.prototype), "toJSON", this).call(this);

      data.points = [];

      for (var _i183 = 0, l = this.points.length; _i183 < l; _i183++) {
        var point = this.points[_i183];
        data.points.push(point.toArray());
      }

      data.closed = this.closed;
      data.curveType = this.curveType;
      data.tension = this.tension;
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(CatmullRomCurve3.prototype), "fromJSON", this).call(this, json);

      this.points = [];

      for (var _i184 = 0, l = json.points.length; _i184 < l; _i184++) {
        var point = json.points[_i184];
        this.points.push(new Vector3().fromArray(point));
      }

      this.closed = json.closed;
      this.curveType = json.curveType;
      this.tension = json.tension;
      return this;
    }
  }]);

  return CatmullRomCurve3;
}(Curve);

exports.CatmullRomCurve3 = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */

function CatmullRom(t, p0, p1, p2, p3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  var t2 = t * t;
  var t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
} //


function QuadraticBezierP0(t, p) {
  var k = 1 - t;
  return k * k * p;
}

function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}

function QuadraticBezierP2(t, p) {
  return t * t * p;
}

function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
} //


function CubicBezierP0(t, p) {
  var k = 1 - t;
  return k * k * k * p;
}

function CubicBezierP1(t, p) {
  var k = 1 - t;
  return 3 * k * k * t * p;
}

function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}

function CubicBezierP3(t, p) {
  return t * t * t * p;
}

function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}

var CubicBezierCurve = /*#__PURE__*/function (_Curve3) {
  _inherits(CubicBezierCurve, _Curve3);

  var _super61 = _createSuper(CubicBezierCurve);

  function CubicBezierCurve(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    var _this51;

    _classCallCheck(this, CubicBezierCurve);

    _this51 = _super61.call(this);
    _this51.type = 'CubicBezierCurve';
    _this51.v0 = v0;
    _this51.v1 = v1;
    _this51.v2 = v2;
    _this51.v3 = v3;
    return _this51;
  }

  _createClass(CubicBezierCurve, [{
    key: "getPoint",
    value: function getPoint(t, optionalTarget = new Vector2()) {
      var point = optionalTarget;
      var v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;
      point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(CubicBezierCurve.prototype), "copy", this).call(this, source);

      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(CubicBezierCurve.prototype), "toJSON", this).call(this);

      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(CubicBezierCurve.prototype), "fromJSON", this).call(this, json);

      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    }
  }]);

  return CubicBezierCurve;
}(Curve);

exports.CubicBezierCurve = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;

var CubicBezierCurve3 = /*#__PURE__*/function (_Curve4) {
  _inherits(CubicBezierCurve3, _Curve4);

  var _super62 = _createSuper(CubicBezierCurve3);

  function CubicBezierCurve3(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    var _this52;

    _classCallCheck(this, CubicBezierCurve3);

    _this52 = _super62.call(this);
    _this52.type = 'CubicBezierCurve3';
    _this52.v0 = v0;
    _this52.v1 = v1;
    _this52.v2 = v2;
    _this52.v3 = v3;
    return _this52;
  }

  _createClass(CubicBezierCurve3, [{
    key: "getPoint",
    value: function getPoint(t, optionalTarget = new Vector3()) {
      var point = optionalTarget;
      var v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;
      point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(CubicBezierCurve3.prototype), "copy", this).call(this, source);

      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(CubicBezierCurve3.prototype), "toJSON", this).call(this);

      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(CubicBezierCurve3.prototype), "fromJSON", this).call(this, json);

      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    }
  }]);

  return CubicBezierCurve3;
}(Curve);

exports.CubicBezierCurve3 = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

var LineCurve = /*#__PURE__*/function (_Curve5) {
  _inherits(LineCurve, _Curve5);

  var _super63 = _createSuper(LineCurve);

  function LineCurve(v1 = new Vector2(), v2 = new Vector2()) {
    var _this53;

    _classCallCheck(this, LineCurve);

    _this53 = _super63.call(this);
    _this53.type = 'LineCurve';
    _this53.v1 = v1;
    _this53.v2 = v2;
    return _this53;
  }

  _createClass(LineCurve, [{
    key: "getPoint",
    value: function getPoint(t, optionalTarget = new Vector2()) {
      var point = optionalTarget;

      if (t === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
      }

      return point;
    } // Line curve is linear, so we can overwrite default getPointAt

  }, {
    key: "getPointAt",
    value: function getPointAt(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    }
  }, {
    key: "getTangent",
    value: function getTangent(t, optionalTarget) {
      var tangent = optionalTarget || new Vector2();
      tangent.copy(this.v2).sub(this.v1).normalize();
      return tangent;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(LineCurve.prototype), "copy", this).call(this, source);

      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(LineCurve.prototype), "toJSON", this).call(this);

      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(LineCurve.prototype), "fromJSON", this).call(this, json);

      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  }]);

  return LineCurve;
}(Curve);

exports.LineCurve = LineCurve;
LineCurve.prototype.isLineCurve = true;

var LineCurve3 = /*#__PURE__*/function (_Curve6) {
  _inherits(LineCurve3, _Curve6);

  var _super64 = _createSuper(LineCurve3);

  function LineCurve3(v1 = new Vector3(), v2 = new Vector3()) {
    var _this54;

    _classCallCheck(this, LineCurve3);

    _this54 = _super64.call(this);
    _this54.type = 'LineCurve3';
    _this54.isLineCurve3 = true;
    _this54.v1 = v1;
    _this54.v2 = v2;
    return _this54;
  }

  _createClass(LineCurve3, [{
    key: "getPoint",
    value: function getPoint(t, optionalTarget = new Vector3()) {
      var point = optionalTarget;

      if (t === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
      }

      return point;
    } // Line curve is linear, so we can overwrite default getPointAt

  }, {
    key: "getPointAt",
    value: function getPointAt(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(LineCurve3.prototype), "copy", this).call(this, source);

      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(LineCurve3.prototype), "toJSON", this).call(this);

      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(LineCurve3.prototype), "fromJSON", this).call(this, json);

      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  }]);

  return LineCurve3;
}(Curve);

exports.LineCurve3 = LineCurve3;

var QuadraticBezierCurve = /*#__PURE__*/function (_Curve7) {
  _inherits(QuadraticBezierCurve, _Curve7);

  var _super65 = _createSuper(QuadraticBezierCurve);

  function QuadraticBezierCurve(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    var _this55;

    _classCallCheck(this, QuadraticBezierCurve);

    _this55 = _super65.call(this);
    _this55.type = 'QuadraticBezierCurve';
    _this55.v0 = v0;
    _this55.v1 = v1;
    _this55.v2 = v2;
    return _this55;
  }

  _createClass(QuadraticBezierCurve, [{
    key: "getPoint",
    value: function getPoint(t, optionalTarget = new Vector2()) {
      var point = optionalTarget;
      var v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;
      point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(QuadraticBezierCurve.prototype), "copy", this).call(this, source);

      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(QuadraticBezierCurve.prototype), "toJSON", this).call(this);

      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(QuadraticBezierCurve.prototype), "fromJSON", this).call(this, json);

      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  }]);

  return QuadraticBezierCurve;
}(Curve);

exports.QuadraticBezierCurve = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

var QuadraticBezierCurve3 = /*#__PURE__*/function (_Curve8) {
  _inherits(QuadraticBezierCurve3, _Curve8);

  var _super66 = _createSuper(QuadraticBezierCurve3);

  function QuadraticBezierCurve3(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    var _this56;

    _classCallCheck(this, QuadraticBezierCurve3);

    _this56 = _super66.call(this);
    _this56.type = 'QuadraticBezierCurve3';
    _this56.v0 = v0;
    _this56.v1 = v1;
    _this56.v2 = v2;
    return _this56;
  }

  _createClass(QuadraticBezierCurve3, [{
    key: "getPoint",
    value: function getPoint(t, optionalTarget = new Vector3()) {
      var point = optionalTarget;
      var v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;
      point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(QuadraticBezierCurve3.prototype), "copy", this).call(this, source);

      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(QuadraticBezierCurve3.prototype), "toJSON", this).call(this);

      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(QuadraticBezierCurve3.prototype), "fromJSON", this).call(this, json);

      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  }]);

  return QuadraticBezierCurve3;
}(Curve);

exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

var SplineCurve = /*#__PURE__*/function (_Curve9) {
  _inherits(SplineCurve, _Curve9);

  var _super67 = _createSuper(SplineCurve);

  function SplineCurve(points = []) {
    var _this57;

    _classCallCheck(this, SplineCurve);

    _this57 = _super67.call(this);
    _this57.type = 'SplineCurve';
    _this57.points = points;
    return _this57;
  }

  _createClass(SplineCurve, [{
    key: "getPoint",
    value: function getPoint(t, optionalTarget = new Vector2()) {
      var point = optionalTarget;
      var points = this.points;
      var p = (points.length - 1) * t;
      var intPoint = Math.floor(p);
      var weight = p - intPoint;
      var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
      var p1 = points[intPoint];
      var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
      return point;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(SplineCurve.prototype), "copy", this).call(this, source);

      this.points = [];

      for (var _i185 = 0, l = source.points.length; _i185 < l; _i185++) {
        var point = source.points[_i185];
        this.points.push(point.clone());
      }

      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(SplineCurve.prototype), "toJSON", this).call(this);

      data.points = [];

      for (var _i186 = 0, l = this.points.length; _i186 < l; _i186++) {
        var point = this.points[_i186];
        data.points.push(point.toArray());
      }

      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(SplineCurve.prototype), "fromJSON", this).call(this, json);

      this.points = [];

      for (var _i187 = 0, l = json.points.length; _i187 < l; _i187++) {
        var point = json.points[_i187];
        this.points.push(new Vector2().fromArray(point));
      }

      return this;
    }
  }]);

  return SplineCurve;
}(Curve);

exports.SplineCurve = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
var Curves = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ArcCurve: ArcCurve,
  CatmullRomCurve3: CatmullRomCurve3,
  CubicBezierCurve: CubicBezierCurve,
  CubicBezierCurve3: CubicBezierCurve3,
  EllipseCurve: EllipseCurve,
  LineCurve: LineCurve,
  LineCurve3: LineCurve3,
  QuadraticBezierCurve: QuadraticBezierCurve,
  QuadraticBezierCurve3: QuadraticBezierCurve3,
  SplineCurve: SplineCurve
});
/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

var CurvePath = /*#__PURE__*/function (_Curve10) {
  _inherits(CurvePath, _Curve10);

  var _super68 = _createSuper(CurvePath);

  function CurvePath() {
    var _this58;

    _classCallCheck(this, CurvePath);

    _this58 = _super68.call(this);
    _this58.type = 'CurvePath';
    _this58.curves = [];
    _this58.autoClose = false; // Automatically closes the path

    return _this58;
  }

  _createClass(CurvePath, [{
    key: "add",
    value: function add(curve) {
      this.curves.push(curve);
    }
  }, {
    key: "closePath",
    value: function closePath() {
      // Add a line curve if start and end of lines are not connected
      var startPoint = this.curves[0].getPoint(0);
      var endPoint = this.curves[this.curves.length - 1].getPoint(1);

      if (!startPoint.equals(endPoint)) {
        this.curves.push(new LineCurve(endPoint, startPoint));
      }
    } // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:
    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')

  }, {
    key: "getPoint",
    value: function getPoint(t, optionalTarget) {
      var d = t * this.getLength();
      var curveLengths = this.getCurveLengths();
      var i = 0; // To think about boundaries points.

      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          var diff = curveLengths[i] - d;
          var curve = this.curves[i];
          var segmentLength = curve.getLength();
          var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
          return curve.getPointAt(u, optionalTarget);
        }

        i++;
      }

      return null; // loop where sum != 0, sum > d , sum+1 <d
    } // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength

  }, {
    key: "getLength",
    value: function getLength() {
      var lens = this.getCurveLengths();
      return lens[lens.length - 1];
    } // cacheLengths must be recalculated.

  }, {
    key: "updateArcLengths",
    value: function updateArcLengths() {
      this.needsUpdate = true;
      this.cacheLengths = null;
      this.getCurveLengths();
    } // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.

  }, {
    key: "getCurveLengths",
    value: function getCurveLengths() {
      // We use cache values if curves and cache array are same length
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
      } // Get length of sub-curve
      // Push sums into cached array


      var lengths = [];
      var sums = 0;

      for (var _i188 = 0, l = this.curves.length; _i188 < l; _i188++) {
        sums += this.curves[_i188].getLength();
        lengths.push(sums);
      }

      this.cacheLengths = lengths;
      return lengths;
    }
  }, {
    key: "getSpacedPoints",
    value: function getSpacedPoints(divisions = 40) {
      var points = [];

      for (var _i189 = 0; _i189 <= divisions; _i189++) {
        points.push(this.getPoint(_i189 / divisions));
      }

      if (this.autoClose) {
        points.push(points[0]);
      }

      return points;
    }
  }, {
    key: "getPoints",
    value: function getPoints(divisions = 12) {
      var points = [];
      var last;

      for (var _i190 = 0, curves = this.curves; _i190 < curves.length; _i190++) {
        var curve = curves[_i190];
        var resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
        var pts = curve.getPoints(resolution);

        for (var j = 0; j < pts.length; j++) {
          var point = pts[j];
          if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

          points.push(point);
          last = point;
        }
      }

      if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
        points.push(points[0]);
      }

      return points;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(CurvePath.prototype), "copy", this).call(this, source);

      this.curves = [];

      for (var _i191 = 0, l = source.curves.length; _i191 < l; _i191++) {
        var curve = source.curves[_i191];
        this.curves.push(curve.clone());
      }

      this.autoClose = source.autoClose;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(CurvePath.prototype), "toJSON", this).call(this);

      data.autoClose = this.autoClose;
      data.curves = [];

      for (var _i192 = 0, l = this.curves.length; _i192 < l; _i192++) {
        var curve = this.curves[_i192];
        data.curves.push(curve.toJSON());
      }

      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(CurvePath.prototype), "fromJSON", this).call(this, json);

      this.autoClose = json.autoClose;
      this.curves = [];

      for (var _i193 = 0, l = json.curves.length; _i193 < l; _i193++) {
        var curve = json.curves[_i193];
        this.curves.push(new Curves[curve.type]().fromJSON(curve));
      }

      return this;
    }
  }]);

  return CurvePath;
}(Curve);

exports.CurvePath = CurvePath;

var Path = /*#__PURE__*/function (_CurvePath) {
  _inherits(Path, _CurvePath);

  var _super69 = _createSuper(Path);

  function Path(points) {
    var _this59;

    _classCallCheck(this, Path);

    _this59 = _super69.call(this);
    _this59.type = 'Path';
    _this59.currentPoint = new Vector2();

    if (points) {
      _this59.setFromPoints(points);
    }

    return _this59;
  }

  _createClass(Path, [{
    key: "setFromPoints",
    value: function setFromPoints(points) {
      this.moveTo(points[0].x, points[0].y);

      for (var _i194 = 1, l = points.length; _i194 < l; _i194++) {
        this.lineTo(points[_i194].x, points[_i194].y);
      }

      return this;
    }
  }, {
    key: "moveTo",
    value: function moveTo(x, y) {
      this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

      return this;
    }
  }, {
    key: "lineTo",
    value: function lineTo(x, y) {
      var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
      this.curves.push(curve);
      this.currentPoint.set(x, y);
      return this;
    }
  }, {
    key: "quadraticCurveTo",
    value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
      var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    }
  }, {
    key: "bezierCurveTo",
    value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    }
  }, {
    key: "splineThru",
    value: function splineThru(pts
    /*Array of Vector*/
    ) {
      var npts = [this.currentPoint.clone()].concat(pts);
      var curve = new SplineCurve(npts);
      this.curves.push(curve);
      this.currentPoint.copy(pts[pts.length - 1]);
      return this;
    }
  }, {
    key: "arc",
    value: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      var x0 = this.currentPoint.x;
      var y0 = this.currentPoint.y;
      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    }
  }, {
    key: "absarc",
    value: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    }
  }, {
    key: "ellipse",
    value: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var x0 = this.currentPoint.x;
      var y0 = this.currentPoint.y;
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      return this;
    }
  }, {
    key: "absellipse",
    value: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

      if (this.curves.length > 0) {
        // if a previous curve is present, attempt to join
        var firstPoint = curve.getPoint(0);

        if (!firstPoint.equals(this.currentPoint)) {
          this.lineTo(firstPoint.x, firstPoint.y);
        }
      }

      this.curves.push(curve);
      var lastPoint = curve.getPoint(1);
      this.currentPoint.copy(lastPoint);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(Path.prototype), "copy", this).call(this, source);

      this.currentPoint.copy(source.currentPoint);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(Path.prototype), "toJSON", this).call(this);

      data.currentPoint = this.currentPoint.toArray();
      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(Path.prototype), "fromJSON", this).call(this, json);

      this.currentPoint.fromArray(json.currentPoint);
      return this;
    }
  }]);

  return Path;
}(CurvePath);

exports.Path = Path;

var LatheGeometry = /*#__PURE__*/function (_BufferGeometry3) {
  _inherits(LatheGeometry, _BufferGeometry3);

  var _super70 = _createSuper(LatheGeometry);

  function LatheGeometry(points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    var _this60;

    _classCallCheck(this, LatheGeometry);

    _this60 = _super70.call(this);
    _this60.type = 'LatheGeometry';
    _this60.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]

    phiLength = clamp(phiLength, 0, Math.PI * 2); // buffers

    var indices = [];
    var vertices = [];
    var uvs = [];
    var initNormals = [];
    var normals = []; // helper variables

    var inverseSegments = 1.0 / segments;
    var vertex = new Vector3();
    var uv = new Vector2();
    var normal = new Vector3();
    var curNormal = new Vector3();
    var prevNormal = new Vector3();
    var dx = 0;
    var dy = 0; // pre-compute normals for initial "meridian"

    for (var j = 0; j <= points.length - 1; j++) {
      switch (j) {
        case 0:
          // special handling for 1st vertex on path
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1.0;
          normal.y = -dx;
          normal.z = dy * 0.0;
          prevNormal.copy(normal);
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          break;

        case points.length - 1:
          // special handling for last Vertex on path
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;

        default:
          // default handling for all vertices in between
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1.0;
          normal.y = -dx;
          normal.z = dy * 0.0;
          curNormal.copy(normal);
          normal.x += prevNormal.x;
          normal.y += prevNormal.y;
          normal.z += prevNormal.z;
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          prevNormal.copy(curNormal);
      }
    } // generate vertices, uvs and normals


    for (var _i195 = 0; _i195 <= segments; _i195++) {
      var phi = phiStart + _i195 * inverseSegments * phiLength;
      var sin = Math.sin(phi);
      var cos = Math.cos(phi);

      for (var _j5 = 0; _j5 <= points.length - 1; _j5++) {
        // vertex
        vertex.x = points[_j5].x * sin;
        vertex.y = points[_j5].y;
        vertex.z = points[_j5].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z); // uv

        uv.x = _i195 / segments;
        uv.y = _j5 / (points.length - 1);
        uvs.push(uv.x, uv.y); // normal

        var x = initNormals[3 * _j5 + 0] * sin;
        var y = initNormals[3 * _j5 + 1];
        var z = initNormals[3 * _j5 + 0] * cos;
        normals.push(x, y, z);
      }
    } // indices


    for (var _i196 = 0; _i196 < segments; _i196++) {
      for (var _j6 = 0; _j6 < points.length - 1; _j6++) {
        var base = _j6 + _i196 * points.length;
        var a = base;
        var b = base + points.length;
        var c = base + points.length + 1;
        var d = base + 1; // faces

        indices.push(a, b, d);
        indices.push(c, d, b);
      }
    } // build geometry


    _this60.setIndex(indices);

    _this60.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this60.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    _this60.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    return _this60;
  }

  _createClass(LatheGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
    }
  }]);

  return LatheGeometry;
}(BufferGeometry);

exports.LatheGeometry = exports.LatheBufferGeometry = LatheGeometry;

var CapsuleGeometry = /*#__PURE__*/function (_LatheGeometry) {
  _inherits(CapsuleGeometry, _LatheGeometry);

  var _super71 = _createSuper(CapsuleGeometry);

  function CapsuleGeometry(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
    var _this61;

    _classCallCheck(this, CapsuleGeometry);

    var path = new Path();
    path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
    path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
    _this61 = _super71.call(this, path.getPoints(capSegments), radialSegments);
    _this61.type = 'CapsuleGeometry';
    _this61.parameters = {
      radius: radius,
      height: length,
      capSegments: capSegments,
      radialSegments: radialSegments
    };
    return _this61;
  }

  _createClass(CapsuleGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
    }
  }]);

  return CapsuleGeometry;
}(LatheGeometry);

exports.CapsuleGeometry = exports.CapsuleBufferGeometry = CapsuleGeometry;

var CircleGeometry = /*#__PURE__*/function (_BufferGeometry4) {
  _inherits(CircleGeometry, _BufferGeometry4);

  var _super72 = _createSuper(CircleGeometry);

  function CircleGeometry(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
    var _this62;

    _classCallCheck(this, CircleGeometry);

    _this62 = _super72.call(this);
    _this62.type = 'CircleGeometry';
    _this62.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    segments = Math.max(3, segments); // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // helper variables

    var vertex = new Vector3();
    var uv = new Vector2(); // center point

    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);

    for (var s = 0, _i197 = 3; s <= segments; s++, _i197 += 3) {
      var segment = thetaStart + s / segments * thetaLength; // vertex

      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, 0, 1); // uvs

      uv.x = (vertices[_i197] / radius + 1) / 2;
      uv.y = (vertices[_i197 + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    } // indices


    for (var _i198 = 1; _i198 <= segments; _i198++) {
      indices.push(_i198, _i198 + 1, 0);
    } // build geometry


    _this62.setIndex(indices);

    _this62.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this62.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this62.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    return _this62;
  }

  _createClass(CircleGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
    }
  }]);

  return CircleGeometry;
}(BufferGeometry);

exports.CircleGeometry = exports.CircleBufferGeometry = CircleGeometry;

var CylinderGeometry = /*#__PURE__*/function (_BufferGeometry5) {
  _inherits(CylinderGeometry, _BufferGeometry5);

  var _super73 = _createSuper(CylinderGeometry);

  function CylinderGeometry(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    var _this63;

    _classCallCheck(this, CylinderGeometry);

    _this63 = _super73.call(this);
    _this63.type = 'CylinderGeometry';
    _this63.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };

    var scope = _assertThisInitialized(_this63);

    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments); // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // helper variables

    var index = 0;
    var indexArray = [];
    var halfHeight = height / 2;
    var groupStart = 0; // generate geometry

    generateTorso();

    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    } // build geometry


    _this63.setIndex(indices);

    _this63.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this63.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this63.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    function generateTorso() {
      var normal = new Vector3();
      var vertex = new Vector3();
      var groupCount = 0; // this will be used to calculate the normal

      var slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

      for (var y = 0; y <= heightSegments; y++) {
        var indexRow = [];
        var v = y / heightSegments; // calculate the radius of the current row

        var radius = v * (radiusBottom - radiusTop) + radiusTop;

        for (var x = 0; x <= radialSegments; x++) {
          var u = x / radialSegments;
          var theta = u * thetaLength + thetaStart;
          var sinTheta = Math.sin(theta);
          var cosTheta = Math.cos(theta); // vertex

          vertex.x = radius * sinTheta;
          vertex.y = -v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z); // normal

          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z); // uv

          uvs.push(u, 1 - v); // save index of vertex in respective row

          indexRow.push(index++);
        } // now save vertices of the row in our index array


        indexArray.push(indexRow);
      } // generate indices


      for (var _x4 = 0; _x4 < radialSegments; _x4++) {
        for (var _y2 = 0; _y2 < heightSegments; _y2++) {
          // we use the index array to access the correct indices
          var a = indexArray[_y2][_x4];
          var b = indexArray[_y2 + 1][_x4];
          var c = indexArray[_y2 + 1][_x4 + 1];
          var d = indexArray[_y2][_x4 + 1]; // faces

          indices.push(a, b, d);
          indices.push(b, c, d); // update group counter

          groupCount += 6;
        }
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

      groupStart += groupCount;
    }

    function generateCap(top) {
      // save the index of the first center vertex
      var centerIndexStart = index;
      var uv = new Vector2();
      var vertex = new Vector3();
      var groupCount = 0;
      var radius = top === true ? radiusTop : radiusBottom;
      var sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
      // because the geometry needs one set of uvs per face,
      // we must generate a center vertex per face/segment

      for (var x = 1; x <= radialSegments; x++) {
        // vertex
        vertices.push(0, halfHeight * sign, 0); // normal

        normals.push(0, sign, 0); // uv

        uvs.push(0.5, 0.5); // increase index

        index++;
      } // save the index of the last center vertex


      var centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

      for (var _x5 = 0; _x5 <= radialSegments; _x5++) {
        var u = _x5 / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normals.push(0, sign, 0); // uv

        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.push(uv.x, uv.y); // increase index

        index++;
      } // generate indices


      for (var _x6 = 0; _x6 < radialSegments; _x6++) {
        var c = centerIndexStart + _x6;

        var _i199 = centerIndexEnd + _x6;

        if (top === true) {
          // face top
          indices.push(_i199, _i199 + 1, c);
        } else {
          // face bottom
          indices.push(_i199 + 1, _i199, c);
        }

        groupCount += 3;
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

      groupStart += groupCount;
    }

    return _this63;
  }

  _createClass(CylinderGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
    }
  }]);

  return CylinderGeometry;
}(BufferGeometry);

exports.CylinderGeometry = exports.CylinderBufferGeometry = CylinderGeometry;

var ConeGeometry = /*#__PURE__*/function (_CylinderGeometry) {
  _inherits(ConeGeometry, _CylinderGeometry);

  var _super74 = _createSuper(ConeGeometry);

  function ConeGeometry(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    var _this64;

    _classCallCheck(this, ConeGeometry);

    _this64 = _super74.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    _this64.type = 'ConeGeometry';
    _this64.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    return _this64;
  }

  _createClass(ConeGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
    }
  }]);

  return ConeGeometry;
}(CylinderGeometry);

exports.ConeGeometry = exports.ConeBufferGeometry = ConeGeometry;

var PolyhedronGeometry = /*#__PURE__*/function (_BufferGeometry6) {
  _inherits(PolyhedronGeometry, _BufferGeometry6);

  var _super75 = _createSuper(PolyhedronGeometry);

  function PolyhedronGeometry(vertices = [], indices = [], radius = 1, detail = 0) {
    var _this65;

    _classCallCheck(this, PolyhedronGeometry);

    _this65 = _super75.call(this);
    _this65.type = 'PolyhedronGeometry';
    _this65.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    }; // default buffer data

    var vertexBuffer = [];
    var uvBuffer = []; // the subdivision creates the vertex buffer data

    subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

    applyRadius(radius); // finally, create the uv data

    generateUVs(); // build non-indexed geometry

    _this65.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));

    _this65.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));

    _this65.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

    if (detail === 0) {
      _this65.computeVertexNormals(); // flat normals

    } else {
      _this65.normalizeNormals(); // smooth normals

    } // helper functions


    function subdivide(detail) {
      var a = new Vector3();
      var b = new Vector3();
      var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

      for (var _i200 = 0; _i200 < indices.length; _i200 += 3) {
        // get the vertices of the face
        getVertexByIndex(indices[_i200 + 0], a);
        getVertexByIndex(indices[_i200 + 1], b);
        getVertexByIndex(indices[_i200 + 2], c); // perform subdivision

        subdivideFace(a, b, c, detail);
      }
    }

    function subdivideFace(a, b, c, detail) {
      var cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision

      var v = []; // construct all of the vertices for this subdivision

      for (var _i201 = 0; _i201 <= cols; _i201++) {
        v[_i201] = [];
        var aj = a.clone().lerp(c, _i201 / cols);
        var bj = b.clone().lerp(c, _i201 / cols);
        var rows = cols - _i201;

        for (var j = 0; j <= rows; j++) {
          if (j === 0 && _i201 === cols) {
            v[_i201][j] = aj;
          } else {
            v[_i201][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      } // construct all of the faces


      for (var _i202 = 0; _i202 < cols; _i202++) {
        for (var _j7 = 0; _j7 < 2 * (cols - _i202) - 1; _j7++) {
          var k = Math.floor(_j7 / 2);

          if (_j7 % 2 === 0) {
            pushVertex(v[_i202][k + 1]);
            pushVertex(v[_i202 + 1][k]);
            pushVertex(v[_i202][k]);
          } else {
            pushVertex(v[_i202][k + 1]);
            pushVertex(v[_i202 + 1][k + 1]);
            pushVertex(v[_i202 + 1][k]);
          }
        }
      }
    }

    function applyRadius(radius) {
      var vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

      for (var _i203 = 0; _i203 < vertexBuffer.length; _i203 += 3) {
        vertex.x = vertexBuffer[_i203 + 0];
        vertex.y = vertexBuffer[_i203 + 1];
        vertex.z = vertexBuffer[_i203 + 2];
        vertex.normalize().multiplyScalar(radius);
        vertexBuffer[_i203 + 0] = vertex.x;
        vertexBuffer[_i203 + 1] = vertex.y;
        vertexBuffer[_i203 + 2] = vertex.z;
      }
    }

    function generateUVs() {
      var vertex = new Vector3();

      for (var _i204 = 0; _i204 < vertexBuffer.length; _i204 += 3) {
        vertex.x = vertexBuffer[_i204 + 0];
        vertex.y = vertexBuffer[_i204 + 1];
        vertex.z = vertexBuffer[_i204 + 2];
        var u = azimuth(vertex) / 2 / Math.PI + 0.5;
        var v = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }

      correctUVs();
      correctSeam();
    }

    function correctSeam() {
      // handle case when face straddles the seam, see #3269
      for (var _i205 = 0; _i205 < uvBuffer.length; _i205 += 6) {
        // uv data of a single face
        var x0 = uvBuffer[_i205 + 0];
        var x1 = uvBuffer[_i205 + 2];
        var x2 = uvBuffer[_i205 + 4];
        var max = Math.max(x0, x1, x2);
        var min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[_i205 + 0] += 1;
          if (x1 < 0.2) uvBuffer[_i205 + 2] += 1;
          if (x2 < 0.2) uvBuffer[_i205 + 4] += 1;
        }
      }
    }

    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }

    function getVertexByIndex(index, vertex) {
      var stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }

    function correctUVs() {
      var a = new Vector3();
      var b = new Vector3();
      var c = new Vector3();
      var centroid = new Vector3();
      var uvA = new Vector2();
      var uvB = new Vector2();
      var uvC = new Vector2();

      for (var _i206 = 0, j = 0; _i206 < vertexBuffer.length; _i206 += 9, j += 6) {
        a.set(vertexBuffer[_i206 + 0], vertexBuffer[_i206 + 1], vertexBuffer[_i206 + 2]);
        b.set(vertexBuffer[_i206 + 3], vertexBuffer[_i206 + 4], vertexBuffer[_i206 + 5]);
        c.set(vertexBuffer[_i206 + 6], vertexBuffer[_i206 + 7], vertexBuffer[_i206 + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        var azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }

    function correctUV(uv, stride, vector, azimuth) {
      if (azimuth < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }

      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
      }
    } // Angle around the Y axis, counter-clockwise when looking from above.


    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    } // Angle above the XZ plane.


    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }

    return _this65;
  }

  _createClass(PolyhedronGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
    }
  }]);

  return PolyhedronGeometry;
}(BufferGeometry);

exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = PolyhedronGeometry;

var DodecahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
  _inherits(DodecahedronGeometry, _PolyhedronGeometry);

  var _super76 = _createSuper(DodecahedronGeometry);

  function DodecahedronGeometry(radius = 1, detail = 0) {
    var _this66;

    _classCallCheck(this, DodecahedronGeometry);

    var t = (1 + Math.sqrt(5)) / 2;
    var r = 1 / t;
    var vertices = [// (±1, ±1, ±1)
    -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)
    0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)
    -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)
    -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
    var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    _this66 = _super76.call(this, vertices, indices, radius, detail);
    _this66.type = 'DodecahedronGeometry';
    _this66.parameters = {
      radius: radius,
      detail: detail
    };
    return _this66;
  }

  _createClass(DodecahedronGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new DodecahedronGeometry(data.radius, data.detail);
    }
  }]);

  return DodecahedronGeometry;
}(PolyhedronGeometry);

exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = DodecahedronGeometry;

var _v0 = new Vector3();

var _v1$1 = new Vector3();

var _normal = new Vector3();

var _triangle = new Triangle();

var EdgesGeometry = /*#__PURE__*/function (_BufferGeometry7) {
  _inherits(EdgesGeometry, _BufferGeometry7);

  var _super77 = _createSuper(EdgesGeometry);

  function EdgesGeometry(geometry = null, thresholdAngle = 1) {
    var _this67;

    _classCallCheck(this, EdgesGeometry);

    _this67 = _super77.call(this);
    _this67.type = 'EdgesGeometry';
    _this67.parameters = {
      geometry: geometry,
      thresholdAngle: thresholdAngle
    };

    if (geometry !== null) {
      var precisionPoints = 4;
      var precision = Math.pow(10, precisionPoints);
      var thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
      var indexAttr = geometry.getIndex();
      var positionAttr = geometry.getAttribute('position');
      var indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      var indexArr = [0, 0, 0];
      var vertKeys = ['a', 'b', 'c'];
      var hashes = new Array(3);
      var edgeData = {};
      var vertices = [];

      for (var _i207 = 0; _i207 < indexCount; _i207 += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(_i207);
          indexArr[1] = indexAttr.getX(_i207 + 1);
          indexArr[2] = indexAttr.getX(_i207 + 2);
        } else {
          indexArr[0] = _i207;
          indexArr[1] = _i207 + 1;
          indexArr[2] = _i207 + 2;
        }

        var a = _triangle.a,
            b = _triangle.b,
            c = _triangle.c;
        a.fromBufferAttribute(positionAttr, indexArr[0]);
        b.fromBufferAttribute(positionAttr, indexArr[1]);
        c.fromBufferAttribute(positionAttr, indexArr[2]);

        _triangle.getNormal(_normal); // create hashes for the edge from the vertices


        hashes[0] = "".concat(Math.round(a.x * precision), ",").concat(Math.round(a.y * precision), ",").concat(Math.round(a.z * precision));
        hashes[1] = "".concat(Math.round(b.x * precision), ",").concat(Math.round(b.y * precision), ",").concat(Math.round(b.z * precision));
        hashes[2] = "".concat(Math.round(c.x * precision), ",").concat(Math.round(c.y * precision), ",").concat(Math.round(c.z * precision)); // skip degenerate triangles

        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        } // iterate over every edge


        for (var j = 0; j < 3; j++) {
          // get the first and next vertex making up the edge
          var jNext = (j + 1) % 3;
          var vecHash0 = hashes[j];
          var vecHash1 = hashes[jNext];
          var v0 = _triangle[vertKeys[j]];
          var v1 = _triangle[vertKeys[jNext]];
          var hash = "".concat(vecHash0, "_").concat(vecHash1);
          var reverseHash = "".concat(vecHash1, "_").concat(vecHash0);

          if (reverseHash in edgeData && edgeData[reverseHash]) {
            // if we found a sibling edge add it into the vertex array if
            // it meets the angle threshold and delete the edge from the map.
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }

            edgeData[reverseHash] = null;
          } else if (!(hash in edgeData)) {
            // if we've already got an edge here then skip adding a new one
            edgeData[hash] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      } // iterate over all remaining, unmatched edges and add them to the vertex array


      for (var key in edgeData) {
        if (edgeData[key]) {
          var _edgeData$key = edgeData[key],
              index0 = _edgeData$key.index0,
              index1 = _edgeData$key.index1;

          _v0.fromBufferAttribute(positionAttr, index0);

          _v1$1.fromBufferAttribute(positionAttr, index1);

          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }

      _this67.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    }

    return _this67;
  }

  return _createClass(EdgesGeometry);
}(BufferGeometry);

exports.EdgesGeometry = EdgesGeometry;

var Shape = /*#__PURE__*/function (_Path) {
  _inherits(Shape, _Path);

  var _super78 = _createSuper(Shape);

  function Shape(points) {
    var _this68;

    _classCallCheck(this, Shape);

    _this68 = _super78.call(this, points);
    _this68.uuid = generateUUID();
    _this68.type = 'Shape';
    _this68.holes = [];
    return _this68;
  }

  _createClass(Shape, [{
    key: "getPointsHoles",
    value: function getPointsHoles(divisions) {
      var holesPts = [];

      for (var _i208 = 0, l = this.holes.length; _i208 < l; _i208++) {
        holesPts[_i208] = this.holes[_i208].getPoints(divisions);
      }

      return holesPts;
    } // get points of shape and holes (keypoints based on segments parameter)

  }, {
    key: "extractPoints",
    value: function extractPoints(divisions) {
      return {
        shape: this.getPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(Shape.prototype), "copy", this).call(this, source);

      this.holes = [];

      for (var _i209 = 0, l = source.holes.length; _i209 < l; _i209++) {
        var hole = source.holes[_i209];
        this.holes.push(hole.clone());
      }

      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(Shape.prototype), "toJSON", this).call(this);

      data.uuid = this.uuid;
      data.holes = [];

      for (var _i210 = 0, l = this.holes.length; _i210 < l; _i210++) {
        var hole = this.holes[_i210];
        data.holes.push(hole.toJSON());
      }

      return data;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      _get(_getPrototypeOf(Shape.prototype), "fromJSON", this).call(this, json);

      this.uuid = json.uuid;
      this.holes = [];

      for (var _i211 = 0, l = json.holes.length; _i211 < l; _i211++) {
        var hole = json.holes[_i211];
        this.holes.push(new Path().fromJSON(hole));
      }

      return this;
    }
  }]);

  return Shape;
}(Path);
/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */


exports.Shape = Shape;
var Earcut = {
  triangulate: function triangulate(data, holeIndices, dim = 2) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var outerNode = linkedList(data, 0, outerLen, dim, true);
    var triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];

      for (var _i212 = dim; _i212 < outerLen; _i212 += dim) {
        x = data[_i212];
        y = data[_i212 + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
}; // create a circular doubly linked list from polygon points in the specified winding order

function linkedList(data, start, end, dim, clockwise) {
  var i, last;

  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) {
      last = insertNode(i, data[i], data[i + 1], last);
    }
  } else {
    for (i = end - dim; i >= start; i -= dim) {
      last = insertNode(i, data[i], data[i + 1], last);
    }
  }

  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }

  return last;
} // eliminate colinear or duplicate points


function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  var p = start,
      again;

  do {
    again = false;

    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);

  return end;
} // main ear slicing loop which triangulates a polygon (given as a linked list)


function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return; // interlink polygon nodes in z-order

  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  var stop = ear,
      prev,
      next; // iterate through ears, slicing them one by one

  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;

    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear); // skipping the next vertex leads to less sliver triangles

      ear = next.next;
      stop = next.next;
      continue;
    }

    ear = next; // if we looped through the whole remaining polygon and can't find any more ears

    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }

      break;
    }
  }
} // check whether a polygon node forms a valid ear with adjacent nodes


function isEar(ear) {
  var a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear

  var p = ear.next.next;

  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }

  return true;
}

function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // triangle bbox; min & max are calculated like this for speed

  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
      minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
      maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
      maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

  var minZ = zOrder(minTX, minTY, minX, minY, invSize),
      maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  var p = ear.prevZ,
      n = ear.nextZ; // look for points inside the triangle in both directions

  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  } // look for remaining points in decreasing z-order


  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  } // look for remaining points in increasing z-order


  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  return true;
} // go through all polygon nodes and cure small local self-intersections


function cureLocalIntersections(start, triangles, dim) {
  var p = start;

  do {
    var a = p.prev,
        b = p.next.next;

    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim); // remove two nodes involved

      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }

    p = p.next;
  } while (p !== start);

  return filterPoints(p);
} // try splitting polygon into two and triangulate them independently


function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  var a = start;

  do {
    var b = a.next.next;

    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        var c = splitPolygon(a, b); // filter colinear points around the cuts

        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next); // run earcut on each half

        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }

      b = b.next;
    }

    a = a.next;
  } while (a !== start);
} // link every hole into the outer loop, producing a single-ring polygon without holes


function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [];
  var i, len, start, end, list;

  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }

  queue.sort(compareX); // process holes from left to right

  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }

  return outerNode;
}

function compareX(a, b) {
  return a.x - b.x;
} // find a bridge between vertices that connects hole with an outer ring and link it


function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);

  if (outerNode) {
    var b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
} // David Eberly's algorithm for finding a bridge between hole and outer polygon


function findHoleBridge(hole, outerNode) {
  var p = outerNode;
  var hx = hole.x;
  var hy = hole.y;
  var qx = -Infinity,
      m; // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point

  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

      if (x <= hx && x > qx) {
        qx = x;

        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }

        m = p.x < p.next.x ? p : p.next;
      }
    }

    p = p.next;
  } while (p !== outerNode);

  if (!m) return null;
  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  var stop = m,
      mx = m.x,
      my = m.y;
  var tanMin = Infinity,
      tan;
  p = m;

  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }

    p = p.next;
  } while (p !== stop);

  return m;
} // whether sector in vertex m contains sector in vertex p in the same coordinates


function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
} // interlink polygon nodes in z-order


function indexCurve(start, minX, minY, invSize) {
  var p = start;

  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);

  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
} // Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


function sortLinked(list) {
  var i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;

  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;

    while (p) {
      numMerges++;
      q = p;
      pSize = 0;

      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }

      qSize = inSize;

      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }

        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }

      p = q;
    }

    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);

  return list;
} // z-order of a point given coords and inverse of the longer side of data bbox


function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
} // find the leftmost node of a polygon ring


function getLeftmost(start) {
  var p = start,
      leftmost = start;

  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);

  return leftmost;
} // check if a point lies within a convex triangle


function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // doesn't intersect other edges
  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
  area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
} // signed area of a triangle


function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
} // check if two points are equal


function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
} // check if two segments intersect


function intersects(p1, q1, p2, q2) {
  var o1 = sign(area(p1, q1, p2));
  var o2 = sign(area(p1, q1, q2));
  var o3 = sign(area(p2, q2, p1));
  var o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true; // general case

  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  return false;
} // for collinear points p, q, r, check if point q lies on segment pr


function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
} // check if a polygon diagonal intersects any polygon segments


function intersectsPolygon(a, b) {
  var p = a;

  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);

  return false;
} // check if a polygon diagonal is locally inside the polygon


function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
} // check if the middle point of a polygon diagonal is inside the polygon


function middleInside(a, b) {
  var p = a,
      inside = false;
  var px = (a.x + b.x) / 2,
      py = (a.y + b.y) / 2;

  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);

  return inside;
} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring


function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y),
      b2 = new Node(b.i, b.x, b.y),
      an = a.next,
      bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
} // create a node and optionally link it with previous one (in a circular doubly linked list)


function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);

  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }

  return p;
}

function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
  // vertex index in coordinates array
  this.i = i; // vertex coordinates

  this.x = x;
  this.y = y; // previous and next vertex nodes in a polygon ring

  this.prev = null;
  this.next = null; // z-order curve value

  this.z = null; // previous and next nodes in z-order

  this.prevZ = null;
  this.nextZ = null; // indicates whether this is a steiner point

  this.steiner = false;
}

function signedArea(data, start, end, dim) {
  var sum = 0;

  for (var _i213 = start, j = end - dim; _i213 < end; _i213 += dim) {
    sum += (data[j] - data[_i213]) * (data[_i213 + 1] + data[j + 1]);
    j = _i213;
  }

  return sum;
}

var ShapeUtils = /*#__PURE__*/function () {
  function ShapeUtils() {
    _classCallCheck(this, ShapeUtils);
  }

  _createClass(ShapeUtils, null, [{
    key: "area",
    value: // calculate area of the contour polygon
    function area(contour) {
      var n = contour.length;
      var a = 0.0;

      for (var p = n - 1, q = 0; q < n; p = q++) {
        a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
      }

      return a * 0.5;
    }
  }, {
    key: "isClockWise",
    value: function isClockWise(pts) {
      return ShapeUtils.area(pts) < 0;
    }
  }, {
    key: "triangulateShape",
    value: function triangulateShape(contour, holes) {
      var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

      var holeIndices = []; // array of hole indices

      var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

      removeDupEndPts(contour);
      addContour(vertices, contour); //

      var holeIndex = contour.length;
      holes.forEach(removeDupEndPts);

      for (var _i214 = 0; _i214 < holes.length; _i214++) {
        holeIndices.push(holeIndex);
        holeIndex += holes[_i214].length;
        addContour(vertices, holes[_i214]);
      } //


      var triangles = Earcut.triangulate(vertices, holeIndices); //

      for (var _i215 = 0; _i215 < triangles.length; _i215 += 3) {
        faces.push(triangles.slice(_i215, _i215 + 3));
      }

      return faces;
    }
  }]);

  return ShapeUtils;
}();

exports.ShapeUtils = ShapeUtils;

function removeDupEndPts(points) {
  var l = points.length;

  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}

function addContour(vertices, contour) {
  for (var _i216 = 0; _i216 < contour.length; _i216++) {
    vertices.push(contour[_i216].x);
    vertices.push(contour[_i216].y);
  }
}
/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */


var ExtrudeGeometry = /*#__PURE__*/function (_BufferGeometry8) {
  _inherits(ExtrudeGeometry, _BufferGeometry8);

  var _super79 = _createSuper(ExtrudeGeometry);

  function ExtrudeGeometry(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
    var _this69;

    _classCallCheck(this, ExtrudeGeometry);

    _this69 = _super79.call(this);
    _this69.type = 'ExtrudeGeometry';
    _this69.parameters = {
      shapes: shapes,
      options: options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];

    var scope = _assertThisInitialized(_this69);

    var verticesArray = [];
    var uvArray = [];

    for (var _i217 = 0, l = shapes.length; _i217 < l; _i217++) {
      var shape = shapes[_i217];
      addShape(shape);
    } // build geometry


    _this69.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));

    _this69.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));

    _this69.computeVertexNormals(); // functions


    function addShape(shape) {
      var placeholder = []; // options

      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var steps = options.steps !== undefined ? options.steps : 1;
      var depth = options.depth !== undefined ? options.depth : 1;
      var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
      var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
      var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
      var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      var extrudePath = options.extrudePath;
      var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

      if (options.amount !== undefined) {
        console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
        depth = options.amount;
      } //


      var extrudePts,
          extrudeByPath = false;
      var splineTube, binormal, normal, position2;

      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion
        // SETUP TNB variables
        // TODO1 - have a .isClosed in spline?

        splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      } // Safeguards if bevels are not enabled


      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      } // Variables initialization


      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !ShapeUtils.isClockWise(vertices);

      if (reverse) {
        vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for (var h = 0, hl = holes.length; h < hl; h++) {
          var ahole = holes[h];

          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }

      var faces = ShapeUtils.triangulateShape(vertices, holes);
      /* Vertices */

      var contour = vertices; // vertices has all points but contour has only points of circumference

      for (var _h = 0, _hl = holes.length; _h < _hl; _h++) {
        var _ahole = holes[_h];
        vertices = vertices.concat(_ahole);
      }

      function scalePt2(pt, vec, size) {
        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
        return vec.clone().multiplyScalar(size).add(pt);
      }

      var vlen = vertices.length,
          flen = faces.length; // Find directions for point movement

      function getBevelVec(inPt, inPrev, inNext) {
        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.
        var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        var v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;
        var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

        var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

        if (Math.abs(collinear0) > Number.EPSILON) {
          // not collinear
          // length of vectors for normalizing
          var v_prev_len = Math.sqrt(v_prev_lensq);
          var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

          var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          var ptNextShift_x = inNext.x - v_next_y / v_next_len;
          var ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

          var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
          //  but prevent crazy spikes

          var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          // handle special case of collinear edges
          var direction_eq = false; // assumes: opposite

          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }

          if (direction_eq) {
            // console.log("Warning: lines are a straight sequence");
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            // console.log("Warning: lines are a straight spike");
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }

        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }

      var contourMovements = [];

      for (var _i218 = 0, il = contour.length, j = il - 1, k = _i218 + 1; _i218 < il; _i218++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0; //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[_i218] = getBevelVec(contour[_i218], contour[j], contour[k]);
      }

      var holesMovements = [];
      var oneHoleMovements,
          verticesMovements = contourMovements.concat();

      for (var _h2 = 0, _hl2 = holes.length; _h2 < _hl2; _h2++) {
        var _ahole2 = holes[_h2];
        oneHoleMovements = [];

        for (var _i219 = 0, _il13 = _ahole2.length, _j8 = _il13 - 1, _k = _i219 + 1; _i219 < _il13; _i219++, _j8++, _k++) {
          if (_j8 === _il13) _j8 = 0;
          if (_k === _il13) _k = 0; //  (j)---(i)---(k)

          oneHoleMovements[_i219] = getBevelVec(_ahole2[_i219], _ahole2[_j8], _ahole2[_k]);
        }

        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      } // Loop bevelSegments, 1 for the front, 1 for the back


      for (var b = 0; b < bevelSegments; b++) {
        //for ( b = bevelSegments; b > 0; b -- ) {
        var t = b / bevelSegments;
        var z = bevelThickness * Math.cos(t * Math.PI / 2);

        var _bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape


        for (var _i220 = 0, _il14 = contour.length; _i220 < _il14; _i220++) {
          var vert = scalePt2(contour[_i220], contourMovements[_i220], _bs);
          v(vert.x, vert.y, -z);
        } // expand holes


        for (var _h3 = 0, _hl3 = holes.length; _h3 < _hl3; _h3++) {
          var _ahole3 = holes[_h3];
          oneHoleMovements = holesMovements[_h3];

          for (var _i221 = 0, _il15 = _ahole3.length; _i221 < _il15; _i221++) {
            var _vert = scalePt2(_ahole3[_i221], oneHoleMovements[_i221], _bs);

            v(_vert.x, _vert.y, -z);
          }
        }
      }

      var bs = bevelSize + bevelOffset; // Back facing vertices

      for (var _i222 = 0; _i222 < vlen; _i222++) {
        var _vert2 = bevelEnabled ? scalePt2(vertices[_i222], verticesMovements[_i222], bs) : vertices[_i222];

        if (!extrudeByPath) {
          v(_vert2.x, _vert2.y, 0);
        } else {
          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
          normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      } // Add stepped vertices...
      // Including front facing vertices


      for (var s = 1; s <= steps; s++) {
        for (var _i223 = 0; _i223 < vlen; _i223++) {
          var _vert3 = bevelEnabled ? scalePt2(vertices[_i223], verticesMovements[_i223], bs) : vertices[_i223];

          if (!extrudeByPath) {
            v(_vert3.x, _vert3.y, depth / steps * s);
          } else {
            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
            normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      } // Add bevel segments planes
      //for ( b = 1; b <= bevelSegments; b ++ ) {


      for (var _b5 = bevelSegments - 1; _b5 >= 0; _b5--) {
        var _t = _b5 / bevelSegments;

        var _z2 = bevelThickness * Math.cos(_t * Math.PI / 2);

        var _bs2 = bevelSize * Math.sin(_t * Math.PI / 2) + bevelOffset; // contract shape


        for (var _i224 = 0, _il16 = contour.length; _i224 < _il16; _i224++) {
          var _vert4 = scalePt2(contour[_i224], contourMovements[_i224], _bs2);

          v(_vert4.x, _vert4.y, depth + _z2);
        } // expand holes


        for (var _h4 = 0, _hl4 = holes.length; _h4 < _hl4; _h4++) {
          var _ahole4 = holes[_h4];
          oneHoleMovements = holesMovements[_h4];

          for (var _i225 = 0, _il17 = _ahole4.length; _i225 < _il17; _i225++) {
            var _vert5 = scalePt2(_ahole4[_i225], oneHoleMovements[_i225], _bs2);

            if (!extrudeByPath) {
              v(_vert5.x, _vert5.y, depth + _z2);
            } else {
              v(_vert5.x, _vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + _z2);
            }
          }
        }
      }
      /* Faces */
      // Top and bottom faces


      buildLidFaces(); // Sides faces

      buildSideFaces(); /////  Internal functions

      function buildLidFaces() {
        var start = verticesArray.length / 3;

        if (bevelEnabled) {
          var layer = 0; // steps + 1

          var offset = vlen * layer; // Bottom faces

          for (var _i226 = 0; _i226 < flen; _i226++) {
            var face = faces[_i226];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }

          layer = steps + bevelSegments * 2;
          offset = vlen * layer; // Top faces

          for (var _i227 = 0; _i227 < flen; _i227++) {
            var _face = faces[_i227];
            f3(_face[0] + offset, _face[1] + offset, _face[2] + offset);
          }
        } else {
          // Bottom faces
          for (var _i228 = 0; _i228 < flen; _i228++) {
            var _face2 = faces[_i228];
            f3(_face2[2], _face2[1], _face2[0]);
          } // Top faces


          for (var _i229 = 0; _i229 < flen; _i229++) {
            var _face3 = faces[_i229];
            f3(_face3[0] + vlen * steps, _face3[1] + vlen * steps, _face3[2] + vlen * steps);
          }
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      } // Create faces for the z-sides of the shape


      function buildSideFaces() {
        var start = verticesArray.length / 3;
        var layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;

        for (var _h5 = 0, _hl5 = holes.length; _h5 < _hl5; _h5++) {
          var _ahole5 = holes[_h5];
          sidewalls(_ahole5, layeroffset); //, true

          layeroffset += _ahole5.length;
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }

      function sidewalls(contour, layeroffset) {
        var i = contour.length;

        while (--i >= 0) {
          var _j9 = i;

          var _k2 = i - 1;

          if (_k2 < 0) _k2 = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

          for (var _s4 = 0, sl = steps + bevelSegments * 2; _s4 < sl; _s4++) {
            var slen1 = vlen * _s4;
            var slen2 = vlen * (_s4 + 1);

            var a = layeroffset + _j9 + slen1,
                _b6 = layeroffset + _k2 + slen1,
                c = layeroffset + _k2 + slen2,
                d = layeroffset + _j9 + slen2;

            f4(a, _b6, c, d);
          }
        }
      }

      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }

      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        var nextIndex = verticesArray.length / 3;
        var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }

      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        var nextIndex = verticesArray.length / 3;
        var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }

      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }

      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }

    return _this69;
  }

  _createClass(ExtrudeGeometry, [{
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(ExtrudeGeometry.prototype), "toJSON", this).call(this);

      var shapes = this.parameters.shapes;
      var options = this.parameters.options;
      return toJSON$1(shapes, options, data);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data, shapes) {
      var geometryShapes = [];

      for (var j = 0, jl = data.shapes.length; j < jl; j++) {
        var shape = shapes[data.shapes[j]];
        geometryShapes.push(shape);
      }

      var extrudePath = data.options.extrudePath;

      if (extrudePath !== undefined) {
        data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
      }

      return new ExtrudeGeometry(geometryShapes, data.options);
    }
  }]);

  return ExtrudeGeometry;
}(BufferGeometry);

exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = ExtrudeGeometry;
var WorldUVGenerator = {
  generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
  },
  generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var a_z = vertices[indexA * 3 + 2];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var b_z = vertices[indexB * 3 + 2];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    var c_z = vertices[indexC * 3 + 2];
    var d_x = vertices[indexD * 3];
    var d_y = vertices[indexD * 3 + 1];
    var d_z = vertices[indexD * 3 + 2];

    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
    } else {
      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
    }
  }
};

function toJSON$1(shapes, options, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (var _i230 = 0, l = shapes.length; _i230 < l; _i230++) {
      var shape = shapes[_i230];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}

var IcosahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry2) {
  _inherits(IcosahedronGeometry, _PolyhedronGeometry2);

  var _super80 = _createSuper(IcosahedronGeometry);

  function IcosahedronGeometry(radius = 1, detail = 0) {
    var _this70;

    _classCallCheck(this, IcosahedronGeometry);

    var t = (1 + Math.sqrt(5)) / 2;
    var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
    var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    _this70 = _super80.call(this, vertices, indices, radius, detail);
    _this70.type = 'IcosahedronGeometry';
    _this70.parameters = {
      radius: radius,
      detail: detail
    };
    return _this70;
  }

  _createClass(IcosahedronGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new IcosahedronGeometry(data.radius, data.detail);
    }
  }]);

  return IcosahedronGeometry;
}(PolyhedronGeometry);

exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = IcosahedronGeometry;

var OctahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry3) {
  _inherits(OctahedronGeometry, _PolyhedronGeometry3);

  var _super81 = _createSuper(OctahedronGeometry);

  function OctahedronGeometry(radius = 1, detail = 0) {
    var _this71;

    _classCallCheck(this, OctahedronGeometry);

    var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
    var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    _this71 = _super81.call(this, vertices, indices, radius, detail);
    _this71.type = 'OctahedronGeometry';
    _this71.parameters = {
      radius: radius,
      detail: detail
    };
    return _this71;
  }

  _createClass(OctahedronGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new OctahedronGeometry(data.radius, data.detail);
    }
  }]);

  return OctahedronGeometry;
}(PolyhedronGeometry);

exports.OctahedronGeometry = exports.OctahedronBufferGeometry = OctahedronGeometry;

var RingGeometry = /*#__PURE__*/function (_BufferGeometry9) {
  _inherits(RingGeometry, _BufferGeometry9);

  var _super82 = _createSuper(RingGeometry);

  function RingGeometry(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    var _this72;

    _classCallCheck(this, RingGeometry);

    _this72 = _super82.call(this);
    _this72.type = 'RingGeometry';
    _this72.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments); // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // some helper variables

    var radius = innerRadius;
    var radiusStep = (outerRadius - innerRadius) / phiSegments;
    var vertex = new Vector3();
    var uv = new Vector2(); // generate vertices, normals and uvs

    for (var j = 0; j <= phiSegments; j++) {
      for (var _i231 = 0; _i231 <= thetaSegments; _i231++) {
        // values are generate from the inside of the ring to the outside
        var segment = thetaStart + _i231 / thetaSegments * thetaLength; // vertex

        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normals.push(0, 0, 1); // uv

        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      } // increase the radius for next row of vertices


      radius += radiusStep;
    } // indices


    for (var _j10 = 0; _j10 < phiSegments; _j10++) {
      var thetaSegmentLevel = _j10 * (thetaSegments + 1);

      for (var _i232 = 0; _i232 < thetaSegments; _i232++) {
        var _segment = _i232 + thetaSegmentLevel;

        var a = _segment;
        var b = _segment + thetaSegments + 1;
        var c = _segment + thetaSegments + 2;
        var d = _segment + 1; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    _this72.setIndex(indices);

    _this72.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this72.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this72.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    return _this72;
  }

  _createClass(RingGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
    }
  }]);

  return RingGeometry;
}(BufferGeometry);

exports.RingGeometry = exports.RingBufferGeometry = RingGeometry;

var ShapeGeometry = /*#__PURE__*/function (_BufferGeometry10) {
  _inherits(ShapeGeometry, _BufferGeometry10);

  var _super83 = _createSuper(ShapeGeometry);

  function ShapeGeometry(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
    var _this73;

    _classCallCheck(this, ShapeGeometry);

    _this73 = _super83.call(this);
    _this73.type = 'ShapeGeometry';
    _this73.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    }; // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // helper variables

    var groupStart = 0;
    var groupCount = 0; // allow single and array values for "shapes" parameter

    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (var _i233 = 0; _i233 < shapes.length; _i233++) {
        addShape(shapes[_i233]);

        _this73.addGroup(groupStart, groupCount, _i233); // enables MultiMaterial support


        groupStart += groupCount;
        groupCount = 0;
      }
    } // build geometry


    _this73.setIndex(indices);

    _this73.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this73.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this73.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions


    function addShape(shape) {
      var indexOffset = vertices.length / 3;
      var points = shape.extractPoints(curveSegments);
      var shapeVertices = points.shape;
      var shapeHoles = points.holes; // check direction of vertices

      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }

      for (var _i234 = 0, l = shapeHoles.length; _i234 < l; _i234++) {
        var shapeHole = shapeHoles[_i234];

        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[_i234] = shapeHole.reverse();
        }
      }

      var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

      for (var _i235 = 0, _l8 = shapeHoles.length; _i235 < _l8; _i235++) {
        var _shapeHole = shapeHoles[_i235];
        shapeVertices = shapeVertices.concat(_shapeHole);
      } // vertices, normals, uvs


      for (var _i236 = 0, _l9 = shapeVertices.length; _i236 < _l9; _i236++) {
        var _vertex = shapeVertices[_i236];
        vertices.push(_vertex.x, _vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(_vertex.x, _vertex.y); // world uvs
      } // incides


      for (var _i237 = 0, _l10 = faces.length; _i237 < _l10; _i237++) {
        var face = faces[_i237];
        var a = face[0] + indexOffset;
        var b = face[1] + indexOffset;
        var c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }

    return _this73;
  }

  _createClass(ShapeGeometry, [{
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(ShapeGeometry.prototype), "toJSON", this).call(this);

      var shapes = this.parameters.shapes;
      return _toJSON(shapes, data);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data, shapes) {
      var geometryShapes = [];

      for (var j = 0, jl = data.shapes.length; j < jl; j++) {
        var shape = shapes[data.shapes[j]];
        geometryShapes.push(shape);
      }

      return new ShapeGeometry(geometryShapes, data.curveSegments);
    }
  }]);

  return ShapeGeometry;
}(BufferGeometry);

exports.ShapeGeometry = exports.ShapeBufferGeometry = ShapeGeometry;

function _toJSON(shapes, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (var _i238 = 0, l = shapes.length; _i238 < l; _i238++) {
      var shape = shapes[_i238];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  return data;
}

var SphereGeometry = /*#__PURE__*/function (_BufferGeometry11) {
  _inherits(SphereGeometry, _BufferGeometry11);

  var _super84 = _createSuper(SphereGeometry);

  function SphereGeometry(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    var _this74;

    _classCallCheck(this, SphereGeometry);

    _this74 = _super84.call(this);
    _this74.type = 'SphereGeometry';
    _this74.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    var index = 0;
    var grid = [];
    var vertex = new Vector3();
    var normal = new Vector3(); // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // generate vertices, normals and uvs

    for (var iy = 0; iy <= heightSegments; iy++) {
      var verticesRow = [];
      var v = iy / heightSegments; // special case for the poles

      var uOffset = 0;

      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }

      for (var ix = 0; ix <= widthSegments; ix++) {
        var u = ix / widthSegments; // vertex

        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }

      grid.push(verticesRow);
    } // indices


    for (var _iy3 = 0; _iy3 < heightSegments; _iy3++) {
      for (var _ix3 = 0; _ix3 < widthSegments; _ix3++) {
        var a = grid[_iy3][_ix3 + 1];
        var b = grid[_iy3][_ix3];
        var c = grid[_iy3 + 1][_ix3];
        var d = grid[_iy3 + 1][_ix3 + 1];
        if (_iy3 !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (_iy3 !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    } // build geometry


    _this74.setIndex(indices);

    _this74.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this74.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this74.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    return _this74;
  }

  _createClass(SphereGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
    }
  }]);

  return SphereGeometry;
}(BufferGeometry);

exports.SphereGeometry = exports.SphereBufferGeometry = SphereGeometry;

var TetrahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry4) {
  _inherits(TetrahedronGeometry, _PolyhedronGeometry4);

  var _super85 = _createSuper(TetrahedronGeometry);

  function TetrahedronGeometry(radius = 1, detail = 0) {
    var _this75;

    _classCallCheck(this, TetrahedronGeometry);

    var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
    var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    _this75 = _super85.call(this, vertices, indices, radius, detail);
    _this75.type = 'TetrahedronGeometry';
    _this75.parameters = {
      radius: radius,
      detail: detail
    };
    return _this75;
  }

  _createClass(TetrahedronGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new TetrahedronGeometry(data.radius, data.detail);
    }
  }]);

  return TetrahedronGeometry;
}(PolyhedronGeometry);

exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = TetrahedronGeometry;

var TorusGeometry = /*#__PURE__*/function (_BufferGeometry12) {
  _inherits(TorusGeometry, _BufferGeometry12);

  var _super86 = _createSuper(TorusGeometry);

  function TorusGeometry(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
    var _this76;

    _classCallCheck(this, TorusGeometry);

    _this76 = _super86.call(this);
    _this76.type = 'TorusGeometry';
    _this76.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments); // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // helper variables

    var center = new Vector3();
    var vertex = new Vector3();
    var normal = new Vector3(); // generate vertices, normals and uvs

    for (var j = 0; j <= radialSegments; j++) {
      for (var _i239 = 0; _i239 <= tubularSegments; _i239++) {
        var u = _i239 / tubularSegments * arc;
        var v = j / radialSegments * Math.PI * 2; // vertex

        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(_i239 / tubularSegments);
        uvs.push(j / radialSegments);
      }
    } // generate indices


    for (var _j11 = 1; _j11 <= radialSegments; _j11++) {
      for (var _i240 = 1; _i240 <= tubularSegments; _i240++) {
        // indices
        var a = (tubularSegments + 1) * _j11 + _i240 - 1;
        var b = (tubularSegments + 1) * (_j11 - 1) + _i240 - 1;
        var c = (tubularSegments + 1) * (_j11 - 1) + _i240;
        var d = (tubularSegments + 1) * _j11 + _i240; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    _this76.setIndex(indices);

    _this76.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this76.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this76.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    return _this76;
  }

  _createClass(TorusGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
    }
  }]);

  return TorusGeometry;
}(BufferGeometry);

exports.TorusGeometry = exports.TorusBufferGeometry = TorusGeometry;

var TorusKnotGeometry = /*#__PURE__*/function (_BufferGeometry13) {
  _inherits(TorusKnotGeometry, _BufferGeometry13);

  var _super87 = _createSuper(TorusKnotGeometry);

  function TorusKnotGeometry(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
    var _this77;

    _classCallCheck(this, TorusKnotGeometry);

    _this77 = _super87.call(this);
    _this77.type = 'TorusKnotGeometry';
    _this77.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments); // buffers

    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = []; // helper variables

    var vertex = new Vector3();
    var normal = new Vector3();
    var P1 = new Vector3();
    var P2 = new Vector3();
    var B = new Vector3();
    var T = new Vector3();
    var N = new Vector3(); // generate vertices, normals and uvs

    for (var _i241 = 0; _i241 <= tubularSegments; ++_i241) {
      // the radian "u" is used to calculate the position on the torus curve of the current tubular segment
      var u = _i241 / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
      // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

      B.normalize();
      N.normalize();

      for (var j = 0; j <= radialSegments; ++j) {
        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
        var v = j / radialSegments * Math.PI * 2;
        var cx = -tube * Math.cos(v);
        var cy = tube * Math.sin(v); // now calculate the final vertex position.
        // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

        vertex.x = P1.x + (cx * N.x + cy * B.x);
        vertex.y = P1.y + (cx * N.y + cy * B.y);
        vertex.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(_i241 / tubularSegments);
        uvs.push(j / radialSegments);
      }
    } // generate indices


    for (var _j12 = 1; _j12 <= tubularSegments; _j12++) {
      for (var _i242 = 1; _i242 <= radialSegments; _i242++) {
        // indices
        var a = (radialSegments + 1) * (_j12 - 1) + (_i242 - 1);
        var b = (radialSegments + 1) * _j12 + (_i242 - 1);
        var c = (radialSegments + 1) * _j12 + _i242;
        var d = (radialSegments + 1) * (_j12 - 1) + _i242; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    _this77.setIndex(indices);

    _this77.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this77.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this77.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve


    function calculatePositionOnCurve(u, p, q, radius, position) {
      var cu = Math.cos(u);
      var su = Math.sin(u);
      var quOverP = q / p * u;
      var cs = Math.cos(quOverP);
      position.x = radius * (2 + cs) * 0.5 * cu;
      position.y = radius * (2 + cs) * su * 0.5;
      position.z = radius * Math.sin(quOverP) * 0.5;
    }

    return _this77;
  }

  _createClass(TorusKnotGeometry, null, [{
    key: "fromJSON",
    value: function fromJSON(data) {
      return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
    }
  }]);

  return TorusKnotGeometry;
}(BufferGeometry);

exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = TorusKnotGeometry;

var TubeGeometry = /*#__PURE__*/function (_BufferGeometry14) {
  _inherits(TubeGeometry, _BufferGeometry14);

  var _super88 = _createSuper(TubeGeometry);

  function TubeGeometry(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    var _this78;

    _classCallCheck(this, TubeGeometry);

    _this78 = _super88.call(this);
    _this78.type = 'TubeGeometry';
    _this78.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };
    var frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

    _this78.tangents = frames.tangents;
    _this78.normals = frames.normals;
    _this78.binormals = frames.binormals; // helper variables

    var vertex = new Vector3();
    var normal = new Vector3();
    var uv = new Vector2();
    var P = new Vector3(); // buffer

    var vertices = [];
    var normals = [];
    var uvs = [];
    var indices = []; // create buffer data

    generateBufferData(); // build geometry

    _this78.setIndex(indices);

    _this78.setAttribute('position', new Float32BufferAttribute(vertices, 3));

    _this78.setAttribute('normal', new Float32BufferAttribute(normals, 3));

    _this78.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions


    function generateBufferData() {
      for (var _i243 = 0; _i243 < tubularSegments; _i243++) {
        generateSegment(_i243);
      } // if the geometry is not closed, generate the last row of vertices and normals
      // at the regular position on the given path
      //
      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


      generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
      // this makes it easy compute correct values for closed geometries

      generateUVs(); // finally create faces

      generateIndices();
    }

    function generateSegment(i) {
      // we use getPointAt to sample evenly distributed points from the given path
      P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

      var N = frames.normals[i];
      var B = frames.binormals[i]; // generate normals and vertices for the current segment

      for (var j = 0; j <= radialSegments; j++) {
        var v = j / radialSegments * Math.PI * 2;
        var sin = Math.sin(v);
        var cos = -Math.cos(v); // normal

        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z); // vertex

        vertex.x = P.x + radius * normal.x;
        vertex.y = P.y + radius * normal.y;
        vertex.z = P.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }

    function generateIndices() {
      for (var j = 1; j <= tubularSegments; j++) {
        for (var _i244 = 1; _i244 <= radialSegments; _i244++) {
          var a = (radialSegments + 1) * (j - 1) + (_i244 - 1);
          var b = (radialSegments + 1) * j + (_i244 - 1);
          var c = (radialSegments + 1) * j + _i244;
          var d = (radialSegments + 1) * (j - 1) + _i244; // faces

          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }

    function generateUVs() {
      for (var _i245 = 0; _i245 <= tubularSegments; _i245++) {
        for (var j = 0; j <= radialSegments; j++) {
          uv.x = _i245 / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }

    return _this78;
  }

  _createClass(TubeGeometry, [{
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(TubeGeometry.prototype), "toJSON", this).call(this);

      data.path = this.parameters.path.toJSON();
      return data;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(data) {
      // This only works for built-in curves (e.g. CatmullRomCurve3).
      // User defined curves or instances of CurvePath will not be deserialized.
      return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
    }
  }]);

  return TubeGeometry;
}(BufferGeometry);

exports.TubeGeometry = exports.TubeBufferGeometry = TubeGeometry;

var WireframeGeometry = /*#__PURE__*/function (_BufferGeometry15) {
  _inherits(WireframeGeometry, _BufferGeometry15);

  var _super89 = _createSuper(WireframeGeometry);

  function WireframeGeometry(geometry = null) {
    var _this79;

    _classCallCheck(this, WireframeGeometry);

    _this79 = _super89.call(this);
    _this79.type = 'WireframeGeometry';
    _this79.parameters = {
      geometry: geometry
    };

    if (geometry !== null) {
      // buffer
      var vertices = [];
      var edges = new Set(); // helper variables

      var start = new Vector3();
      var end = new Vector3();

      if (geometry.index !== null) {
        // indexed BufferGeometry
        var position = geometry.attributes.position;
        var indices = geometry.index;
        var groups = geometry.groups;

        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: indices.count,
            materialIndex: 0
          }];
        } // create a data structure that contains all edges without duplicates


        for (var o = 0, ol = groups.length; o < ol; ++o) {
          var group = groups[o];
          var groupStart = group.start;
          var groupCount = group.count;

          for (var _i246 = groupStart, l = groupStart + groupCount; _i246 < l; _i246 += 3) {
            for (var j = 0; j < 3; j++) {
              var index1 = indices.getX(_i246 + j);
              var index2 = indices.getX(_i246 + (j + 1) % 3);
              start.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index2);

              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        // non-indexed BufferGeometry
        var _position2 = geometry.attributes.position;

        for (var _i247 = 0, _l11 = _position2.count / 3; _i247 < _l11; _i247++) {
          for (var _j13 = 0; _j13 < 3; _j13++) {
            // three edges per triangle, an edge is represented as (index1, index2)
            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
            var _index = 3 * _i247 + _j13;

            var _index2 = 3 * _i247 + (_j13 + 1) % 3;

            start.fromBufferAttribute(_position2, _index);
            end.fromBufferAttribute(_position2, _index2);

            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      } // build geometry


      _this79.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    }

    return _this79;
  }

  return _createClass(WireframeGeometry);
}(BufferGeometry);

exports.WireframeGeometry = WireframeGeometry;

function isUniqueEdge(start, end, edges) {
  var hash1 = "".concat(start.x, ",").concat(start.y, ",").concat(start.z, "-").concat(end.x, ",").concat(end.y, ",").concat(end.z);
  var hash2 = "".concat(end.x, ",").concat(end.y, ",").concat(end.z, "-").concat(start.x, ",").concat(start.y, ",").concat(start.z); // coincident edge

  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}

var Geometries = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BoxGeometry: BoxGeometry,
  BoxBufferGeometry: BoxGeometry,
  CapsuleGeometry: CapsuleGeometry,
  CapsuleBufferGeometry: CapsuleGeometry,
  CircleGeometry: CircleGeometry,
  CircleBufferGeometry: CircleGeometry,
  ConeGeometry: ConeGeometry,
  ConeBufferGeometry: ConeGeometry,
  CylinderGeometry: CylinderGeometry,
  CylinderBufferGeometry: CylinderGeometry,
  DodecahedronGeometry: DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  EdgesGeometry: EdgesGeometry,
  ExtrudeGeometry: ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  IcosahedronGeometry: IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  LatheGeometry: LatheGeometry,
  LatheBufferGeometry: LatheGeometry,
  OctahedronGeometry: OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronGeometry,
  PlaneGeometry: PlaneGeometry,
  PlaneBufferGeometry: PlaneGeometry,
  PolyhedronGeometry: PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  RingGeometry: RingGeometry,
  RingBufferGeometry: RingGeometry,
  ShapeGeometry: ShapeGeometry,
  ShapeBufferGeometry: ShapeGeometry,
  SphereGeometry: SphereGeometry,
  SphereBufferGeometry: SphereGeometry,
  TetrahedronGeometry: TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TorusGeometry: TorusGeometry,
  TorusBufferGeometry: TorusGeometry,
  TorusKnotGeometry: TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TubeGeometry: TubeGeometry,
  TubeBufferGeometry: TubeGeometry,
  WireframeGeometry: WireframeGeometry
});

var ShadowMaterial = /*#__PURE__*/function (_Material8) {
  _inherits(ShadowMaterial, _Material8);

  var _super90 = _createSuper(ShadowMaterial);

  function ShadowMaterial(parameters) {
    var _this80;

    _classCallCheck(this, ShadowMaterial);

    _this80 = _super90.call(this);
    _this80.type = 'ShadowMaterial';
    _this80.color = new Color(0x000000);
    _this80.transparent = true;

    _this80.setValues(parameters);

    return _this80;
  }

  _createClass(ShadowMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(ShadowMaterial.prototype), "copy", this).call(this, source);

      this.color.copy(source.color);
      return this;
    }
  }]);

  return ShadowMaterial;
}(Material);

exports.ShadowMaterial = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;

var RawShaderMaterial = /*#__PURE__*/function (_ShaderMaterial) {
  _inherits(RawShaderMaterial, _ShaderMaterial);

  var _super91 = _createSuper(RawShaderMaterial);

  function RawShaderMaterial(parameters) {
    var _this81;

    _classCallCheck(this, RawShaderMaterial);

    _this81 = _super91.call(this, parameters);
    _this81.type = 'RawShaderMaterial';
    return _this81;
  }

  return _createClass(RawShaderMaterial);
}(ShaderMaterial);

exports.RawShaderMaterial = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;

var MeshStandardMaterial = /*#__PURE__*/function (_Material9) {
  _inherits(MeshStandardMaterial, _Material9);

  var _super92 = _createSuper(MeshStandardMaterial);

  function MeshStandardMaterial(parameters) {
    var _this82;

    _classCallCheck(this, MeshStandardMaterial);

    _this82 = _super92.call(this);
    _this82.defines = {
      'STANDARD': ''
    };
    _this82.type = 'MeshStandardMaterial';
    _this82.color = new Color(0xffffff); // diffuse

    _this82.roughness = 1.0;
    _this82.metalness = 0.0;
    _this82.map = null;
    _this82.lightMap = null;
    _this82.lightMapIntensity = 1.0;
    _this82.aoMap = null;
    _this82.aoMapIntensity = 1.0;
    _this82.emissive = new Color(0x000000);
    _this82.emissiveIntensity = 1.0;
    _this82.emissiveMap = null;
    _this82.bumpMap = null;
    _this82.bumpScale = 1;
    _this82.normalMap = null;
    _this82.normalMapType = TangentSpaceNormalMap;
    _this82.normalScale = new Vector2(1, 1);
    _this82.displacementMap = null;
    _this82.displacementScale = 1;
    _this82.displacementBias = 0;
    _this82.roughnessMap = null;
    _this82.metalnessMap = null;
    _this82.alphaMap = null;
    _this82.envMap = null;
    _this82.envMapIntensity = 1.0;
    _this82.wireframe = false;
    _this82.wireframeLinewidth = 1;
    _this82.wireframeLinecap = 'round';
    _this82.wireframeLinejoin = 'round';
    _this82.flatShading = false;

    _this82.setValues(parameters);

    return _this82;
  }

  _createClass(MeshStandardMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(MeshStandardMaterial.prototype), "copy", this).call(this, source);

      this.defines = {
        'STANDARD': ''
      };
      this.color.copy(source.color);
      this.roughness = source.roughness;
      this.metalness = source.metalness;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.roughnessMap = source.roughnessMap;
      this.metalnessMap = source.metalnessMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapIntensity = source.envMapIntensity;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      return this;
    }
  }]);

  return MeshStandardMaterial;
}(Material);

exports.MeshStandardMaterial = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

var MeshPhysicalMaterial = /*#__PURE__*/function (_MeshStandardMaterial) {
  _inherits(MeshPhysicalMaterial, _MeshStandardMaterial);

  var _super93 = _createSuper(MeshPhysicalMaterial);

  function MeshPhysicalMaterial(parameters) {
    var _this83;

    _classCallCheck(this, MeshPhysicalMaterial);

    _this83 = _super93.call(this);
    _this83.defines = {
      'STANDARD': '',
      'PHYSICAL': ''
    };
    _this83.type = 'MeshPhysicalMaterial';
    _this83.clearcoatMap = null;
    _this83.clearcoatRoughness = 0.0;
    _this83.clearcoatRoughnessMap = null;
    _this83.clearcoatNormalScale = new Vector2(1, 1);
    _this83.clearcoatNormalMap = null;
    _this83.ior = 1.5;
    Object.defineProperty(_assertThisInitialized(_this83), 'reflectivity', {
      get: function get() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function set(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    _this83.sheenColor = new Color(0x000000);
    _this83.sheenColorMap = null;
    _this83.sheenRoughness = 1.0;
    _this83.sheenRoughnessMap = null;
    _this83.transmissionMap = null;
    _this83.thickness = 0;
    _this83.thicknessMap = null;
    _this83.attenuationDistance = 0.0;
    _this83.attenuationColor = new Color(1, 1, 1);
    _this83.specularIntensity = 1.0;
    _this83.specularIntensityMap = null;
    _this83.specularColor = new Color(1, 1, 1);
    _this83.specularColorMap = null;
    _this83._sheen = 0.0;
    _this83._clearcoat = 0;
    _this83._transmission = 0;

    _this83.setValues(parameters);

    return _this83;
  }

  _createClass(MeshPhysicalMaterial, [{
    key: "sheen",
    get: function get() {
      return this._sheen;
    },
    set: function set(value) {
      if (this._sheen > 0 !== value > 0) {
        this.version++;
      }

      this._sheen = value;
    }
  }, {
    key: "clearcoat",
    get: function get() {
      return this._clearcoat;
    },
    set: function set(value) {
      if (this._clearcoat > 0 !== value > 0) {
        this.version++;
      }

      this._clearcoat = value;
    }
  }, {
    key: "transmission",
    get: function get() {
      return this._transmission;
    },
    set: function set(value) {
      if (this._transmission > 0 !== value > 0) {
        this.version++;
      }

      this._transmission = value;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(MeshPhysicalMaterial.prototype), "copy", this).call(this, source);

      this.defines = {
        'STANDARD': '',
        'PHYSICAL': ''
      };
      this.clearcoat = source.clearcoat;
      this.clearcoatMap = source.clearcoatMap;
      this.clearcoatRoughness = source.clearcoatRoughness;
      this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
      this.clearcoatNormalMap = source.clearcoatNormalMap;
      this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
      this.ior = source.ior;
      this.sheen = source.sheen;
      this.sheenColor.copy(source.sheenColor);
      this.sheenColorMap = source.sheenColorMap;
      this.sheenRoughness = source.sheenRoughness;
      this.sheenRoughnessMap = source.sheenRoughnessMap;
      this.transmission = source.transmission;
      this.transmissionMap = source.transmissionMap;
      this.thickness = source.thickness;
      this.thicknessMap = source.thicknessMap;
      this.attenuationDistance = source.attenuationDistance;
      this.attenuationColor.copy(source.attenuationColor);
      this.specularIntensity = source.specularIntensity;
      this.specularIntensityMap = source.specularIntensityMap;
      this.specularColor.copy(source.specularColor);
      this.specularColorMap = source.specularColorMap;
      return this;
    }
  }]);

  return MeshPhysicalMaterial;
}(MeshStandardMaterial);

exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

var MeshPhongMaterial = /*#__PURE__*/function (_Material10) {
  _inherits(MeshPhongMaterial, _Material10);

  var _super94 = _createSuper(MeshPhongMaterial);

  function MeshPhongMaterial(parameters) {
    var _this84;

    _classCallCheck(this, MeshPhongMaterial);

    _this84 = _super94.call(this);
    _this84.type = 'MeshPhongMaterial';
    _this84.color = new Color(0xffffff); // diffuse

    _this84.specular = new Color(0x111111);
    _this84.shininess = 30;
    _this84.map = null;
    _this84.lightMap = null;
    _this84.lightMapIntensity = 1.0;
    _this84.aoMap = null;
    _this84.aoMapIntensity = 1.0;
    _this84.emissive = new Color(0x000000);
    _this84.emissiveIntensity = 1.0;
    _this84.emissiveMap = null;
    _this84.bumpMap = null;
    _this84.bumpScale = 1;
    _this84.normalMap = null;
    _this84.normalMapType = TangentSpaceNormalMap;
    _this84.normalScale = new Vector2(1, 1);
    _this84.displacementMap = null;
    _this84.displacementScale = 1;
    _this84.displacementBias = 0;
    _this84.specularMap = null;
    _this84.alphaMap = null;
    _this84.envMap = null;
    _this84.combine = MultiplyOperation;
    _this84.reflectivity = 1;
    _this84.refractionRatio = 0.98;
    _this84.wireframe = false;
    _this84.wireframeLinewidth = 1;
    _this84.wireframeLinecap = 'round';
    _this84.wireframeLinejoin = 'round';
    _this84.flatShading = false;

    _this84.setValues(parameters);

    return _this84;
  }

  _createClass(MeshPhongMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(MeshPhongMaterial.prototype), "copy", this).call(this, source);

      this.color.copy(source.color);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      return this;
    }
  }]);

  return MeshPhongMaterial;
}(Material);

exports.MeshPhongMaterial = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

var MeshToonMaterial = /*#__PURE__*/function (_Material11) {
  _inherits(MeshToonMaterial, _Material11);

  var _super95 = _createSuper(MeshToonMaterial);

  function MeshToonMaterial(parameters) {
    var _this85;

    _classCallCheck(this, MeshToonMaterial);

    _this85 = _super95.call(this);
    _this85.defines = {
      'TOON': ''
    };
    _this85.type = 'MeshToonMaterial';
    _this85.color = new Color(0xffffff);
    _this85.map = null;
    _this85.gradientMap = null;
    _this85.lightMap = null;
    _this85.lightMapIntensity = 1.0;
    _this85.aoMap = null;
    _this85.aoMapIntensity = 1.0;
    _this85.emissive = new Color(0x000000);
    _this85.emissiveIntensity = 1.0;
    _this85.emissiveMap = null;
    _this85.bumpMap = null;
    _this85.bumpScale = 1;
    _this85.normalMap = null;
    _this85.normalMapType = TangentSpaceNormalMap;
    _this85.normalScale = new Vector2(1, 1);
    _this85.displacementMap = null;
    _this85.displacementScale = 1;
    _this85.displacementBias = 0;
    _this85.alphaMap = null;
    _this85.wireframe = false;
    _this85.wireframeLinewidth = 1;
    _this85.wireframeLinecap = 'round';
    _this85.wireframeLinejoin = 'round';

    _this85.setValues(parameters);

    return _this85;
  }

  _createClass(MeshToonMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(MeshToonMaterial.prototype), "copy", this).call(this, source);

      this.color.copy(source.color);
      this.map = source.map;
      this.gradientMap = source.gradientMap;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      return this;
    }
  }]);

  return MeshToonMaterial;
}(Material);

exports.MeshToonMaterial = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;

var MeshNormalMaterial = /*#__PURE__*/function (_Material12) {
  _inherits(MeshNormalMaterial, _Material12);

  var _super96 = _createSuper(MeshNormalMaterial);

  function MeshNormalMaterial(parameters) {
    var _this86;

    _classCallCheck(this, MeshNormalMaterial);

    _this86 = _super96.call(this);
    _this86.type = 'MeshNormalMaterial';
    _this86.bumpMap = null;
    _this86.bumpScale = 1;
    _this86.normalMap = null;
    _this86.normalMapType = TangentSpaceNormalMap;
    _this86.normalScale = new Vector2(1, 1);
    _this86.displacementMap = null;
    _this86.displacementScale = 1;
    _this86.displacementBias = 0;
    _this86.wireframe = false;
    _this86.wireframeLinewidth = 1;
    _this86.fog = false;
    _this86.flatShading = false;

    _this86.setValues(parameters);

    return _this86;
  }

  _createClass(MeshNormalMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(MeshNormalMaterial.prototype), "copy", this).call(this, source);

      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.flatShading = source.flatShading;
      return this;
    }
  }]);

  return MeshNormalMaterial;
}(Material);

exports.MeshNormalMaterial = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

var MeshLambertMaterial = /*#__PURE__*/function (_Material13) {
  _inherits(MeshLambertMaterial, _Material13);

  var _super97 = _createSuper(MeshLambertMaterial);

  function MeshLambertMaterial(parameters) {
    var _this87;

    _classCallCheck(this, MeshLambertMaterial);

    _this87 = _super97.call(this);
    _this87.type = 'MeshLambertMaterial';
    _this87.color = new Color(0xffffff); // diffuse

    _this87.map = null;
    _this87.lightMap = null;
    _this87.lightMapIntensity = 1.0;
    _this87.aoMap = null;
    _this87.aoMapIntensity = 1.0;
    _this87.emissive = new Color(0x000000);
    _this87.emissiveIntensity = 1.0;
    _this87.emissiveMap = null;
    _this87.specularMap = null;
    _this87.alphaMap = null;
    _this87.envMap = null;
    _this87.combine = MultiplyOperation;
    _this87.reflectivity = 1;
    _this87.refractionRatio = 0.98;
    _this87.wireframe = false;
    _this87.wireframeLinewidth = 1;
    _this87.wireframeLinecap = 'round';
    _this87.wireframeLinejoin = 'round';

    _this87.setValues(parameters);

    return _this87;
  }

  _createClass(MeshLambertMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(MeshLambertMaterial.prototype), "copy", this).call(this, source);

      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      return this;
    }
  }]);

  return MeshLambertMaterial;
}(Material);

exports.MeshLambertMaterial = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

var MeshMatcapMaterial = /*#__PURE__*/function (_Material14) {
  _inherits(MeshMatcapMaterial, _Material14);

  var _super98 = _createSuper(MeshMatcapMaterial);

  function MeshMatcapMaterial(parameters) {
    var _this88;

    _classCallCheck(this, MeshMatcapMaterial);

    _this88 = _super98.call(this);
    _this88.defines = {
      'MATCAP': ''
    };
    _this88.type = 'MeshMatcapMaterial';
    _this88.color = new Color(0xffffff); // diffuse

    _this88.matcap = null;
    _this88.map = null;
    _this88.bumpMap = null;
    _this88.bumpScale = 1;
    _this88.normalMap = null;
    _this88.normalMapType = TangentSpaceNormalMap;
    _this88.normalScale = new Vector2(1, 1);
    _this88.displacementMap = null;
    _this88.displacementScale = 1;
    _this88.displacementBias = 0;
    _this88.alphaMap = null;
    _this88.flatShading = false;

    _this88.setValues(parameters);

    return _this88;
  }

  _createClass(MeshMatcapMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(MeshMatcapMaterial.prototype), "copy", this).call(this, source);

      this.defines = {
        'MATCAP': ''
      };
      this.color.copy(source.color);
      this.matcap = source.matcap;
      this.map = source.map;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.flatShading = source.flatShading;
      return this;
    }
  }]);

  return MeshMatcapMaterial;
}(Material);

exports.MeshMatcapMaterial = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

var LineDashedMaterial = /*#__PURE__*/function (_LineBasicMaterial) {
  _inherits(LineDashedMaterial, _LineBasicMaterial);

  var _super99 = _createSuper(LineDashedMaterial);

  function LineDashedMaterial(parameters) {
    var _this89;

    _classCallCheck(this, LineDashedMaterial);

    _this89 = _super99.call(this);
    _this89.type = 'LineDashedMaterial';
    _this89.scale = 1;
    _this89.dashSize = 3;
    _this89.gapSize = 1;

    _this89.setValues(parameters);

    return _this89;
  }

  _createClass(LineDashedMaterial, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(LineDashedMaterial.prototype), "copy", this).call(this, source);

      this.scale = source.scale;
      this.dashSize = source.dashSize;
      this.gapSize = source.gapSize;
      return this;
    }
  }]);

  return LineDashedMaterial;
}(LineBasicMaterial);

exports.LineDashedMaterial = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
var materialLib = {
  ShadowMaterial: ShadowMaterial,
  SpriteMaterial: SpriteMaterial,
  RawShaderMaterial: RawShaderMaterial,
  ShaderMaterial: ShaderMaterial,
  PointsMaterial: PointsMaterial,
  MeshPhysicalMaterial: MeshPhysicalMaterial,
  MeshStandardMaterial: MeshStandardMaterial,
  MeshPhongMaterial: MeshPhongMaterial,
  MeshToonMaterial: MeshToonMaterial,
  MeshNormalMaterial: MeshNormalMaterial,
  MeshLambertMaterial: MeshLambertMaterial,
  MeshDepthMaterial: MeshDepthMaterial,
  MeshDistanceMaterial: MeshDistanceMaterial,
  MeshBasicMaterial: MeshBasicMaterial,
  MeshMatcapMaterial: MeshMatcapMaterial,
  LineDashedMaterial: LineDashedMaterial,
  LineBasicMaterial: LineBasicMaterial,
  Material: Material
};

Material.fromType = function (type) {
  return new materialLib[type]();
};

var AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function arraySlice(array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      // in ios9 array.subarray(from, undefined) will return empty array
      // but array.subarray(from) or array.subarray(from, len) is correct
      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
    }

    return array.slice(from, to);
  },
  // converts an array to a specific type
  convertArray: function convertArray(array, type, forceClone) {
    if (!array || // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type) return array;

    if (typeof type.BYTES_PER_ELEMENT === 'number') {
      return new type(array); // create typed array
    }

    return Array.prototype.slice.call(array); // create Array
  },
  isTypedArray: function isTypedArray(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function getKeyframeOrder(times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }

    var n = times.length;
    var result = new Array(n);

    for (var _i248 = 0; _i248 !== n; ++_i248) {
      result[_i248] = _i248;
    }

    result.sort(compareTime);
    return result;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function sortedArray(values, stride, order) {
    var nValues = values.length;
    var result = new values.constructor(nValues);

    for (var _i249 = 0, dstOffset = 0; dstOffset !== nValues; ++_i249) {
      var srcOffset = order[_i249] * stride;

      for (var j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }

    return result;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function flattenJSON(jsonKeys, times, values, valuePropertyName) {
    var i = 1,
        key = jsonKeys[0];

    while (key !== undefined && key[valuePropertyName] === undefined) {
      key = jsonKeys[i++];
    }

    if (key === undefined) return; // no data

    var value = key[valuePropertyName];
    if (value === undefined) return; // no data

    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push.apply(values, value); // push all elements
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else if (value.toArray !== undefined) {
      // ...assume THREE.Math-ish
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          value.toArray(values, values.length);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else {
      // otherwise push as-is
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push(value);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    }
  },
  subclip: function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
    var clip = sourceClip.clone();
    clip.name = name;
    var tracks = [];

    for (var _i250 = 0; _i250 < clip.tracks.length; ++_i250) {
      var track = clip.tracks[_i250];
      var valueSize = track.getValueSize();
      var times = [];
      var values = [];

      for (var j = 0; j < track.times.length; ++j) {
        var frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame) continue;
        times.push(track.times[j]);

        for (var k = 0; k < valueSize; ++k) {
          values.push(track.values[j * valueSize + k]);
        }
      }

      if (times.length === 0) continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }

    clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip

    var minStartTime = Infinity;

    for (var _i251 = 0; _i251 < clip.tracks.length; ++_i251) {
      if (minStartTime > clip.tracks[_i251].times[0]) {
        minStartTime = clip.tracks[_i251].times[0];
      }
    } // shift all tracks such that clip begins at t=0


    for (var _i252 = 0; _i252 < clip.tracks.length; ++_i252) {
      clip.tracks[_i252].shift(-1 * minStartTime);
    }

    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0) fps = 30;
    var numTracks = referenceClip.tracks.length;
    var referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame

    var _loop = function _loop(_i253) {
      var referenceTrack = referenceClip.tracks[_i253];
      var referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric

      if (referenceTrackType === 'bool' || referenceTrackType === 'string') return "continue"; // Find the track in the target clip whose name and type matches the reference track

      var targetTrack = targetClip.tracks.find(function (track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === undefined) return "continue";
      var referenceOffset = 0;
      var referenceValueSize = referenceTrack.getValueSize();

      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }

      var targetOffset = 0;
      var targetValueSize = targetTrack.getValueSize();

      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }

      var lastIndex = referenceTrack.times.length - 1;
      var referenceValue = void 0; // Find the value to subtract out of the track

      if (referenceTime <= referenceTrack.times[0]) {
        // Reference frame is earlier than the first keyframe, so just use the first keyframe
        var startIndex = referenceOffset;
        var endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        // Reference frame is after the last keyframe, so just use the last keyframe
        var _startIndex = lastIndex * referenceValueSize + referenceOffset;

        var _endIndex = _startIndex + referenceValueSize - referenceOffset;

        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, _startIndex, _endIndex);
      } else {
        // Interpolate to the reference value
        var interpolant = referenceTrack.createInterpolant();
        var _startIndex2 = referenceOffset;

        var _endIndex2 = referenceValueSize - referenceOffset;

        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, _startIndex2, _endIndex2);
      } // Conjugate the quaternion


      if (referenceTrackType === 'quaternion') {
        var referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      } // Subtract the reference value from all of the track values


      var numTimes = targetTrack.times.length;

      for (var j = 0; j < numTimes; ++j) {
        var valueStart = j * targetValueSize + targetOffset;

        if (referenceTrackType === 'quaternion') {
          // Multiply the conjugate for quaternion track types
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          var valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types

          for (var k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    };

    for (var _i253 = 0; _i253 < numTracks; ++_i253) {
      var _ret = _loop(_i253);

      if (_ret === "continue") continue;
    }

    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

exports.AnimationUtils = AnimationUtils;

var Interpolant = /*#__PURE__*/function () {
  function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    _classCallCheck(this, Interpolant);

    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }

  _createClass(Interpolant, [{
    key: "evaluate",
    value: function evaluate(t) {
      var pp = this.parameterPositions;
      var i1 = this._cachedIndex,
          t1 = pp[i1],
          t0 = pp[i1 - 1];

      validate_interval: {
        seek: {
          var right;

          linear_scan: {
            //- See http://jsperf.com/comparison-to-undefined/3
            //- slower code:
            //-
            //- 				if ( t >= t1 || t1 === undefined ) {
            forward_scan: if (!(t < t1)) {
              for (var giveUpAt = i1 + 2;;) {
                if (t1 === undefined) {
                  if (t < t0) break forward_scan; // after end

                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t, t0);
                }

                if (i1 === giveUpAt) break; // this loop

                t0 = t1;
                t1 = pp[++i1];

                if (t < t1) {
                  // we have arrived at the sought interval
                  break seek;
                }
              } // prepare binary search on the right side of the index


              right = pp.length;
              break linear_scan;
            } //- slower code:
            //-					if ( t < t0 || t0 === undefined ) {


            if (!(t >= t0)) {
              // looping?
              var t1global = pp[1];

              if (t < t1global) {
                i1 = 2; // + 1, using the scan for the details

                t0 = t1global;
              } // linear reverse scan


              for (var _giveUpAt = i1 - 2;;) {
                if (t0 === undefined) {
                  // before start
                  this._cachedIndex = 0;
                  return this.beforeStart_(0, t, t1);
                }

                if (i1 === _giveUpAt) break; // this loop

                t1 = t0;
                t0 = pp[--i1 - 1];

                if (t >= t0) {
                  // we have arrived at the sought interval
                  break seek;
                }
              } // prepare binary search on the left side of the index


              right = i1;
              i1 = 0;
              break linear_scan;
            } // the interval is valid


            break validate_interval;
          } // linear scan
          // binary search


          while (i1 < right) {
            var mid = i1 + right >>> 1;

            if (t < pp[mid]) {
              right = mid;
            } else {
              i1 = mid + 1;
            }
          }

          t1 = pp[i1];
          t0 = pp[i1 - 1]; // check boundary cases, again

          if (t0 === undefined) {
            this._cachedIndex = 0;
            return this.beforeStart_(0, t, t1);
          }

          if (t1 === undefined) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.afterEnd_(i1 - 1, t0, t);
          }
        } // seek


        this._cachedIndex = i1;
        this.intervalChanged_(i1, t0, t1);
      } // validate_interval


      return this.interpolate_(i1, t0, t, t1);
    }
  }, {
    key: "getSettings_",
    value: function getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
  }, {
    key: "copySampleValue_",
    value: function copySampleValue_(index) {
      // copies a sample value to the result buffer
      var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset = index * stride;

      for (var _i254 = 0; _i254 !== stride; ++_i254) {
        result[_i254] = values[offset + _i254];
      }

      return result;
    } // Template methods for derived classes:

  }, {
    key: "interpolate_",
    value: function
      /* i1, t0, t, t1 */
    interpolate_() {
      throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
    }
  }, {
    key: "intervalChanged_",
    value: function
      /* i1, t0, t1 */
    intervalChanged_() {// empty
    }
  }]);

  return Interpolant;
}(); // ALIAS DEFINITIONS


exports.Interpolant = Interpolant;
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

var CubicInterpolant = /*#__PURE__*/function (_Interpolant) {
  _inherits(CubicInterpolant, _Interpolant);

  var _super100 = _createSuper(CubicInterpolant);

  function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    var _this90;

    _classCallCheck(this, CubicInterpolant);

    _this90 = _super100.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    _this90._weightPrev = -0;
    _this90._offsetPrev = -0;
    _this90._weightNext = -0;
    _this90._offsetNext = -0;
    _this90.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    return _this90;
  }

  _createClass(CubicInterpolant, [{
    key: "intervalChanged_",
    value: function intervalChanged_(i1, t0, t1) {
      var pp = this.parameterPositions;
      var iPrev = i1 - 2,
          iNext = i1 + 1,
          tPrev = pp[iPrev],
          tNext = pp[iNext];

      if (tPrev === undefined) {
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            // f'(t0) = 0
            iPrev = i1;
            tPrev = 2 * t0 - t1;
            break;

          case WrapAroundEnding:
            // use the other end of the curve
            iPrev = pp.length - 2;
            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
            break;

          default:
            // ZeroCurvatureEnding
            // f''(t0) = 0 a.k.a. Natural Spline
            iPrev = i1;
            tPrev = t1;
        }
      }

      if (tNext === undefined) {
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            // f'(tN) = 0
            iNext = i1;
            tNext = 2 * t1 - t0;
            break;

          case WrapAroundEnding:
            // use the other end of the curve
            iNext = 1;
            tNext = t1 + pp[1] - pp[0];
            break;

          default:
            // ZeroCurvatureEnding
            // f''(tN) = 0, a.k.a. Natural Spline
            iNext = i1 - 1;
            tNext = t0;
        }
      }

      var halfDt = (t1 - t0) * 0.5,
          stride = this.valueSize;
      this._weightPrev = halfDt / (t0 - tPrev);
      this._weightNext = halfDt / (tNext - t1);
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;
    }
  }, {
    key: "interpolate_",
    value: function interpolate_(i1, t0, t, t1) {
      var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          o1 = i1 * stride,
          o0 = o1 - stride,
          oP = this._offsetPrev,
          oN = this._offsetNext,
          wP = this._weightPrev,
          wN = this._weightNext,
          p = (t - t0) / (t1 - t0),
          pp = p * p,
          ppp = pp * p; // evaluate polynomials

      var sP = -wP * ppp + 2 * wP * pp - wP * p;
      var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
      var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
      var sN = wN * ppp - wN * pp; // combine data linearly

      for (var _i255 = 0; _i255 !== stride; ++_i255) {
        result[_i255] = sP * values[oP + _i255] + s0 * values[o0 + _i255] + s1 * values[o1 + _i255] + sN * values[oN + _i255];
      }

      return result;
    }
  }]);

  return CubicInterpolant;
}(Interpolant);

exports.CubicInterpolant = CubicInterpolant;

var LinearInterpolant = /*#__PURE__*/function (_Interpolant2) {
  _inherits(LinearInterpolant, _Interpolant2);

  var _super101 = _createSuper(LinearInterpolant);

  function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    _classCallCheck(this, LinearInterpolant);

    return _super101.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  _createClass(LinearInterpolant, [{
    key: "interpolate_",
    value: function interpolate_(i1, t0, t, t1) {
      var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset1 = i1 * stride,
          offset0 = offset1 - stride,
          weight1 = (t - t0) / (t1 - t0),
          weight0 = 1 - weight1;

      for (var _i256 = 0; _i256 !== stride; ++_i256) {
        result[_i256] = values[offset0 + _i256] * weight0 + values[offset1 + _i256] * weight1;
      }

      return result;
    }
  }]);

  return LinearInterpolant;
}(Interpolant);
/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */


exports.LinearInterpolant = LinearInterpolant;

var DiscreteInterpolant = /*#__PURE__*/function (_Interpolant3) {
  _inherits(DiscreteInterpolant, _Interpolant3);

  var _super102 = _createSuper(DiscreteInterpolant);

  function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    _classCallCheck(this, DiscreteInterpolant);

    return _super102.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  _createClass(DiscreteInterpolant, [{
    key: "interpolate_",
    value: function interpolate_(i1
    /*, t0, t, t1 */
    ) {
      return this.copySampleValue_(i1 - 1);
    }
  }]);

  return DiscreteInterpolant;
}(Interpolant);

exports.DiscreteInterpolant = DiscreteInterpolant;

var KeyframeTrack = /*#__PURE__*/function () {
  function KeyframeTrack(name, times, values, interpolation) {
    _classCallCheck(this, KeyframeTrack);

    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  } // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):


  _createClass(KeyframeTrack, [{
    key: "InterpolantFactoryMethodDiscrete",
    value: function InterpolantFactoryMethodDiscrete(result) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  }, {
    key: "InterpolantFactoryMethodLinear",
    value: function InterpolantFactoryMethodLinear(result) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  }, {
    key: "InterpolantFactoryMethodSmooth",
    value: function InterpolantFactoryMethodSmooth(result) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  }, {
    key: "setInterpolation",
    value: function setInterpolation(interpolation) {
      var factoryMethod;

      switch (interpolation) {
        case InterpolateDiscrete:
          factoryMethod = this.InterpolantFactoryMethodDiscrete;
          break;

        case InterpolateLinear:
          factoryMethod = this.InterpolantFactoryMethodLinear;
          break;

        case InterpolateSmooth:
          factoryMethod = this.InterpolantFactoryMethodSmooth;
          break;
      }

      if (factoryMethod === undefined) {
        var message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;

        if (this.createInterpolant === undefined) {
          // fall back to default, unless the default itself is messed up
          if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else {
            throw new Error(message); // fatal, in this case
          }
        }

        console.warn('THREE.KeyframeTrack:', message);
        return this;
      }

      this.createInterpolant = factoryMethod;
      return this;
    }
  }, {
    key: "getInterpolation",
    value: function getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;

        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;

        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    }
  }, {
    key: "getValueSize",
    value: function getValueSize() {
      return this.values.length / this.times.length;
    } // move all keyframes either forwards or backwards in time

  }, {
    key: "shift",
    value: function shift(timeOffset) {
      if (timeOffset !== 0.0) {
        var times = this.times;

        for (var _i257 = 0, n = times.length; _i257 !== n; ++_i257) {
          times[_i257] += timeOffset;
        }
      }

      return this;
    } // scale all keyframe times by a factor (useful for frame <-> seconds conversions)

  }, {
    key: "scale",
    value: function scale(timeScale) {
      if (timeScale !== 1.0) {
        var times = this.times;

        for (var _i258 = 0, n = times.length; _i258 !== n; ++_i258) {
          times[_i258] *= timeScale;
        }
      }

      return this;
    } // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values

  }, {
    key: "trim",
    value: function trim(startTime, endTime) {
      var times = this.times,
          nKeys = times.length;
      var from = 0,
          to = nKeys - 1;

      while (from !== nKeys && times[from] < startTime) {
        ++from;
      }

      while (to !== -1 && times[to] > endTime) {
        --to;
      }

      ++to; // inclusive -> exclusive bound

      if (from !== 0 || to !== nKeys) {
        // empty tracks are forbidden, so keep at least one keyframe
        if (from >= to) {
          to = Math.max(to, 1);
          from = to - 1;
        }

        var stride = this.getValueSize();
        this.times = AnimationUtils.arraySlice(times, from, to);
        this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
      }

      return this;
    } // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable

  }, {
    key: "validate",
    value: function validate() {
      var valid = true;
      var valueSize = this.getValueSize();

      if (valueSize - Math.floor(valueSize) !== 0) {
        console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
        valid = false;
      }

      var times = this.times,
          values = this.values,
          nKeys = times.length;

      if (nKeys === 0) {
        console.error('THREE.KeyframeTrack: Track is empty.', this);
        valid = false;
      }

      var prevTime = null;

      for (var _i259 = 0; _i259 !== nKeys; _i259++) {
        var currTime = times[_i259];

        if (typeof currTime === 'number' && isNaN(currTime)) {
          console.error('THREE.KeyframeTrack: Time is not a valid number.', this, _i259, currTime);
          valid = false;
          break;
        }

        if (prevTime !== null && prevTime > currTime) {
          console.error('THREE.KeyframeTrack: Out of order keys.', this, _i259, currTime, prevTime);
          valid = false;
          break;
        }

        prevTime = currTime;
      }

      if (values !== undefined) {
        if (AnimationUtils.isTypedArray(values)) {
          for (var _i260 = 0, n = values.length; _i260 !== n; ++_i260) {
            var _value5 = values[_i260];

            if (isNaN(_value5)) {
              console.error('THREE.KeyframeTrack: Value is not a valid number.', this, _i260, _value5);
              valid = false;
              break;
            }
          }
        }
      }

      return valid;
    } // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)

  }, {
    key: "optimize",
    value: function optimize() {
      // times or values may be shared with other tracks, so overwriting is unsafe
      var times = AnimationUtils.arraySlice(this.times),
          values = AnimationUtils.arraySlice(this.values),
          stride = this.getValueSize(),
          smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
          lastIndex = times.length - 1;
      var writeIndex = 1;

      for (var _i261 = 1; _i261 < lastIndex; ++_i261) {
        var keep = false;
        var time = times[_i261];
        var timeNext = times[_i261 + 1]; // remove adjacent keyframes scheduled at the same time

        if (time !== timeNext && (_i261 !== 1 || time !== times[0])) {
          if (!smoothInterpolation) {
            // remove unnecessary keyframes same as their neighbors
            var offset = _i261 * stride,
                offsetP = offset - stride,
                offsetN = offset + stride;

            for (var j = 0; j !== stride; ++j) {
              var _value6 = values[offset + j];

              if (_value6 !== values[offsetP + j] || _value6 !== values[offsetN + j]) {
                keep = true;
                break;
              }
            }
          } else {
            keep = true;
          }
        } // in-place compaction


        if (keep) {
          if (_i261 !== writeIndex) {
            times[writeIndex] = times[_i261];
            var readOffset = _i261 * stride,
                writeOffset = writeIndex * stride;

            for (var _j14 = 0; _j14 !== stride; ++_j14) {
              values[writeOffset + _j14] = values[readOffset + _j14];
            }
          }

          ++writeIndex;
        }
      } // flush last keyframe (compaction looks ahead)


      if (lastIndex > 0) {
        times[writeIndex] = times[lastIndex];

        for (var _readOffset = lastIndex * stride, _writeOffset = writeIndex * stride, _j15 = 0; _j15 !== stride; ++_j15) {
          values[_writeOffset + _j15] = values[_readOffset + _j15];
        }

        ++writeIndex;
      }

      if (writeIndex !== times.length) {
        this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
        this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
      } else {
        this.times = times;
        this.values = values;
      }

      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var times = AnimationUtils.arraySlice(this.times, 0);
      var values = AnimationUtils.arraySlice(this.values, 0);
      var TypedKeyframeTrack = this.constructor;
      var track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

      track.createInterpolant = this.createInterpolant;
      return track;
    }
  }], [{
    key: "toJSON",
    value: function toJSON(track) {
      var trackType = track.constructor;
      var json; // derived classes can define a static toJSON method

      if (trackType.toJSON !== this.toJSON) {
        json = trackType.toJSON(track);
      } else {
        // by default, we assume the data can be serialized as-is
        json = {
          'name': track.name,
          'times': AnimationUtils.convertArray(track.times, Array),
          'values': AnimationUtils.convertArray(track.values, Array)
        };
        var interpolation = track.getInterpolation();

        if (interpolation !== track.DefaultInterpolation) {
          json.interpolation = interpolation;
        }
      }

      json.type = track.ValueTypeName; // mandatory

      return json;
    }
  }]);

  return KeyframeTrack;
}();

exports.KeyframeTrack = KeyframeTrack;
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
/**
 * A Track of Boolean keyframe values.
 */

var BooleanKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack) {
  _inherits(BooleanKeyframeTrack, _KeyframeTrack);

  var _super103 = _createSuper(BooleanKeyframeTrack);

  function BooleanKeyframeTrack() {
    _classCallCheck(this, BooleanKeyframeTrack);

    return _super103.apply(this, arguments);
  }

  return _createClass(BooleanKeyframeTrack);
}(KeyframeTrack);

exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track of keyframe values that represent color.
 */

var ColorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack2) {
  _inherits(ColorKeyframeTrack, _KeyframeTrack2);

  var _super104 = _createSuper(ColorKeyframeTrack);

  function ColorKeyframeTrack() {
    _classCallCheck(this, ColorKeyframeTrack);

    return _super104.apply(this, arguments);
  }

  return _createClass(ColorKeyframeTrack);
}(KeyframeTrack);

exports.ColorKeyframeTrack = ColorKeyframeTrack;
ColorKeyframeTrack.prototype.ValueTypeName = 'color';
/**
 * A Track of numeric keyframe values.
 */

var NumberKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack3) {
  _inherits(NumberKeyframeTrack, _KeyframeTrack3);

  var _super105 = _createSuper(NumberKeyframeTrack);

  function NumberKeyframeTrack() {
    _classCallCheck(this, NumberKeyframeTrack);

    return _super105.apply(this, arguments);
  }

  return _createClass(NumberKeyframeTrack);
}(KeyframeTrack);

exports.NumberKeyframeTrack = NumberKeyframeTrack;
NumberKeyframeTrack.prototype.ValueTypeName = 'number';
/**
 * Spherical linear unit quaternion interpolant.
 */

var QuaternionLinearInterpolant = /*#__PURE__*/function (_Interpolant4) {
  _inherits(QuaternionLinearInterpolant, _Interpolant4);

  var _super106 = _createSuper(QuaternionLinearInterpolant);

  function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    _classCallCheck(this, QuaternionLinearInterpolant);

    return _super106.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  _createClass(QuaternionLinearInterpolant, [{
    key: "interpolate_",
    value: function interpolate_(i1, t0, t, t1) {
      var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          alpha = (t - t0) / (t1 - t0);
      var offset = i1 * stride;

      for (var end = offset + stride; offset !== end; offset += 4) {
        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
      }

      return result;
    }
  }]);

  return QuaternionLinearInterpolant;
}(Interpolant);
/**
 * A Track of quaternion keyframe values.
 */


exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;

var QuaternionKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack4) {
  _inherits(QuaternionKeyframeTrack, _KeyframeTrack4);

  var _super107 = _createSuper(QuaternionKeyframeTrack);

  function QuaternionKeyframeTrack() {
    _classCallCheck(this, QuaternionKeyframeTrack);

    return _super107.apply(this, arguments);
  }

  _createClass(QuaternionKeyframeTrack, [{
    key: "InterpolantFactoryMethodLinear",
    value: function InterpolantFactoryMethodLinear(result) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  }]);

  return QuaternionKeyframeTrack;
}(KeyframeTrack);

exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited

QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track that interpolates Strings
 */

var StringKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack5) {
  _inherits(StringKeyframeTrack, _KeyframeTrack5);

  var _super108 = _createSuper(StringKeyframeTrack);

  function StringKeyframeTrack() {
    _classCallCheck(this, StringKeyframeTrack);

    return _super108.apply(this, arguments);
  }

  return _createClass(StringKeyframeTrack);
}(KeyframeTrack);

exports.StringKeyframeTrack = StringKeyframeTrack;
StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track of vectored keyframe values.
 */

var VectorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack6) {
  _inherits(VectorKeyframeTrack, _KeyframeTrack6);

  var _super109 = _createSuper(VectorKeyframeTrack);

  function VectorKeyframeTrack() {
    _classCallCheck(this, VectorKeyframeTrack);

    return _super109.apply(this, arguments);
  }

  return _createClass(VectorKeyframeTrack);
}(KeyframeTrack);

exports.VectorKeyframeTrack = VectorKeyframeTrack;
VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

var AnimationClip = /*#__PURE__*/function () {
  function AnimationClip(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    _classCallCheck(this, AnimationClip);

    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks

    if (this.duration < 0) {
      this.resetDuration();
    }
  }

  _createClass(AnimationClip, [{
    key: "resetDuration",
    value: function resetDuration() {
      var tracks = this.tracks;
      var duration = 0;

      for (var _i262 = 0, n = tracks.length; _i262 !== n; ++_i262) {
        var track = this.tracks[_i262];
        duration = Math.max(duration, track.times[track.times.length - 1]);
      }

      this.duration = duration;
      return this;
    }
  }, {
    key: "trim",
    value: function trim() {
      for (var _i263 = 0; _i263 < this.tracks.length; _i263++) {
        this.tracks[_i263].trim(0, this.duration);
      }

      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var valid = true;

      for (var _i264 = 0; _i264 < this.tracks.length; _i264++) {
        valid = valid && this.tracks[_i264].validate();
      }

      return valid;
    }
  }, {
    key: "optimize",
    value: function optimize() {
      for (var _i265 = 0; _i265 < this.tracks.length; _i265++) {
        this.tracks[_i265].optimize();
      }

      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var tracks = [];

      for (var _i266 = 0; _i266 < this.tracks.length; _i266++) {
        tracks.push(this.tracks[_i266].clone());
      }

      return new this.constructor(this.name, this.duration, tracks, this.blendMode);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.constructor.toJSON(this);
    }
  }], [{
    key: "parse",
    value: function parse(json) {
      var tracks = [],
          jsonTracks = json.tracks,
          frameTime = 1.0 / (json.fps || 1.0);

      for (var _i267 = 0, n = jsonTracks.length; _i267 !== n; ++_i267) {
        tracks.push(parseKeyframeTrack(jsonTracks[_i267]).scale(frameTime));
      }

      var clip = new this(json.name, json.duration, tracks, json.blendMode);
      clip.uuid = json.uuid;
      return clip;
    }
  }, {
    key: "toJSON",
    value: function toJSON(clip) {
      var tracks = [],
          clipTracks = clip.tracks;
      var json = {
        'name': clip.name,
        'duration': clip.duration,
        'tracks': tracks,
        'uuid': clip.uuid,
        'blendMode': clip.blendMode
      };

      for (var _i268 = 0, n = clipTracks.length; _i268 !== n; ++_i268) {
        tracks.push(KeyframeTrack.toJSON(clipTracks[_i268]));
      }

      return json;
    }
  }, {
    key: "CreateFromMorphTargetSequence",
    value: function CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
      var numMorphTargets = morphTargetSequence.length;
      var tracks = [];

      for (var _i269 = 0; _i269 < numMorphTargets; _i269++) {
        var times = [];
        var values = [];
        times.push((_i269 + numMorphTargets - 1) % numMorphTargets, _i269, (_i269 + 1) % numMorphTargets);
        values.push(0, 1, 0);
        var order = AnimationUtils.getKeyframeOrder(times);
        times = AnimationUtils.sortedArray(times, 1, order);
        values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
        // last frame as well for perfect loop.

        if (!noLoop && times[0] === 0) {
          times.push(numMorphTargets);
          values.push(values[0]);
        }

        tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[_i269].name + ']', times, values).scale(1.0 / fps));
      }

      return new this(name, -1, tracks);
    }
  }, {
    key: "findByName",
    value: function findByName(objectOrClipArray, name) {
      var clipArray = objectOrClipArray;

      if (!Array.isArray(objectOrClipArray)) {
        var o = objectOrClipArray;
        clipArray = o.geometry && o.geometry.animations || o.animations;
      }

      for (var _i270 = 0; _i270 < clipArray.length; _i270++) {
        if (clipArray[_i270].name === name) {
          return clipArray[_i270];
        }
      }

      return null;
    }
  }, {
    key: "CreateClipsFromMorphTargetSequences",
    value: function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
      var animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
      // such flamingo_flyA_003, flamingo_run1_003, crdeath0059

      var pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
      // patterns like Walk_001, Walk_002, Run_001, Run_002

      for (var _i271 = 0, il = morphTargets.length; _i271 < il; _i271++) {
        var morphTarget = morphTargets[_i271];
        var parts = morphTarget.name.match(pattern);

        if (parts && parts.length > 1) {
          var name = parts[1];
          var animationMorphTargets = animationToMorphTargets[name];

          if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
          }

          animationMorphTargets.push(morphTarget);
        }
      }

      var clips = [];

      for (var _name4 in animationToMorphTargets) {
        clips.push(this.CreateFromMorphTargetSequence(_name4, animationToMorphTargets[_name4], fps, noLoop));
      }

      return clips;
    } // parse the animation.hierarchy format

  }, {
    key: "parseAnimation",
    value: function parseAnimation(animation, bones) {
      if (!animation) {
        console.error('THREE.AnimationClip: No animation in JSONLoader data.');
        return null;
      }

      var addNonemptyTrack = function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {
        // only return track if there are actually keys.
        if (animationKeys.length !== 0) {
          var times = [];
          var values = [];
          AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

          if (times.length !== 0) {
            destTracks.push(new trackType(trackName, times, values));
          }
        }
      };

      var tracks = [];
      var clipName = animation.name || 'default';
      var fps = animation.fps || 30;
      var blendMode = animation.blendMode; // automatic length determination in AnimationClip.

      var duration = animation.length || -1;
      var hierarchyTracks = animation.hierarchy || [];

      for (var h = 0; h < hierarchyTracks.length; h++) {
        var animationKeys = hierarchyTracks[h].keys; // skip empty tracks

        if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

        if (animationKeys[0].morphTargets) {
          // figure out all morph targets used in this track
          var morphTargetNames = {};
          var k = void 0;

          for (k = 0; k < animationKeys.length; k++) {
            if (animationKeys[k].morphTargets) {
              for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
              }
            }
          } // create a track for each morph target with all zero
          // morphTargetInfluences except for the keys in which
          // the morphTarget is named.


          for (var morphTargetName in morphTargetNames) {
            var times = [];
            var values = [];

            for (var _m = 0; _m !== animationKeys[k].morphTargets.length; ++_m) {
              var animationKey = animationKeys[k];
              times.push(animationKey.time);
              values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
            }

            tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
          }

          duration = morphTargetNames.length * fps;
        } else {
          // ...assume skeletal animation
          var boneName = '.bones[' + bones[h].name + ']';
          addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
          addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
          addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
        }
      }

      if (tracks.length === 0) {
        return null;
      }

      var clip = new this(clipName, duration, tracks, blendMode);
      return clip;
    }
  }]);

  return AnimationClip;
}();

exports.AnimationClip = AnimationClip;

function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return NumberKeyframeTrack;

    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return VectorKeyframeTrack;

    case 'color':
      return ColorKeyframeTrack;

    case 'quaternion':
      return QuaternionKeyframeTrack;

    case 'bool':
    case 'boolean':
      return BooleanKeyframeTrack;

    case 'string':
      return StringKeyframeTrack;
  }

  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}

function parseKeyframeTrack(json) {
  if (json.type === undefined) {
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
  }

  var trackType = getTrackTypeForValueTypeName(json.type);

  if (json.times === undefined) {
    var times = [],
        values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, 'value');
    json.times = times;
    json.values = values;
  } // derived classes can define a static parse method


  if (trackType.parse !== undefined) {
    return trackType.parse(json);
  } else {
    // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}

var Cache = {
  enabled: false,
  files: {},
  add: function add(key, file) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[key] = file;
  },
  get: function get(key) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[key];
  },
  remove: function remove(key) {
    delete this.files[key];
  },
  clear: function clear() {
    this.files = {};
  }
};
exports.Cache = Cache;

var LoadingManager = /*#__PURE__*/_createClass(function LoadingManager(onLoad, onProgress, onError) {
  _classCallCheck(this, LoadingManager);

  var scope = this;
  var isLoading = false;
  var itemsLoaded = 0;
  var itemsTotal = 0;
  var urlModifier = undefined;
  var handlers = []; // Refer to #5689 for the reason why we don't set .onStart
  // in the constructor

  this.onStart = undefined;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;

  this.itemStart = function (url) {
    itemsTotal++;

    if (isLoading === false) {
      if (scope.onStart !== undefined) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }

    isLoading = true;
  };

  this.itemEnd = function (url) {
    itemsLoaded++;

    if (scope.onProgress !== undefined) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }

    if (itemsLoaded === itemsTotal) {
      isLoading = false;

      if (scope.onLoad !== undefined) {
        scope.onLoad();
      }
    }
  };

  this.itemError = function (url) {
    if (scope.onError !== undefined) {
      scope.onError(url);
    }
  };

  this.resolveURL = function (url) {
    if (urlModifier) {
      return urlModifier(url);
    }

    return url;
  };

  this.setURLModifier = function (transform) {
    urlModifier = transform;
    return this;
  };

  this.addHandler = function (regex, loader) {
    handlers.push(regex, loader);
    return this;
  };

  this.removeHandler = function (regex) {
    var index = handlers.indexOf(regex);

    if (index !== -1) {
      handlers.splice(index, 2);
    }

    return this;
  };

  this.getHandler = function (file) {
    for (var _i272 = 0, l = handlers.length; _i272 < l; _i272 += 2) {
      var regex = handlers[_i272];
      var loader = handlers[_i272 + 1];
      if (regex.global) regex.lastIndex = 0; // see #17920

      if (regex.test(file)) {
        return loader;
      }
    }

    return null;
  };
});

exports.LoadingManager = LoadingManager;
var DefaultLoadingManager = new LoadingManager();
exports.DefaultLoadingManager = DefaultLoadingManager;

var Loader = /*#__PURE__*/function () {
  function Loader(manager) {
    _classCallCheck(this, Loader);

    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.crossOrigin = 'anonymous';
    this.withCredentials = false;
    this.path = '';
    this.resourcePath = '';
    this.requestHeader = {};
  }

  _createClass(Loader, [{
    key: "load",
    value: function
      /* url, onLoad, onProgress, onError */
    load() {}
  }, {
    key: "loadAsync",
    value: function loadAsync(url, onProgress) {
      var scope = this;
      return new Promise(function (resolve, reject) {
        scope.load(url, resolve, onProgress, reject);
      });
    }
  }, {
    key: "parse",
    value: function
      /* data */
    parse() {}
  }, {
    key: "setCrossOrigin",
    value: function setCrossOrigin(crossOrigin) {
      this.crossOrigin = crossOrigin;
      return this;
    }
  }, {
    key: "setWithCredentials",
    value: function setWithCredentials(value) {
      this.withCredentials = value;
      return this;
    }
  }, {
    key: "setPath",
    value: function setPath(path) {
      this.path = path;
      return this;
    }
  }, {
    key: "setResourcePath",
    value: function setResourcePath(resourcePath) {
      this.resourcePath = resourcePath;
      return this;
    }
  }, {
    key: "setRequestHeader",
    value: function setRequestHeader(requestHeader) {
      this.requestHeader = requestHeader;
      return this;
    }
  }]);

  return Loader;
}();

exports.Loader = Loader;
var loading = {};

var FileLoader = /*#__PURE__*/function (_Loader) {
  _inherits(FileLoader, _Loader);

  var _super110 = _createSuper(FileLoader);

  function FileLoader(manager) {
    _classCallCheck(this, FileLoader);

    return _super110.call(this, manager);
  }

  _createClass(FileLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var _this91 = this;

      if (url === undefined) url = '';
      if (this.path !== undefined) url = this.path + url;
      url = this.manager.resolveURL(url);
      var cached = Cache.get(url);

      if (cached !== undefined) {
        this.manager.itemStart(url);
        setTimeout(function () {
          if (onLoad) onLoad(cached);

          _this91.manager.itemEnd(url);
        }, 0);
        return cached;
      } // Check if request is duplicate


      if (loading[url] !== undefined) {
        loading[url].push({
          onLoad: onLoad,
          onProgress: onProgress,
          onError: onError
        });
        return;
      } // Initialise array for duplicate requests


      loading[url] = [];
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      }); // create request

      var req = new Request(url, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? 'include' : 'same-origin' // An abort controller could be added within a future PR

      }); // record states ( avoid data race )

      var mimeType = this.mimeType;
      var responseType = this.responseType; // start the fetch

      fetch(req).then(function (response) {
        if (response.status === 200 || response.status === 0) {
          // Some browsers return HTTP Status 0 when using non-http protocol
          // e.g. 'file://' or 'data://'. Handle as success.
          if (response.status === 0) {
            console.warn('THREE.FileLoader: HTTP Status 0 received.');
          } // Workaround: Checking if response.body === undefined for Alipay browser #23548


          if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {
            return response;
          }

          var callbacks = loading[url];
          var reader = response.body.getReader();
          var contentLength = response.headers.get('Content-Length');
          var total = contentLength ? parseInt(contentLength) : 0;
          var lengthComputable = total !== 0;
          var loaded = 0; // periodically read data into the new stream tracking while download progress

          var stream = new ReadableStream({
            start: function start(controller) {
              readData();

              function readData() {
                reader.read().then(function ({
                  done: done,
                  value: value
                }) {
                  if (done) {
                    controller.close();
                  } else {
                    loaded += value.byteLength;
                    var event = new ProgressEvent('progress', {
                      lengthComputable: lengthComputable,
                      loaded: loaded,
                      total: total
                    });

                    for (var _i273 = 0, il = callbacks.length; _i273 < il; _i273++) {
                      var callback = callbacks[_i273];
                      if (callback.onProgress) callback.onProgress(event);
                    }

                    controller.enqueue(value);
                    readData();
                  }
                });
              }
            }
          });
          return new Response(stream);
        } else {
          throw Error("fetch for \"".concat(response.url, "\" responded with ").concat(response.status, ": ").concat(response.statusText));
        }
      }).then(function (response) {
        switch (responseType) {
          case 'arraybuffer':
            return response.arrayBuffer();

          case 'blob':
            return response.blob();

          case 'document':
            return response.text().then(function (text) {
              var parser = new DOMParser();
              return parser.parseFromString(text, mimeType);
            });

          case 'json':
            return response.json();

          default:
            if (mimeType === undefined) {
              return response.text();
            } else {
              // sniff encoding
              var re = /charset="?([^;"\s]*)"?/i;
              var exec = re.exec(mimeType);
              var label = exec && exec[1] ? exec[1].toLowerCase() : undefined;
              var decoder = new TextDecoder(label);
              return response.arrayBuffer().then(function (ab) {
                return decoder.decode(ab);
              });
            }

        }
      }).then(function (data) {
        // Add to cache only on HTTP success, so that we do not cache
        // error response bodies as proper responses to requests.
        Cache.add(url, data);
        var callbacks = loading[url];
        delete loading[url];

        for (var _i274 = 0, il = callbacks.length; _i274 < il; _i274++) {
          var callback = callbacks[_i274];
          if (callback.onLoad) callback.onLoad(data);
        }
      }).catch(function (err) {
        // Abort errors and other errors are handled the same
        var callbacks = loading[url];

        if (callbacks === undefined) {
          // When onLoad was called and url was deleted in `loading`
          _this91.manager.itemError(url);

          throw err;
        }

        delete loading[url];

        for (var _i275 = 0, il = callbacks.length; _i275 < il; _i275++) {
          var callback = callbacks[_i275];
          if (callback.onError) callback.onError(err);
        }

        _this91.manager.itemError(url);
      }).finally(function () {
        _this91.manager.itemEnd(url);
      });
      this.manager.itemStart(url);
    }
  }, {
    key: "setResponseType",
    value: function setResponseType(value) {
      this.responseType = value;
      return this;
    }
  }, {
    key: "setMimeType",
    value: function setMimeType(value) {
      this.mimeType = value;
      return this;
    }
  }]);

  return FileLoader;
}(Loader);

exports.FileLoader = FileLoader;

var AnimationLoader = /*#__PURE__*/function (_Loader2) {
  _inherits(AnimationLoader, _Loader2);

  var _super111 = _createSuper(AnimationLoader);

  function AnimationLoader(manager) {
    _classCallCheck(this, AnimationLoader);

    return _super111.call(this, manager);
  }

  _createClass(AnimationLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }

          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  }, {
    key: "parse",
    value: function parse(json) {
      var animations = [];

      for (var _i276 = 0; _i276 < json.length; _i276++) {
        var clip = AnimationClip.parse(json[_i276]);
        animations.push(clip);
      }

      return animations;
    }
  }]);

  return AnimationLoader;
}(Loader);
/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */


exports.AnimationLoader = AnimationLoader;

var CompressedTextureLoader = /*#__PURE__*/function (_Loader3) {
  _inherits(CompressedTextureLoader, _Loader3);

  var _super112 = _createSuper(CompressedTextureLoader);

  function CompressedTextureLoader(manager) {
    _classCallCheck(this, CompressedTextureLoader);

    return _super112.call(this, manager);
  }

  _createClass(CompressedTextureLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var images = [];
      var texture = new CompressedTexture();
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType('arraybuffer');
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      var loaded = 0;

      function loadTexture(i) {
        loader.load(url[i], function (buffer) {
          var texDatas = scope.parse(buffer, true);
          images[i] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
          };
          loaded += 1;

          if (loaded === 6) {
            if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.image = images;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
          }
        }, onProgress, onError);
      }

      if (Array.isArray(url)) {
        for (var _i277 = 0, il = url.length; _i277 < il; ++_i277) {
          loadTexture(_i277);
        }
      } else {
        // compressed cubemap texture stored in a single DDS file
        loader.load(url, function (buffer) {
          var texDatas = scope.parse(buffer, true);

          if (texDatas.isCubemap) {
            var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

            for (var f = 0; f < faces; f++) {
              images[f] = {
                mipmaps: []
              };

              for (var _i278 = 0; _i278 < texDatas.mipmapCount; _i278++) {
                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + _i278]);
                images[f].format = texDatas.format;
                images[f].width = texDatas.width;
                images[f].height = texDatas.height;
              }
            }

            texture.image = images;
          } else {
            texture.image.width = texDatas.width;
            texture.image.height = texDatas.height;
            texture.mipmaps = texDatas.mipmaps;
          }

          if (texDatas.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }

          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }, onProgress, onError);
      }

      return texture;
    }
  }]);

  return CompressedTextureLoader;
}(Loader);

exports.CompressedTextureLoader = CompressedTextureLoader;

var ImageLoader = /*#__PURE__*/function (_Loader4) {
  _inherits(ImageLoader, _Loader4);

  var _super113 = _createSuper(ImageLoader);

  function ImageLoader(manager) {
    _classCallCheck(this, ImageLoader);

    return _super113.call(this, manager);
  }

  _createClass(ImageLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      if (this.path !== undefined) url = this.path + url;
      url = this.manager.resolveURL(url);
      var scope = this;
      var cached = Cache.get(url);

      if (cached !== undefined) {
        scope.manager.itemStart(url);
        setTimeout(function () {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }

      var image = createElementNS('img');

      function onImageLoad() {
        removeEventListeners();
        Cache.add(url, this);
        if (onLoad) onLoad(this);
        scope.manager.itemEnd(url);
      }

      function onImageError(event) {
        removeEventListeners();
        if (onError) onError(event);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }

      function removeEventListeners() {
        image.removeEventListener('load', onImageLoad, false);
        image.removeEventListener('error', onImageError, false);
      }

      image.addEventListener('load', onImageLoad, false);
      image.addEventListener('error', onImageError, false);

      if (url.slice(0, 5) !== 'data:') {
        if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
      }

      scope.manager.itemStart(url);
      image.src = url;
      return image;
    }
  }]);

  return ImageLoader;
}(Loader);

exports.ImageLoader = ImageLoader;

var CubeTextureLoader = /*#__PURE__*/function (_Loader5) {
  _inherits(CubeTextureLoader, _Loader5);

  var _super114 = _createSuper(CubeTextureLoader);

  function CubeTextureLoader(manager) {
    _classCallCheck(this, CubeTextureLoader);

    return _super114.call(this, manager);
  }

  _createClass(CubeTextureLoader, [{
    key: "load",
    value: function load(urls, onLoad, onProgress, onError) {
      var texture = new CubeTexture();
      var loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      var loaded = 0;

      function loadTexture(i) {
        loader.load(urls[i], function (image) {
          texture.images[i] = image;
          loaded++;

          if (loaded === 6) {
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
          }
        }, undefined, onError);
      }

      for (var _i279 = 0; _i279 < urls.length; ++_i279) {
        loadTexture(_i279);
      }

      return texture;
    }
  }]);

  return CubeTextureLoader;
}(Loader);
/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */


exports.CubeTextureLoader = CubeTextureLoader;

var DataTextureLoader = /*#__PURE__*/function (_Loader6) {
  _inherits(DataTextureLoader, _Loader6);

  var _super115 = _createSuper(DataTextureLoader);

  function DataTextureLoader(manager) {
    _classCallCheck(this, DataTextureLoader);

    return _super115.call(this, manager);
  }

  _createClass(DataTextureLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var texture = new DataTexture();
      var loader = new FileLoader(this.manager);
      loader.setResponseType('arraybuffer');
      loader.setRequestHeader(this.requestHeader);
      loader.setPath(this.path);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function (buffer) {
        var texData = scope.parse(buffer);
        if (!texData) return;

        if (texData.image !== undefined) {
          texture.image = texData.image;
        } else if (texData.data !== undefined) {
          texture.image.width = texData.width;
          texture.image.height = texData.height;
          texture.image.data = texData.data;
        }

        texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
        texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
        texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
        texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
        texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

        if (texData.encoding !== undefined) {
          texture.encoding = texData.encoding;
        }

        if (texData.flipY !== undefined) {
          texture.flipY = texData.flipY;
        }

        if (texData.format !== undefined) {
          texture.format = texData.format;
        }

        if (texData.type !== undefined) {
          texture.type = texData.type;
        }

        if (texData.mipmaps !== undefined) {
          texture.mipmaps = texData.mipmaps;
          texture.minFilter = LinearMipmapLinearFilter; // presumably...
        }

        if (texData.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }

        if (texData.generateMipmaps !== undefined) {
          texture.generateMipmaps = texData.generateMipmaps;
        }

        texture.needsUpdate = true;
        if (onLoad) onLoad(texture, texData);
      }, onProgress, onError);
      return texture;
    }
  }]);

  return DataTextureLoader;
}(Loader);

exports.DataTextureLoader = DataTextureLoader;

var TextureLoader = /*#__PURE__*/function (_Loader7) {
  _inherits(TextureLoader, _Loader7);

  var _super116 = _createSuper(TextureLoader);

  function TextureLoader(manager) {
    _classCallCheck(this, TextureLoader);

    return _super116.call(this, manager);
  }

  _createClass(TextureLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var texture = new Texture();
      var loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      loader.load(url, function (image) {
        texture.image = image;
        texture.needsUpdate = true;

        if (onLoad !== undefined) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    }
  }]);

  return TextureLoader;
}(Loader);

exports.TextureLoader = TextureLoader;

var Light = /*#__PURE__*/function (_Object3D11) {
  _inherits(Light, _Object3D11);

  var _super117 = _createSuper(Light);

  function Light(color, intensity = 1) {
    var _this92;

    _classCallCheck(this, Light);

    _this92 = _super117.call(this);
    _this92.type = 'Light';
    _this92.color = new Color(color);
    _this92.intensity = intensity;
    return _this92;
  }

  _createClass(Light, [{
    key: "dispose",
    value: function dispose() {// Empty here in base class; some subclasses override.
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(Light.prototype), "copy", this).call(this, source);

      this.color.copy(source.color);
      this.intensity = source.intensity;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(Light.prototype), "toJSON", this).call(this, meta);

      data.object.color = this.color.getHex();
      data.object.intensity = this.intensity;
      if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
      if (this.distance !== undefined) data.object.distance = this.distance;
      if (this.angle !== undefined) data.object.angle = this.angle;
      if (this.decay !== undefined) data.object.decay = this.decay;
      if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
      if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
      return data;
    }
  }]);

  return Light;
}(Object3D);

exports.Light = Light;
Light.prototype.isLight = true;

var HemisphereLight = /*#__PURE__*/function (_Light) {
  _inherits(HemisphereLight, _Light);

  var _super118 = _createSuper(HemisphereLight);

  function HemisphereLight(skyColor, groundColor, intensity) {
    var _this93;

    _classCallCheck(this, HemisphereLight);

    _this93 = _super118.call(this, skyColor, intensity);
    _this93.type = 'HemisphereLight';

    _this93.position.copy(Object3D.DefaultUp);

    _this93.updateMatrix();

    _this93.groundColor = new Color(groundColor);
    return _this93;
  }

  _createClass(HemisphereLight, [{
    key: "copy",
    value: function copy(source) {
      Light.prototype.copy.call(this, source);
      this.groundColor.copy(source.groundColor);
      return this;
    }
  }]);

  return HemisphereLight;
}(Light);

exports.HemisphereLight = HemisphereLight;
HemisphereLight.prototype.isHemisphereLight = true;

var _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();

var _lightPositionWorld$1 = /*@__PURE__*/new Vector3();

var _lookTarget$1 = /*@__PURE__*/new Vector3();

var LightShadow = /*#__PURE__*/function () {
  function LightShadow(camera) {
    _classCallCheck(this, LightShadow);

    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [new Vector4(0, 0, 1, 1)];
  }

  _createClass(LightShadow, [{
    key: "getViewportCount",
    value: function getViewportCount() {
      return this._viewportCount;
    }
  }, {
    key: "getFrustum",
    value: function getFrustum() {
      return this._frustum;
    }
  }, {
    key: "updateMatrices",
    value: function updateMatrices(light) {
      var shadowCamera = this.camera;
      var shadowMatrix = this.matrix;

      _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);

      shadowCamera.position.copy(_lightPositionWorld$1);

      _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);

      shadowCamera.lookAt(_lookTarget$1);
      shadowCamera.updateMatrixWorld();

      _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);

      shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
      shadowMatrix.multiply(shadowCamera.projectionMatrix);
      shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    }
  }, {
    key: "getViewport",
    value: function getViewport(viewportIndex) {
      return this._viewports[viewportIndex];
    }
  }, {
    key: "getFrameExtents",
    value: function getFrameExtents() {
      return this._frameExtents;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.map) {
        this.map.dispose();
      }

      if (this.mapPass) {
        this.mapPass.dispose();
      }
    }
  }, {
    key: "copy",
    value: function copy(source) {
      this.camera = source.camera.clone();
      this.bias = source.bias;
      this.radius = source.radius;
      this.mapSize.copy(source.mapSize);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var object = {};
      if (this.bias !== 0) object.bias = this.bias;
      if (this.normalBias !== 0) object.normalBias = this.normalBias;
      if (this.radius !== 1) object.radius = this.radius;
      if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
      object.camera = this.camera.toJSON(false).object;
      delete object.camera.matrix;
      return object;
    }
  }]);

  return LightShadow;
}();

var SpotLightShadow = /*#__PURE__*/function (_LightShadow) {
  _inherits(SpotLightShadow, _LightShadow);

  var _super119 = _createSuper(SpotLightShadow);

  function SpotLightShadow() {
    var _this94;

    _classCallCheck(this, SpotLightShadow);

    _this94 = _super119.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
    _this94.focus = 1;
    return _this94;
  }

  _createClass(SpotLightShadow, [{
    key: "updateMatrices",
    value: function updateMatrices(light) {
      var camera = this.camera;
      var fov = RAD2DEG * 2 * light.angle * this.focus;
      var aspect = this.mapSize.width / this.mapSize.height;
      var far = light.distance || camera.far;

      if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
        camera.fov = fov;
        camera.aspect = aspect;
        camera.far = far;
        camera.updateProjectionMatrix();
      }

      _get(_getPrototypeOf(SpotLightShadow.prototype), "updateMatrices", this).call(this, light);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(SpotLightShadow.prototype), "copy", this).call(this, source);

      this.focus = source.focus;
      return this;
    }
  }]);

  return SpotLightShadow;
}(LightShadow);

SpotLightShadow.prototype.isSpotLightShadow = true;

var SpotLight = /*#__PURE__*/function (_Light2) {
  _inherits(SpotLight, _Light2);

  var _super120 = _createSuper(SpotLight);

  function SpotLight(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    var _this95;

    _classCallCheck(this, SpotLight);

    _this95 = _super120.call(this, color, intensity);
    _this95.type = 'SpotLight';

    _this95.position.copy(Object3D.DefaultUp);

    _this95.updateMatrix();

    _this95.target = new Object3D();
    _this95.distance = distance;
    _this95.angle = angle;
    _this95.penumbra = penumbra;
    _this95.decay = decay; // for physically correct lights, should be 2.

    _this95.shadow = new SpotLightShadow();
    return _this95;
  }

  _createClass(SpotLight, [{
    key: "power",
    get: function get() {
      // compute the light's luminous power (in lumens) from its intensity (in candela)
      // by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
      return this.intensity * Math.PI;
    },
    set: function set(power) {
      // set the light's intensity (in candela) from the desired luminous power (in lumens)
      this.intensity = power / Math.PI;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(SpotLight.prototype), "copy", this).call(this, source);

      this.distance = source.distance;
      this.angle = source.angle;
      this.penumbra = source.penumbra;
      this.decay = source.decay;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  }]);

  return SpotLight;
}(Light);

exports.SpotLight = SpotLight;
SpotLight.prototype.isSpotLight = true;

var _projScreenMatrix = /*@__PURE__*/new Matrix4();

var _lightPositionWorld = /*@__PURE__*/new Vector3();

var _lookTarget = /*@__PURE__*/new Vector3();

var PointLightShadow = /*#__PURE__*/function (_LightShadow2) {
  _inherits(PointLightShadow, _LightShadow2);

  var _super121 = _createSuper(PointLightShadow);

  function PointLightShadow() {
    var _this96;

    _classCallCheck(this, PointLightShadow);

    _this96 = _super121.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
    _this96._frameExtents = new Vector2(4, 2);
    _this96._viewportCount = 6;
    _this96._viewports = [// These viewports map a cube-map onto a 2D texture with the
    // following orientation:
    //
    //  xzXZ
    //   y Y
    //
    // X - Positive x direction
    // x - Negative x direction
    // Y - Positive y direction
    // y - Negative y direction
    // Z - Positive z direction
    // z - Negative z direction
    // positive X
    new Vector4(2, 1, 1, 1), // negative X
    new Vector4(0, 1, 1, 1), // positive Z
    new Vector4(3, 1, 1, 1), // negative Z
    new Vector4(1, 1, 1, 1), // positive Y
    new Vector4(3, 0, 1, 1), // negative Y
    new Vector4(1, 0, 1, 1)];
    _this96._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
    _this96._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
    return _this96;
  }

  _createClass(PointLightShadow, [{
    key: "updateMatrices",
    value: function updateMatrices(light, viewportIndex = 0) {
      var camera = this.camera;
      var shadowMatrix = this.matrix;
      var far = light.distance || camera.far;

      if (far !== camera.far) {
        camera.far = far;
        camera.updateProjectionMatrix();
      }

      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);

      camera.position.copy(_lightPositionWorld);

      _lookTarget.copy(camera.position);

      _lookTarget.add(this._cubeDirections[viewportIndex]);

      camera.up.copy(this._cubeUps[viewportIndex]);
      camera.lookAt(_lookTarget);
      camera.updateMatrixWorld();
      shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);

      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

      this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    }
  }]);

  return PointLightShadow;
}(LightShadow);

PointLightShadow.prototype.isPointLightShadow = true;

var PointLight = /*#__PURE__*/function (_Light3) {
  _inherits(PointLight, _Light3);

  var _super122 = _createSuper(PointLight);

  function PointLight(color, intensity, distance = 0, decay = 1) {
    var _this97;

    _classCallCheck(this, PointLight);

    _this97 = _super122.call(this, color, intensity);
    _this97.type = 'PointLight';
    _this97.distance = distance;
    _this97.decay = decay; // for physically correct lights, should be 2.

    _this97.shadow = new PointLightShadow();
    return _this97;
  }

  _createClass(PointLight, [{
    key: "power",
    get: function get() {
      // compute the light's luminous power (in lumens) from its intensity (in candela)
      // for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
      return this.intensity * 4 * Math.PI;
    },
    set: function set(power) {
      // set the light's intensity (in candela) from the desired luminous power (in lumens)
      this.intensity = power / (4 * Math.PI);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(PointLight.prototype), "copy", this).call(this, source);

      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    }
  }]);

  return PointLight;
}(Light);

exports.PointLight = PointLight;
PointLight.prototype.isPointLight = true;

var DirectionalLightShadow = /*#__PURE__*/function (_LightShadow3) {
  _inherits(DirectionalLightShadow, _LightShadow3);

  var _super123 = _createSuper(DirectionalLightShadow);

  function DirectionalLightShadow() {
    _classCallCheck(this, DirectionalLightShadow);

    return _super123.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }

  return _createClass(DirectionalLightShadow);
}(LightShadow);

DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

var DirectionalLight = /*#__PURE__*/function (_Light4) {
  _inherits(DirectionalLight, _Light4);

  var _super124 = _createSuper(DirectionalLight);

  function DirectionalLight(color, intensity) {
    var _this98;

    _classCallCheck(this, DirectionalLight);

    _this98 = _super124.call(this, color, intensity);
    _this98.type = 'DirectionalLight';

    _this98.position.copy(Object3D.DefaultUp);

    _this98.updateMatrix();

    _this98.target = new Object3D();
    _this98.shadow = new DirectionalLightShadow();
    return _this98;
  }

  _createClass(DirectionalLight, [{
    key: "dispose",
    value: function dispose() {
      this.shadow.dispose();
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(DirectionalLight.prototype), "copy", this).call(this, source);

      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  }]);

  return DirectionalLight;
}(Light);

exports.DirectionalLight = DirectionalLight;
DirectionalLight.prototype.isDirectionalLight = true;

var AmbientLight = /*#__PURE__*/function (_Light5) {
  _inherits(AmbientLight, _Light5);

  var _super125 = _createSuper(AmbientLight);

  function AmbientLight(color, intensity) {
    var _this99;

    _classCallCheck(this, AmbientLight);

    _this99 = _super125.call(this, color, intensity);
    _this99.type = 'AmbientLight';
    return _this99;
  }

  return _createClass(AmbientLight);
}(Light);

exports.AmbientLight = AmbientLight;
AmbientLight.prototype.isAmbientLight = true;

var RectAreaLight = /*#__PURE__*/function (_Light6) {
  _inherits(RectAreaLight, _Light6);

  var _super126 = _createSuper(RectAreaLight);

  function RectAreaLight(color, intensity, width = 10, height = 10) {
    var _this100;

    _classCallCheck(this, RectAreaLight);

    _this100 = _super126.call(this, color, intensity);
    _this100.type = 'RectAreaLight';
    _this100.width = width;
    _this100.height = height;
    return _this100;
  }

  _createClass(RectAreaLight, [{
    key: "power",
    get: function get() {
      // compute the light's luminous power (in lumens) from its intensity (in nits)
      return this.intensity * this.width * this.height * Math.PI;
    },
    set: function set(power) {
      // set the light's intensity (in nits) from the desired luminous power (in lumens)
      this.intensity = power / (this.width * this.height * Math.PI);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(RectAreaLight.prototype), "copy", this).call(this, source);

      this.width = source.width;
      this.height = source.height;
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(RectAreaLight.prototype), "toJSON", this).call(this, meta);

      data.object.width = this.width;
      data.object.height = this.height;
      return data;
    }
  }]);

  return RectAreaLight;
}(Light);

exports.RectAreaLight = RectAreaLight;
RectAreaLight.prototype.isRectAreaLight = true;
/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */
// 3-band SH defined by 9 coefficients

var SphericalHarmonics3 = /*#__PURE__*/function () {
  function SphericalHarmonics3() {
    _classCallCheck(this, SphericalHarmonics3);

    this.coefficients = [];

    for (var _i280 = 0; _i280 < 9; _i280++) {
      this.coefficients.push(new Vector3());
    }
  }

  _createClass(SphericalHarmonics3, [{
    key: "set",
    value: function set(coefficients) {
      for (var _i281 = 0; _i281 < 9; _i281++) {
        this.coefficients[_i281].copy(coefficients[_i281]);
      }

      return this;
    }
  }, {
    key: "zero",
    value: function zero() {
      for (var _i282 = 0; _i282 < 9; _i282++) {
        this.coefficients[_i282].set(0, 0, 0);
      }

      return this;
    } // get the radiance in the direction of the normal
    // target is a Vector3

  }, {
    key: "getAt",
    value: function getAt(normal, target) {
      // normal is assumed to be unit length
      var x = normal.x,
          y = normal.y,
          z = normal.z;
      var coeff = this.coefficients; // band 0

      target.copy(coeff[0]).multiplyScalar(0.282095); // band 1

      target.addScaledVector(coeff[1], 0.488603 * y);
      target.addScaledVector(coeff[2], 0.488603 * z);
      target.addScaledVector(coeff[3], 0.488603 * x); // band 2

      target.addScaledVector(coeff[4], 1.092548 * (x * y));
      target.addScaledVector(coeff[5], 1.092548 * (y * z));
      target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
      target.addScaledVector(coeff[7], 1.092548 * (x * z));
      target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
      return target;
    } // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
    // target is a Vector3
    // https://graphics.stanford.edu/papers/envmap/envmap.pdf

  }, {
    key: "getIrradianceAt",
    value: function getIrradianceAt(normal, target) {
      // normal is assumed to be unit length
      var x = normal.x,
          y = normal.y,
          z = normal.z;
      var coeff = this.coefficients; // band 0

      target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095
      // band 1

      target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603

      target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
      target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2

      target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548

      target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
      target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3

      target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
      target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274

      return target;
    }
  }, {
    key: "add",
    value: function add(sh) {
      for (var _i283 = 0; _i283 < 9; _i283++) {
        this.coefficients[_i283].add(sh.coefficients[_i283]);
      }

      return this;
    }
  }, {
    key: "addScaledSH",
    value: function addScaledSH(sh, s) {
      for (var _i284 = 0; _i284 < 9; _i284++) {
        this.coefficients[_i284].addScaledVector(sh.coefficients[_i284], s);
      }

      return this;
    }
  }, {
    key: "scale",
    value: function scale(s) {
      for (var _i285 = 0; _i285 < 9; _i285++) {
        this.coefficients[_i285].multiplyScalar(s);
      }

      return this;
    }
  }, {
    key: "lerp",
    value: function lerp(sh, alpha) {
      for (var _i286 = 0; _i286 < 9; _i286++) {
        this.coefficients[_i286].lerp(sh.coefficients[_i286], alpha);
      }

      return this;
    }
  }, {
    key: "equals",
    value: function equals(sh) {
      for (var _i287 = 0; _i287 < 9; _i287++) {
        if (!this.coefficients[_i287].equals(sh.coefficients[_i287])) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "copy",
    value: function copy(sh) {
      return this.set(sh.coefficients);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "fromArray",
    value: function fromArray(array, offset = 0) {
      var coefficients = this.coefficients;

      for (var _i288 = 0; _i288 < 9; _i288++) {
        coefficients[_i288].fromArray(array, offset + _i288 * 3);
      }

      return this;
    }
  }, {
    key: "toArray",
    value: function toArray(array = [], offset = 0) {
      var coefficients = this.coefficients;

      for (var _i289 = 0; _i289 < 9; _i289++) {
        coefficients[_i289].toArray(array, offset + _i289 * 3);
      }

      return array;
    } // evaluate the basis functions
    // shBasis is an Array[ 9 ]

  }], [{
    key: "getBasisAt",
    value: function getBasisAt(normal, shBasis) {
      // normal is assumed to be unit length
      var x = normal.x,
          y = normal.y,
          z = normal.z; // band 0

      shBasis[0] = 0.282095; // band 1

      shBasis[1] = 0.488603 * y;
      shBasis[2] = 0.488603 * z;
      shBasis[3] = 0.488603 * x; // band 2

      shBasis[4] = 1.092548 * x * y;
      shBasis[5] = 1.092548 * y * z;
      shBasis[6] = 0.315392 * (3 * z * z - 1);
      shBasis[7] = 1.092548 * x * z;
      shBasis[8] = 0.546274 * (x * x - y * y);
    }
  }]);

  return SphericalHarmonics3;
}();

exports.SphericalHarmonics3 = SphericalHarmonics3;
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

var LightProbe = /*#__PURE__*/function (_Light7) {
  _inherits(LightProbe, _Light7);

  var _super127 = _createSuper(LightProbe);

  function LightProbe(sh = new SphericalHarmonics3(), intensity = 1) {
    var _this101;

    _classCallCheck(this, LightProbe);

    _this101 = _super127.call(this, undefined, intensity);
    _this101.sh = sh;
    return _this101;
  }

  _createClass(LightProbe, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(LightProbe.prototype), "copy", this).call(this, source);

      this.sh.copy(source.sh);
      return this;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(json) {
      this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();

      this.sh.fromArray(json.sh);
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON(meta) {
      var data = _get(_getPrototypeOf(LightProbe.prototype), "toJSON", this).call(this, meta);

      data.object.sh = this.sh.toArray();
      return data;
    }
  }]);

  return LightProbe;
}(Light);

exports.LightProbe = LightProbe;
LightProbe.prototype.isLightProbe = true;

var MaterialLoader = /*#__PURE__*/function (_Loader8) {
  _inherits(MaterialLoader, _Loader8);

  var _super128 = _createSuper(MaterialLoader);

  function MaterialLoader(manager) {
    var _this102;

    _classCallCheck(this, MaterialLoader);

    _this102 = _super128.call(this, manager);
    _this102.textures = {};
    return _this102;
  }

  _createClass(MaterialLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }

          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  }, {
    key: "parse",
    value: function parse(json) {
      var textures = this.textures;

      function getTexture(name) {
        if (textures[name] === undefined) {
          console.warn('THREE.MaterialLoader: Undefined texture', name);
        }

        return textures[name];
      }

      var material = Material.fromType(json.type);
      if (json.uuid !== undefined) material.uuid = json.uuid;
      if (json.name !== undefined) material.name = json.name;
      if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
      if (json.roughness !== undefined) material.roughness = json.roughness;
      if (json.metalness !== undefined) material.metalness = json.metalness;
      if (json.sheen !== undefined) material.sheen = json.sheen;
      if (json.sheenColor !== undefined) material.sheenColor = new Color().setHex(json.sheenColor);
      if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;
      if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
      if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
      if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
      if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);
      if (json.shininess !== undefined) material.shininess = json.shininess;
      if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
      if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
      if (json.transmission !== undefined) material.transmission = json.transmission;
      if (json.thickness !== undefined) material.thickness = json.thickness;
      if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
      if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);
      if (json.fog !== undefined) material.fog = json.fog;
      if (json.flatShading !== undefined) material.flatShading = json.flatShading;
      if (json.blending !== undefined) material.blending = json.blending;
      if (json.combine !== undefined) material.combine = json.combine;
      if (json.side !== undefined) material.side = json.side;
      if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
      if (json.opacity !== undefined) material.opacity = json.opacity;
      if (json.transparent !== undefined) material.transparent = json.transparent;
      if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
      if (json.depthTest !== undefined) material.depthTest = json.depthTest;
      if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
      if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
      if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
      if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
      if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
      if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
      if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
      if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
      if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
      if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
      if (json.wireframe !== undefined) material.wireframe = json.wireframe;
      if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
      if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
      if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
      if (json.rotation !== undefined) material.rotation = json.rotation;
      if (json.linewidth !== 1) material.linewidth = json.linewidth;
      if (json.dashSize !== undefined) material.dashSize = json.dashSize;
      if (json.gapSize !== undefined) material.gapSize = json.gapSize;
      if (json.scale !== undefined) material.scale = json.scale;
      if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
      if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
      if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
      if (json.dithering !== undefined) material.dithering = json.dithering;
      if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
      if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
      if (json.visible !== undefined) material.visible = json.visible;
      if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
      if (json.userData !== undefined) material.userData = json.userData;

      if (json.vertexColors !== undefined) {
        if (typeof json.vertexColors === 'number') {
          material.vertexColors = json.vertexColors > 0 ? true : false;
        } else {
          material.vertexColors = json.vertexColors;
        }
      } // Shader Material


      if (json.uniforms !== undefined) {
        for (var name in json.uniforms) {
          var uniform = json.uniforms[name];
          material.uniforms[name] = {};

          switch (uniform.type) {
            case 't':
              material.uniforms[name].value = getTexture(uniform.value);
              break;

            case 'c':
              material.uniforms[name].value = new Color().setHex(uniform.value);
              break;

            case 'v2':
              material.uniforms[name].value = new Vector2().fromArray(uniform.value);
              break;

            case 'v3':
              material.uniforms[name].value = new Vector3().fromArray(uniform.value);
              break;

            case 'v4':
              material.uniforms[name].value = new Vector4().fromArray(uniform.value);
              break;

            case 'm3':
              material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
              break;

            case 'm4':
              material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
              break;

            default:
              material.uniforms[name].value = uniform.value;
          }
        }
      }

      if (json.defines !== undefined) material.defines = json.defines;
      if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
      if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

      if (json.extensions !== undefined) {
        for (var key in json.extensions) {
          material.extensions[key] = json.extensions[key];
        }
      } // Deprecated


      if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
      // for PointsMaterial

      if (json.size !== undefined) material.size = json.size;
      if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

      if (json.map !== undefined) material.map = getTexture(json.map);
      if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
      if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
      if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
      if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
      if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
      if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

      if (json.normalScale !== undefined) {
        var normalScale = json.normalScale;

        if (Array.isArray(normalScale) === false) {
          // Blender exporter used to export a scalar. See #7459
          normalScale = [normalScale, normalScale];
        }

        material.normalScale = new Vector2().fromArray(normalScale);
      }

      if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
      if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
      if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
      if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
      if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
      if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
      if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
      if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
      if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
      if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);
      if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
      if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
      if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
      if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
      if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
      if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
      if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
      if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
      if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
      if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
      if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
      if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
      if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
      if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
      if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
      if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);
      if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
      return material;
    }
  }, {
    key: "setTextures",
    value: function setTextures(value) {
      this.textures = value;
      return this;
    }
  }]);

  return MaterialLoader;
}(Loader);

exports.MaterialLoader = MaterialLoader;

var LoaderUtils = /*#__PURE__*/function () {
  function LoaderUtils() {
    _classCallCheck(this, LoaderUtils);
  }

  _createClass(LoaderUtils, null, [{
    key: "decodeText",
    value: function decodeText(array) {
      if (typeof TextDecoder !== 'undefined') {
        return new TextDecoder().decode(array);
      } // Avoid the String.fromCharCode.apply(null, array) shortcut, which
      // throws a "maximum call stack size exceeded" error for large arrays.


      var s = '';

      for (var _i290 = 0, il = array.length; _i290 < il; _i290++) {
        // Implicitly assumes little-endian.
        s += String.fromCharCode(array[_i290]);
      }

      try {
        // merges multi-byte utf-8 characters.
        return decodeURIComponent(escape(s));
      } catch (e) {
        // see #16358
        return s;
      }
    }
  }, {
    key: "extractUrlBase",
    value: function extractUrlBase(url) {
      var index = url.lastIndexOf('/');
      if (index === -1) return './';
      return url.slice(0, index + 1);
    }
  }, {
    key: "resolveURL",
    value: function resolveURL(url, path) {
      // Invalid URL
      if (typeof url !== 'string' || url === '') return ''; // Host Relative URL

      if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
        path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
      } // Absolute URL http://,https://,//


      if (/^(https?:)?\/\//i.test(url)) return url; // Data URI

      if (/^data:.*,.*$/i.test(url)) return url; // Blob URL

      if (/^blob:.*$/i.test(url)) return url; // Relative URL

      return path + url;
    }
  }]);

  return LoaderUtils;
}();

exports.LoaderUtils = LoaderUtils;

var InstancedBufferGeometry = /*#__PURE__*/function (_BufferGeometry16) {
  _inherits(InstancedBufferGeometry, _BufferGeometry16);

  var _super129 = _createSuper(InstancedBufferGeometry);

  function InstancedBufferGeometry() {
    var _this103;

    _classCallCheck(this, InstancedBufferGeometry);

    _this103 = _super129.call(this);
    _this103.type = 'InstancedBufferGeometry';
    _this103.instanceCount = Infinity;
    return _this103;
  }

  _createClass(InstancedBufferGeometry, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(InstancedBufferGeometry.prototype), "copy", this).call(this, source);

      this.instanceCount = source.instanceCount;
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var data = _get(_getPrototypeOf(InstancedBufferGeometry.prototype), "toJSON", this).call(this, this);

      data.instanceCount = this.instanceCount;
      data.isInstancedBufferGeometry = true;
      return data;
    }
  }]);

  return InstancedBufferGeometry;
}(BufferGeometry);

exports.InstancedBufferGeometry = InstancedBufferGeometry;
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

var BufferGeometryLoader = /*#__PURE__*/function (_Loader9) {
  _inherits(BufferGeometryLoader, _Loader9);

  var _super130 = _createSuper(BufferGeometryLoader);

  function BufferGeometryLoader(manager) {
    _classCallCheck(this, BufferGeometryLoader);

    return _super130.call(this, manager);
  }

  _createClass(BufferGeometryLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }

          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  }, {
    key: "parse",
    value: function parse(json) {
      var interleavedBufferMap = {};
      var arrayBufferMap = {};

      function getInterleavedBuffer(json, uuid) {
        if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
        var interleavedBuffers = json.interleavedBuffers;
        var interleavedBuffer = interleavedBuffers[uuid];
        var buffer = getArrayBuffer(json, interleavedBuffer.buffer);
        var array = getTypedArray(interleavedBuffer.type, buffer);
        var ib = new InterleavedBuffer(array, interleavedBuffer.stride);
        ib.uuid = interleavedBuffer.uuid;
        interleavedBufferMap[uuid] = ib;
        return ib;
      }

      function getArrayBuffer(json, uuid) {
        if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
        var arrayBuffers = json.arrayBuffers;
        var arrayBuffer = arrayBuffers[uuid];
        var ab = new Uint32Array(arrayBuffer).buffer;
        arrayBufferMap[uuid] = ab;
        return ab;
      }

      var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
      var index = json.data.index;

      if (index !== undefined) {
        var typedArray = getTypedArray(index.type, index.array);
        geometry.setIndex(new BufferAttribute(typedArray, 1));
      }

      var attributes = json.data.attributes;

      for (var key in attributes) {
        var attribute = attributes[key];
        var bufferAttribute = void 0;

        if (attribute.isInterleavedBufferAttribute) {
          var interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
          bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
        } else {
          var _typedArray = getTypedArray(attribute.type, attribute.array);

          var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
          bufferAttribute = new bufferAttributeConstr(_typedArray, attribute.itemSize, attribute.normalized);
        }

        if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
        if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);

        if (attribute.updateRange !== undefined) {
          bufferAttribute.updateRange.offset = attribute.updateRange.offset;
          bufferAttribute.updateRange.count = attribute.updateRange.count;
        }

        geometry.setAttribute(key, bufferAttribute);
      }

      var morphAttributes = json.data.morphAttributes;

      if (morphAttributes) {
        for (var _key3 in morphAttributes) {
          var attributeArray = morphAttributes[_key3];
          var array = [];

          for (var _i291 = 0, il = attributeArray.length; _i291 < il; _i291++) {
            var _attribute3 = attributeArray[_i291];

            var _bufferAttribute = void 0;

            if (_attribute3.isInterleavedBufferAttribute) {
              var _interleavedBuffer = getInterleavedBuffer(json.data, _attribute3.data);

              _bufferAttribute = new InterleavedBufferAttribute(_interleavedBuffer, _attribute3.itemSize, _attribute3.offset, _attribute3.normalized);
            } else {
              var _typedArray2 = getTypedArray(_attribute3.type, _attribute3.array);

              _bufferAttribute = new BufferAttribute(_typedArray2, _attribute3.itemSize, _attribute3.normalized);
            }

            if (_attribute3.name !== undefined) _bufferAttribute.name = _attribute3.name;
            array.push(_bufferAttribute);
          }

          geometry.morphAttributes[_key3] = array;
        }
      }

      var morphTargetsRelative = json.data.morphTargetsRelative;

      if (morphTargetsRelative) {
        geometry.morphTargetsRelative = true;
      }

      var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

      if (groups !== undefined) {
        for (var _i292 = 0, n = groups.length; _i292 !== n; ++_i292) {
          var group = groups[_i292];
          geometry.addGroup(group.start, group.count, group.materialIndex);
        }
      }

      var boundingSphere = json.data.boundingSphere;

      if (boundingSphere !== undefined) {
        var center = new Vector3();

        if (boundingSphere.center !== undefined) {
          center.fromArray(boundingSphere.center);
        }

        geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
      }

      if (json.name) geometry.name = json.name;
      if (json.userData) geometry.userData = json.userData;
      return geometry;
    }
  }]);

  return BufferGeometryLoader;
}(Loader);

exports.BufferGeometryLoader = BufferGeometryLoader;

var ObjectLoader = /*#__PURE__*/function (_Loader10) {
  _inherits(ObjectLoader, _Loader10);

  var _super131 = _createSuper(ObjectLoader);

  function ObjectLoader(manager) {
    _classCallCheck(this, ObjectLoader);

    return _super131.call(this, manager);
  }

  _createClass(ObjectLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
      this.resourcePath = this.resourcePath || path;
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function (text) {
        var json = null;

        try {
          json = JSON.parse(text);
        } catch (error) {
          if (onError !== undefined) onError(error);
          console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
          return;
        }

        var metadata = json.metadata;

        if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
          console.error('THREE.ObjectLoader: Can\'t load ' + url);
          return;
        }

        scope.parse(json, onLoad);
      }, onProgress, onError);
    }
  }, {
    key: "loadAsync",
    value: function () {
      var _loadAsync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(url, onProgress) {
        var scope, path, loader, text, json, metadata;
        return regeneratorRuntime.wrap(function _callee2$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                scope = this;
                path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
                this.resourcePath = this.resourcePath || path;
                loader = new FileLoader(this.manager);
                loader.setPath(this.path);
                loader.setRequestHeader(this.requestHeader);
                loader.setWithCredentials(this.withCredentials);
                _context6.next = 9;
                return loader.loadAsync(url, onProgress);

              case 9:
                text = _context6.sent;
                json = JSON.parse(text);
                metadata = json.metadata;

                if (!(metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry')) {
                  _context6.next = 14;
                  break;
                }

                throw new Error('THREE.ObjectLoader: Can\'t load ' + url);

              case 14:
                _context6.next = 16;
                return scope.parseAsync(json);

              case 16:
                return _context6.abrupt("return", _context6.sent);

              case 17:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee2, this);
      }));

      function loadAsync(_x7, _x8) {
        return _loadAsync.apply(this, arguments);
      }

      return loadAsync;
    }()
  }, {
    key: "parse",
    value: function parse(json, onLoad) {
      var animations = this.parseAnimations(json.animations);
      var shapes = this.parseShapes(json.shapes);
      var geometries = this.parseGeometries(json.geometries, shapes);
      var images = this.parseImages(json.images, function () {
        if (onLoad !== undefined) onLoad(object);
      });
      var textures = this.parseTextures(json.textures, images);
      var materials = this.parseMaterials(json.materials, textures);
      var object = this.parseObject(json.object, geometries, materials, textures, animations);
      var skeletons = this.parseSkeletons(json.skeletons, object);
      this.bindSkeletons(object, skeletons); //

      if (onLoad !== undefined) {
        var hasImages = false;

        for (var uuid in images) {
          if (images[uuid] instanceof HTMLImageElement) {
            hasImages = true;
            break;
          }
        }

        if (hasImages === false) onLoad(object);
      }

      return object;
    }
  }, {
    key: "parseAsync",
    value: function () {
      var _parseAsync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(json) {
        var animations, shapes, geometries, images, textures, materials, object, skeletons;
        return regeneratorRuntime.wrap(function _callee3$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                animations = this.parseAnimations(json.animations);
                shapes = this.parseShapes(json.shapes);
                geometries = this.parseGeometries(json.geometries, shapes);
                _context7.next = 5;
                return this.parseImagesAsync(json.images);

              case 5:
                images = _context7.sent;
                textures = this.parseTextures(json.textures, images);
                materials = this.parseMaterials(json.materials, textures);
                object = this.parseObject(json.object, geometries, materials, textures, animations);
                skeletons = this.parseSkeletons(json.skeletons, object);
                this.bindSkeletons(object, skeletons);
                return _context7.abrupt("return", object);

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee3, this);
      }));

      function parseAsync(_x9) {
        return _parseAsync.apply(this, arguments);
      }

      return parseAsync;
    }()
  }, {
    key: "parseShapes",
    value: function parseShapes(json) {
      var shapes = {};

      if (json !== undefined) {
        for (var _i293 = 0, l = json.length; _i293 < l; _i293++) {
          var shape = new Shape().fromJSON(json[_i293]);
          shapes[shape.uuid] = shape;
        }
      }

      return shapes;
    }
  }, {
    key: "parseSkeletons",
    value: function parseSkeletons(json, object) {
      var skeletons = {};
      var bones = {}; // generate bone lookup table

      object.traverse(function (child) {
        if (child.isBone) bones[child.uuid] = child;
      }); // create skeletons

      if (json !== undefined) {
        for (var _i294 = 0, l = json.length; _i294 < l; _i294++) {
          var skeleton = new Skeleton().fromJSON(json[_i294], bones);
          skeletons[skeleton.uuid] = skeleton;
        }
      }

      return skeletons;
    }
  }, {
    key: "parseGeometries",
    value: function parseGeometries(json, shapes) {
      var geometries = {};

      if (json !== undefined) {
        var bufferGeometryLoader = new BufferGeometryLoader();

        for (var _i295 = 0, l = json.length; _i295 < l; _i295++) {
          var geometry = void 0;
          var data = json[_i295];

          switch (data.type) {
            case 'BufferGeometry':
            case 'InstancedBufferGeometry':
              geometry = bufferGeometryLoader.parse(data);
              break;

            case 'Geometry':
              console.error('THREE.ObjectLoader: The legacy Geometry type is no longer supported.');
              break;

            default:
              if (data.type in Geometries) {
                geometry = Geometries[data.type].fromJSON(data, shapes);
              } else {
                console.warn("THREE.ObjectLoader: Unsupported geometry type \"".concat(data.type, "\""));
              }

          }

          geometry.uuid = data.uuid;
          if (data.name !== undefined) geometry.name = data.name;
          if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
          geometries[data.uuid] = geometry;
        }
      }

      return geometries;
    }
  }, {
    key: "parseMaterials",
    value: function parseMaterials(json, textures) {
      var cache = {}; // MultiMaterial

      var materials = {};

      if (json !== undefined) {
        var loader = new MaterialLoader();
        loader.setTextures(textures);

        for (var _i296 = 0, l = json.length; _i296 < l; _i296++) {
          var data = json[_i296];

          if (data.type === 'MultiMaterial') {
            // Deprecated
            var array = [];

            for (var j = 0; j < data.materials.length; j++) {
              var material = data.materials[j];

              if (cache[material.uuid] === undefined) {
                cache[material.uuid] = loader.parse(material);
              }

              array.push(cache[material.uuid]);
            }

            materials[data.uuid] = array;
          } else {
            if (cache[data.uuid] === undefined) {
              cache[data.uuid] = loader.parse(data);
            }

            materials[data.uuid] = cache[data.uuid];
          }
        }
      }

      return materials;
    }
  }, {
    key: "parseAnimations",
    value: function parseAnimations(json) {
      var animations = {};

      if (json !== undefined) {
        for (var _i297 = 0; _i297 < json.length; _i297++) {
          var data = json[_i297];
          var clip = AnimationClip.parse(data);
          animations[clip.uuid] = clip;
        }
      }

      return animations;
    }
  }, {
    key: "parseImages",
    value: function parseImages(json, onLoad) {
      var scope = this;
      var images = {};
      var loader;

      function loadImage(url) {
        scope.manager.itemStart(url);
        return loader.load(url, function () {
          scope.manager.itemEnd(url);
        }, undefined, function () {
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        });
      }

      function deserializeImage(image) {
        if (typeof image === 'string') {
          var url = image;
          var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
          return loadImage(path);
        } else {
          if (image.data) {
            return {
              data: getTypedArray(image.type, image.data),
              width: image.width,
              height: image.height
            };
          } else {
            return null;
          }
        }
      }

      if (json !== undefined && json.length > 0) {
        var manager = new LoadingManager(onLoad);
        loader = new ImageLoader(manager);
        loader.setCrossOrigin(this.crossOrigin);

        for (var _i298 = 0, il = json.length; _i298 < il; _i298++) {
          var image = json[_i298];
          var url = image.url;

          if (Array.isArray(url)) {
            // load array of images e.g CubeTexture
            var imageArray = [];

            for (var j = 0, jl = url.length; j < jl; j++) {
              var currentUrl = url[j];
              var deserializedImage = deserializeImage(currentUrl);

              if (deserializedImage !== null) {
                if (deserializedImage instanceof HTMLImageElement) {
                  imageArray.push(deserializedImage);
                } else {
                  // special case: handle array of data textures for cube textures
                  imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                }
              }
            }

            images[image.uuid] = new Source(imageArray);
          } else {
            // load single image
            var _deserializedImage = deserializeImage(image.url);

            images[image.uuid] = new Source(_deserializedImage);
          }
        }
      }

      return images;
    }
  }, {
    key: "parseImagesAsync",
    value: function () {
      var _parseImagesAsync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(json) {
        var scope, images, loader, deserializeImage, _deserializeImage, _i299, il, image, url, imageArray, j, jl, currentUrl, deserializedImage, _deserializedImage2;

        return regeneratorRuntime.wrap(function _callee5$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _deserializeImage = function _deserializeImage3() {
                  _deserializeImage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(image) {
                    var _url, path;

                    return regeneratorRuntime.wrap(function _callee4$(_context8) {
                      while (1) {
                        switch (_context8.prev = _context8.next) {
                          case 0:
                            if (!(typeof image === 'string')) {
                              _context8.next = 8;
                              break;
                            }

                            _url = image;
                            path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(_url) ? _url : scope.resourcePath + _url;
                            _context8.next = 5;
                            return loader.loadAsync(path);

                          case 5:
                            return _context8.abrupt("return", _context8.sent);

                          case 8:
                            if (!image.data) {
                              _context8.next = 12;
                              break;
                            }

                            return _context8.abrupt("return", {
                              data: getTypedArray(image.type, image.data),
                              width: image.width,
                              height: image.height
                            });

                          case 12:
                            return _context8.abrupt("return", null);

                          case 13:
                          case "end":
                            return _context8.stop();
                        }
                      }
                    }, _callee4);
                  }));
                  return _deserializeImage.apply(this, arguments);
                };

                deserializeImage = function _deserializeImage2(_x11) {
                  return _deserializeImage.apply(this, arguments);
                };

                scope = this;
                images = {};

                if (!(json !== undefined && json.length > 0)) {
                  _context9.next = 33;
                  break;
                }

                loader = new ImageLoader(this.manager);
                loader.setCrossOrigin(this.crossOrigin);
                _i299 = 0, il = json.length;

              case 8:
                if (!(_i299 < il)) {
                  _context9.next = 33;
                  break;
                }

                image = json[_i299];
                url = image.url;

                if (!Array.isArray(url)) {
                  _context9.next = 26;
                  break;
                }

                // load array of images e.g CubeTexture
                imageArray = [];
                j = 0, jl = url.length;

              case 14:
                if (!(j < jl)) {
                  _context9.next = 23;
                  break;
                }

                currentUrl = url[j];
                _context9.next = 18;
                return deserializeImage(currentUrl);

              case 18:
                deserializedImage = _context9.sent;

                if (deserializedImage !== null) {
                  if (deserializedImage instanceof HTMLImageElement) {
                    imageArray.push(deserializedImage);
                  } else {
                    // special case: handle array of data textures for cube textures
                    imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                  }
                }

              case 20:
                j++;
                _context9.next = 14;
                break;

              case 23:
                images[image.uuid] = new Source(imageArray);
                _context9.next = 30;
                break;

              case 26:
                _context9.next = 28;
                return deserializeImage(image.url);

              case 28:
                _deserializedImage2 = _context9.sent;
                images[image.uuid] = new Source(_deserializedImage2);

              case 30:
                _i299++;
                _context9.next = 8;
                break;

              case 33:
                return _context9.abrupt("return", images);

              case 34:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee5, this);
      }));

      function parseImagesAsync(_x10) {
        return _parseImagesAsync.apply(this, arguments);
      }

      return parseImagesAsync;
    }()
  }, {
    key: "parseTextures",
    value: function parseTextures(json, images) {
      function parseConstant(value, type) {
        if (typeof value === 'number') return value;
        console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
        return type[value];
      }

      var textures = {};

      if (json !== undefined) {
        for (var _i300 = 0, l = json.length; _i300 < l; _i300++) {
          var data = json[_i300];

          if (data.image === undefined) {
            console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
          }

          if (images[data.image] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined image', data.image);
          }

          var source = images[data.image];
          var image = source.data;
          var texture = void 0;

          if (Array.isArray(image)) {
            texture = new CubeTexture();
            if (image.length === 6) texture.needsUpdate = true;
          } else {
            if (image && image.data) {
              texture = new DataTexture();
            } else {
              texture = new Texture();
            }

            if (image) texture.needsUpdate = true; // textures can have undefined image data
          }

          texture.source = source;
          texture.uuid = data.uuid;
          if (data.name !== undefined) texture.name = data.name;
          if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
          if (data.offset !== undefined) texture.offset.fromArray(data.offset);
          if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
          if (data.center !== undefined) texture.center.fromArray(data.center);
          if (data.rotation !== undefined) texture.rotation = data.rotation;

          if (data.wrap !== undefined) {
            texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
            texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
          }

          if (data.format !== undefined) texture.format = data.format;
          if (data.type !== undefined) texture.type = data.type;
          if (data.encoding !== undefined) texture.encoding = data.encoding;
          if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
          if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
          if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
          if (data.flipY !== undefined) texture.flipY = data.flipY;
          if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
          if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
          if (data.userData !== undefined) texture.userData = data.userData;
          textures[data.uuid] = texture;
        }
      }

      return textures;
    }
  }, {
    key: "parseObject",
    value: function parseObject(data, geometries, materials, textures, animations) {
      var object;

      function getGeometry(name) {
        if (geometries[name] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined geometry', name);
        }

        return geometries[name];
      }

      function getMaterial(name) {
        if (name === undefined) return undefined;

        if (Array.isArray(name)) {
          var array = [];

          for (var _i301 = 0, l = name.length; _i301 < l; _i301++) {
            var uuid = name[_i301];

            if (materials[uuid] === undefined) {
              console.warn('THREE.ObjectLoader: Undefined material', uuid);
            }

            array.push(materials[uuid]);
          }

          return array;
        }

        if (materials[name] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined material', name);
        }

        return materials[name];
      }

      function getTexture(uuid) {
        if (textures[uuid] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined texture', uuid);
        }

        return textures[uuid];
      }

      var geometry, material;

      switch (data.type) {
        case 'Scene':
          object = new Scene();

          if (data.background !== undefined) {
            if (Number.isInteger(data.background)) {
              object.background = new Color(data.background);
            } else {
              object.background = getTexture(data.background);
            }
          }

          if (data.environment !== undefined) {
            object.environment = getTexture(data.environment);
          }

          if (data.fog !== undefined) {
            if (data.fog.type === 'Fog') {
              object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
            } else if (data.fog.type === 'FogExp2') {
              object.fog = new FogExp2(data.fog.color, data.fog.density);
            }
          }

          break;

        case 'PerspectiveCamera':
          object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
          if (data.focus !== undefined) object.focus = data.focus;
          if (data.zoom !== undefined) object.zoom = data.zoom;
          if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
          if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
          if (data.view !== undefined) object.view = Object.assign({}, data.view);
          break;

        case 'OrthographicCamera':
          object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
          if (data.zoom !== undefined) object.zoom = data.zoom;
          if (data.view !== undefined) object.view = Object.assign({}, data.view);
          break;

        case 'AmbientLight':
          object = new AmbientLight(data.color, data.intensity);
          break;

        case 'DirectionalLight':
          object = new DirectionalLight(data.color, data.intensity);
          break;

        case 'PointLight':
          object = new PointLight(data.color, data.intensity, data.distance, data.decay);
          break;

        case 'RectAreaLight':
          object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
          break;

        case 'SpotLight':
          object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
          break;

        case 'HemisphereLight':
          object = new HemisphereLight(data.color, data.groundColor, data.intensity);
          break;

        case 'LightProbe':
          object = new LightProbe().fromJSON(data);
          break;

        case 'SkinnedMesh':
          geometry = getGeometry(data.geometry);
          material = getMaterial(data.material);
          object = new SkinnedMesh(geometry, material);
          if (data.bindMode !== undefined) object.bindMode = data.bindMode;
          if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
          if (data.skeleton !== undefined) object.skeleton = data.skeleton;
          break;

        case 'Mesh':
          geometry = getGeometry(data.geometry);
          material = getMaterial(data.material);
          object = new Mesh(geometry, material);
          break;

        case 'InstancedMesh':
          geometry = getGeometry(data.geometry);
          material = getMaterial(data.material);
          var count = data.count;
          var instanceMatrix = data.instanceMatrix;
          var instanceColor = data.instanceColor;
          object = new InstancedMesh(geometry, material, count);
          object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
          if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
          break;

        case 'LOD':
          object = new LOD();
          break;

        case 'Line':
          object = new Line(getGeometry(data.geometry), getMaterial(data.material));
          break;

        case 'LineLoop':
          object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
          break;

        case 'LineSegments':
          object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
          break;

        case 'PointCloud':
        case 'Points':
          object = new Points(getGeometry(data.geometry), getMaterial(data.material));
          break;

        case 'Sprite':
          object = new Sprite(getMaterial(data.material));
          break;

        case 'Group':
          object = new Group();
          break;

        case 'Bone':
          object = new Bone();
          break;

        default:
          object = new Object3D();
      }

      object.uuid = data.uuid;
      if (data.name !== undefined) object.name = data.name;

      if (data.matrix !== undefined) {
        object.matrix.fromArray(data.matrix);
        if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
        if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
      } else {
        if (data.position !== undefined) object.position.fromArray(data.position);
        if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
        if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
        if (data.scale !== undefined) object.scale.fromArray(data.scale);
      }

      if (data.castShadow !== undefined) object.castShadow = data.castShadow;
      if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

      if (data.shadow) {
        if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
        if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
        if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
        if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
        if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
      }

      if (data.visible !== undefined) object.visible = data.visible;
      if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
      if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
      if (data.userData !== undefined) object.userData = data.userData;
      if (data.layers !== undefined) object.layers.mask = data.layers;

      if (data.children !== undefined) {
        var children = data.children;

        for (var _i302 = 0; _i302 < children.length; _i302++) {
          object.add(this.parseObject(children[_i302], geometries, materials, textures, animations));
        }
      }

      if (data.animations !== undefined) {
        var objectAnimations = data.animations;

        for (var _i303 = 0; _i303 < objectAnimations.length; _i303++) {
          var uuid = objectAnimations[_i303];
          object.animations.push(animations[uuid]);
        }
      }

      if (data.type === 'LOD') {
        if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
        var levels = data.levels;

        for (var l = 0; l < levels.length; l++) {
          var level = levels[l];
          var child = object.getObjectByProperty('uuid', level.object);

          if (child !== undefined) {
            object.addLevel(child, level.distance);
          }
        }
      }

      return object;
    }
  }, {
    key: "bindSkeletons",
    value: function bindSkeletons(object, skeletons) {
      if (Object.keys(skeletons).length === 0) return;
      object.traverse(function (child) {
        if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
          var skeleton = skeletons[child.skeleton];

          if (skeleton === undefined) {
            console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
          } else {
            child.bind(skeleton, child.bindMatrix);
          }
        }
      });
    }
    /* DEPRECATED */

  }, {
    key: "setTexturePath",
    value: function setTexturePath(value) {
      console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
      return this.setResourcePath(value);
    }
  }]);

  return ObjectLoader;
}(Loader);

exports.ObjectLoader = ObjectLoader;
var TEXTURE_MAPPING = {
  UVMapping: UVMapping,
  CubeReflectionMapping: CubeReflectionMapping,
  CubeRefractionMapping: CubeRefractionMapping,
  EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  CubeUVReflectionMapping: CubeUVReflectionMapping
};
var TEXTURE_WRAPPING = {
  RepeatWrapping: RepeatWrapping,
  ClampToEdgeWrapping: ClampToEdgeWrapping,
  MirroredRepeatWrapping: MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
  NearestFilter: NearestFilter,
  NearestMipmapNearestFilter: NearestMipmapNearestFilter,
  NearestMipmapLinearFilter: NearestMipmapLinearFilter,
  LinearFilter: LinearFilter,
  LinearMipmapNearestFilter: LinearMipmapNearestFilter,
  LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

var ImageBitmapLoader = /*#__PURE__*/function (_Loader11) {
  _inherits(ImageBitmapLoader, _Loader11);

  var _super132 = _createSuper(ImageBitmapLoader);

  function ImageBitmapLoader(manager) {
    var _this104;

    _classCallCheck(this, ImageBitmapLoader);

    _this104 = _super132.call(this, manager);

    if (typeof createImageBitmap === 'undefined') {
      console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
    }

    if (typeof fetch === 'undefined') {
      console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
    }

    _this104.options = {
      premultiplyAlpha: 'none'
    };
    return _this104;
  }

  _createClass(ImageBitmapLoader, [{
    key: "setOptions",
    value: function setOptions(options) {
      this.options = options;
      return this;
    }
  }, {
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      if (url === undefined) url = '';
      if (this.path !== undefined) url = this.path + url;
      url = this.manager.resolveURL(url);
      var scope = this;
      var cached = Cache.get(url);

      if (cached !== undefined) {
        scope.manager.itemStart(url);
        setTimeout(function () {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }

      var fetchOptions = {};
      fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
      fetchOptions.headers = this.requestHeader;
      fetch(url, fetchOptions).then(function (res) {
        return res.blob();
      }).then(function (blob) {
        return createImageBitmap(blob, Object.assign(scope.options, {
          colorSpaceConversion: 'none'
        }));
      }).then(function (imageBitmap) {
        Cache.add(url, imageBitmap);
        if (onLoad) onLoad(imageBitmap);
        scope.manager.itemEnd(url);
      }).catch(function (e) {
        if (onError) onError(e);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
      scope.manager.itemStart(url);
    }
  }]);

  return ImageBitmapLoader;
}(Loader);

exports.ImageBitmapLoader = ImageBitmapLoader;
ImageBitmapLoader.prototype.isImageBitmapLoader = true;

var _context;

var AudioContext = {
  getContext: function getContext() {
    if (_context === undefined) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }

    return _context;
  },
  setContext: function setContext(value) {
    _context = value;
  }
};
exports.AudioContext = AudioContext;

var AudioLoader = /*#__PURE__*/function (_Loader12) {
  _inherits(AudioLoader, _Loader12);

  var _super133 = _createSuper(AudioLoader);

  function AudioLoader(manager) {
    _classCallCheck(this, AudioLoader);

    return _super133.call(this, manager);
  }

  _createClass(AudioLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(this.manager);
      loader.setResponseType('arraybuffer');
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function (buffer) {
        try {
          // Create a copy of the buffer. The `decodeAudioData` method
          // detaches the buffer when complete, preventing reuse.
          var bufferCopy = buffer.slice(0);
          var context = AudioContext.getContext();
          context.decodeAudioData(bufferCopy, function (audioBuffer) {
            onLoad(audioBuffer);
          });
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }

          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  }]);

  return AudioLoader;
}(Loader);

exports.AudioLoader = AudioLoader;

var HemisphereLightProbe = /*#__PURE__*/function (_LightProbe) {
  _inherits(HemisphereLightProbe, _LightProbe);

  var _super134 = _createSuper(HemisphereLightProbe);

  function HemisphereLightProbe(skyColor, groundColor, intensity = 1) {
    var _this105;

    _classCallCheck(this, HemisphereLightProbe);

    _this105 = _super134.call(this, undefined, intensity);
    var color1 = new Color().set(skyColor);
    var color2 = new Color().set(groundColor);
    var sky = new Vector3(color1.r, color1.g, color1.b);
    var ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );

    var c0 = Math.sqrt(Math.PI);
    var c1 = c0 * Math.sqrt(0.75);

    _this105.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);

    _this105.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);

    return _this105;
  }

  return _createClass(HemisphereLightProbe);
}(LightProbe);

exports.HemisphereLightProbe = HemisphereLightProbe;
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

var AmbientLightProbe = /*#__PURE__*/function (_LightProbe2) {
  _inherits(AmbientLightProbe, _LightProbe2);

  var _super135 = _createSuper(AmbientLightProbe);

  function AmbientLightProbe(color, intensity = 1) {
    var _this106;

    _classCallCheck(this, AmbientLightProbe);

    _this106 = _super135.call(this, undefined, intensity);
    var color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

    _this106.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));

    return _this106;
  }

  return _createClass(AmbientLightProbe);
}(LightProbe);

exports.AmbientLightProbe = AmbientLightProbe;
AmbientLightProbe.prototype.isAmbientLightProbe = true;

var _eyeRight = /*@__PURE__*/new Matrix4();

var _eyeLeft = /*@__PURE__*/new Matrix4();

var _projectionMatrix = /*@__PURE__*/new Matrix4();

var StereoCamera = /*#__PURE__*/function () {
  function StereoCamera() {
    _classCallCheck(this, StereoCamera);

    this.type = 'StereoCamera';
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }

  _createClass(StereoCamera, [{
    key: "update",
    value: function update(camera) {
      var cache = this._cache;
      var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

      if (needsUpdate) {
        cache.focus = camera.focus;
        cache.fov = camera.fov;
        cache.aspect = camera.aspect * this.aspect;
        cache.near = camera.near;
        cache.far = camera.far;
        cache.zoom = camera.zoom;
        cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
        // http://paulbourke.net/stereographics/stereorender/

        _projectionMatrix.copy(camera.projectionMatrix);

        var eyeSepHalf = cache.eyeSep / 2;
        var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
        var ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
        var xmin, xmax; // translate xOffset

        _eyeLeft.elements[12] = -eyeSepHalf;
        _eyeRight.elements[12] = eyeSepHalf; // for left eye

        xmin = -ymax * cache.aspect + eyeSepOnProjection;
        xmax = ymax * cache.aspect + eyeSepOnProjection;
        _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
        _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraL.projectionMatrix.copy(_projectionMatrix); // for right eye

        xmin = -ymax * cache.aspect - eyeSepOnProjection;
        xmax = ymax * cache.aspect - eyeSepOnProjection;
        _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
        _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraR.projectionMatrix.copy(_projectionMatrix);
      }

      this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
      this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
    }
  }]);

  return StereoCamera;
}();

exports.StereoCamera = StereoCamera;

var Clock = /*#__PURE__*/function () {
  function Clock(autoStart = true) {
    _classCallCheck(this, Clock);

    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }

  _createClass(Clock, [{
    key: "start",
    value: function start() {
      this.startTime = now();
      this.oldTime = this.startTime;
      this.elapsedTime = 0;
      this.running = true;
    }
  }, {
    key: "stop",
    value: function stop() {
      this.getElapsedTime();
      this.running = false;
      this.autoStart = false;
    }
  }, {
    key: "getElapsedTime",
    value: function getElapsedTime() {
      this.getDelta();
      return this.elapsedTime;
    }
  }, {
    key: "getDelta",
    value: function getDelta() {
      var diff = 0;

      if (this.autoStart && !this.running) {
        this.start();
        return 0;
      }

      if (this.running) {
        var newTime = now();
        diff = (newTime - this.oldTime) / 1000;
        this.oldTime = newTime;
        this.elapsedTime += diff;
      }

      return diff;
    }
  }]);

  return Clock;
}();

exports.Clock = Clock;

function now() {
  return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
}

var _position$1 = /*@__PURE__*/new Vector3();

var _quaternion$1 = /*@__PURE__*/new Quaternion();

var _scale$1 = /*@__PURE__*/new Vector3();

var _orientation$1 = /*@__PURE__*/new Vector3();

var AudioListener = /*#__PURE__*/function (_Object3D12) {
  _inherits(AudioListener, _Object3D12);

  var _super136 = _createSuper(AudioListener);

  function AudioListener() {
    var _this107;

    _classCallCheck(this, AudioListener);

    _this107 = _super136.call(this);
    _this107.type = 'AudioListener';
    _this107.context = AudioContext.getContext();
    _this107.gain = _this107.context.createGain();

    _this107.gain.connect(_this107.context.destination);

    _this107.filter = null;
    _this107.timeDelta = 0; // private

    _this107._clock = new Clock();
    return _this107;
  }

  _createClass(AudioListener, [{
    key: "getInput",
    value: function getInput() {
      return this.gain;
    }
  }, {
    key: "removeFilter",
    value: function removeFilter() {
      if (this.filter !== null) {
        this.gain.disconnect(this.filter);
        this.filter.disconnect(this.context.destination);
        this.gain.connect(this.context.destination);
        this.filter = null;
      }

      return this;
    }
  }, {
    key: "getFilter",
    value: function getFilter() {
      return this.filter;
    }
  }, {
    key: "setFilter",
    value: function setFilter(value) {
      if (this.filter !== null) {
        this.gain.disconnect(this.filter);
        this.filter.disconnect(this.context.destination);
      } else {
        this.gain.disconnect(this.context.destination);
      }

      this.filter = value;
      this.gain.connect(this.filter);
      this.filter.connect(this.context.destination);
      return this;
    }
  }, {
    key: "getMasterVolume",
    value: function getMasterVolume() {
      return this.gain.gain.value;
    }
  }, {
    key: "setMasterVolume",
    value: function setMasterVolume(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      _get(_getPrototypeOf(AudioListener.prototype), "updateMatrixWorld", this).call(this, force);

      var listener = this.context.listener;
      var up = this.up;
      this.timeDelta = this._clock.getDelta();
      this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);

      _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);

      if (listener.positionX) {
        // code path for Chrome (see #14393)
        var endTime = this.context.currentTime + this.timeDelta;
        listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
        listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
        listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
        listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
        listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
        listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
        listener.upX.linearRampToValueAtTime(up.x, endTime);
        listener.upY.linearRampToValueAtTime(up.y, endTime);
        listener.upZ.linearRampToValueAtTime(up.z, endTime);
      } else {
        listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
        listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
      }
    }
  }]);

  return AudioListener;
}(Object3D);

exports.AudioListener = AudioListener;

var Audio = /*#__PURE__*/function (_Object3D13) {
  _inherits(Audio, _Object3D13);

  var _super137 = _createSuper(Audio);

  function Audio(listener) {
    var _this108;

    _classCallCheck(this, Audio);

    _this108 = _super137.call(this);
    _this108.type = 'Audio';
    _this108.listener = listener;
    _this108.context = listener.context;
    _this108.gain = _this108.context.createGain();

    _this108.gain.connect(listener.getInput());

    _this108.autoplay = false;
    _this108.buffer = null;
    _this108.detune = 0;
    _this108.loop = false;
    _this108.loopStart = 0;
    _this108.loopEnd = 0;
    _this108.offset = 0;
    _this108.duration = undefined;
    _this108.playbackRate = 1;
    _this108.isPlaying = false;
    _this108.hasPlaybackControl = true;
    _this108.source = null;
    _this108.sourceType = 'empty';
    _this108._startedAt = 0;
    _this108._progress = 0;
    _this108._connected = false;
    _this108.filters = [];
    return _this108;
  }

  _createClass(Audio, [{
    key: "getOutput",
    value: function getOutput() {
      return this.gain;
    }
  }, {
    key: "setNodeSource",
    value: function setNodeSource(audioNode) {
      this.hasPlaybackControl = false;
      this.sourceType = 'audioNode';
      this.source = audioNode;
      this.connect();
      return this;
    }
  }, {
    key: "setMediaElementSource",
    value: function setMediaElementSource(mediaElement) {
      this.hasPlaybackControl = false;
      this.sourceType = 'mediaNode';
      this.source = this.context.createMediaElementSource(mediaElement);
      this.connect();
      return this;
    }
  }, {
    key: "setMediaStreamSource",
    value: function setMediaStreamSource(mediaStream) {
      this.hasPlaybackControl = false;
      this.sourceType = 'mediaStreamNode';
      this.source = this.context.createMediaStreamSource(mediaStream);
      this.connect();
      return this;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(audioBuffer) {
      this.buffer = audioBuffer;
      this.sourceType = 'buffer';
      if (this.autoplay) this.play();
      return this;
    }
  }, {
    key: "play",
    value: function play(delay = 0) {
      if (this.isPlaying === true) {
        console.warn('THREE.Audio: Audio is already playing.');
        return;
      }

      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }

      this._startedAt = this.context.currentTime + delay;
      var source = this.context.createBufferSource();
      source.buffer = this.buffer;
      source.loop = this.loop;
      source.loopStart = this.loopStart;
      source.loopEnd = this.loopEnd;
      source.onended = this.onEnded.bind(this);
      source.start(this._startedAt, this._progress + this.offset, this.duration);
      this.isPlaying = true;
      this.source = source;
      this.setDetune(this.detune);
      this.setPlaybackRate(this.playbackRate);
      return this.connect();
    }
  }, {
    key: "pause",
    value: function pause() {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }

      if (this.isPlaying === true) {
        // update current progress
        this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;

        if (this.loop === true) {
          // ensure _progress does not exceed duration with looped audios
          this._progress = this._progress % (this.duration || this.buffer.duration);
        }

        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
      }

      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }

      this._progress = 0;
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
      return this;
    }
  }, {
    key: "connect",
    value: function connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);

        for (var _i304 = 1, l = this.filters.length; _i304 < l; _i304++) {
          this.filters[_i304 - 1].connect(this.filters[_i304]);
        }

        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else {
        this.source.connect(this.getOutput());
      }

      this._connected = true;
      return this;
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);

        for (var _i305 = 1, l = this.filters.length; _i305 < l; _i305++) {
          this.filters[_i305 - 1].disconnect(this.filters[_i305]);
        }

        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else {
        this.source.disconnect(this.getOutput());
      }

      this._connected = false;
      return this;
    }
  }, {
    key: "getFilters",
    value: function getFilters() {
      return this.filters;
    }
  }, {
    key: "setFilters",
    value: function setFilters(value) {
      if (!value) value = [];

      if (this._connected === true) {
        this.disconnect();
        this.filters = value.slice();
        this.connect();
      } else {
        this.filters = value.slice();
      }

      return this;
    }
  }, {
    key: "setDetune",
    value: function setDetune(value) {
      this.detune = value;
      if (this.source.detune === undefined) return; // only set detune when available

      if (this.isPlaying === true) {
        this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
      }

      return this;
    }
  }, {
    key: "getDetune",
    value: function getDetune() {
      return this.detune;
    }
  }, {
    key: "getFilter",
    value: function getFilter() {
      return this.getFilters()[0];
    }
  }, {
    key: "setFilter",
    value: function setFilter(filter) {
      return this.setFilters(filter ? [filter] : []);
    }
  }, {
    key: "setPlaybackRate",
    value: function setPlaybackRate(value) {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }

      this.playbackRate = value;

      if (this.isPlaying === true) {
        this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
      }

      return this;
    }
  }, {
    key: "getPlaybackRate",
    value: function getPlaybackRate() {
      return this.playbackRate;
    }
  }, {
    key: "onEnded",
    value: function onEnded() {
      this.isPlaying = false;
    }
  }, {
    key: "getLoop",
    value: function getLoop() {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return false;
      }

      return this.loop;
    }
  }, {
    key: "setLoop",
    value: function setLoop(value) {
      if (this.hasPlaybackControl === false) {
        console.warn('THREE.Audio: this Audio has no playback control.');
        return;
      }

      this.loop = value;

      if (this.isPlaying === true) {
        this.source.loop = this.loop;
      }

      return this;
    }
  }, {
    key: "setLoopStart",
    value: function setLoopStart(value) {
      this.loopStart = value;
      return this;
    }
  }, {
    key: "setLoopEnd",
    value: function setLoopEnd(value) {
      this.loopEnd = value;
      return this;
    }
  }, {
    key: "getVolume",
    value: function getVolume() {
      return this.gain.gain.value;
    }
  }, {
    key: "setVolume",
    value: function setVolume(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    }
  }]);

  return Audio;
}(Object3D);

exports.Audio = Audio;

var _position = /*@__PURE__*/new Vector3();

var _quaternion = /*@__PURE__*/new Quaternion();

var _scale = /*@__PURE__*/new Vector3();

var _orientation = /*@__PURE__*/new Vector3();

var PositionalAudio = /*#__PURE__*/function (_Audio) {
  _inherits(PositionalAudio, _Audio);

  var _super138 = _createSuper(PositionalAudio);

  function PositionalAudio(listener) {
    var _this109;

    _classCallCheck(this, PositionalAudio);

    _this109 = _super138.call(this, listener);
    _this109.panner = _this109.context.createPanner();
    _this109.panner.panningModel = 'HRTF';

    _this109.panner.connect(_this109.gain);

    return _this109;
  }

  _createClass(PositionalAudio, [{
    key: "disconnect",
    value: function disconnect() {
      _get(_getPrototypeOf(PositionalAudio.prototype), "disconnect", this).call(this);

      this.panner.disconnect(this.gain);
    }
  }, {
    key: "getOutput",
    value: function getOutput() {
      return this.panner;
    }
  }, {
    key: "getRefDistance",
    value: function getRefDistance() {
      return this.panner.refDistance;
    }
  }, {
    key: "setRefDistance",
    value: function setRefDistance(value) {
      this.panner.refDistance = value;
      return this;
    }
  }, {
    key: "getRolloffFactor",
    value: function getRolloffFactor() {
      return this.panner.rolloffFactor;
    }
  }, {
    key: "setRolloffFactor",
    value: function setRolloffFactor(value) {
      this.panner.rolloffFactor = value;
      return this;
    }
  }, {
    key: "getDistanceModel",
    value: function getDistanceModel() {
      return this.panner.distanceModel;
    }
  }, {
    key: "setDistanceModel",
    value: function setDistanceModel(value) {
      this.panner.distanceModel = value;
      return this;
    }
  }, {
    key: "getMaxDistance",
    value: function getMaxDistance() {
      return this.panner.maxDistance;
    }
  }, {
    key: "setMaxDistance",
    value: function setMaxDistance(value) {
      this.panner.maxDistance = value;
      return this;
    }
  }, {
    key: "setDirectionalCone",
    value: function setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
      this.panner.coneInnerAngle = coneInnerAngle;
      this.panner.coneOuterAngle = coneOuterAngle;
      this.panner.coneOuterGain = coneOuterGain;
      return this;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      _get(_getPrototypeOf(PositionalAudio.prototype), "updateMatrixWorld", this).call(this, force);

      if (this.hasPlaybackControl === true && this.isPlaying === false) return;
      this.matrixWorld.decompose(_position, _quaternion, _scale);

      _orientation.set(0, 0, 1).applyQuaternion(_quaternion);

      var panner = this.panner;

      if (panner.positionX) {
        // code path for Chrome and Firefox (see #14393)
        var endTime = this.context.currentTime + this.listener.timeDelta;
        panner.positionX.linearRampToValueAtTime(_position.x, endTime);
        panner.positionY.linearRampToValueAtTime(_position.y, endTime);
        panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
        panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
        panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
        panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
      } else {
        panner.setPosition(_position.x, _position.y, _position.z);
        panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
      }
    }
  }]);

  return PositionalAudio;
}(Audio);

exports.PositionalAudio = PositionalAudio;

var AudioAnalyser = /*#__PURE__*/function () {
  function AudioAnalyser(audio, fftSize = 2048) {
    _classCallCheck(this, AudioAnalyser);

    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }

  _createClass(AudioAnalyser, [{
    key: "getFrequencyData",
    value: function getFrequencyData() {
      this.analyser.getByteFrequencyData(this.data);
      return this.data;
    }
  }, {
    key: "getAverageFrequency",
    value: function getAverageFrequency() {
      var value = 0;
      var data = this.getFrequencyData();

      for (var _i306 = 0; _i306 < data.length; _i306++) {
        value += data[_i306];
      }

      return value / data.length;
    }
  }]);

  return AudioAnalyser;
}();

exports.AudioAnalyser = AudioAnalyser;

var PropertyMixer = /*#__PURE__*/function () {
  function PropertyMixer(binding, typeName, valueSize) {
    _classCallCheck(this, PropertyMixer);

    this.binding = binding;
    this.valueSize = valueSize;
    var mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
    //
    // interpolators can use .buffer as their .result
    // the data then goes to 'incoming'
    //
    // 'accu0' and 'accu1' are used frame-interleaved for
    // the cumulative result and are compared to detect
    // changes
    //
    // 'orig' stores the original state of the property
    //
    // 'add' is used for additive cumulative results
    //
    // 'work' is optional and is only present for quaternion types. It is used
    // to store intermediate quaternion multiplication results

    switch (typeName) {
      case 'quaternion':
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;

      case 'string':
      case 'bool':
        mixFunction = this._select; // Use the regular mix function and for additive on these types,
        // additive is not relevant for non-numeric types

        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;

      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }

    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  } // accumulate data in the 'incoming' region into 'accu<i>'


  _createClass(PropertyMixer, [{
    key: "accumulate",
    value: function accumulate(accuIndex, weight) {
      // note: happily accumulating nothing when weight = 0, the caller knows
      // the weight and shouldn't have made the call in the first place
      var buffer = this.buffer,
          stride = this.valueSize,
          offset = accuIndex * stride + stride;
      var currentWeight = this.cumulativeWeight;

      if (currentWeight === 0) {
        // accuN := incoming * weight
        for (var _i307 = 0; _i307 !== stride; ++_i307) {
          buffer[offset + _i307] = buffer[_i307];
        }

        currentWeight = weight;
      } else {
        // accuN := accuN + incoming * weight
        currentWeight += weight;
        var mix = weight / currentWeight;

        this._mixBufferRegion(buffer, offset, 0, mix, stride);
      }

      this.cumulativeWeight = currentWeight;
    } // accumulate data in the 'incoming' region into 'add'

  }, {
    key: "accumulateAdditive",
    value: function accumulateAdditive(weight) {
      var buffer = this.buffer,
          stride = this.valueSize,
          offset = stride * this._addIndex;

      if (this.cumulativeWeightAdditive === 0) {
        // add = identity
        this._setIdentity();
      } // add := add + incoming * weight


      this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);

      this.cumulativeWeightAdditive += weight;
    } // apply the state of 'accu<i>' to the binding when accus differ

  }, {
    key: "apply",
    value: function apply(accuIndex) {
      var stride = this.valueSize,
          buffer = this.buffer,
          offset = accuIndex * stride + stride,
          weight = this.cumulativeWeight,
          weightAdditive = this.cumulativeWeightAdditive,
          binding = this.binding;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;

      if (weight < 1) {
        // accuN := accuN + original * ( 1 - cumulativeWeight )
        var originalValueOffset = stride * this._origIndex;

        this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
      }

      if (weightAdditive > 0) {
        // accuN := accuN + additive accuN
        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
      }

      for (var _i308 = stride, e = stride + stride; _i308 !== e; ++_i308) {
        if (buffer[_i308] !== buffer[_i308 + stride]) {
          // value has changed -> update scene graph
          binding.setValue(buffer, offset);
          break;
        }
      }
    } // remember the state of the bound property and copy it to both accus

  }, {
    key: "saveOriginalState",
    value: function saveOriginalState() {
      var binding = this.binding;
      var buffer = this.buffer,
          stride = this.valueSize,
          originalValueOffset = stride * this._origIndex;
      binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

      for (var _i309 = stride, e = originalValueOffset; _i309 !== e; ++_i309) {
        buffer[_i309] = buffer[originalValueOffset + _i309 % stride];
      } // Add to identity for additive


      this._setIdentity();

      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
    } // apply the state previously taken via 'saveOriginalState' to the binding

  }, {
    key: "restoreOriginalState",
    value: function restoreOriginalState() {
      var originalValueOffset = this.valueSize * 3;
      this.binding.setValue(this.buffer, originalValueOffset);
    }
  }, {
    key: "_setAdditiveIdentityNumeric",
    value: function _setAdditiveIdentityNumeric() {
      var startIndex = this._addIndex * this.valueSize;
      var endIndex = startIndex + this.valueSize;

      for (var _i310 = startIndex; _i310 < endIndex; _i310++) {
        this.buffer[_i310] = 0;
      }
    }
  }, {
    key: "_setAdditiveIdentityQuaternion",
    value: function _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric();

      this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
  }, {
    key: "_setAdditiveIdentityOther",
    value: function _setAdditiveIdentityOther() {
      var startIndex = this._origIndex * this.valueSize;
      var targetIndex = this._addIndex * this.valueSize;

      for (var _i311 = 0; _i311 < this.valueSize; _i311++) {
        this.buffer[targetIndex + _i311] = this.buffer[startIndex + _i311];
      }
    } // mix functions

  }, {
    key: "_select",
    value: function _select(buffer, dstOffset, srcOffset, t, stride) {
      if (t >= 0.5) {
        for (var _i312 = 0; _i312 !== stride; ++_i312) {
          buffer[dstOffset + _i312] = buffer[srcOffset + _i312];
        }
      }
    }
  }, {
    key: "_slerp",
    value: function _slerp(buffer, dstOffset, srcOffset, t) {
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    }
  }, {
    key: "_slerpAdditive",
    value: function _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
      var workOffset = this._workIndex * stride; // Store result in intermediate buffer offset

      Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result

      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
    }
  }, {
    key: "_lerp",
    value: function _lerp(buffer, dstOffset, srcOffset, t, stride) {
      var s = 1 - t;

      for (var _i313 = 0; _i313 !== stride; ++_i313) {
        var j = dstOffset + _i313;
        buffer[j] = buffer[j] * s + buffer[srcOffset + _i313] * t;
      }
    }
  }, {
    key: "_lerpAdditive",
    value: function _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
      for (var _i314 = 0; _i314 !== stride; ++_i314) {
        var j = dstOffset + _i314;
        buffer[j] = buffer[j] + buffer[srcOffset + _i314] * t;
      }
    }
  }]);

  return PropertyMixer;
}(); // Characters [].:/ are reserved for track binding syntax.


exports.PropertyMixer = PropertyMixer;
var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

var _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.


var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.


var _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.


var _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.


var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.


var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

var _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

var _supportedObjectNames = ['material', 'materials', 'bones'];

var Composite = /*#__PURE__*/function () {
  function Composite(targetGroup, path, optionalParsedPath) {
    _classCallCheck(this, Composite);

    var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }

  _createClass(Composite, [{
    key: "getValue",
    value: function getValue(array, offset) {
      this.bind(); // bind all binding

      var firstValidIndex = this._targetGroup.nCachedObjects_,
          binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

      if (binding !== undefined) binding.getValue(array, offset);
    }
  }, {
    key: "setValue",
    value: function setValue(array, offset) {
      var bindings = this._bindings;

      for (var _i315 = this._targetGroup.nCachedObjects_, n = bindings.length; _i315 !== n; ++_i315) {
        bindings[_i315].setValue(array, offset);
      }
    }
  }, {
    key: "bind",
    value: function bind() {
      var bindings = this._bindings;

      for (var _i316 = this._targetGroup.nCachedObjects_, n = bindings.length; _i316 !== n; ++_i316) {
        bindings[_i316].bind();
      }
    }
  }, {
    key: "unbind",
    value: function unbind() {
      var bindings = this._bindings;

      for (var _i317 = this._targetGroup.nCachedObjects_, n = bindings.length; _i317 !== n; ++_i317) {
        bindings[_i317].unbind();
      }
    }
  }]);

  return Composite;
}(); // Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.


var PropertyBinding = /*#__PURE__*/function () {
  function PropertyBinding(rootNode, path, parsedPath) {
    _classCallCheck(this, PropertyBinding);

    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode; // initial state of these methods that calls 'bind'

    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }

  _createClass(PropertyBinding, [{
    key: "_getValue_unavailable",
    value: // these are used to "bind" a nonexistent property
    function _getValue_unavailable() {}
  }, {
    key: "_setValue_unavailable",
    value: function _setValue_unavailable() {} // Getters

  }, {
    key: "_getValue_direct",
    value: function _getValue_direct(buffer, offset) {
      buffer[offset] = this.targetObject[this.propertyName];
    }
  }, {
    key: "_getValue_array",
    value: function _getValue_array(buffer, offset) {
      var source = this.resolvedProperty;

      for (var _i318 = 0, n = source.length; _i318 !== n; ++_i318) {
        buffer[offset++] = source[_i318];
      }
    }
  }, {
    key: "_getValue_arrayElement",
    value: function _getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    }
  }, {
    key: "_getValue_toArray",
    value: function _getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    } // Direct

  }, {
    key: "_setValue_direct",
    value: function _setValue_direct(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
    }
  }, {
    key: "_setValue_direct_setNeedsUpdate",
    value: function _setValue_direct_setNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
  }, {
    key: "_setValue_direct_setMatrixWorldNeedsUpdate",
    value: function _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    } // EntireArray

  }, {
    key: "_setValue_array",
    value: function _setValue_array(buffer, offset) {
      var dest = this.resolvedProperty;

      for (var _i319 = 0, n = dest.length; _i319 !== n; ++_i319) {
        dest[_i319] = buffer[offset++];
      }
    }
  }, {
    key: "_setValue_array_setNeedsUpdate",
    value: function _setValue_array_setNeedsUpdate(buffer, offset) {
      var dest = this.resolvedProperty;

      for (var _i320 = 0, n = dest.length; _i320 !== n; ++_i320) {
        dest[_i320] = buffer[offset++];
      }

      this.targetObject.needsUpdate = true;
    }
  }, {
    key: "_setValue_array_setMatrixWorldNeedsUpdate",
    value: function _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
      var dest = this.resolvedProperty;

      for (var _i321 = 0, n = dest.length; _i321 !== n; ++_i321) {
        dest[_i321] = buffer[offset++];
      }

      this.targetObject.matrixWorldNeedsUpdate = true;
    } // ArrayElement

  }, {
    key: "_setValue_arrayElement",
    value: function _setValue_arrayElement(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
    }
  }, {
    key: "_setValue_arrayElement_setNeedsUpdate",
    value: function _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
  }, {
    key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
    value: function _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    } // HasToFromArray

  }, {
    key: "_setValue_fromArray",
    value: function _setValue_fromArray(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
    }
  }, {
    key: "_setValue_fromArray_setNeedsUpdate",
    value: function _setValue_fromArray_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.needsUpdate = true;
    }
  }, {
    key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
    value: function _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
  }, {
    key: "_getValue_unbound",
    value: function _getValue_unbound(targetArray, offset) {
      this.bind();
      this.getValue(targetArray, offset);
    }
  }, {
    key: "_setValue_unbound",
    value: function _setValue_unbound(sourceArray, offset) {
      this.bind();
      this.setValue(sourceArray, offset);
    } // create getter / setter pair for a property in the scene graph

  }, {
    key: "bind",
    value: function bind() {
      var targetObject = this.node;
      var parsedPath = this.parsedPath;
      var objectName = parsedPath.objectName;
      var propertyName = parsedPath.propertyName;
      var propertyIndex = parsedPath.propertyIndex;

      if (!targetObject) {
        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
        this.node = targetObject;
      } // set fail state so we can just 'return' on error


      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable; // ensure there is a value node

      if (!targetObject) {
        console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
        return;
      }

      if (objectName) {
        var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

        switch (objectName) {
          case 'materials':
            if (!targetObject.material) {
              console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
              return;
            }

            if (!targetObject.material.materials) {
              console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
              return;
            }

            targetObject = targetObject.material.materials;
            break;

          case 'bones':
            if (!targetObject.skeleton) {
              console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
              return;
            } // potential future optimization: skip this if propertyIndex is already an integer
            // and convert the integer string to a true integer.


            targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

            for (var _i322 = 0; _i322 < targetObject.length; _i322++) {
              if (targetObject[_i322].name === objectIndex) {
                objectIndex = _i322;
                break;
              }
            }

            break;

          default:
            if (targetObject[objectName] === undefined) {
              console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
              return;
            }

            targetObject = targetObject[objectName];
        }

        if (objectIndex !== undefined) {
          if (targetObject[objectIndex] === undefined) {
            console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
            return;
          }

          targetObject = targetObject[objectIndex];
        }
      } // resolve property


      var nodeProperty = targetObject[propertyName];

      if (nodeProperty === undefined) {
        var nodeName = parsedPath.nodeName;
        console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
        return;
      } // determine versioning scheme


      var versioning = this.Versioning.None;
      this.targetObject = targetObject;

      if (targetObject.needsUpdate !== undefined) {
        // material
        versioning = this.Versioning.NeedsUpdate;
      } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
        // node transform
        versioning = this.Versioning.MatrixWorldNeedsUpdate;
      } // determine how the property gets bound


      var bindingType = this.BindingType.Direct;

      if (propertyIndex !== undefined) {
        // access a sub element of the property array (only primitives are supported right now)
        if (propertyName === 'morphTargetInfluences') {
          // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
          // support resolving morphTarget names into indices.
          if (!targetObject.geometry) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
            return;
          }

          if (targetObject.geometry.isBufferGeometry) {
            if (!targetObject.geometry.morphAttributes) {
              console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
              return;
            }

            if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
              propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
            }
          } else {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
            return;
          }
        }

        bindingType = this.BindingType.ArrayElement;
        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;
      } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
        // must use copy for Object3D.Euler/Quaternion
        bindingType = this.BindingType.HasFromToArray;
        this.resolvedProperty = nodeProperty;
      } else if (Array.isArray(nodeProperty)) {
        bindingType = this.BindingType.EntireArray;
        this.resolvedProperty = nodeProperty;
      } else {
        this.propertyName = propertyName;
      } // select getter / setter


      this.getValue = this.GetterByBindingType[bindingType];
      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    }
  }, {
    key: "unbind",
    value: function unbind() {
      this.node = null; // back to the prototype version of getValue / setValue
      // note: avoiding to mutate the shape of 'this' via 'delete'

      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  }], [{
    key: "create",
    value: function create(root, path, parsedPath) {
      if (!(root && root.isAnimationObjectGroup)) {
        return new PropertyBinding(root, path, parsedPath);
      } else {
        return new PropertyBinding.Composite(root, path, parsedPath);
      }
    }
    /**
     * Replaces spaces with underscores and removes unsupported characters from
     * node names, to ensure compatibility with parseTrackName().
     *
     * @param {string} name Node name to be sanitized.
     * @return {string}
     */

  }, {
    key: "sanitizeNodeName",
    value: function sanitizeNodeName(name) {
      return name.replace(/\s/g, '_').replace(_reservedRe, '');
    }
  }, {
    key: "parseTrackName",
    value: function parseTrackName(trackName) {
      var matches = _trackRe.exec(trackName);

      if (matches === null) {
        throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
      }

      var results = {
        // directoryName: matches[ 1 ], // (tschw) currently unused
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        // required
        propertyIndex: matches[6]
      };
      var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

      if (lastDot !== undefined && lastDot !== -1) {
        var objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there
        // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
        // 'bar' could be the objectName, or part of a nodeName (which can
        // include '.' characters).

        if (_supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }

      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
      }

      return results;
    }
  }, {
    key: "findNode",
    value: function findNode(root, nodeName) {
      if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      } // search into skeleton bones.


      if (root.skeleton) {
        var bone = root.skeleton.getBoneByName(nodeName);

        if (bone !== undefined) {
          return bone;
        }
      } // search into node subtree.


      if (root.children) {
        var searchNodeSubtree = function searchNodeSubtree(children) {
          for (var _i323 = 0; _i323 < children.length; _i323++) {
            var childNode = children[_i323];

            if (childNode.name === nodeName || childNode.uuid === nodeName) {
              return childNode;
            }

            var result = searchNodeSubtree(childNode.children);
            if (result) return result;
          }

          return null;
        };

        var subTreeNode = searchNodeSubtree(root.children);

        if (subTreeNode) {
          return subTreeNode;
        }
      }

      return null;
    }
  }]);

  return PropertyBinding;
}();

exports.PropertyBinding = PropertyBinding;
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct
PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray
PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement
PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray
PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

var AnimationObjectGroup = /*#__PURE__*/function () {
  function AnimationObjectGroup() {
    _classCallCheck(this, AnimationObjectGroup);

    this.uuid = generateUUID(); // cached objects followed by the active ones

    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0; // threshold
    // note: read by PropertyBinding.Composite

    var indices = {};
    this._indicesByUUID = indices; // for bookkeeping

    for (var _i324 = 0, n = arguments.length; _i324 !== n; ++_i324) {
      indices[arguments[_i324].uuid] = _i324;
    }

    this._paths = []; // inside: string

    this._parsedPaths = []; // inside: { we don't care, here }

    this._bindings = []; // inside: Array< PropertyBinding >

    this._bindingsIndicesByPath = {}; // inside: indices in these arrays

    var scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },

        get inUse() {
          return this.total - scope.nCachedObjects_;
        }

      },

      get bindingsPerObject() {
        return scope._bindings.length;
      }

    };
  }

  _createClass(AnimationObjectGroup, [{
    key: "add",
    value: function add() {
      var objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          paths = this._paths,
          parsedPaths = this._parsedPaths,
          bindings = this._bindings,
          nBindings = bindings.length;
      var knownObject = undefined,
          nObjects = objects.length,
          nCachedObjects = this.nCachedObjects_;

      for (var _i325 = 0, n = arguments.length; _i325 !== n; ++_i325) {
        var object = arguments[_i325],
            uuid = object.uuid;
        var index = indicesByUUID[uuid];

        if (index === undefined) {
          // unknown object -> add it to the ACTIVE region
          index = nObjects++;
          indicesByUUID[uuid] = index;
          objects.push(object); // accounting is done, now do the same for all bindings

          for (var j = 0, m = nBindings; j !== m; ++j) {
            bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
          }
        } else if (index < nCachedObjects) {
          knownObject = objects[index]; // move existing object to the ACTIVE region

          var firstActiveIndex = --nCachedObjects,
              lastCachedObject = objects[firstActiveIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[uuid] = firstActiveIndex;
          objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

          for (var _j16 = 0, _m2 = nBindings; _j16 !== _m2; ++_j16) {
            var bindingsForPath = bindings[_j16],
                lastCached = bindingsForPath[firstActiveIndex];
            var binding = bindingsForPath[index];
            bindingsForPath[index] = lastCached;

            if (binding === undefined) {
              // since we do not bother to create new bindings
              // for objects that are cached, the binding may
              // or may not exist
              binding = new PropertyBinding(object, paths[_j16], parsedPaths[_j16]);
            }

            bindingsForPath[firstActiveIndex] = binding;
          }
        } else if (objects[index] !== knownObject) {
          console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
        } // else the object is already where we want it to be

      } // for arguments


      this.nCachedObjects_ = nCachedObjects;
    }
  }, {
    key: "remove",
    value: function remove() {
      var objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;
      var nCachedObjects = this.nCachedObjects_;

      for (var _i326 = 0, n = arguments.length; _i326 !== n; ++_i326) {
        var object = arguments[_i326],
            uuid = object.uuid,
            index = indicesByUUID[uuid];

        if (index !== undefined && index >= nCachedObjects) {
          // move existing object into the CACHED region
          var lastCachedIndex = nCachedObjects++,
              firstActiveObject = objects[lastCachedIndex];
          indicesByUUID[firstActiveObject.uuid] = index;
          objects[index] = firstActiveObject;
          indicesByUUID[uuid] = lastCachedIndex;
          objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j],
                firstActive = bindingsForPath[lastCachedIndex],
                binding = bindingsForPath[index];
            bindingsForPath[index] = firstActive;
            bindingsForPath[lastCachedIndex] = binding;
          }
        }
      } // for arguments


      this.nCachedObjects_ = nCachedObjects;
    } // remove & forget

  }, {
    key: "uncache",
    value: function uncache() {
      var objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;
      var nCachedObjects = this.nCachedObjects_,
          nObjects = objects.length;

      for (var _i327 = 0, n = arguments.length; _i327 !== n; ++_i327) {
        var object = arguments[_i327],
            uuid = object.uuid,
            index = indicesByUUID[uuid];

        if (index !== undefined) {
          delete indicesByUUID[uuid];

          if (index < nCachedObjects) {
            // object is cached, shrink the CACHED region
            var firstActiveIndex = --nCachedObjects,
                lastCachedObject = objects[firstActiveIndex],
                lastIndex = --nObjects,
                lastObject = objects[lastIndex]; // last cached object takes this object's place

            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject; // last object goes to the activated slot and pop

            indicesByUUID[lastObject.uuid] = firstActiveIndex;
            objects[firstActiveIndex] = lastObject;
            objects.pop(); // accounting is done, now do the same for all bindings

            for (var j = 0, m = nBindings; j !== m; ++j) {
              var bindingsForPath = bindings[j],
                  lastCached = bindingsForPath[firstActiveIndex],
                  last = bindingsForPath[lastIndex];
              bindingsForPath[index] = lastCached;
              bindingsForPath[firstActiveIndex] = last;
              bindingsForPath.pop();
            }
          } else {
            // object is active, just swap with the last and pop
            var _lastIndex = --nObjects,
                _lastObject = objects[_lastIndex];

            if (_lastIndex > 0) {
              indicesByUUID[_lastObject.uuid] = index;
            }

            objects[index] = _lastObject;
            objects.pop(); // accounting is done, now do the same for all bindings

            for (var _j17 = 0, _m3 = nBindings; _j17 !== _m3; ++_j17) {
              var _bindingsForPath = bindings[_j17];
              _bindingsForPath[index] = _bindingsForPath[_lastIndex];

              _bindingsForPath.pop();
            }
          } // cached or active

        } // if object is known

      } // for arguments


      this.nCachedObjects_ = nCachedObjects;
    } // Internal interface used by befriended PropertyBinding.Composite:

  }, {
    key: "subscribe_",
    value: function subscribe_(path, parsedPath) {
      // returns an array of bindings for the given path that is changed
      // according to the contained objects in the group
      var indicesByPath = this._bindingsIndicesByPath;
      var index = indicesByPath[path];
      var bindings = this._bindings;
      if (index !== undefined) return bindings[index];
      var paths = this._paths,
          parsedPaths = this._parsedPaths,
          objects = this._objects,
          nObjects = objects.length,
          nCachedObjects = this.nCachedObjects_,
          bindingsForPath = new Array(nObjects);
      index = bindings.length;
      indicesByPath[path] = index;
      paths.push(path);
      parsedPaths.push(parsedPath);
      bindings.push(bindingsForPath);

      for (var _i328 = nCachedObjects, n = objects.length; _i328 !== n; ++_i328) {
        var object = objects[_i328];
        bindingsForPath[_i328] = new PropertyBinding(object, path, parsedPath);
      }

      return bindingsForPath;
    }
  }, {
    key: "unsubscribe_",
    value: function unsubscribe_(path) {
      // tells the group to forget about a property path and no longer
      // update the array previously obtained with 'subscribe_'
      var indicesByPath = this._bindingsIndicesByPath,
          index = indicesByPath[path];

      if (index !== undefined) {
        var paths = this._paths,
            parsedPaths = this._parsedPaths,
            bindings = this._bindings,
            lastBindingsIndex = bindings.length - 1,
            lastBindings = bindings[lastBindingsIndex],
            lastBindingsPath = path[lastBindingsIndex];
        indicesByPath[lastBindingsPath] = index;
        bindings[index] = lastBindings;
        bindings.pop();
        parsedPaths[index] = parsedPaths[lastBindingsIndex];
        parsedPaths.pop();
        paths[index] = paths[lastBindingsIndex];
        paths.pop();
      }
    }
  }]);

  return AnimationObjectGroup;
}();

exports.AnimationObjectGroup = AnimationObjectGroup;
AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

var AnimationAction = /*#__PURE__*/function () {
  function AnimationAction(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    _classCallCheck(this, AnimationAction);

    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    var tracks = clip.tracks,
        nTracks = tracks.length,
        interpolants = new Array(nTracks);
    var interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };

    for (var _i329 = 0; _i329 !== nTracks; ++_i329) {
      var interpolant = tracks[_i329].createInterpolant(null);

      interpolants[_i329] = interpolant;
      interpolant.settings = interpolantSettings;
    }

    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants; // bound by the mixer
    // inside: PropertyMixer (managed by the mixer)

    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null; // for the memory manager

    this._byClipCacheIndex = null; // for the memory manager

    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1; // global mixer time when the action is to be started
    // it's set back to 'null' upon start of the action

    this._startTime = null; // scaled local time of the action
    // gets clamped or wrapped to 0..clip.duration according to loop

    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity; // no. of repetitions when looping

    this.paused = false; // true -> zero effective time scale

    this.enabled = true; // false -> zero effective weight

    this.clampWhenFinished = false; // keep feeding the last frame?

    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

    this.zeroSlopeAtEnd = true; // clips for start, loop and end
  } // State & Scheduling


  _createClass(AnimationAction, [{
    key: "play",
    value: function play() {
      this._mixer._activateAction(this);

      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      this._mixer._deactivateAction(this);

      return this.reset();
    }
  }, {
    key: "reset",
    value: function reset() {
      this.paused = false;
      this.enabled = true;
      this.time = 0; // restart clip

      this._loopCount = -1; // forget previous loops

      this._startTime = null; // forget scheduling

      return this.stopFading().stopWarping();
    }
  }, {
    key: "isRunning",
    value: function isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    } // return true when play has been called

  }, {
    key: "isScheduled",
    value: function isScheduled() {
      return this._mixer._isActiveAction(this);
    }
  }, {
    key: "startAt",
    value: function startAt(time) {
      this._startTime = time;
      return this;
    }
  }, {
    key: "setLoop",
    value: function setLoop(mode, repetitions) {
      this.loop = mode;
      this.repetitions = repetitions;
      return this;
    } // Weight
    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing

  }, {
    key: "setEffectiveWeight",
    value: function setEffectiveWeight(weight) {
      this.weight = weight; // note: same logic as when updated at runtime

      this._effectiveWeight = this.enabled ? weight : 0;
      return this.stopFading();
    } // return the weight considering fading and .enabled

  }, {
    key: "getEffectiveWeight",
    value: function getEffectiveWeight() {
      return this._effectiveWeight;
    }
  }, {
    key: "fadeIn",
    value: function fadeIn(duration) {
      return this._scheduleFading(duration, 0, 1);
    }
  }, {
    key: "fadeOut",
    value: function fadeOut(duration) {
      return this._scheduleFading(duration, 1, 0);
    }
  }, {
    key: "crossFadeFrom",
    value: function crossFadeFrom(fadeOutAction, duration, warp) {
      fadeOutAction.fadeOut(duration);
      this.fadeIn(duration);

      if (warp) {
        var fadeInDuration = this._clip.duration,
            fadeOutDuration = fadeOutAction._clip.duration,
            startEndRatio = fadeOutDuration / fadeInDuration,
            endStartRatio = fadeInDuration / fadeOutDuration;
        fadeOutAction.warp(1.0, startEndRatio, duration);
        this.warp(endStartRatio, 1.0, duration);
      }

      return this;
    }
  }, {
    key: "crossFadeTo",
    value: function crossFadeTo(fadeInAction, duration, warp) {
      return fadeInAction.crossFadeFrom(this, duration, warp);
    }
  }, {
    key: "stopFading",
    value: function stopFading() {
      var weightInterpolant = this._weightInterpolant;

      if (weightInterpolant !== null) {
        this._weightInterpolant = null;

        this._mixer._takeBackControlInterpolant(weightInterpolant);
      }

      return this;
    } // Time Scale Control
    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing

  }, {
    key: "setEffectiveTimeScale",
    value: function setEffectiveTimeScale(timeScale) {
      this.timeScale = timeScale;
      this._effectiveTimeScale = this.paused ? 0 : timeScale;
      return this.stopWarping();
    } // return the time scale considering warping and .paused

  }, {
    key: "getEffectiveTimeScale",
    value: function getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
  }, {
    key: "setDuration",
    value: function setDuration(duration) {
      this.timeScale = this._clip.duration / duration;
      return this.stopWarping();
    }
  }, {
    key: "syncWith",
    value: function syncWith(action) {
      this.time = action.time;
      this.timeScale = action.timeScale;
      return this.stopWarping();
    }
  }, {
    key: "halt",
    value: function halt(duration) {
      return this.warp(this._effectiveTimeScale, 0, duration);
    }
  }, {
    key: "warp",
    value: function warp(startTimeScale, endTimeScale, duration) {
      var mixer = this._mixer,
          now = mixer.time,
          timeScale = this.timeScale;
      var interpolant = this._timeScaleInterpolant;

      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._timeScaleInterpolant = interpolant;
      }

      var times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
      times[0] = now;
      times[1] = now + duration;
      values[0] = startTimeScale / timeScale;
      values[1] = endTimeScale / timeScale;
      return this;
    }
  }, {
    key: "stopWarping",
    value: function stopWarping() {
      var timeScaleInterpolant = this._timeScaleInterpolant;

      if (timeScaleInterpolant !== null) {
        this._timeScaleInterpolant = null;

        this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
      }

      return this;
    } // Object Accessors

  }, {
    key: "getMixer",
    value: function getMixer() {
      return this._mixer;
    }
  }, {
    key: "getClip",
    value: function getClip() {
      return this._clip;
    }
  }, {
    key: "getRoot",
    value: function getRoot() {
      return this._localRoot || this._mixer._root;
    } // Interna

  }, {
    key: "_update",
    value: function _update(time, deltaTime, timeDirection, accuIndex) {
      // called by the mixer
      if (!this.enabled) {
        // call ._updateWeight() to update ._effectiveWeight
        this._updateWeight(time);

        return;
      }

      var startTime = this._startTime;

      if (startTime !== null) {
        // check for scheduled start of action
        var timeRunning = (time - startTime) * timeDirection;

        if (timeRunning < 0 || timeDirection === 0) {
          return; // yet to come / don't decide when delta = 0
        } // start


        this._startTime = null; // unschedule

        deltaTime = timeDirection * timeRunning;
      } // apply time scale and advance time


      deltaTime *= this._updateTimeScale(time);

      var clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
      // an effective weight of 0


      var weight = this._updateWeight(time);

      if (weight > 0) {
        var interpolants = this._interpolants;
        var propertyMixers = this._propertyBindings;

        switch (this.blendMode) {
          case AdditiveAnimationBlendMode:
            for (var j = 0, m = interpolants.length; j !== m; ++j) {
              interpolants[j].evaluate(clipTime);
              propertyMixers[j].accumulateAdditive(weight);
            }

            break;

          case NormalAnimationBlendMode:
          default:
            for (var _j18 = 0, _m4 = interpolants.length; _j18 !== _m4; ++_j18) {
              interpolants[_j18].evaluate(clipTime);

              propertyMixers[_j18].accumulate(accuIndex, weight);
            }

        }
      }
    }
  }, {
    key: "_updateWeight",
    value: function _updateWeight(time) {
      var weight = 0;

      if (this.enabled) {
        weight = this.weight;
        var interpolant = this._weightInterpolant;

        if (interpolant !== null) {
          var interpolantValue = interpolant.evaluate(time)[0];
          weight *= interpolantValue;

          if (time > interpolant.parameterPositions[1]) {
            this.stopFading();

            if (interpolantValue === 0) {
              // faded out, disable
              this.enabled = false;
            }
          }
        }
      }

      this._effectiveWeight = weight;
      return weight;
    }
  }, {
    key: "_updateTimeScale",
    value: function _updateTimeScale(time) {
      var timeScale = 0;

      if (!this.paused) {
        timeScale = this.timeScale;
        var interpolant = this._timeScaleInterpolant;

        if (interpolant !== null) {
          var interpolantValue = interpolant.evaluate(time)[0];
          timeScale *= interpolantValue;

          if (time > interpolant.parameterPositions[1]) {
            this.stopWarping();

            if (timeScale === 0) {
              // motion has halted, pause
              this.paused = true;
            } else {
              // warp done - apply final time scale
              this.timeScale = timeScale;
            }
          }
        }
      }

      this._effectiveTimeScale = timeScale;
      return timeScale;
    }
  }, {
    key: "_updateTime",
    value: function _updateTime(deltaTime) {
      var duration = this._clip.duration;
      var loop = this.loop;
      var time = this.time + deltaTime;
      var loopCount = this._loopCount;
      var pingPong = loop === LoopPingPong;

      if (deltaTime === 0) {
        if (loopCount === -1) return time;
        return pingPong && (loopCount & 1) === 1 ? duration - time : time;
      }

      if (loop === LoopOnce) {
        if (loopCount === -1) {
          // just started
          this._loopCount = 0;

          this._setEndings(true, true, false);
        }

        handle_stop: {
          if (time >= duration) {
            time = duration;
          } else if (time < 0) {
            time = 0;
          } else {
            this.time = time;
            break handle_stop;
          }

          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
          this.time = time;

          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: deltaTime < 0 ? -1 : 1
          });
        }
      } else {
        // repetitive Repeat or PingPong
        if (loopCount === -1) {
          // just started
          if (deltaTime >= 0) {
            loopCount = 0;

            this._setEndings(true, this.repetitions === 0, pingPong);
          } else {
            // when looping in reverse direction, the initial
            // transition through zero counts as a repetition,
            // so leave loopCount at -1
            this._setEndings(this.repetitions === 0, true, pingPong);
          }
        }

        if (time >= duration || time < 0) {
          // wrap around
          var loopDelta = Math.floor(time / duration); // signed

          time -= duration * loopDelta;
          loopCount += Math.abs(loopDelta);
          var pending = this.repetitions - loopCount;

          if (pending <= 0) {
            // have to stop (switch state, clamp time, fire event)
            if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
            time = deltaTime > 0 ? duration : 0;
            this.time = time;

            this._mixer.dispatchEvent({
              type: 'finished',
              action: this,
              direction: deltaTime > 0 ? 1 : -1
            });
          } else {
            // keep running
            if (pending === 1) {
              // entering the last round
              var atStart = deltaTime < 0;

              this._setEndings(atStart, !atStart, pingPong);
            } else {
              this._setEndings(false, false, pingPong);
            }

            this._loopCount = loopCount;
            this.time = time;

            this._mixer.dispatchEvent({
              type: 'loop',
              action: this,
              loopDelta: loopDelta
            });
          }
        } else {
          this.time = time;
        }

        if (pingPong && (loopCount & 1) === 1) {
          // invert time for the "pong round"
          return duration - time;
        }
      }

      return time;
    }
  }, {
    key: "_setEndings",
    value: function _setEndings(atStart, atEnd, pingPong) {
      var settings = this._interpolantSettings;

      if (pingPong) {
        settings.endingStart = ZeroSlopeEnding;
        settings.endingEnd = ZeroSlopeEnding;
      } else {
        // assuming for LoopOnce atStart == atEnd == true
        if (atStart) {
          settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingStart = WrapAroundEnding;
        }

        if (atEnd) {
          settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingEnd = WrapAroundEnding;
        }
      }
    }
  }, {
    key: "_scheduleFading",
    value: function _scheduleFading(duration, weightNow, weightThen) {
      var mixer = this._mixer,
          now = mixer.time;
      var interpolant = this._weightInterpolant;

      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._weightInterpolant = interpolant;
      }

      var times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
      times[0] = now;
      values[0] = weightNow;
      times[1] = now + duration;
      values[1] = weightThen;
      return this;
    }
  }]);

  return AnimationAction;
}();

var AnimationMixer = /*#__PURE__*/function (_EventDispatcher7) {
  _inherits(AnimationMixer, _EventDispatcher7);

  var _super139 = _createSuper(AnimationMixer);

  function AnimationMixer(root) {
    var _this110;

    _classCallCheck(this, AnimationMixer);

    _this110 = _super139.call(this);
    _this110._root = root;

    _this110._initMemoryManager();

    _this110._accuIndex = 0;
    _this110.time = 0;
    _this110.timeScale = 1.0;
    return _this110;
  }

  _createClass(AnimationMixer, [{
    key: "_bindAction",
    value: function _bindAction(action, prototypeAction) {
      var root = action._localRoot || this._root,
          tracks = action._clip.tracks,
          nTracks = tracks.length,
          bindings = action._propertyBindings,
          interpolants = action._interpolants,
          rootUuid = root.uuid,
          bindingsByRoot = this._bindingsByRootAndName;
      var bindingsByName = bindingsByRoot[rootUuid];

      if (bindingsByName === undefined) {
        bindingsByName = {};
        bindingsByRoot[rootUuid] = bindingsByName;
      }

      for (var _i330 = 0; _i330 !== nTracks; ++_i330) {
        var track = tracks[_i330],
            trackName = track.name;
        var binding = bindingsByName[trackName];

        if (binding !== undefined) {
          ++binding.referenceCount;
          bindings[_i330] = binding;
        } else {
          binding = bindings[_i330];

          if (binding !== undefined) {
            // existing binding, make sure the cache knows
            if (binding._cacheIndex === null) {
              ++binding.referenceCount;

              this._addInactiveBinding(binding, rootUuid, trackName);
            }

            continue;
          }

          var path = prototypeAction && prototypeAction._propertyBindings[_i330].binding.parsedPath;
          binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
          ++binding.referenceCount;

          this._addInactiveBinding(binding, rootUuid, trackName);

          bindings[_i330] = binding;
        }

        interpolants[_i330].resultBuffer = binding.buffer;
      }
    }
  }, {
    key: "_activateAction",
    value: function _activateAction(action) {
      if (!this._isActiveAction(action)) {
        if (action._cacheIndex === null) {
          // this action has been forgotten by the cache, but the user
          // appears to be still using it -> rebind
          var rootUuid = (action._localRoot || this._root).uuid,
              clipUuid = action._clip.uuid,
              actionsForClip = this._actionsByClip[clipUuid];

          this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

          this._addInactiveAction(action, clipUuid, rootUuid);
        }

        var bindings = action._propertyBindings; // increment reference counts / sort out state

        for (var _i331 = 0, n = bindings.length; _i331 !== n; ++_i331) {
          var binding = bindings[_i331];

          if (binding.useCount++ === 0) {
            this._lendBinding(binding);

            binding.saveOriginalState();
          }
        }

        this._lendAction(action);
      }
    }
  }, {
    key: "_deactivateAction",
    value: function _deactivateAction(action) {
      if (this._isActiveAction(action)) {
        var bindings = action._propertyBindings; // decrement reference counts / sort out state

        for (var _i332 = 0, n = bindings.length; _i332 !== n; ++_i332) {
          var binding = bindings[_i332];

          if (--binding.useCount === 0) {
            binding.restoreOriginalState();

            this._takeBackBinding(binding);
          }
        }

        this._takeBackAction(action);
      }
    } // Memory manager

  }, {
    key: "_initMemoryManager",
    value: function _initMemoryManager() {
      this._actions = []; // 'nActiveActions' followed by inactive ones

      this._nActiveActions = 0;
      this._actionsByClip = {}; // inside:
      // {
      // 	knownActions: Array< AnimationAction > - used as prototypes
      // 	actionByRoot: AnimationAction - lookup
      // }

      this._bindings = []; // 'nActiveBindings' followed by inactive ones

      this._nActiveBindings = 0;
      this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

      this._controlInterpolants = []; // same game as above

      this._nActiveControlInterpolants = 0;
      var scope = this;
      this.stats = {
        actions: {
          get total() {
            return scope._actions.length;
          },

          get inUse() {
            return scope._nActiveActions;
          }

        },
        bindings: {
          get total() {
            return scope._bindings.length;
          },

          get inUse() {
            return scope._nActiveBindings;
          }

        },
        controlInterpolants: {
          get total() {
            return scope._controlInterpolants.length;
          },

          get inUse() {
            return scope._nActiveControlInterpolants;
          }

        }
      };
    } // Memory management for AnimationAction objects

  }, {
    key: "_isActiveAction",
    value: function _isActiveAction(action) {
      var index = action._cacheIndex;
      return index !== null && index < this._nActiveActions;
    }
  }, {
    key: "_addInactiveAction",
    value: function _addInactiveAction(action, clipUuid, rootUuid) {
      var actions = this._actions,
          actionsByClip = this._actionsByClip;
      var actionsForClip = actionsByClip[clipUuid];

      if (actionsForClip === undefined) {
        actionsForClip = {
          knownActions: [action],
          actionByRoot: {}
        };
        action._byClipCacheIndex = 0;
        actionsByClip[clipUuid] = actionsForClip;
      } else {
        var knownActions = actionsForClip.knownActions;
        action._byClipCacheIndex = knownActions.length;
        knownActions.push(action);
      }

      action._cacheIndex = actions.length;
      actions.push(action);
      actionsForClip.actionByRoot[rootUuid] = action;
    }
  }, {
    key: "_removeInactiveAction",
    value: function _removeInactiveAction(action) {
      var actions = this._actions,
          lastInactiveAction = actions[actions.length - 1],
          cacheIndex = action._cacheIndex;
      lastInactiveAction._cacheIndex = cacheIndex;
      actions[cacheIndex] = lastInactiveAction;
      actions.pop();
      action._cacheIndex = null;
      var clipUuid = action._clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid],
          knownActionsForClip = actionsForClip.knownActions,
          lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
          byClipCacheIndex = action._byClipCacheIndex;
      lastKnownAction._byClipCacheIndex = byClipCacheIndex;
      knownActionsForClip[byClipCacheIndex] = lastKnownAction;
      knownActionsForClip.pop();
      action._byClipCacheIndex = null;
      var actionByRoot = actionsForClip.actionByRoot,
          rootUuid = (action._localRoot || this._root).uuid;
      delete actionByRoot[rootUuid];

      if (knownActionsForClip.length === 0) {
        delete actionsByClip[clipUuid];
      }

      this._removeInactiveBindingsForAction(action);
    }
  }, {
    key: "_removeInactiveBindingsForAction",
    value: function _removeInactiveBindingsForAction(action) {
      var bindings = action._propertyBindings;

      for (var _i333 = 0, n = bindings.length; _i333 !== n; ++_i333) {
        var binding = bindings[_i333];

        if (--binding.referenceCount === 0) {
          this._removeInactiveBinding(binding);
        }
      }
    }
  }, {
    key: "_lendAction",
    value: function _lendAction(action) {
      // [ active actions |  inactive actions  ]
      // [  active actions >| inactive actions ]
      //                 s        a
      //                  <-swap->
      //                 a        s
      var actions = this._actions,
          prevIndex = action._cacheIndex,
          lastActiveIndex = this._nActiveActions++,
          firstInactiveAction = actions[lastActiveIndex];
      action._cacheIndex = lastActiveIndex;
      actions[lastActiveIndex] = action;
      firstInactiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = firstInactiveAction;
    }
  }, {
    key: "_takeBackAction",
    value: function _takeBackAction(action) {
      // [  active actions  | inactive actions ]
      // [ active actions |< inactive actions  ]
      //        a        s
      //         <-swap->
      //        s        a
      var actions = this._actions,
          prevIndex = action._cacheIndex,
          firstInactiveIndex = --this._nActiveActions,
          lastActiveAction = actions[firstInactiveIndex];
      action._cacheIndex = firstInactiveIndex;
      actions[firstInactiveIndex] = action;
      lastActiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = lastActiveAction;
    } // Memory management for PropertyMixer objects

  }, {
    key: "_addInactiveBinding",
    value: function _addInactiveBinding(binding, rootUuid, trackName) {
      var bindingsByRoot = this._bindingsByRootAndName,
          bindings = this._bindings;
      var bindingByName = bindingsByRoot[rootUuid];

      if (bindingByName === undefined) {
        bindingByName = {};
        bindingsByRoot[rootUuid] = bindingByName;
      }

      bindingByName[trackName] = binding;
      binding._cacheIndex = bindings.length;
      bindings.push(binding);
    }
  }, {
    key: "_removeInactiveBinding",
    value: function _removeInactiveBinding(binding) {
      var bindings = this._bindings,
          propBinding = binding.binding,
          rootUuid = propBinding.rootNode.uuid,
          trackName = propBinding.path,
          bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid],
          lastInactiveBinding = bindings[bindings.length - 1],
          cacheIndex = binding._cacheIndex;
      lastInactiveBinding._cacheIndex = cacheIndex;
      bindings[cacheIndex] = lastInactiveBinding;
      bindings.pop();
      delete bindingByName[trackName];

      if (Object.keys(bindingByName).length === 0) {
        delete bindingsByRoot[rootUuid];
      }
    }
  }, {
    key: "_lendBinding",
    value: function _lendBinding(binding) {
      var bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          lastActiveIndex = this._nActiveBindings++,
          firstInactiveBinding = bindings[lastActiveIndex];
      binding._cacheIndex = lastActiveIndex;
      bindings[lastActiveIndex] = binding;
      firstInactiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = firstInactiveBinding;
    }
  }, {
    key: "_takeBackBinding",
    value: function _takeBackBinding(binding) {
      var bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          firstInactiveIndex = --this._nActiveBindings,
          lastActiveBinding = bindings[firstInactiveIndex];
      binding._cacheIndex = firstInactiveIndex;
      bindings[firstInactiveIndex] = binding;
      lastActiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = lastActiveBinding;
    } // Memory management of Interpolants for weight and time scale

  }, {
    key: "_lendControlInterpolant",
    value: function _lendControlInterpolant() {
      var interpolants = this._controlInterpolants,
          lastActiveIndex = this._nActiveControlInterpolants++;
      var interpolant = interpolants[lastActiveIndex];

      if (interpolant === undefined) {
        interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
        interpolant.__cacheIndex = lastActiveIndex;
        interpolants[lastActiveIndex] = interpolant;
      }

      return interpolant;
    }
  }, {
    key: "_takeBackControlInterpolant",
    value: function _takeBackControlInterpolant(interpolant) {
      var interpolants = this._controlInterpolants,
          prevIndex = interpolant.__cacheIndex,
          firstInactiveIndex = --this._nActiveControlInterpolants,
          lastActiveInterpolant = interpolants[firstInactiveIndex];
      interpolant.__cacheIndex = firstInactiveIndex;
      interpolants[firstInactiveIndex] = interpolant;
      lastActiveInterpolant.__cacheIndex = prevIndex;
      interpolants[prevIndex] = lastActiveInterpolant;
    } // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)

  }, {
    key: "clipAction",
    value: function clipAction(clip, optionalRoot, blendMode) {
      var root = optionalRoot || this._root,
          rootUuid = root.uuid;
      var clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
      var clipUuid = clipObject !== null ? clipObject.uuid : clip;
      var actionsForClip = this._actionsByClip[clipUuid];
      var prototypeAction = null;

      if (blendMode === undefined) {
        if (clipObject !== null) {
          blendMode = clipObject.blendMode;
        } else {
          blendMode = NormalAnimationBlendMode;
        }
      }

      if (actionsForClip !== undefined) {
        var existingAction = actionsForClip.actionByRoot[rootUuid];

        if (existingAction !== undefined && existingAction.blendMode === blendMode) {
          return existingAction;
        } // we know the clip, so we don't have to parse all
        // the bindings again but can just copy


        prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

        if (clipObject === null) clipObject = prototypeAction._clip;
      } // clip must be known when specified via string


      if (clipObject === null) return null; // allocate all resources required to run it

      var newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);

      this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


      this._addInactiveAction(newAction, clipUuid, rootUuid);

      return newAction;
    } // get an existing action

  }, {
    key: "existingAction",
    value: function existingAction(clip, optionalRoot) {
      var root = optionalRoot || this._root,
          rootUuid = root.uuid,
          clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
          clipUuid = clipObject ? clipObject.uuid : clip,
          actionsForClip = this._actionsByClip[clipUuid];

      if (actionsForClip !== undefined) {
        return actionsForClip.actionByRoot[rootUuid] || null;
      }

      return null;
    } // deactivates all previously scheduled actions

  }, {
    key: "stopAllAction",
    value: function stopAllAction() {
      var actions = this._actions,
          nActions = this._nActiveActions;

      for (var _i334 = nActions - 1; _i334 >= 0; --_i334) {
        actions[_i334].stop();
      }

      return this;
    } // advance the time and update apply the animation

  }, {
    key: "update",
    value: function update(deltaTime) {
      deltaTime *= this.timeScale;
      var actions = this._actions,
          nActions = this._nActiveActions,
          time = this.time += deltaTime,
          timeDirection = Math.sign(deltaTime),
          accuIndex = this._accuIndex ^= 1; // run active actions

      for (var _i335 = 0; _i335 !== nActions; ++_i335) {
        var action = actions[_i335];

        action._update(time, deltaTime, timeDirection, accuIndex);
      } // update scene graph


      var bindings = this._bindings,
          nBindings = this._nActiveBindings;

      for (var _i336 = 0; _i336 !== nBindings; ++_i336) {
        bindings[_i336].apply(accuIndex);
      }

      return this;
    } // Allows you to seek to a specific time in an animation.

  }, {
    key: "setTime",
    value: function setTime(timeInSeconds) {
      this.time = 0; // Zero out time attribute for AnimationMixer object;

      for (var _i337 = 0; _i337 < this._actions.length; _i337++) {
        this._actions[_i337].time = 0; // Zero out time attribute for all associated AnimationAction objects.
      }

      return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
    } // return this mixer's root target object

  }, {
    key: "getRoot",
    value: function getRoot() {
      return this._root;
    } // free all resources specific to a particular clip

  }, {
    key: "uncacheClip",
    value: function uncacheClip(clip) {
      var actions = this._actions,
          clipUuid = clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid];

      if (actionsForClip !== undefined) {
        // note: just calling _removeInactiveAction would mess up the
        // iteration state and also require updating the state we can
        // just throw away
        var actionsToRemove = actionsForClip.knownActions;

        for (var _i338 = 0, n = actionsToRemove.length; _i338 !== n; ++_i338) {
          var action = actionsToRemove[_i338];

          this._deactivateAction(action);

          var cacheIndex = action._cacheIndex,
              lastInactiveAction = actions[actions.length - 1];
          action._cacheIndex = null;
          action._byClipCacheIndex = null;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();

          this._removeInactiveBindingsForAction(action);
        }

        delete actionsByClip[clipUuid];
      }
    } // free all resources specific to a particular root target object

  }, {
    key: "uncacheRoot",
    value: function uncacheRoot(root) {
      var rootUuid = root.uuid,
          actionsByClip = this._actionsByClip;

      for (var clipUuid in actionsByClip) {
        var actionByRoot = actionsByClip[clipUuid].actionByRoot,
            action = actionByRoot[rootUuid];

        if (action !== undefined) {
          this._deactivateAction(action);

          this._removeInactiveAction(action);
        }
      }

      var bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid];

      if (bindingByName !== undefined) {
        for (var trackName in bindingByName) {
          var binding = bindingByName[trackName];
          binding.restoreOriginalState();

          this._removeInactiveBinding(binding);
        }
      }
    } // remove a targeted clip from the cache

  }, {
    key: "uncacheAction",
    value: function uncacheAction(clip, optionalRoot) {
      var action = this.existingAction(clip, optionalRoot);

      if (action !== null) {
        this._deactivateAction(action);

        this._removeInactiveAction(action);
      }
    }
  }]);

  return AnimationMixer;
}(EventDispatcher);

exports.AnimationMixer = AnimationMixer;
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);

var Uniform = /*#__PURE__*/function () {
  function Uniform(value) {
    _classCallCheck(this, Uniform);

    if (typeof value === 'string') {
      console.warn('THREE.Uniform: Type parameter is no longer needed.');
      value = arguments[1];
    }

    this.value = value;
  }

  _createClass(Uniform, [{
    key: "clone",
    value: function clone() {
      return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
    }
  }]);

  return Uniform;
}();

exports.Uniform = Uniform;

var InstancedInterleavedBuffer = /*#__PURE__*/function (_InterleavedBuffer) {
  _inherits(InstancedInterleavedBuffer, _InterleavedBuffer);

  var _super140 = _createSuper(InstancedInterleavedBuffer);

  function InstancedInterleavedBuffer(array, stride, meshPerAttribute = 1) {
    var _this111;

    _classCallCheck(this, InstancedInterleavedBuffer);

    _this111 = _super140.call(this, array, stride);
    _this111.meshPerAttribute = meshPerAttribute;
    return _this111;
  }

  _createClass(InstancedInterleavedBuffer, [{
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(InstancedInterleavedBuffer.prototype), "copy", this).call(this, source);

      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
  }, {
    key: "clone",
    value: function clone(data) {
      var ib = _get(_getPrototypeOf(InstancedInterleavedBuffer.prototype), "clone", this).call(this, data);

      ib.meshPerAttribute = this.meshPerAttribute;
      return ib;
    }
  }, {
    key: "toJSON",
    value: function toJSON(data) {
      var json = _get(_getPrototypeOf(InstancedInterleavedBuffer.prototype), "toJSON", this).call(this, data);

      json.isInstancedInterleavedBuffer = true;
      json.meshPerAttribute = this.meshPerAttribute;
      return json;
    }
  }]);

  return InstancedInterleavedBuffer;
}(InterleavedBuffer);

exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

var GLBufferAttribute = /*#__PURE__*/function () {
  function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
    _classCallCheck(this, GLBufferAttribute);

    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
  }

  _createClass(GLBufferAttribute, [{
    key: "needsUpdate",
    set: function set(value) {
      if (value === true) this.version++;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(buffer) {
      this.buffer = buffer;
      return this;
    }
  }, {
    key: "setType",
    value: function setType(type, elementSize) {
      this.type = type;
      this.elementSize = elementSize;
      return this;
    }
  }, {
    key: "setItemSize",
    value: function setItemSize(itemSize) {
      this.itemSize = itemSize;
      return this;
    }
  }, {
    key: "setCount",
    value: function setCount(count) {
      this.count = count;
      return this;
    }
  }]);

  return GLBufferAttribute;
}();

exports.GLBufferAttribute = GLBufferAttribute;
GLBufferAttribute.prototype.isGLBufferAttribute = true;

var Raycaster = /*#__PURE__*/function () {
  function Raycaster(origin, direction, near = 0, far = Infinity) {
    _classCallCheck(this, Raycaster);

    this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: {
        threshold: 1
      },
      LOD: {},
      Points: {
        threshold: 1
      },
      Sprite: {}
    };
  }

  _createClass(Raycaster, [{
    key: "set",
    value: function set(origin, direction) {
      // direction is assumed to be normalized (for accurate distance calculations)
      this.ray.set(origin, direction);
    }
  }, {
    key: "setFromCamera",
    value: function setFromCamera(coords, camera) {
      if (camera.isPerspectiveCamera) {
        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
        this.camera = camera;
      } else if (camera.isOrthographicCamera) {
        this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
        this.camera = camera;
      } else {
        console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
      }
    }
  }, {
    key: "intersectObject",
    value: function intersectObject(object, recursive = true, intersects = []) {
      _intersectObject(object, this, intersects, recursive);

      intersects.sort(ascSort);
      return intersects;
    }
  }, {
    key: "intersectObjects",
    value: function intersectObjects(objects, recursive = true, intersects = []) {
      for (var _i339 = 0, l = objects.length; _i339 < l; _i339++) {
        _intersectObject(objects[_i339], this, intersects, recursive);
      }

      intersects.sort(ascSort);
      return intersects;
    }
  }]);

  return Raycaster;
}();

exports.Raycaster = Raycaster;

function ascSort(a, b) {
  return a.distance - b.distance;
}

function _intersectObject(object, raycaster, intersects, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects);
  }

  if (recursive === true) {
    var children = object.children;

    for (var _i340 = 0, l = children.length; _i340 < l; _i340++) {
      _intersectObject(children[_i340], raycaster, intersects, true);
    }
  }
}
/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */


var Spherical = /*#__PURE__*/function () {
  function Spherical(radius = 1, phi = 0, theta = 0) {
    _classCallCheck(this, Spherical);

    this.radius = radius;
    this.phi = phi; // polar angle

    this.theta = theta; // azimuthal angle

    return this;
  }

  _createClass(Spherical, [{
    key: "set",
    value: function set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
  }, {
    key: "copy",
    value: function copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    } // restrict phi to be between EPS and PI-EPS

  }, {
    key: "makeSafe",
    value: function makeSafe() {
      var EPS = 0.000001;
      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
      return this;
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
  }, {
    key: "setFromCartesianCoords",
    value: function setFromCartesianCoords(x, y, z) {
      this.radius = Math.sqrt(x * x + y * y + z * z);

      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(x, z);
        this.phi = Math.acos(clamp(y / this.radius, -1, 1));
      }

      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return Spherical;
}();
/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */


exports.Spherical = Spherical;

var Cylindrical = /*#__PURE__*/function () {
  function Cylindrical(radius = 1, theta = 0, y = 0) {
    _classCallCheck(this, Cylindrical);

    this.radius = radius; // distance from the origin to a point in the x-z plane

    this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

    this.y = y; // height above the x-z plane

    return this;
  }

  _createClass(Cylindrical, [{
    key: "set",
    value: function set(radius, theta, y) {
      this.radius = radius;
      this.theta = theta;
      this.y = y;
      return this;
    }
  }, {
    key: "copy",
    value: function copy(other) {
      this.radius = other.radius;
      this.theta = other.theta;
      this.y = other.y;
      return this;
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
  }, {
    key: "setFromCartesianCoords",
    value: function setFromCartesianCoords(x, y, z) {
      this.radius = Math.sqrt(x * x + z * z);
      this.theta = Math.atan2(x, z);
      this.y = y;
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return Cylindrical;
}();

exports.Cylindrical = Cylindrical;

var _vector$4 = /*@__PURE__*/new Vector2();

var Box2 = /*#__PURE__*/function () {
  function Box2(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {
    _classCallCheck(this, Box2);

    this.min = min;
    this.max = max;
  }

  _createClass(Box2, [{
    key: "set",
    value: function set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
  }, {
    key: "setFromPoints",
    value: function setFromPoints(points) {
      this.makeEmpty();

      for (var _i341 = 0, il = points.length; _i341 < il; _i341++) {
        this.expandByPoint(points[_i341]);
      }

      return this;
    }
  }, {
    key: "setFromCenterAndSize",
    value: function setFromCenterAndSize(center, size) {
      var halfSize = _vector$4.copy(size).multiplyScalar(0.5);

      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
  }, {
    key: "makeEmpty",
    value: function makeEmpty() {
      this.min.x = this.min.y = +Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
  }, {
    key: "getCenter",
    value: function getCenter(target) {
      return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
  }, {
    key: "getSize",
    value: function getSize(target) {
      return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
  }, {
    key: "expandByPoint",
    value: function expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
  }, {
    key: "expandByVector",
    value: function expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
  }, {
    key: "expandByScalar",
    value: function expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }
  }, {
    key: "containsBox",
    value: function containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
  }, {
    key: "getParameter",
    value: function getParameter(point, target) {
      // This can potentially have a divide by zero if the box
      // has a size dimension of 0.
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
  }, {
    key: "intersectsBox",
    value: function intersectsBox(box) {
      // using 4 splitting planes to rule out intersections
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }
  }, {
    key: "clampPoint",
    value: function clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      var clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);

      return clampedPoint.sub(point).length();
    }
  }, {
    key: "intersect",
    value: function intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      return this;
    }
  }, {
    key: "union",
    value: function union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
  }, {
    key: "translate",
    value: function translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  }]);

  return Box2;
}();

exports.Box2 = Box2;
Box2.prototype.isBox2 = true;

var _startP = /*@__PURE__*/new Vector3();

var _startEnd = /*@__PURE__*/new Vector3();

var Line3 = /*#__PURE__*/function () {
  function Line3(start = new Vector3(), end = new Vector3()) {
    _classCallCheck(this, Line3);

    this.start = start;
    this.end = end;
  }

  _createClass(Line3, [{
    key: "set",
    value: function set(start, end) {
      this.start.copy(start);
      this.end.copy(end);
      return this;
    }
  }, {
    key: "copy",
    value: function copy(line) {
      this.start.copy(line.start);
      this.end.copy(line.end);
      return this;
    }
  }, {
    key: "getCenter",
    value: function getCenter(target) {
      return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
  }, {
    key: "delta",
    value: function delta(target) {
      return target.subVectors(this.end, this.start);
    }
  }, {
    key: "distanceSq",
    value: function distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
  }, {
    key: "distance",
    value: function distance() {
      return this.start.distanceTo(this.end);
    }
  }, {
    key: "at",
    value: function at(t, target) {
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
  }, {
    key: "closestPointToPointParameter",
    value: function closestPointToPointParameter(point, clampToLine) {
      _startP.subVectors(point, this.start);

      _startEnd.subVectors(this.end, this.start);

      var startEnd2 = _startEnd.dot(_startEnd);

      var startEnd_startP = _startEnd.dot(_startP);

      var t = startEnd_startP / startEnd2;

      if (clampToLine) {
        t = clamp(t, 0, 1);
      }

      return t;
    }
  }, {
    key: "closestPointToPoint",
    value: function closestPointToPoint(point, clampToLine, target) {
      var t = this.closestPointToPointParameter(point, clampToLine);
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(matrix) {
      this.start.applyMatrix4(matrix);
      this.end.applyMatrix4(matrix);
      return this;
    }
  }, {
    key: "equals",
    value: function equals(line) {
      return line.start.equals(this.start) && line.end.equals(this.end);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }]);

  return Line3;
}();

exports.Line3 = Line3;

var _vector$3 = /*@__PURE__*/new Vector3();

var SpotLightHelper = /*#__PURE__*/function (_Object3D14) {
  _inherits(SpotLightHelper, _Object3D14);

  var _super141 = _createSuper(SpotLightHelper);

  function SpotLightHelper(light, color) {
    var _this112;

    _classCallCheck(this, SpotLightHelper);

    _this112 = _super141.call(this);
    _this112.light = light;

    _this112.light.updateMatrixWorld();

    _this112.matrix = light.matrixWorld;
    _this112.matrixAutoUpdate = false;
    _this112.color = color;
    var geometry = new BufferGeometry();
    var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

    for (var _i342 = 0, j = 1, l = 32; _i342 < l; _i342++, j++) {
      var p1 = _i342 / l * Math.PI * 2;
      var p2 = j / l * Math.PI * 2;
      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }

    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    var material = new LineBasicMaterial({
      fog: false,
      toneMapped: false
    });
    _this112.cone = new LineSegments(geometry, material);

    _this112.add(_this112.cone);

    _this112.update();

    return _this112;
  }

  _createClass(SpotLightHelper, [{
    key: "dispose",
    value: function dispose() {
      this.cone.geometry.dispose();
      this.cone.material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      this.light.updateMatrixWorld();
      var coneLength = this.light.distance ? this.light.distance : 1000;
      var coneWidth = coneLength * Math.tan(this.light.angle);
      this.cone.scale.set(coneWidth, coneWidth, coneLength);

      _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);

      this.cone.lookAt(_vector$3);

      if (this.color !== undefined) {
        this.cone.material.color.set(this.color);
      } else {
        this.cone.material.color.copy(this.light.color);
      }
    }
  }]);

  return SpotLightHelper;
}(Object3D);

exports.SpotLightHelper = SpotLightHelper;

var _vector$2 = /*@__PURE__*/new Vector3();

var _boneMatrix = /*@__PURE__*/new Matrix4();

var _matrixWorldInv = /*@__PURE__*/new Matrix4();

var SkeletonHelper = /*#__PURE__*/function (_LineSegments) {
  _inherits(SkeletonHelper, _LineSegments);

  var _super142 = _createSuper(SkeletonHelper);

  function SkeletonHelper(object) {
    var _this113;

    _classCallCheck(this, SkeletonHelper);

    var bones = getBoneList(object);
    var geometry = new BufferGeometry();
    var vertices = [];
    var colors = [];
    var color1 = new Color(0, 0, 1);
    var color2 = new Color(0, 1, 0);

    for (var _i343 = 0; _i343 < bones.length; _i343++) {
      var bone = bones[_i343];

      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }

    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: true,
      depthTest: false,
      depthWrite: false,
      toneMapped: false,
      transparent: true
    });
    _this113 = _super142.call(this, geometry, material);
    _this113.type = 'SkeletonHelper';
    _this113.isSkeletonHelper = true;
    _this113.root = object;
    _this113.bones = bones;
    _this113.matrix = object.matrixWorld;
    _this113.matrixAutoUpdate = false;
    return _this113;
  }

  _createClass(SkeletonHelper, [{
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      var bones = this.bones;
      var geometry = this.geometry;
      var position = geometry.getAttribute('position');

      _matrixWorldInv.copy(this.root.matrixWorld).invert();

      for (var _i344 = 0, j = 0; _i344 < bones.length; _i344++) {
        var bone = bones[_i344];

        if (bone.parent && bone.parent.isBone) {
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

          _vector$2.setFromMatrixPosition(_boneMatrix);

          position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);

          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

          _vector$2.setFromMatrixPosition(_boneMatrix);

          position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
          j += 2;
        }
      }

      geometry.getAttribute('position').needsUpdate = true;

      _get(_getPrototypeOf(SkeletonHelper.prototype), "updateMatrixWorld", this).call(this, force);
    }
  }]);

  return SkeletonHelper;
}(LineSegments);

exports.SkeletonHelper = SkeletonHelper;

function getBoneList(object) {
  var boneList = [];

  if (object.isBone === true) {
    boneList.push(object);
  }

  for (var _i345 = 0; _i345 < object.children.length; _i345++) {
    boneList.push.apply(boneList, getBoneList(object.children[_i345]));
  }

  return boneList;
}

var PointLightHelper = /*#__PURE__*/function (_Mesh3) {
  _inherits(PointLightHelper, _Mesh3);

  var _super143 = _createSuper(PointLightHelper);

  function PointLightHelper(light, sphereSize, color) {
    var _this114;

    _classCallCheck(this, PointLightHelper);

    var geometry = new SphereGeometry(sphereSize, 4, 2);
    var material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false
    });
    _this114 = _super143.call(this, geometry, material);
    _this114.light = light;

    _this114.light.updateMatrixWorld();

    _this114.color = color;
    _this114.type = 'PointLightHelper';
    _this114.matrix = _this114.light.matrixWorld;
    _this114.matrixAutoUpdate = false;

    _this114.update();
    /*
    // TODO: delete this comment?
    const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
    const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
    const d = light.distance;
    if ( d === 0.0 ) {
    	this.lightDistance.visible = false;
    } else {
    	this.lightDistance.scale.set( d, d, d );
    }
    this.add( this.lightDistance );
    */


    return _this114;
  }

  _createClass(PointLightHelper, [{
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      if (this.color !== undefined) {
        this.material.color.set(this.color);
      } else {
        this.material.color.copy(this.light.color);
      }
      /*
      const d = this.light.distance;
      	if ( d === 0.0 ) {
      		this.lightDistance.visible = false;
      	} else {
      		this.lightDistance.visible = true;
      	this.lightDistance.scale.set( d, d, d );
      	}
      */

    }
  }]);

  return PointLightHelper;
}(Mesh);

exports.PointLightHelper = PointLightHelper;

var _vector$1 = /*@__PURE__*/new Vector3();

var _color1 = /*@__PURE__*/new Color();

var _color2 = /*@__PURE__*/new Color();

var HemisphereLightHelper = /*#__PURE__*/function (_Object3D15) {
  _inherits(HemisphereLightHelper, _Object3D15);

  var _super144 = _createSuper(HemisphereLightHelper);

  function HemisphereLightHelper(light, size, color) {
    var _this115;

    _classCallCheck(this, HemisphereLightHelper);

    _this115 = _super144.call(this);
    _this115.light = light;

    _this115.light.updateMatrixWorld();

    _this115.matrix = light.matrixWorld;
    _this115.matrixAutoUpdate = false;
    _this115.color = color;
    var geometry = new OctahedronGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    _this115.material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false
    });
    if (_this115.color === undefined) _this115.material.vertexColors = true;
    var position = geometry.getAttribute('position');
    var colors = new Float32Array(position.count * 3);
    geometry.setAttribute('color', new BufferAttribute(colors, 3));

    _this115.add(new Mesh(geometry, _this115.material));

    _this115.update();

    return _this115;
  }

  _createClass(HemisphereLightHelper, [{
    key: "dispose",
    value: function dispose() {
      this.children[0].geometry.dispose();
      this.children[0].material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      var mesh = this.children[0];

      if (this.color !== undefined) {
        this.material.color.set(this.color);
      } else {
        var colors = mesh.geometry.getAttribute('color');

        _color1.copy(this.light.color);

        _color2.copy(this.light.groundColor);

        for (var _i346 = 0, l = colors.count; _i346 < l; _i346++) {
          var color = _i346 < l / 2 ? _color1 : _color2;
          colors.setXYZ(_i346, color.r, color.g, color.b);
        }

        colors.needsUpdate = true;
      }

      mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
  }]);

  return HemisphereLightHelper;
}(Object3D);

exports.HemisphereLightHelper = HemisphereLightHelper;

var GridHelper = /*#__PURE__*/function (_LineSegments2) {
  _inherits(GridHelper, _LineSegments2);

  var _super145 = _createSuper(GridHelper);

  function GridHelper(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
    var _this116;

    _classCallCheck(this, GridHelper);

    color1 = new Color(color1);
    color2 = new Color(color2);
    var center = divisions / 2;
    var step = size / divisions;
    var halfSize = size / 2;
    var vertices = [],
        colors = [];

    for (var _i347 = 0, j = 0, k = -halfSize; _i347 <= divisions; _i347++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      var color = _i347 === center ? color1 : color2;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
    }

    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    _this116 = _super145.call(this, geometry, material);
    _this116.type = 'GridHelper';
    return _this116;
  }

  return _createClass(GridHelper);
}(LineSegments);

exports.GridHelper = GridHelper;

var PolarGridHelper = /*#__PURE__*/function (_LineSegments3) {
  _inherits(PolarGridHelper, _LineSegments3);

  var _super146 = _createSuper(PolarGridHelper);

  function PolarGridHelper(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {
    var _this117;

    _classCallCheck(this, PolarGridHelper);

    color1 = new Color(color1);
    color2 = new Color(color2);
    var vertices = [];
    var colors = []; // create the radials

    for (var _i348 = 0; _i348 <= radials; _i348++) {
      var v = _i348 / radials * (Math.PI * 2);
      var x = Math.sin(v) * radius;
      var z = Math.cos(v) * radius;
      vertices.push(0, 0, 0);
      vertices.push(x, 0, z);
      var color = _i348 & 1 ? color1 : color2;
      colors.push(color.r, color.g, color.b);
      colors.push(color.r, color.g, color.b);
    } // create the circles


    for (var _i349 = 0; _i349 <= circles; _i349++) {
      var _color = _i349 & 1 ? color1 : color2;

      var r = radius - radius / circles * _i349;

      for (var j = 0; j < divisions; j++) {
        // first vertex
        var _v = j / divisions * (Math.PI * 2);

        var _x12 = Math.sin(_v) * r;

        var _z3 = Math.cos(_v) * r;

        vertices.push(_x12, 0, _z3);
        colors.push(_color.r, _color.g, _color.b); // second vertex

        _v = (j + 1) / divisions * (Math.PI * 2);
        _x12 = Math.sin(_v) * r;
        _z3 = Math.cos(_v) * r;
        vertices.push(_x12, 0, _z3);
        colors.push(_color.r, _color.g, _color.b);
      }
    }

    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    _this117 = _super146.call(this, geometry, material);
    _this117.type = 'PolarGridHelper';
    return _this117;
  }

  return _createClass(PolarGridHelper);
}(LineSegments);

exports.PolarGridHelper = PolarGridHelper;

var _v1 = /*@__PURE__*/new Vector3();

var _v2 = /*@__PURE__*/new Vector3();

var _v3 = /*@__PURE__*/new Vector3();

var DirectionalLightHelper = /*#__PURE__*/function (_Object3D16) {
  _inherits(DirectionalLightHelper, _Object3D16);

  var _super147 = _createSuper(DirectionalLightHelper);

  function DirectionalLightHelper(light, size, color) {
    var _this118;

    _classCallCheck(this, DirectionalLightHelper);

    _this118 = _super147.call(this);
    _this118.light = light;

    _this118.light.updateMatrixWorld();

    _this118.matrix = light.matrixWorld;
    _this118.matrixAutoUpdate = false;
    _this118.color = color;
    if (size === undefined) size = 1;
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
    var material = new LineBasicMaterial({
      fog: false,
      toneMapped: false
    });
    _this118.lightPlane = new Line(geometry, material);

    _this118.add(_this118.lightPlane);

    geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    _this118.targetLine = new Line(geometry, material);

    _this118.add(_this118.targetLine);

    _this118.update();

    return _this118;
  }

  _createClass(DirectionalLightHelper, [{
    key: "dispose",
    value: function dispose() {
      this.lightPlane.geometry.dispose();
      this.lightPlane.material.dispose();
      this.targetLine.geometry.dispose();
      this.targetLine.material.dispose();
    }
  }, {
    key: "update",
    value: function update() {
      _v1.setFromMatrixPosition(this.light.matrixWorld);

      _v2.setFromMatrixPosition(this.light.target.matrixWorld);

      _v3.subVectors(_v2, _v1);

      this.lightPlane.lookAt(_v2);

      if (this.color !== undefined) {
        this.lightPlane.material.color.set(this.color);
        this.targetLine.material.color.set(this.color);
      } else {
        this.lightPlane.material.color.copy(this.light.color);
        this.targetLine.material.color.copy(this.light.color);
      }

      this.targetLine.lookAt(_v2);
      this.targetLine.scale.z = _v3.length();
    }
  }]);

  return DirectionalLightHelper;
}(Object3D);

exports.DirectionalLightHelper = DirectionalLightHelper;

var _vector = /*@__PURE__*/new Vector3();

var _camera = /*@__PURE__*/new Camera();
/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
 */


var CameraHelper = /*#__PURE__*/function (_LineSegments4) {
  _inherits(CameraHelper, _LineSegments4);

  var _super148 = _createSuper(CameraHelper);

  function CameraHelper(camera) {
    var _this119;

    _classCallCheck(this, CameraHelper);

    var geometry = new BufferGeometry();
    var material = new LineBasicMaterial({
      color: 0xffffff,
      vertexColors: true,
      toneMapped: false
    });
    var vertices = [];
    var colors = [];
    var pointMap = {}; // colors

    var colorFrustum = new Color(0xffaa00);
    var colorCone = new Color(0xff0000);
    var colorUp = new Color(0x00aaff);
    var colorTarget = new Color(0xffffff);
    var colorCross = new Color(0x333333); // near

    addLine('n1', 'n2', colorFrustum);
    addLine('n2', 'n4', colorFrustum);
    addLine('n4', 'n3', colorFrustum);
    addLine('n3', 'n1', colorFrustum); // far

    addLine('f1', 'f2', colorFrustum);
    addLine('f2', 'f4', colorFrustum);
    addLine('f4', 'f3', colorFrustum);
    addLine('f3', 'f1', colorFrustum); // sides

    addLine('n1', 'f1', colorFrustum);
    addLine('n2', 'f2', colorFrustum);
    addLine('n3', 'f3', colorFrustum);
    addLine('n4', 'f4', colorFrustum); // cone

    addLine('p', 'n1', colorCone);
    addLine('p', 'n2', colorCone);
    addLine('p', 'n3', colorCone);
    addLine('p', 'n4', colorCone); // up

    addLine('u1', 'u2', colorUp);
    addLine('u2', 'u3', colorUp);
    addLine('u3', 'u1', colorUp); // target

    addLine('c', 't', colorTarget);
    addLine('p', 'c', colorCross); // cross

    addLine('cn1', 'cn2', colorCross);
    addLine('cn3', 'cn4', colorCross);
    addLine('cf1', 'cf2', colorCross);
    addLine('cf3', 'cf4', colorCross);

    function addLine(a, b, color) {
      addPoint(a, color);
      addPoint(b, color);
    }

    function addPoint(id, color) {
      vertices.push(0, 0, 0);
      colors.push(color.r, color.g, color.b);

      if (pointMap[id] === undefined) {
        pointMap[id] = [];
      }

      pointMap[id].push(vertices.length / 3 - 1);
    }

    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    _this119 = _super148.call(this, geometry, material);
    _this119.type = 'CameraHelper';
    _this119.camera = camera;
    if (_this119.camera.updateProjectionMatrix) _this119.camera.updateProjectionMatrix();
    _this119.matrix = camera.matrixWorld;
    _this119.matrixAutoUpdate = false;
    _this119.pointMap = pointMap;

    _this119.update();

    return _this119;
  }

  _createClass(CameraHelper, [{
    key: "update",
    value: function update() {
      var geometry = this.geometry;
      var pointMap = this.pointMap;
      var w = 1,
          h = 1; // we need just camera projection matrix inverse
      // world matrix must be identity

      _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target


      setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
      setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near

      setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
      setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
      setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
      setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far

      setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
      setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
      setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
      setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up

      setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
      setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
      setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross

      setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
      setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
      setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
      setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
      setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
      setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
      setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
      setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
      geometry.getAttribute('position').needsUpdate = true;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }]);

  return CameraHelper;
}(LineSegments);

exports.CameraHelper = CameraHelper;

function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector.set(x, y, z).unproject(camera);

  var points = pointMap[point];

  if (points !== undefined) {
    var position = geometry.getAttribute('position');

    for (var _i350 = 0, l = points.length; _i350 < l; _i350++) {
      position.setXYZ(points[_i350], _vector.x, _vector.y, _vector.z);
    }
  }
}

var _box = /*@__PURE__*/new Box3();

var BoxHelper = /*#__PURE__*/function (_LineSegments5) {
  _inherits(BoxHelper, _LineSegments5);

  var _super149 = _createSuper(BoxHelper);

  function BoxHelper(object, color = 0xffff00) {
    var _this120;

    _classCallCheck(this, BoxHelper);

    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var positions = new Float32Array(8 * 3);
    var geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new BufferAttribute(positions, 3));
    _this120 = _super149.call(this, geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    _this120.object = object;
    _this120.type = 'BoxHelper';
    _this120.matrixAutoUpdate = false;

    _this120.update();

    return _this120;
  }

  _createClass(BoxHelper, [{
    key: "update",
    value: function update(object) {
      if (object !== undefined) {
        console.warn('THREE.BoxHelper: .update() has no longer arguments.');
      }

      if (this.object !== undefined) {
        _box.setFromObject(this.object);
      }

      if (_box.isEmpty()) return;
      var min = _box.min;
      var max = _box.max;
      /*
      	5____4
      1/___0/|
      | 6__|_7
      2/___3/
      	0: max.x, max.y, max.z
      1: min.x, max.y, max.z
      2: min.x, min.y, max.z
      3: max.x, min.y, max.z
      4: max.x, max.y, min.z
      5: min.x, max.y, min.z
      6: min.x, min.y, min.z
      7: max.x, min.y, min.z
      */

      var position = this.geometry.attributes.position;
      var array = position.array;
      array[0] = max.x;
      array[1] = max.y;
      array[2] = max.z;
      array[3] = min.x;
      array[4] = max.y;
      array[5] = max.z;
      array[6] = min.x;
      array[7] = min.y;
      array[8] = max.z;
      array[9] = max.x;
      array[10] = min.y;
      array[11] = max.z;
      array[12] = max.x;
      array[13] = max.y;
      array[14] = min.z;
      array[15] = min.x;
      array[16] = max.y;
      array[17] = min.z;
      array[18] = min.x;
      array[19] = min.y;
      array[20] = min.z;
      array[21] = max.x;
      array[22] = min.y;
      array[23] = min.z;
      position.needsUpdate = true;
      this.geometry.computeBoundingSphere();
    }
  }, {
    key: "setFromObject",
    value: function setFromObject(object) {
      this.object = object;
      this.update();
      return this;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      LineSegments.prototype.copy.call(this, source);
      this.object = source.object;
      return this;
    }
  }]);

  return BoxHelper;
}(LineSegments);

exports.BoxHelper = BoxHelper;

var Box3Helper = /*#__PURE__*/function (_LineSegments6) {
  _inherits(Box3Helper, _LineSegments6);

  var _super150 = _createSuper(Box3Helper);

  function Box3Helper(box, color = 0xffff00) {
    var _this121;

    _classCallCheck(this, Box3Helper);

    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    var geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    _this121 = _super150.call(this, geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    _this121.box = box;
    _this121.type = 'Box3Helper';

    _this121.geometry.computeBoundingSphere();

    return _this121;
  }

  _createClass(Box3Helper, [{
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      var box = this.box;
      if (box.isEmpty()) return;
      box.getCenter(this.position);
      box.getSize(this.scale);
      this.scale.multiplyScalar(0.5);

      _get(_getPrototypeOf(Box3Helper.prototype), "updateMatrixWorld", this).call(this, force);
    }
  }]);

  return Box3Helper;
}(LineSegments);

exports.Box3Helper = Box3Helper;

var PlaneHelper = /*#__PURE__*/function (_Line3) {
  _inherits(PlaneHelper, _Line3);

  var _super151 = _createSuper(PlaneHelper);

  function PlaneHelper(plane, size = 1, hex = 0xffff00) {
    var _this122;

    _classCallCheck(this, PlaneHelper);

    var color = hex;
    var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    _this122 = _super151.call(this, geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    _this122.type = 'PlaneHelper';
    _this122.plane = plane;
    _this122.size = size;
    var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
    var geometry2 = new BufferGeometry();
    geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();

    _this122.add(new Mesh(geometry2, new MeshBasicMaterial({
      color: color,
      opacity: 0.2,
      transparent: true,
      depthWrite: false,
      toneMapped: false
    })));

    return _this122;
  }

  _createClass(PlaneHelper, [{
    key: "updateMatrixWorld",
    value: function updateMatrixWorld(force) {
      var scale = -this.plane.constant;
      if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

      this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
      this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

      this.lookAt(this.plane.normal);

      _get(_getPrototypeOf(PlaneHelper.prototype), "updateMatrixWorld", this).call(this, force);
    }
  }]);

  return PlaneHelper;
}(Line);

exports.PlaneHelper = PlaneHelper;

var _axis = /*@__PURE__*/new Vector3();

var _lineGeometry, _coneGeometry;

var ArrowHelper = /*#__PURE__*/function (_Object3D17) {
  _inherits(ArrowHelper, _Object3D17);

  var _super152 = _createSuper(ArrowHelper);

  // dir is assumed to be normalized
  function ArrowHelper(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {
    var _this123;

    _classCallCheck(this, ArrowHelper);

    _this123 = _super152.call(this);
    _this123.type = 'ArrowHelper';

    if (_lineGeometry === undefined) {
      _lineGeometry = new BufferGeometry();

      _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);

      _coneGeometry.translate(0, -0.5, 0);
    }

    _this123.position.copy(origin);

    _this123.line = new Line(_lineGeometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    _this123.line.matrixAutoUpdate = false;

    _this123.add(_this123.line);

    _this123.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
      color: color,
      toneMapped: false
    }));
    _this123.cone.matrixAutoUpdate = false;

    _this123.add(_this123.cone);

    _this123.setDirection(dir);

    _this123.setLength(length, headLength, headWidth);

    return _this123;
  }

  _createClass(ArrowHelper, [{
    key: "setDirection",
    value: function setDirection(dir) {
      // dir is assumed to be normalized
      if (dir.y > 0.99999) {
        this.quaternion.set(0, 0, 0, 1);
      } else if (dir.y < -0.99999) {
        this.quaternion.set(1, 0, 0, 0);
      } else {
        _axis.set(dir.z, 0, -dir.x).normalize();

        var radians = Math.acos(dir.y);
        this.quaternion.setFromAxisAngle(_axis, radians);
      }
    }
  }, {
    key: "setLength",
    value: function setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
      this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458

      this.line.updateMatrix();
      this.cone.scale.set(headWidth, headLength, headWidth);
      this.cone.position.y = length;
      this.cone.updateMatrix();
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      this.line.material.color.set(color);
      this.cone.material.color.set(color);
    }
  }, {
    key: "copy",
    value: function copy(source) {
      _get(_getPrototypeOf(ArrowHelper.prototype), "copy", this).call(this, source, false);

      this.line.copy(source.line);
      this.cone.copy(source.cone);
      return this;
    }
  }]);

  return ArrowHelper;
}(Object3D);

exports.ArrowHelper = ArrowHelper;

var AxesHelper = /*#__PURE__*/function (_LineSegments7) {
  _inherits(AxesHelper, _LineSegments7);

  var _super153 = _createSuper(AxesHelper);

  function AxesHelper(size = 1) {
    var _this124;

    _classCallCheck(this, AxesHelper);

    var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
    var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    _this124 = _super153.call(this, geometry, material);
    _this124.type = 'AxesHelper';
    return _this124;
  }

  _createClass(AxesHelper, [{
    key: "setColors",
    value: function setColors(xAxisColor, yAxisColor, zAxisColor) {
      var color = new Color();
      var array = this.geometry.attributes.color.array;
      color.set(xAxisColor);
      color.toArray(array, 0);
      color.toArray(array, 3);
      color.set(yAxisColor);
      color.toArray(array, 6);
      color.toArray(array, 9);
      color.set(zAxisColor);
      color.toArray(array, 12);
      color.toArray(array, 15);
      this.geometry.attributes.color.needsUpdate = true;
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }]);

  return AxesHelper;
}(LineSegments);

exports.AxesHelper = AxesHelper;

var ShapePath = /*#__PURE__*/function () {
  function ShapePath() {
    _classCallCheck(this, ShapePath);

    this.type = 'ShapePath';
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }

  _createClass(ShapePath, [{
    key: "moveTo",
    value: function moveTo(x, y) {
      this.currentPath = new Path();
      this.subPaths.push(this.currentPath);
      this.currentPath.moveTo(x, y);
      return this;
    }
  }, {
    key: "lineTo",
    value: function lineTo(x, y) {
      this.currentPath.lineTo(x, y);
      return this;
    }
  }, {
    key: "quadraticCurveTo",
    value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
      this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
      return this;
    }
  }, {
    key: "bezierCurveTo",
    value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
      return this;
    }
  }, {
    key: "splineThru",
    value: function splineThru(pts) {
      this.currentPath.splineThru(pts);
      return this;
    }
  }, {
    key: "toShapes",
    value: function toShapes(isCCW, noHoles) {
      function toShapesNoHoles(inSubpaths) {
        var shapes = [];

        for (var _i351 = 0, l = inSubpaths.length; _i351 < l; _i351++) {
          var _tmpPath = inSubpaths[_i351];

          var _tmpShape = new Shape();

          _tmpShape.curves = _tmpPath.curves;
          shapes.push(_tmpShape);
        }

        return shapes;
      }

      function isPointInsidePolygon(inPt, inPolygon) {
        var polyLen = inPolygon.length; // inPt on polygon contour => immediate success    or
        // toggling of inside/outside at every single! intersection point of an edge
        //  with the horizontal line through inPt, left of inPt
        //  not counting lowerY endpoints of edges and whole edges on that line

        var inside = false;

        for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
          var edgeLowPt = inPolygon[p];
          var edgeHighPt = inPolygon[q];
          var edgeDx = edgeHighPt.x - edgeLowPt.x;
          var edgeDy = edgeHighPt.y - edgeLowPt.y;

          if (Math.abs(edgeDy) > Number.EPSILON) {
            // not parallel
            if (edgeDy < 0) {
              edgeLowPt = inPolygon[q];
              edgeDx = -edgeDx;
              edgeHighPt = inPolygon[p];
              edgeDy = -edgeDy;
            }

            if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

            if (inPt.y === edgeLowPt.y) {
              if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
              // continue;				// no intersection or edgeLowPt => doesn't count !!!
            } else {
              var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
              if (perpEdge === 0) return true; // inPt is on contour ?

              if (perpEdge < 0) continue;
              inside = !inside; // true intersection left of inPt
            }
          } else {
            // parallel or collinear
            if (inPt.y !== edgeLowPt.y) continue; // parallel
            // edge lies on the same horizontal line as inPt

            if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
            // continue;
          }
        }

        return inside;
      }

      var isClockWise = ShapeUtils.isClockWise;
      var subPaths = this.subPaths;
      if (subPaths.length === 0) return [];
      if (noHoles === true) return toShapesNoHoles(subPaths);
      var solid, tmpPath, tmpShape;
      var shapes = [];

      if (subPaths.length === 1) {
        tmpPath = subPaths[0];
        tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        return shapes;
      }

      var holesFirst = !isClockWise(subPaths[0].getPoints());
      holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

      var betterShapeHoles = [];
      var newShapes = [];
      var newShapeHoles = [];
      var mainIdx = 0;
      var tmpPoints;
      newShapes[mainIdx] = undefined;
      newShapeHoles[mainIdx] = [];

      for (var _i352 = 0, l = subPaths.length; _i352 < l; _i352++) {
        tmpPath = subPaths[_i352];
        tmpPoints = tmpPath.getPoints();
        solid = isClockWise(tmpPoints);
        solid = isCCW ? !solid : solid;

        if (solid) {
          if (!holesFirst && newShapes[mainIdx]) mainIdx++;
          newShapes[mainIdx] = {
            s: new Shape(),
            p: tmpPoints
          };
          newShapes[mainIdx].s.curves = tmpPath.curves;
          if (holesFirst) mainIdx++;
          newShapeHoles[mainIdx] = []; //console.log('cw', i);
        } else {
          newShapeHoles[mainIdx].push({
            h: tmpPath,
            p: tmpPoints[0]
          }); //console.log('ccw', i);
        }
      } // only Holes? -> probably all Shapes with wrong orientation


      if (!newShapes[0]) return toShapesNoHoles(subPaths);

      if (newShapes.length > 1) {
        var ambiguous = false;
        var toChange = 0;

        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
          betterShapeHoles[sIdx] = [];
        }

        for (var _sIdx = 0, _sLen = newShapes.length; _sIdx < _sLen; _sIdx++) {
          var sho = newShapeHoles[_sIdx];

          for (var hIdx = 0; hIdx < sho.length; hIdx++) {
            var ho = sho[hIdx];
            var hole_unassigned = true;

            for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
              if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                if (_sIdx !== s2Idx) toChange++;

                if (hole_unassigned) {
                  hole_unassigned = false;
                  betterShapeHoles[s2Idx].push(ho);
                } else {
                  ambiguous = true;
                }
              }
            }

            if (hole_unassigned) {
              betterShapeHoles[_sIdx].push(ho);
            }
          }
        }

        if (toChange > 0 && ambiguous === false) {
          newShapeHoles = betterShapeHoles;
        }
      }

      var tmpHoles;

      for (var _i353 = 0, il = newShapes.length; _i353 < il; _i353++) {
        tmpShape = newShapes[_i353].s;
        shapes.push(tmpShape);
        tmpHoles = newShapeHoles[_i353];

        for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
          tmpShape.holes.push(tmpHoles[j].h);
        }
      } //console.log("shape", shapes);


      return shapes;
    }
  }]);

  return ShapePath;
}(); // Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf


exports.ShapePath = ShapePath;

var DataUtils = /*#__PURE__*/function () {
  function DataUtils() {
    _classCallCheck(this, DataUtils);
  }

  _createClass(DataUtils, null, [{
    key: "toHalfFloat",
    value: // float32 to float16
    function toHalfFloat(val) {
      if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
      val = clamp(val, -65504, 65504);
      _floatView[0] = val;
      var f = _uint32View[0];
      var e = f >> 23 & 0x1ff;
      return _baseTable[e] + ((f & 0x007fffff) >> _shiftTable[e]);
    } // float16 to float32

  }, {
    key: "fromHalfFloat",
    value: function fromHalfFloat(val) {
      var m = val >> 10;
      _uint32View[0] = _mantissaTable[_offsetTable[m] + (val & 0x3ff)] + _exponentTable[m];
      return _floatView[0];
    }
  }]);

  return DataUtils;
}(); // float32 to float16 helpers


exports.DataUtils = DataUtils;

var _buffer = new ArrayBuffer(4);

var _floatView = new Float32Array(_buffer);

var _uint32View = new Uint32Array(_buffer);

var _baseTable = new Uint32Array(512);

var _shiftTable = new Uint32Array(512);

for (var _i354 = 0; _i354 < 256; ++_i354) {
  var e = _i354 - 127; // very small number (0, -0)

  if (e < -27) {
    _baseTable[_i354] = 0x0000;
    _baseTable[_i354 | 0x100] = 0x8000;
    _shiftTable[_i354] = 24;
    _shiftTable[_i354 | 0x100] = 24; // small number (denorm)
  } else if (e < -14) {
    _baseTable[_i354] = 0x0400 >> -e - 14;
    _baseTable[_i354 | 0x100] = 0x0400 >> -e - 14 | 0x8000;
    _shiftTable[_i354] = -e - 1;
    _shiftTable[_i354 | 0x100] = -e - 1; // normal number
  } else if (e <= 15) {
    _baseTable[_i354] = e + 15 << 10;
    _baseTable[_i354 | 0x100] = e + 15 << 10 | 0x8000;
    _shiftTable[_i354] = 13;
    _shiftTable[_i354 | 0x100] = 13; // large number (Infinity, -Infinity)
  } else if (e < 128) {
    _baseTable[_i354] = 0x7c00;
    _baseTable[_i354 | 0x100] = 0xfc00;
    _shiftTable[_i354] = 24;
    _shiftTable[_i354 | 0x100] = 24; // stay (NaN, Infinity, -Infinity)
  } else {
    _baseTable[_i354] = 0x7c00;
    _baseTable[_i354 | 0x100] = 0xfc00;
    _shiftTable[_i354] = 13;
    _shiftTable[_i354 | 0x100] = 13;
  }
} // float16 to float32 helpers


var _mantissaTable = new Uint32Array(2048);

var _exponentTable = new Uint32Array(64);

var _offsetTable = new Uint32Array(64);

for (var _i355 = 1; _i355 < 1024; ++_i355) {
  var m = _i355 << 13; // zero pad mantissa bits

  var _e2 = 0; // zero exponent
  // normalized

  while ((m & 0x00800000) === 0) {
    m <<= 1;
    _e2 -= 0x00800000; // decrement exponent
  }

  m &= ~0x00800000; // clear leading 1 bit

  _e2 += 0x38800000; // adjust bias

  _mantissaTable[_i355] = m | _e2;
}

for (var _i356 = 1024; _i356 < 2048; ++_i356) {
  _mantissaTable[_i356] = 0x38000000 + (_i356 - 1024 << 13);
}

for (var _i357 = 1; _i357 < 31; ++_i357) {
  _exponentTable[_i357] = _i357 << 23;
}

_exponentTable[31] = 0x47800000;
_exponentTable[32] = 0x80000000;

for (var _i358 = 33; _i358 < 63; ++_i358) {
  _exponentTable[_i358] = 0x80000000 + (_i358 - 32 << 23);
}

_exponentTable[63] = 0xc7800000;

for (var _i359 = 1; _i359 < 64; ++_i359) {
  if (_i359 !== 32) {
    _offsetTable[_i359] = 1024;
  }
}

var LineStrip = 0;
exports.LineStrip = LineStrip;
var LinePieces = 1;
exports.LinePieces = LinePieces;
var NoColors = 0;
exports.NoColors = NoColors;
var FaceColors = 1;
exports.FaceColors = FaceColors;
var VertexColors = 2;
exports.VertexColors = VertexColors;

function MeshFaceMaterial(materials) {
  console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
  return materials;
}

function MultiMaterial(materials = []) {
  console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
  materials.isMultiMaterial = true;
  materials.materials = materials;

  materials.clone = function () {
    return materials.slice();
  };

  return materials;
}

var PointCloud = /*#__PURE__*/function (_Points) {
  _inherits(PointCloud, _Points);

  var _super154 = _createSuper(PointCloud);

  function PointCloud(geometry, material) {
    _classCallCheck(this, PointCloud);

    console.warn('THREE.PointCloud has been renamed to THREE.Points.');
    return _super154.call(this, geometry, material);
  }

  return _createClass(PointCloud);
}(Points);

exports.PointCloud = PointCloud;

var Particle = /*#__PURE__*/function (_Sprite) {
  _inherits(Particle, _Sprite);

  var _super155 = _createSuper(Particle);

  function Particle(material) {
    _classCallCheck(this, Particle);

    console.warn('THREE.Particle has been renamed to THREE.Sprite.');
    return _super155.call(this, material);
  }

  return _createClass(Particle);
}(Sprite);

exports.Particle = Particle;

var ParticleSystem = /*#__PURE__*/function (_Points2) {
  _inherits(ParticleSystem, _Points2);

  var _super156 = _createSuper(ParticleSystem);

  function ParticleSystem(geometry, material) {
    _classCallCheck(this, ParticleSystem);

    console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
    return _super156.call(this, geometry, material);
  }

  return _createClass(ParticleSystem);
}(Points);

exports.ParticleSystem = ParticleSystem;

var PointCloudMaterial = /*#__PURE__*/function (_PointsMaterial) {
  _inherits(PointCloudMaterial, _PointsMaterial);

  var _super157 = _createSuper(PointCloudMaterial);

  function PointCloudMaterial(parameters) {
    _classCallCheck(this, PointCloudMaterial);

    console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
    return _super157.call(this, parameters);
  }

  return _createClass(PointCloudMaterial);
}(PointsMaterial);

exports.PointCloudMaterial = PointCloudMaterial;

var ParticleBasicMaterial = /*#__PURE__*/function (_PointsMaterial2) {
  _inherits(ParticleBasicMaterial, _PointsMaterial2);

  var _super158 = _createSuper(ParticleBasicMaterial);

  function ParticleBasicMaterial(parameters) {
    _classCallCheck(this, ParticleBasicMaterial);

    console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
    return _super158.call(this, parameters);
  }

  return _createClass(ParticleBasicMaterial);
}(PointsMaterial);

exports.ParticleBasicMaterial = ParticleBasicMaterial;

var ParticleSystemMaterial = /*#__PURE__*/function (_PointsMaterial3) {
  _inherits(ParticleSystemMaterial, _PointsMaterial3);

  var _super159 = _createSuper(ParticleSystemMaterial);

  function ParticleSystemMaterial(parameters) {
    _classCallCheck(this, ParticleSystemMaterial);

    console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
    return _super159.call(this, parameters);
  }

  return _createClass(ParticleSystemMaterial);
}(PointsMaterial);

exports.ParticleSystemMaterial = ParticleSystemMaterial;

var Vertex = /*#__PURE__*/function (_Vector) {
  _inherits(Vertex, _Vector);

  var _super160 = _createSuper(Vertex);

  function Vertex(x, y, z) {
    _classCallCheck(this, Vertex);

    console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
    return _super160.call(this, x, y, z);
  }

  return _createClass(Vertex);
}(Vector3); //


exports.Vertex = Vertex;

var DynamicBufferAttribute = /*#__PURE__*/function (_BufferAttribute12) {
  _inherits(DynamicBufferAttribute, _BufferAttribute12);

  var _super161 = _createSuper(DynamicBufferAttribute);

  function DynamicBufferAttribute(array, itemSize) {
    var _this125;

    _classCallCheck(this, DynamicBufferAttribute);

    console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
    _this125 = _super161.call(this, array, itemSize);

    _this125.setUsage(DynamicDrawUsage);

    return _this125;
  }

  return _createClass(DynamicBufferAttribute);
}(BufferAttribute);

exports.DynamicBufferAttribute = DynamicBufferAttribute;

var Int8Attribute = /*#__PURE__*/function (_Int8BufferAttribute) {
  _inherits(Int8Attribute, _Int8BufferAttribute);

  var _super162 = _createSuper(Int8Attribute);

  function Int8Attribute(array, itemSize) {
    _classCallCheck(this, Int8Attribute);

    console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
    return _super162.call(this, array, itemSize);
  }

  return _createClass(Int8Attribute);
}(Int8BufferAttribute);

exports.Int8Attribute = Int8Attribute;

var Uint8Attribute = /*#__PURE__*/function (_Uint8BufferAttribute) {
  _inherits(Uint8Attribute, _Uint8BufferAttribute);

  var _super163 = _createSuper(Uint8Attribute);

  function Uint8Attribute(array, itemSize) {
    _classCallCheck(this, Uint8Attribute);

    console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
    return _super163.call(this, array, itemSize);
  }

  return _createClass(Uint8Attribute);
}(Uint8BufferAttribute);

exports.Uint8Attribute = Uint8Attribute;

var Uint8ClampedAttribute = /*#__PURE__*/function (_Uint8ClampedBufferAt) {
  _inherits(Uint8ClampedAttribute, _Uint8ClampedBufferAt);

  var _super164 = _createSuper(Uint8ClampedAttribute);

  function Uint8ClampedAttribute(array, itemSize) {
    _classCallCheck(this, Uint8ClampedAttribute);

    console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
    return _super164.call(this, array, itemSize);
  }

  return _createClass(Uint8ClampedAttribute);
}(Uint8ClampedBufferAttribute);

exports.Uint8ClampedAttribute = Uint8ClampedAttribute;

var Int16Attribute = /*#__PURE__*/function (_Int16BufferAttribute) {
  _inherits(Int16Attribute, _Int16BufferAttribute);

  var _super165 = _createSuper(Int16Attribute);

  function Int16Attribute(array, itemSize) {
    _classCallCheck(this, Int16Attribute);

    console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
    return _super165.call(this, array, itemSize);
  }

  return _createClass(Int16Attribute);
}(Int16BufferAttribute);

exports.Int16Attribute = Int16Attribute;

var Uint16Attribute = /*#__PURE__*/function (_Uint16BufferAttribut) {
  _inherits(Uint16Attribute, _Uint16BufferAttribut);

  var _super166 = _createSuper(Uint16Attribute);

  function Uint16Attribute(array, itemSize) {
    _classCallCheck(this, Uint16Attribute);

    console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
    return _super166.call(this, array, itemSize);
  }

  return _createClass(Uint16Attribute);
}(Uint16BufferAttribute);

exports.Uint16Attribute = Uint16Attribute;

var Int32Attribute = /*#__PURE__*/function (_Int32BufferAttribute) {
  _inherits(Int32Attribute, _Int32BufferAttribute);

  var _super167 = _createSuper(Int32Attribute);

  function Int32Attribute(array, itemSize) {
    _classCallCheck(this, Int32Attribute);

    console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
    return _super167.call(this, array, itemSize);
  }

  return _createClass(Int32Attribute);
}(Int32BufferAttribute);

exports.Int32Attribute = Int32Attribute;

var Uint32Attribute = /*#__PURE__*/function (_Uint32BufferAttribut) {
  _inherits(Uint32Attribute, _Uint32BufferAttribut);

  var _super168 = _createSuper(Uint32Attribute);

  function Uint32Attribute(array, itemSize) {
    _classCallCheck(this, Uint32Attribute);

    console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
    return _super168.call(this, array, itemSize);
  }

  return _createClass(Uint32Attribute);
}(Uint32BufferAttribute);

exports.Uint32Attribute = Uint32Attribute;

var Float32Attribute = /*#__PURE__*/function (_Float32BufferAttribu) {
  _inherits(Float32Attribute, _Float32BufferAttribu);

  var _super169 = _createSuper(Float32Attribute);

  function Float32Attribute(array, itemSize) {
    _classCallCheck(this, Float32Attribute);

    console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
    return _super169.call(this, array, itemSize);
  }

  return _createClass(Float32Attribute);
}(Float32BufferAttribute);

exports.Float32Attribute = Float32Attribute;

var Float64Attribute = /*#__PURE__*/function (_Float64BufferAttribu) {
  _inherits(Float64Attribute, _Float64BufferAttribu);

  var _super170 = _createSuper(Float64Attribute);

  function Float64Attribute(array, itemSize) {
    _classCallCheck(this, Float64Attribute);

    console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
    return _super170.call(this, array, itemSize);
  }

  return _createClass(Float64Attribute);
}(Float64BufferAttribute); //


exports.Float64Attribute = Float64Attribute;

Curve.create = function (construct, getPoint) {
  console.log('THREE.Curve.create() has been deprecated');
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
}; //


Path.prototype.fromPoints = function (points) {
  console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
  return this.setFromPoints(points);
}; //


var AxisHelper = /*#__PURE__*/function (_AxesHelper) {
  _inherits(AxisHelper, _AxesHelper);

  var _super171 = _createSuper(AxisHelper);

  function AxisHelper(size) {
    _classCallCheck(this, AxisHelper);

    console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
    return _super171.call(this, size);
  }

  return _createClass(AxisHelper);
}(AxesHelper);

exports.AxisHelper = AxisHelper;

var BoundingBoxHelper = /*#__PURE__*/function (_BoxHelper) {
  _inherits(BoundingBoxHelper, _BoxHelper);

  var _super172 = _createSuper(BoundingBoxHelper);

  function BoundingBoxHelper(object, color) {
    _classCallCheck(this, BoundingBoxHelper);

    console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
    return _super172.call(this, object, color);
  }

  return _createClass(BoundingBoxHelper);
}(BoxHelper);

exports.BoundingBoxHelper = BoundingBoxHelper;

var EdgesHelper = /*#__PURE__*/function (_LineSegments8) {
  _inherits(EdgesHelper, _LineSegments8);

  var _super173 = _createSuper(EdgesHelper);

  function EdgesHelper(object, hex) {
    _classCallCheck(this, EdgesHelper);

    console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
    return _super173.call(this, new EdgesGeometry(object.geometry), new LineBasicMaterial({
      color: hex !== undefined ? hex : 0xffffff
    }));
  }

  return _createClass(EdgesHelper);
}(LineSegments);

exports.EdgesHelper = EdgesHelper;

GridHelper.prototype.setColors = function () {
  console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};

SkeletonHelper.prototype.update = function () {
  console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
};

var WireframeHelper = /*#__PURE__*/function (_LineSegments9) {
  _inherits(WireframeHelper, _LineSegments9);

  var _super174 = _createSuper(WireframeHelper);

  function WireframeHelper(object, hex) {
    _classCallCheck(this, WireframeHelper);

    console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
    return _super174.call(this, new WireframeGeometry(object.geometry), new LineBasicMaterial({
      color: hex !== undefined ? hex : 0xffffff
    }));
  }

  return _createClass(WireframeHelper);
}(LineSegments); //


exports.WireframeHelper = WireframeHelper;

Loader.prototype.extractUrlBase = function (url) {
  console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
  return LoaderUtils.extractUrlBase(url);
};

Loader.Handlers = {
  add: function
    /* regex, loader */
  add() {
    console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
  },
  get: function
    /* file */
  get() {
    console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
  }
};

var XHRLoader = /*#__PURE__*/function (_FileLoader) {
  _inherits(XHRLoader, _FileLoader);

  var _super175 = _createSuper(XHRLoader);

  function XHRLoader(manager) {
    _classCallCheck(this, XHRLoader);

    console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
    return _super175.call(this, manager);
  }

  return _createClass(XHRLoader);
}(FileLoader);

exports.XHRLoader = XHRLoader;

var BinaryTextureLoader = /*#__PURE__*/function (_DataTextureLoader) {
  _inherits(BinaryTextureLoader, _DataTextureLoader);

  var _super176 = _createSuper(BinaryTextureLoader);

  function BinaryTextureLoader(manager) {
    _classCallCheck(this, BinaryTextureLoader);

    console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
    return _super176.call(this, manager);
  }

  return _createClass(BinaryTextureLoader);
}(DataTextureLoader); //


exports.BinaryTextureLoader = BinaryTextureLoader;

Box2.prototype.center = function (optionalTarget) {
  console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
  return this.getCenter(optionalTarget);
};

Box2.prototype.empty = function () {
  console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
  return this.isEmpty();
};

Box2.prototype.isIntersectionBox = function (box) {
  console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
  return this.intersectsBox(box);
};

Box2.prototype.size = function (optionalTarget) {
  console.warn('THREE.Box2: .size() has been renamed to .getSize().');
  return this.getSize(optionalTarget);
}; //


Box3.prototype.center = function (optionalTarget) {
  console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
  return this.getCenter(optionalTarget);
};

Box3.prototype.empty = function () {
  console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
  return this.isEmpty();
};

Box3.prototype.isIntersectionBox = function (box) {
  console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
  return this.intersectsBox(box);
};

Box3.prototype.isIntersectionSphere = function (sphere) {
  console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
  return this.intersectsSphere(sphere);
};

Box3.prototype.size = function (optionalTarget) {
  console.warn('THREE.Box3: .size() has been renamed to .getSize().');
  return this.getSize(optionalTarget);
}; //


Euler.prototype.toVector3 = function () {
  console.error('THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead');
}; //


Sphere.prototype.empty = function () {
  console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
  return this.isEmpty();
}; //


Frustum.prototype.setFromMatrix = function (m) {
  console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
  return this.setFromProjectionMatrix(m);
}; //


Line3.prototype.center = function (optionalTarget) {
  console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
  return this.getCenter(optionalTarget);
}; //


Matrix3.prototype.flattenToArrayOffset = function (array, offset) {
  console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
  return this.toArray(array, offset);
};

Matrix3.prototype.multiplyVector3 = function (vector) {
  console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
  return vector.applyMatrix3(this);
};

Matrix3.prototype.multiplyVector3Array = function
  /* a */
() {
  console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
};

Matrix3.prototype.applyToBufferAttribute = function (attribute) {
  console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
  return attribute.applyMatrix3(this);
};

Matrix3.prototype.applyToVector3Array = function
  /* array, offset, length */
() {
  console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
};

Matrix3.prototype.getInverse = function (matrix) {
  console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
  return this.copy(matrix).invert();
}; //


Matrix4.prototype.extractPosition = function (m) {
  console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
  return this.copyPosition(m);
};

Matrix4.prototype.flattenToArrayOffset = function (array, offset) {
  console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
  return this.toArray(array, offset);
};

Matrix4.prototype.getPosition = function () {
  console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
  return new Vector3().setFromMatrixColumn(this, 3);
};

Matrix4.prototype.setRotationFromQuaternion = function (q) {
  console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
  return this.makeRotationFromQuaternion(q);
};

Matrix4.prototype.multiplyToArray = function () {
  console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
};

Matrix4.prototype.multiplyVector3 = function (vector) {
  console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
  return vector.applyMatrix4(this);
};

Matrix4.prototype.multiplyVector4 = function (vector) {
  console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
  return vector.applyMatrix4(this);
};

Matrix4.prototype.multiplyVector3Array = function
  /* a */
() {
  console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
};

Matrix4.prototype.rotateAxis = function (v) {
  console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
  v.transformDirection(this);
};

Matrix4.prototype.crossVector = function (vector) {
  console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
  return vector.applyMatrix4(this);
};

Matrix4.prototype.translate = function () {
  console.error('THREE.Matrix4: .translate() has been removed.');
};

Matrix4.prototype.rotateX = function () {
  console.error('THREE.Matrix4: .rotateX() has been removed.');
};

Matrix4.prototype.rotateY = function () {
  console.error('THREE.Matrix4: .rotateY() has been removed.');
};

Matrix4.prototype.rotateZ = function () {
  console.error('THREE.Matrix4: .rotateZ() has been removed.');
};

Matrix4.prototype.rotateByAxis = function () {
  console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
};

Matrix4.prototype.applyToBufferAttribute = function (attribute) {
  console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
  return attribute.applyMatrix4(this);
};

Matrix4.prototype.applyToVector3Array = function
  /* array, offset, length */
() {
  console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
};

Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {
  console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
  return this.makePerspective(left, right, top, bottom, near, far);
};

Matrix4.prototype.getInverse = function (matrix) {
  console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
  return this.copy(matrix).invert();
}; //


Plane.prototype.isIntersectionLine = function (line) {
  console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
  return this.intersectsLine(line);
}; //


Quaternion.prototype.multiplyVector3 = function (vector) {
  console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
  return vector.applyQuaternion(this);
};

Quaternion.prototype.inverse = function () {
  console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
  return this.invert();
}; //


Ray.prototype.isIntersectionBox = function (box) {
  console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
  return this.intersectsBox(box);
};

Ray.prototype.isIntersectionPlane = function (plane) {
  console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
  return this.intersectsPlane(plane);
};

Ray.prototype.isIntersectionSphere = function (sphere) {
  console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
  return this.intersectsSphere(sphere);
}; //


Triangle.prototype.area = function () {
  console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
  return this.getArea();
};

Triangle.prototype.barycoordFromPoint = function (point, target) {
  console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
  return this.getBarycoord(point, target);
};

Triangle.prototype.midpoint = function (target) {
  console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
  return this.getMidpoint(target);
};

Triangle.prototypenormal = function (target) {
  console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
  return this.getNormal(target);
};

Triangle.prototype.plane = function (target) {
  console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
  return this.getPlane(target);
};

Triangle.barycoordFromPoint = function (point, a, b, c, target) {
  console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
  return Triangle.getBarycoord(point, a, b, c, target);
};

Triangle.normal = function (a, b, c, target) {
  console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
  return Triangle.getNormal(a, b, c, target);
}; //


Shape.prototype.extractAllPoints = function (divisions) {
  console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
  return this.extractPoints(divisions);
};

Shape.prototype.extrude = function (options) {
  console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
  return new ExtrudeGeometry(this, options);
};

Shape.prototype.makeGeometry = function (options) {
  console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
  return new ShapeGeometry(this, options);
}; //


Vector2.prototype.fromAttribute = function (attribute, index, offset) {
  console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
  return this.fromBufferAttribute(attribute, index, offset);
};

Vector2.prototype.distanceToManhattan = function (v) {
  console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
  return this.manhattanDistanceTo(v);
};

Vector2.prototype.lengthManhattan = function () {
  console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
  return this.manhattanLength();
}; //


Vector3.prototype.setEulerFromRotationMatrix = function () {
  console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
};

Vector3.prototype.setEulerFromQuaternion = function () {
  console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
};

Vector3.prototype.getPositionFromMatrix = function (m) {
  console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
  return this.setFromMatrixPosition(m);
};

Vector3.prototype.getScaleFromMatrix = function (m) {
  console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
  return this.setFromMatrixScale(m);
};

Vector3.prototype.getColumnFromMatrix = function (index, matrix) {
  console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
  return this.setFromMatrixColumn(matrix, index);
};

Vector3.prototype.applyProjection = function (m) {
  console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
  return this.applyMatrix4(m);
};

Vector3.prototype.fromAttribute = function (attribute, index, offset) {
  console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
  return this.fromBufferAttribute(attribute, index, offset);
};

Vector3.prototype.distanceToManhattan = function (v) {
  console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
  return this.manhattanDistanceTo(v);
};

Vector3.prototype.lengthManhattan = function () {
  console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
  return this.manhattanLength();
}; //


Vector4.prototype.fromAttribute = function (attribute, index, offset) {
  console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
  return this.fromBufferAttribute(attribute, index, offset);
};

Vector4.prototype.lengthManhattan = function () {
  console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
  return this.manhattanLength();
}; //


Object3D.prototype.getChildByName = function (name) {
  console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
  return this.getObjectByName(name);
};

Object3D.prototype.renderDepth = function () {
  console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
};

Object3D.prototype.translate = function (distance, axis) {
  console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
  return this.translateOnAxis(axis, distance);
};

Object3D.prototype.getWorldRotation = function () {
  console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
};

Object3D.prototype.applyMatrix = function (matrix) {
  console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
  return this.applyMatrix4(matrix);
};

Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function get() {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      return this.rotation.order;
    },
    set: function set(value) {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function get() {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    },
    set: function set() {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    }
  }
});

Mesh.prototype.setDrawMode = function () {
  console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
};

Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function get() {
      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
      return TrianglesDrawMode;
    },
    set: function set() {
      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
    }
  }
});

SkinnedMesh.prototype.initBones = function () {
  console.error('THREE.SkinnedMesh: initBones() has been removed.');
}; //


PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
  console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');
  if (filmGauge !== undefined) this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
}; //


Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function set() {
      console.warn('THREE.Light: .onlyShadow has been removed.');
    }
  },
  shadowCameraFov: {
    set: function set(value) {
      console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function set(value) {
      console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function set(value) {
      console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function set(value) {
      console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function set(value) {
      console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function set(value) {
      console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function set(value) {
      console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function set() {
      console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
    }
  },
  shadowBias: {
    set: function set(value) {
      console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function set() {
      console.warn('THREE.Light: .shadowDarkness has been removed.');
    }
  },
  shadowMapWidth: {
    set: function set(value) {
      console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function set(value) {
      console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
      this.shadow.mapSize.height = value;
    }
  }
}); //

Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function get() {
      console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
      return this.array.length;
    }
  },
  dynamic: {
    get: function get() {
      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
      return this.usage === DynamicDrawUsage;
    },
    set: function
      /* value */
    set() {
      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
      this.setUsage(DynamicDrawUsage);
    }
  }
});

BufferAttribute.prototype.setDynamic = function (value) {
  console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};

BufferAttribute.prototype.copyIndicesArray = function
  /* indices */
() {
  console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
}, BufferAttribute.prototype.setArray = function
  /* array */
() {
  console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
}; //

BufferGeometry.prototype.addIndex = function (index) {
  console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
  this.setIndex(index);
};

BufferGeometry.prototype.addAttribute = function (name, attribute) {
  console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
  }

  if (name === 'index') {
    console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
    this.setIndex(attribute);
    return this;
  }

  return this.setAttribute(name, attribute);
};

BufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {
  if (indexOffset !== undefined) {
    console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
  }

  console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
  this.addGroup(start, count);
};

BufferGeometry.prototype.clearDrawCalls = function () {
  console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
  this.clearGroups();
};

BufferGeometry.prototype.computeOffsets = function () {
  console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
};

BufferGeometry.prototype.removeAttribute = function (name) {
  console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
  return this.deleteAttribute(name);
};

BufferGeometry.prototype.applyMatrix = function (matrix) {
  console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
  return this.applyMatrix4(matrix);
};

Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function get() {
      console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
      return this.groups;
    }
  },
  offsets: {
    get: function get() {
      console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
      return this.groups;
    }
  }
});

InterleavedBuffer.prototype.setDynamic = function (value) {
  console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};

InterleavedBuffer.prototype.setArray = function
  /* array */
() {
  console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
}; //


ExtrudeGeometry.prototype.getArrays = function () {
  console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
};

ExtrudeGeometry.prototype.addShapeList = function () {
  console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
};

ExtrudeGeometry.prototype.addShape = function () {
  console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
}; //


Scene.prototype.dispose = function () {
  console.error('THREE.Scene: .dispose() has been removed.');
}; //


Uniform.prototype.onUpdate = function () {
  console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
  return this;
}; //


Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function get() {
      console.warn('THREE.Material: .wrapAround has been removed.');
    },
    set: function set() {
      console.warn('THREE.Material: .wrapAround has been removed.');
    }
  },
  overdraw: {
    get: function get() {
      console.warn('THREE.Material: .overdraw has been removed.');
    },
    set: function set() {
      console.warn('THREE.Material: .overdraw has been removed.');
    }
  },
  wrapRGB: {
    get: function get() {
      console.warn('THREE.Material: .wrapRGB has been removed.');
      return new Color();
    }
  },
  shading: {
    get: function get() {
      console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
    },
    set: function set(value) {
      console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function get() {
      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
      return this.stencilFuncMask;
    },
    set: function set(value) {
      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
      this.stencilFuncMask = value;
    }
  },
  vertexTangents: {
    get: function get() {
      console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
    },
    set: function set() {
      console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function get() {
      console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      return this.extensions.derivatives;
    },
    set: function set(value) {
      console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      this.extensions.derivatives = value;
    }
  }
}); //

WebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {
  console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};

WebGLRenderer.prototype.animate = function (callback) {
  console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
  this.setAnimationLoop(callback);
};

WebGLRenderer.prototype.getCurrentRenderTarget = function () {
  console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
  return this.getRenderTarget();
};

WebGLRenderer.prototype.getMaxAnisotropy = function () {
  console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
  return this.capabilities.getMaxAnisotropy();
};

WebGLRenderer.prototype.getPrecision = function () {
  console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
  return this.capabilities.precision;
};

WebGLRenderer.prototype.resetGLState = function () {
  console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
  return this.state.reset();
};

WebGLRenderer.prototype.supportsFloatTextures = function () {
  console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
  return this.extensions.get('OES_texture_float');
};

WebGLRenderer.prototype.supportsHalfFloatTextures = function () {
  console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
  return this.extensions.get('OES_texture_half_float');
};

WebGLRenderer.prototype.supportsStandardDerivatives = function () {
  console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
  return this.extensions.get('OES_standard_derivatives');
};

WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {
  console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
  return this.extensions.get('WEBGL_compressed_texture_s3tc');
};

WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {
  console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
  return this.extensions.get('WEBGL_compressed_texture_pvrtc');
};

WebGLRenderer.prototype.supportsBlendMinMax = function () {
  console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
  return this.extensions.get('EXT_blend_minmax');
};

WebGLRenderer.prototype.supportsVertexTextures = function () {
  console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
  return this.capabilities.vertexTextures;
};

WebGLRenderer.prototype.supportsInstancedArrays = function () {
  console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
  return this.extensions.get('ANGLE_instanced_arrays');
};

WebGLRenderer.prototype.enableScissorTest = function (boolean) {
  console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
  this.setScissorTest(boolean);
};

WebGLRenderer.prototype.initMaterial = function () {
  console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
};

WebGLRenderer.prototype.addPrePlugin = function () {
  console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
};

WebGLRenderer.prototype.addPostPlugin = function () {
  console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
};

WebGLRenderer.prototype.updateShadowMap = function () {
  console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
};

WebGLRenderer.prototype.setFaceCulling = function () {
  console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
};

WebGLRenderer.prototype.allocTextureUnit = function () {
  console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
};

WebGLRenderer.prototype.setTexture = function () {
  console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
};

WebGLRenderer.prototype.setTexture2D = function () {
  console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
};

WebGLRenderer.prototype.setTextureCube = function () {
  console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
};

WebGLRenderer.prototype.getActiveMipMapLevel = function () {
  console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
  return this.getActiveMipmapLevel();
};

Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function get() {
      return this.shadowMap.enabled;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function get() {
      return this.shadowMap.type;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function get() {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function
      /* value */
    set() {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  context: {
    get: function get() {
      console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
      return this.getContext();
    }
  },
  vr: {
    get: function get() {
      console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
      return this.xr;
    }
  },
  gammaInput: {
    get: function get() {
      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
      return false;
    },
    set: function set() {
      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
    }
  },
  gammaOutput: {
    get: function get() {
      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
      return false;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function get() {
      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
      return 1.0;
    },
    set: function set() {
      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
    }
  },
  gammaFactor: {
    get: function get() {
      console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.');
      return 2;
    },
    set: function set() {
      console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.');
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function get() {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function
      /* cullFace */
    set() {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  renderReverseSided: {
    get: function get() {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function set() {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
    }
  },
  renderSingleSided: {
    get: function get() {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function set() {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
    }
  }
});

var WebGLRenderTargetCube = /*#__PURE__*/function (_WebGLCubeRenderTarge) {
  _inherits(WebGLRenderTargetCube, _WebGLCubeRenderTarge);

  var _super177 = _createSuper(WebGLRenderTargetCube);

  function WebGLRenderTargetCube(width, height, options) {
    _classCallCheck(this, WebGLRenderTargetCube);

    console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
    return _super177.call(this, width, options);
  }

  return _createClass(WebGLRenderTargetCube);
}(WebGLCubeRenderTarget); //


exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function get() {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      return this.texture.wrapS;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function get() {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      return this.texture.wrapT;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function get() {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      return this.texture.magFilter;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function get() {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      return this.texture.minFilter;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function get() {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      return this.texture.anisotropy;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function get() {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      return this.texture.offset;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function get() {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      return this.texture.repeat;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      this.texture.repeat = value;
    }
  },
  format: {
    get: function get() {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      return this.texture.format;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      this.texture.format = value;
    }
  },
  type: {
    get: function get() {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      return this.texture.type;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function get() {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      return this.texture.generateMipmaps;
    },
    set: function set(value) {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      this.texture.generateMipmaps = value;
    }
  }
}); //

Audio.prototype.load = function (file) {
  console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
  var scope = this;
  var audioLoader = new AudioLoader();
  audioLoader.load(file, function (buffer) {
    scope.setBuffer(buffer);
  });
  return this;
};

AudioAnalyser.prototype.getData = function () {
  console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
  return this.getFrequencyData();
}; //


CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
  console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
  return this.update(renderer, scene);
};

CubeCamera.prototype.clear = function (renderer, color, depth, stencil) {
  console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
  return this.renderTarget.clear(renderer, color, depth, stencil);
};

ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
  var loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  var texture = loader.load(url, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
  var loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  var texture = loader.load(urls, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadCompressedTexture = function () {
  console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
};

ImageUtils.loadCompressedTextureCube = function () {
  console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
}; //


function CanvasRenderer() {
  console.error('THREE.CanvasRenderer has been removed');
} //


function JSONLoader() {
  console.error('THREE.JSONLoader has been removed.');
} //


var SceneUtils = {
  createMultiMaterialObject: function
    /* geometry, materials */
  createMultiMaterialObject() {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  },
  detach: function
    /* child, parent, scene */
  detach() {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  },
  attach: function
    /* child, scene, parent */
  attach() {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  }
}; //

exports.SceneUtils = SceneUtils;

function LensFlare() {
  console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
} //


var ParametricGeometry = /*#__PURE__*/function (_BufferGeometry17) {
  _inherits(ParametricGeometry, _BufferGeometry17);

  var _super178 = _createSuper(ParametricGeometry);

  function ParametricGeometry() {
    _classCallCheck(this, ParametricGeometry);

    console.error('THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js');
    return _super178.call(this);
  }

  return _createClass(ParametricGeometry);
}(BufferGeometry);

exports.ParametricGeometry = ParametricGeometry;

var TextGeometry = /*#__PURE__*/function (_BufferGeometry18) {
  _inherits(TextGeometry, _BufferGeometry18);

  var _super179 = _createSuper(TextGeometry);

  function TextGeometry() {
    _classCallCheck(this, TextGeometry);

    console.error('THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js');
    return _super179.call(this);
  }

  return _createClass(TextGeometry);
}(BufferGeometry);

exports.TextGeometry = TextGeometry;

function FontLoader() {
  console.error('THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js');
}

function Font() {
  console.error('THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js');
}

function ImmediateRenderObject() {
  console.error('THREE.ImmediateRenderObject has been removed.');
}

var WebGLMultisampleRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget5) {
  _inherits(WebGLMultisampleRenderTarget, _WebGLRenderTarget5);

  var _super180 = _createSuper(WebGLMultisampleRenderTarget);

  function WebGLMultisampleRenderTarget(width, height, options) {
    var _this126;

    _classCallCheck(this, WebGLMultisampleRenderTarget);

    console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.');
    _this126 = _super180.call(this, width, height, options);
    _this126.samples = 4;
    return _this126;
  }

  return _createClass(WebGLMultisampleRenderTarget);
}(WebGLRenderTarget);

exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;

var DataTexture2DArray = /*#__PURE__*/function (_DataArrayTexture) {
  _inherits(DataTexture2DArray, _DataArrayTexture);

  var _super181 = _createSuper(DataTexture2DArray);

  function DataTexture2DArray(data, width, height, depth) {
    _classCallCheck(this, DataTexture2DArray);

    console.warn('THREE.DataTexture2DArray has been renamed to DataArrayTexture.');
    return _super181.call(this, data, width, height, depth);
  }

  return _createClass(DataTexture2DArray);
}(DataArrayTexture);

exports.DataTexture2DArray = DataTexture2DArray;

var DataTexture3D = /*#__PURE__*/function (_Data3DTexture) {
  _inherits(DataTexture3D, _Data3DTexture);

  var _super182 = _createSuper(DataTexture3D);

  function DataTexture3D(data, width, height, depth) {
    _classCallCheck(this, DataTexture3D);

    console.warn('THREE.DataTexture3D has been renamed to Data3DTexture.');
    return _super182.call(this, data, width, height, depth);
  }

  return _createClass(DataTexture3D);
}(Data3DTexture);

exports.DataTexture3D = DataTexture3D;

if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
    detail: {
      revision: REVISION
    }
  }));
}

if (typeof window !== 'undefined') {
  if (window.__THREE__) {
    console.warn('WARNING: Multiple instances of Three.js being imported.');
  } else {
    window.__THREE__ = REVISION;
  }
}
},{}],"shaders/fragmentBg.glsl":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nuniform float blur;\nuniform float ss1;\nuniform float ss2;\nuniform float ss3;\n\nuniform float hb;\nuniform float col1r;\nuniform float col1g;\nuniform float col1b;\nuniform float col2r;\nuniform float col2g;\nuniform float col2b;\nuniform sampler2D uTexture;\nuniform float sc;\nuniform float ba;\n\nvarying float pulse;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 32.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat noise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat smoothstep2( float x )\n{\n  return x*x*(3.0-2.0*x);\n}\n\n// float lines(vec2 uv, float offset){\n//   return smoothstep(\n//     ss1, ss1 + offset*0.9,\n//     abs(hb*cos(uv.x*ss2) + offset*hb)\n//   );\n// }\n\nfloat lines(vec2 uv, float offset){\n  return smoothstep(\n    ss1, ss1 + offset*0.9,\n    abs(hb*cos(uv.x*ss2) + offset*hb)\n  );\n}\n\nmat2 rotate2d(float angle){\n  return mat2(\n    cos(angle), -cos(angle),\n    sin(angle), cos(angle)\n\n  );\n}\nvoid main() {\n  float n = snoise(vPosition-vec3(0,0,-sc*10.));\n  vec3 color1 = hsb2rgb(vec3(noise(hb + 20.), 0.9, 1.0));\n  vec3 color5 = hsb2rgb(vec3(col1r, col1g, col1b));\n  vec3 color2 = hsb2rgb(vec3(col2r, col2g, col2b));\n  vec3 color4 = hsb2rgb(vec3(noise(hb),0.9,0.9));\n  vec3 color3 = hsb2rgb(vec3(noise(hb),0.9,0.9));\n  vec2 baseUV = rotate2d(n)*vPosition.xy*ss3;\n  float basePattern = lines(baseUV, 0.2);\n  float secondPattern = lines(baseUV, 1.0);\n  float thirdPattern = lines(baseUV, 0.3);\n  float fourthPattern = lines(baseUV, 1.0);\n\n  vec3 baseColor = mix(color2,color1,basePattern);\n  vec3 secondBaseColor = mix(baseColor,color3,secondPattern);\n  vec3 thirdBaseColor = mix(secondBaseColor,color4,thirdPattern);\n  vec3 fourthBaseColor = mix(thirdBaseColor,color5,fourthPattern);\n    // gl_FragColor = vec4(0.,0.,1., 1.);\n\n    // vec4 myimage = texture(\n    //     uTexture,\n    //     vUv + 0.03*sin(vUv*1. + time) \n    // );\n\n    //  vec4 myimage = texture(\n    //     uTexture,\n    //     vUv + 0.003*cnoise(vec4((vUv.x*50. - time)*0.1), vec4(1.0)) \n    // );\n\n    // float sinePulse = 0.01*cnoise(vec4((vUv.x*50. - time)*0.1), vec4(1.0)) ;\n    gl_FragColor = vec4( vec3(fourthBaseColor),1.);\n    // gl_FragColor = vec4( sinePulse,0.,0.,1.);\n    // gl_FragColor = myimage;\n    // gl_FragColor = vec4( pulse,0.,0.,1.);\n}";
},{}],"shaders/vertexBg.glsl":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nuniform float time;\n// uniform float sc;\n// uniform float ba;\n// varying float pulse;\n\n// varying vec3 vPosition;\n\n// uniform vec2 pixels;\n\n// varying vec2 vUv;\n// varying vec3 vNormal;\n\n//\n\n//\n\nuniform float blur;\nuniform float ss1;\nuniform float ss2;\nuniform float ss3;\n\nuniform float hb;\nuniform float col1r;\nuniform float col1g;\nuniform float col1b;\nuniform float col2r;\nuniform float col2g;\nuniform float col2b;\nuniform sampler2D uTexture;\nuniform float sc;\nuniform float ba;\n\nvarying float pulse;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 32.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat noise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat smoothstep2( float x )\n{\n  return x*x*(3.0-2.0*x);\n}\n\n// float lines(vec2 uv, float offset){\n//   return smoothstep(\n//     ss1, ss1 + offset*0.9,\n//     abs(hb*cos(uv.x*ss2) + offset*hb)\n//   );\n// }\n\nfloat lines(vec2 uv, float offset){\n  return smoothstep(\n    ss1, ss1 + offset*0.9,\n    abs(hb*sin(uv.x*ss2) + offset*hb)\n  );\n}\n\nmat2 rotate2d(float angle){\n  return mat2(\n    cos(angle), -cos(angle),\n    sin(angle), cos(angle)\n\n  );\n}\nvoid main() {\n  float n = snoise(vPosition-vec3(0,0,-sc*5.));\n  vec3 color1 = hsb2rgb(vec3(noise(hb + 20.), 0.9, 1.0));\n  vec3 color5 = hsb2rgb(vec3(col1r, col1g, col1b));\n  vec3 color2 = hsb2rgb(vec3(col2r, col2g, col2b));\n  vec3 color4 = hsb2rgb(vec3(noise(hb+10.),0.9,0.9));\n  vec3 color3 = hsb2rgb(vec3(noise(hb),0.9,0.9));\n  vec2 baseUV = rotate2d(n)*vPosition.xy*ss3;\n  float basePattern = lines(baseUV, 0.2);\n  float secondPattern = lines(baseUV, 1.0);\n  float thirdPattern = lines(baseUV, 0.3);\n  float fourthPattern = lines(baseUV, 1.0);\n\n  vec3 baseColor = mix(color2,color1,basePattern);\n  vec3 secondBaseColor = mix(baseColor,color3,secondPattern);\n  vec3 thirdBaseColor = mix(secondBaseColor,color4,thirdPattern);\n  vec3 fourthBaseColor = mix(thirdBaseColor,color5,fourthPattern);\n    // gl_FragColor = vec4(0.,0.,1., 1.);\n\n    // vec4 myimage = texture(\n    //     uTexture,\n    //     vUv + 0.03*sin(vUv*1. + time) \n    // );\n\n    //  vec4 myimage = texture(\n    //     uTexture,\n    //     vUv + 0.003*cnoise(vec4((vUv.x*50. - time)*0.1), vec4(1.0)) \n    // );\n\n    // float sinePulse = 0.01*cnoise(vec4((vUv.x*50. - time)*0.1), vec4(1.0)) ;\n    // gl_FragColor = vec4( vec3(fourthBaseColor),1.);\n\n    // vUv = uv;\n    \n    vPosition = position;\n    vUv = rotate2d(n)*vPosition.xy*ss3;\n    // vNormal = lines(baseUV, 0.2);\n\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1. ) * vec4( vec3(fourthBaseColor),1.);\n\n    // gl_FragColor = vec4( sinePulse,0.,0.,1.);\n    // gl_FragColor = myimage;\n    // gl_FragColor = vec4( pulse,0.,0.,1.);\n}\n\n//\n\n// void main() {\n//     vUv = uv;\n//     vPosition = position;\n//     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n// }";
},{}],"sounds/sound.mp3":[function(require,module,exports) {
module.exports = "/sound.63cda73b.mp3";
},{}],"../node_modules/tone/build/esm/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
const version = "14.7.77";
exports.version = version;
},{}],"../node_modules/@babel/runtime/helpers/arrayWithHoles.js":[function(require,module,exports) {
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],"../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":[function(require,module,exports) {
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],"../node_modules/@babel/runtime/helpers/arrayLikeToArray.js":[function(require,module,exports) {
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],"../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":[function(require,module,exports) {
var arrayLikeToArray = require("./arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./arrayLikeToArray.js":"../node_modules/@babel/runtime/helpers/arrayLikeToArray.js"}],"../node_modules/@babel/runtime/helpers/nonIterableRest.js":[function(require,module,exports) {
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],"../node_modules/@babel/runtime/helpers/slicedToArray.js":[function(require,module,exports) {
var arrayWithHoles = require("./arrayWithHoles.js");

var iterableToArrayLimit = require("./iterableToArrayLimit.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableRest = require("./nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./arrayWithHoles.js":"../node_modules/@babel/runtime/helpers/arrayWithHoles.js","./iterableToArrayLimit.js":"../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","./unsupportedIterableToArray.js":"../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","./nonIterableRest.js":"../node_modules/@babel/runtime/helpers/nonIterableRest.js"}],"../node_modules/@babel/runtime/helpers/classCallCheck.js":[function(require,module,exports) {
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],"../node_modules/@babel/runtime/helpers/createClass.js":[function(require,module,exports) {
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],"../node_modules/automation-events/build/es5/bundle.js":[function(require,module,exports) {
var define;
var global = arguments[3];
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) : typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));
})(this, function (exports, _slicedToArray, _classCallCheck, _createClass) {
  'use strict';

  function _interopDefaultLegacy(e) {
    return e && _typeof(e) === 'object' && 'default' in e ? e : {
      'default': e
    };
  }

  var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);

  var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);

  var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);

  var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {
    return {
      endTime: endTime,
      insertTime: insertTime,
      type: 'exponentialRampToValue',
      value: value
    };
  };

  var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {
    return {
      endTime: endTime,
      insertTime: insertTime,
      type: 'linearRampToValue',
      value: value
    };
  };

  var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {
    return {
      startTime: startTime,
      type: 'setValue',
      value: value
    };
  };

  var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {
    return {
      duration: duration,
      startTime: startTime,
      type: 'setValueCurve',
      values: values
    };
  };

  var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {
    var startTime = _ref.startTime,
        target = _ref.target,
        timeConstant = _ref.timeConstant;
    return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);
  };

  var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {
    return automationEvent.type === 'exponentialRampToValue';
  };

  var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {
    return automationEvent.type === 'linearRampToValue';
  };

  var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {
    return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);
  };

  var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {
    return automationEvent.type === 'setValue';
  };

  var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {
    return automationEvent.type === 'setValueCurve';
  };

  var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {
    var automationEvent = automationEvents[index];
    return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);
  };

  var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {
    return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];
  };

  var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {
    return automationEvent.type === 'cancelAndHold';
  };

  var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {
    return automationEvent.type === 'cancelScheduledValues';
  };

  var getEventTime = function getEventTime(automationEvent) {
    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
      return automationEvent.cancelTime;
    }

    if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {
      return automationEvent.endTime;
    }

    return automationEvent.startTime;
  };

  var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {
    var endTime = _ref.endTime,
        value = _ref.value;

    if (valueAtStartTime === value) {
      return value;
    }

    if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {
      return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));
    }

    return 0;
  };

  var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {
    var endTime = _ref.endTime,
        value = _ref.value;
    return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);
  };

  var interpolateValue = function interpolateValue(values, theoreticIndex) {
    var lowerIndex = Math.floor(theoreticIndex);
    var upperIndex = Math.ceil(theoreticIndex);

    if (lowerIndex === upperIndex) {
      return values[lowerIndex];
    }

    return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];
  };

  var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {
    var duration = _ref.duration,
        startTime = _ref.startTime,
        values = _ref.values;
    var theoreticIndex = (time - startTime) / duration * (values.length - 1);
    return interpolateValue(values, theoreticIndex);
  };

  var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {
    return automationEvent.type === 'setTarget';
  };

  var AutomationEventList = /*#__PURE__*/function (_Symbol$iterator) {
    function AutomationEventList(defaultValue) {
      _classCallCheck__default["default"](this, AutomationEventList);

      this._automationEvents = [];
      this._currenTime = 0;
      this._defaultValue = defaultValue;
    }

    _createClass__default["default"](AutomationEventList, [{
      key: _Symbol$iterator,
      value: function value() {
        return this._automationEvents[Symbol.iterator]();
      }
    }, {
      key: "add",
      value: function add(automationEvent) {
        var eventTime = getEventTime(automationEvent);

        if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {
            if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {
              return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;
            }

            return getEventTime(currentAutomationEvent) >= eventTime;
          });

          var removedAutomationEvent = this._automationEvents[index];

          if (index !== -1) {
            this._automationEvents = this._automationEvents.slice(0, index);
          }

          if (isCancelAndHoldAutomationEvent(automationEvent)) {
            var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];

            if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {
              if (isSetTargetAutomationEvent(lastAutomationEvent)) {
                throw new Error('The internal list is malformed.');
              }

              var startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);
              var startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;
              var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);
              var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);

              this._automationEvents.push(truncatedAutomationEvent);
            }

            if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {
              this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));
            }

            if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {
              this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);
            }
          }
        } else {
          var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {
            return getEventTime(currentAutomationEvent) > eventTime;
          });

          var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];

          if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {
            return false;
          }

          var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;

          if (_index === -1) {
            this._automationEvents.push(persistentAutomationEvent);
          } else {
            if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {
              return false;
            }

            this._automationEvents.splice(_index, 0, persistentAutomationEvent);
          }
        }

        return true;
      }
    }, {
      key: "flush",
      value: function flush(time) {
        var index = this._automationEvents.findIndex(function (currentAutomationEvent) {
          return getEventTime(currentAutomationEvent) > time;
        });

        if (index > 1) {
          var remainingAutomationEvents = this._automationEvents.slice(index - 1);

          var firstRemainingAutomationEvent = remainingAutomationEvents[0];

          if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {
            remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));
          }

          this._automationEvents = remainingAutomationEvents;
        }
      }
    }, {
      key: "getValue",
      value: function getValue(time) {
        if (this._automationEvents.length === 0) {
          return this._defaultValue;
        }

        var indexOfNextEvent = this._automationEvents.findIndex(function (automationEvent) {
          return getEventTime(automationEvent) > time;
        });

        var nextAutomationEvent = this._automationEvents[indexOfNextEvent];
        var indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;
        var currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];

        if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {
          return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);
        }

        if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
          return currentAutomationEvent.value;
        }

        if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {
          if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {
            return getValueCurveValueAtTime(time, currentAutomationEvent);
          }

          return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];
        }

        if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
          return currentAutomationEvent.value;
        }

        if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {
          var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),
              _getEndTimeAndValueOf2 = _slicedToArray__default["default"](_getEndTimeAndValueOf, 2),
              startTime = _getEndTimeAndValueOf2[0],
              value = _getEndTimeAndValueOf2[1];

          return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);
        }

        if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {
          var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),
              _getEndTimeAndValueOf4 = _slicedToArray__default["default"](_getEndTimeAndValueOf3, 2),
              _startTime = _getEndTimeAndValueOf4[0],
              _value = _getEndTimeAndValueOf4[1];

          return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);
        }

        return this._defaultValue;
      }
    }]);

    return AutomationEventList;
  }(Symbol.iterator);

  var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {
    return {
      cancelTime: cancelTime,
      type: 'cancelAndHold'
    };
  };

  var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {
    return {
      cancelTime: cancelTime,
      type: 'cancelScheduledValues'
    };
  };

  var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {
    return {
      endTime: endTime,
      type: 'exponentialRampToValue',
      value: value
    };
  };

  var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {
    return {
      endTime: endTime,
      type: 'linearRampToValue',
      value: value
    };
  };

  var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {
    return {
      startTime: startTime,
      target: target,
      timeConstant: timeConstant,
      type: 'setTarget'
    };
  };

  exports.AutomationEventList = AutomationEventList;
  exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;
  exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;
  exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;
  exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;
  exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;
  exports.createSetValueAutomationEvent = createSetValueAutomationEvent;
  exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});
},{"@babel/runtime/helpers/slicedToArray":"../node_modules/@babel/runtime/helpers/slicedToArray.js","@babel/runtime/helpers/classCallCheck":"../node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"../node_modules/@babel/runtime/helpers/createClass.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/abort-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAbortError = void 0;

const createAbortError = () => new DOMException('', 'AbortError');

exports.createAbortError = createAbortError;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/add-active-input-connection-to-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAddActiveInputConnectionToAudioNode = void 0;

const createAddActiveInputConnectionToAudioNode = insertElementInSet => {
  return (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {
    insertElementInSet(activeInputs[input], [source, output, eventListener], activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);
  };
};

exports.createAddActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAddAudioNodeConnections = void 0;

const createAddAudioNodeConnections = audioNodeConnectionsStore => {
  return (audioNode, audioNodeRenderer, nativeAudioNode) => {
    const activeInputs = [];

    for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {
      activeInputs.push(new Set());
    }

    audioNodeConnectionsStore.set(audioNode, {
      activeInputs,
      outputs: new Set(),
      passiveInputs: new WeakMap(),
      renderer: audioNodeRenderer
    });
  };
};

exports.createAddAudioNodeConnections = createAddAudioNodeConnections;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAddAudioParamConnections = void 0;

const createAddAudioParamConnections = audioParamConnectionsStore => {
  return (audioParam, audioParamRenderer) => {
    audioParamConnectionsStore.set(audioParam, {
      activeInputs: new Set(),
      passiveInputs: new WeakMap(),
      renderer: audioParamRenderer
    });
  };
};

exports.createAddAudioParamConnections = createAddAudioParamConnections;
},{}],"../node_modules/standardized-audio-context/build/es2019/globals.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NODE_TO_PROCESSOR_MAPS = exports.NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = exports.EVENT_LISTENERS = exports.CYCLE_COUNTERS = exports.CONTEXT_STORE = exports.AUDIO_PARAM_STORE = exports.AUDIO_PARAM_CONNECTIONS_STORE = exports.AUDIO_NODE_STORE = exports.AUDIO_NODE_CONNECTIONS_STORE = exports.ACTIVE_AUDIO_NODE_STORE = void 0;
const ACTIVE_AUDIO_NODE_STORE = new WeakSet();
exports.ACTIVE_AUDIO_NODE_STORE = ACTIVE_AUDIO_NODE_STORE;
const AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();
exports.AUDIO_NODE_CONNECTIONS_STORE = AUDIO_NODE_CONNECTIONS_STORE;
const AUDIO_NODE_STORE = new WeakMap();
exports.AUDIO_NODE_STORE = AUDIO_NODE_STORE;
const AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();
exports.AUDIO_PARAM_CONNECTIONS_STORE = AUDIO_PARAM_CONNECTIONS_STORE;
const AUDIO_PARAM_STORE = new WeakMap();
exports.AUDIO_PARAM_STORE = AUDIO_PARAM_STORE;
const CONTEXT_STORE = new WeakMap();
exports.CONTEXT_STORE = CONTEXT_STORE;
const EVENT_LISTENERS = new WeakMap();
exports.EVENT_LISTENERS = EVENT_LISTENERS;
const CYCLE_COUNTERS = new WeakMap(); // This clunky name is borrowed from the spec. :-)

exports.CYCLE_COUNTERS = CYCLE_COUNTERS;
const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();
exports.NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS;
const NODE_TO_PROCESSOR_MAPS = new WeakMap();
exports.NODE_TO_PROCESSOR_MAPS = NODE_TO_PROCESSOR_MAPS;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isConstructible = void 0;
const handler = {
  construct() {
    return handler;
  }

};

const isConstructible = constructible => {
  try {
    const proxy = new Proxy(constructible, handler);
    new proxy(); // tslint:disable-line:no-unused-expression
  } catch {
    return false;
  }

  return true;
};

exports.isConstructible = isConstructible;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitImportStatements = void 0;

/*
 * This massive regex tries to cover all the following cases.
 *
 * import './path';
 * import defaultImport from './path';
 * import { namedImport } from './path';
 * import { namedImport as renamendImport } from './path';
 * import * as namespaceImport from './path';
 * import defaultImport, { namedImport } from './path';
 * import defaultImport, { namedImport as renamendImport } from './path';
 * import defaultImport, * as namespaceImport from './path';
 */
const IMPORT_STATEMENT_REGEX = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/; // tslint:disable-line:max-line-length

const splitImportStatements = (source, url) => {
  const importStatements = [];
  let sourceWithoutImportStatements = source.replace(/^[\s]+/, '');
  let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);

  while (result !== null) {
    const unresolvedUrl = result[1].slice(1, -1);
    const importStatementWithResolvedUrl = result[0].replace(/([\s]+)?;?$/, '').replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());
    importStatements.push(importStatementWithResolvedUrl);
    sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\s]+/, '');
    result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);
  }

  return [importStatements.join(';'), sourceWithoutImportStatements];
};

exports.splitImportStatements = splitImportStatements;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAddAudioWorkletModule = void 0;

var _globals = require("../globals");

var _isConstructible = require("../helpers/is-constructible");

var _splitImportStatements = require("../helpers/split-import-statements");

const verifyParameterDescriptors = parameterDescriptors => {
  if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {
    throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');
  }
};

const verifyProcessorCtor = processorCtor => {
  if (!(0, _isConstructible.isConstructible)(processorCtor)) {
    throw new TypeError('The given value for processorCtor should be a constructor.');
  }

  if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {
    throw new TypeError('The given value for processorCtor should have a prototype.');
  }
};

const createAddAudioWorkletModule = (cacheTestResult, createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window) => {
  let index = 0;
  return (context, moduleURL, options = {
    credentials: 'omit'
  }) => {
    const resolvedRequestsOfContext = resolvedRequests.get(context);

    if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {
      return Promise.resolve();
    }

    const ongoingRequestsOfContext = ongoingRequests.get(context);

    if (ongoingRequestsOfContext !== undefined) {
      const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);

      if (promiseOfOngoingRequest !== undefined) {
        return promiseOfOngoingRequest;
      }
    }

    const nativeContext = getNativeContext(context); // Bug #59: Safari does not implement the audioWorklet property.

    const promise = nativeContext.audioWorklet === undefined ? fetchSource(moduleURL).then(([source, absoluteUrl]) => {
      const [importStatements, sourceWithoutImportStatements] = (0, _splitImportStatements.splitImportStatements)(source, absoluteUrl);
      /*
       * This is the unminified version of the code used below:
       *
       * ```js
       * ${ importStatements };
       * ((a, b) => {
       *     (a[b] = a[b] || [ ]).push(
       *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {
       *             ${ sourceWithoutImportStatements }
       *         }
       *     );
       * })(window, '_AWGS');
       * ```
       */
      // tslint:disable-next-line:max-line-length

      const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}
})})(window,'_AWGS')`; // @todo Evaluating the given source code is a possible security problem.

      return evaluateSource(wrappedSource);
    }).then(() => {
      const evaluateAudioWorkletGlobalScope = window._AWGS.pop();

      if (evaluateAudioWorkletGlobalScope === undefined) {
        // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.
        throw new SyntaxError();
      }

      exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {}, undefined, (name, processorCtor) => {
        if (name.trim() === '') {
          throw createNotSupportedError();
        }

        const nodeNameToProcessorConstructorMap = _globals.NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);

        if (nodeNameToProcessorConstructorMap !== undefined) {
          if (nodeNameToProcessorConstructorMap.has(name)) {
            throw createNotSupportedError();
          }

          verifyProcessorCtor(processorCtor);
          verifyParameterDescriptors(processorCtor.parameterDescriptors);
          nodeNameToProcessorConstructorMap.set(name, processorCtor);
        } else {
          verifyProcessorCtor(processorCtor);
          verifyParameterDescriptors(processorCtor.parameterDescriptors);

          _globals.NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));
        }
      }, nativeContext.sampleRate, undefined, undefined));
    }) : Promise.all([fetchSource(moduleURL), Promise.resolve(cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {
      const currentIndex = index + 1;
      index = currentIndex;
      const [importStatements, sourceWithoutImportStatements] = (0, _splitImportStatements.splitImportStatements)(source, absoluteUrl);
      /*
       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.
       *
       * This is the unminified version of the code used below.
       *
       * ```js
       * class extends AudioWorkletProcessor {
       *
       *     __buffers = new WeakSet();
       *
       *     constructor () {
       *         super();
       *
       *         this.port.postMessage = ((postMessage) => {
       *             return (message, transferables) => {
       *                 const filteredTransferables = (transferables)
       *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))
       *                     : transferables;
       *
       *                 return postMessage.call(this.port, message, filteredTransferables);
       *              };
       *         })(this.port.postMessage);
       *     }
       * }
       * ```
       */

      const patchedAudioWorkletProcessor = isSupportingPostMessage ? 'AudioWorkletProcessor' : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';
      /*
       * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.
       *
       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.
       *
       * Bug #190: Safari doesn't throw an error when loading an unparsable module.
       *
       * This is the unminified version of the code used below:
       *
       * ```js
       * `${ importStatements };
       * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }
       * })(
       *     ${ patchedAudioWorkletProcessor },
       *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {
       *
       *         __collectBuffers = (array) => {
       *             array.forEach((element) => this.__buffers.add(element.buffer));
       *         };
       *
       *         process (inputs, outputs, parameters) {
       *             inputs.forEach(this.__collectBuffers);
       *             outputs.forEach(this.__collectBuffers);
       *             this.__collectBuffers(Object.values(parameters));
       *
       *             return super.process(
       *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),
       *                 outputs,
       *                 parameters
       *             );
       *         }
       *
       *     })
       * );
       *
       * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{
       *
       *     process () {
       *         return false;
       *     }
       *
       * })`
       * ```
       */

      const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';
      const bufferRegistration = isSupportingPostMessage ? '' : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';
      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}
})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;
      const blob = new Blob([wrappedSource], {
        type: 'application/javascript; charset=utf-8'
      });
      const url = URL.createObjectURL(blob);
      return nativeContext.audioWorklet.addModule(url, options).then(() => {
        if (isNativeOfflineAudioContext(nativeContext)) {
          return nativeContext;
        } // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.


        const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);
        return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);
      }).then(nativeContextOrBackupOfflineAudioContext => {
        if (nativeAudioWorkletNodeConstructor === null) {
          throw new SyntaxError();
        }

        try {
          // Bug #190: Safari doesn't throw an error when loading an unparsable module.
          new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression
        } catch {
          throw new SyntaxError();
        }
      }).finally(() => URL.revokeObjectURL(url));
    });

    if (ongoingRequestsOfContext === undefined) {
      ongoingRequests.set(context, new Map([[moduleURL, promise]]));
    } else {
      ongoingRequestsOfContext.set(moduleURL, promise);
    }

    promise.then(() => {
      const updatedResolvedRequestsOfContext = resolvedRequests.get(context);

      if (updatedResolvedRequestsOfContext === undefined) {
        resolvedRequests.set(context, new Set([moduleURL]));
      } else {
        updatedResolvedRequestsOfContext.add(moduleURL);
      }
    }).finally(() => {
      const updatedOngoingRequestsOfContext = ongoingRequests.get(context);

      if (updatedOngoingRequestsOfContext !== undefined) {
        updatedOngoingRequestsOfContext.delete(moduleURL);
      }
    });
    return promise;
  };
};

exports.createAddAudioWorkletModule = createAddAudioWorkletModule;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","../helpers/is-constructible":"../node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js","../helpers/split-import-statements":"../node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getValueForKey = void 0;

const getValueForKey = (map, key) => {
  const value = map.get(key);

  if (value === undefined) {
    throw new Error('A value with the given key could not be found.');
  }

  return value;
};

exports.getValueForKey = getValueForKey;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pickElementFromSet = void 0;

const pickElementFromSet = (set, predicate) => {
  const matchingElements = Array.from(set).filter(predicate);

  if (matchingElements.length > 1) {
    throw Error('More than one element was found.');
  }

  if (matchingElements.length === 0) {
    throw Error('No element was found.');
  }

  const [matchingElement] = matchingElements;
  set.delete(matchingElement);
  return matchingElement;
};

exports.pickElementFromSet = pickElementFromSet;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deletePassiveInputConnectionToAudioNode = void 0;

var _getValueForKey = require("./get-value-for-key");

var _pickElementFromSet = require("./pick-element-from-set");

const deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {
  const passiveInputConnections = (0, _getValueForKey.getValueForKey)(passiveInputs, source);
  const matchingConnection = (0, _pickElementFromSet.pickElementFromSet)(passiveInputConnections, passiveInputConnection => passiveInputConnection[0] === output && passiveInputConnection[1] === input);

  if (passiveInputConnections.size === 0) {
    passiveInputs.delete(source);
  }

  return matchingConnection;
};

exports.deletePassiveInputConnectionToAudioNode = deletePassiveInputConnectionToAudioNode;
},{"./get-value-for-key":"../node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js","./pick-element-from-set":"../node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEventListenersOfAudioNode = void 0;

var _globals = require("../globals");

var _getValueForKey = require("./get-value-for-key");

const getEventListenersOfAudioNode = audioNode => {
  return (0, _getValueForKey.getValueForKey)(_globals.EVENT_LISTENERS, audioNode);
};

exports.getEventListenersOfAudioNode = getEventListenersOfAudioNode;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","./get-value-for-key":"../node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setInternalStateToActive = void 0;

var _globals = require("../globals");

var _getEventListenersOfAudioNode = require("./get-event-listeners-of-audio-node");

const setInternalStateToActive = audioNode => {
  if (_globals.ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
    throw new Error('The AudioNode is already stored.');
  }

  _globals.ACTIVE_AUDIO_NODE_STORE.add(audioNode);

  (0, _getEventListenersOfAudioNode.getEventListenersOfAudioNode)(audioNode).forEach(eventListener => eventListener(true));
};

exports.setInternalStateToActive = setInternalStateToActive;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","./get-event-listeners-of-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js"}],"../node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAudioWorkletNode = void 0;

const isAudioWorkletNode = audioNode => {
  return 'port' in audioNode;
};

exports.isAudioWorkletNode = isAudioWorkletNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setInternalStateToPassive = void 0;

var _globals = require("../globals");

var _getEventListenersOfAudioNode = require("./get-event-listeners-of-audio-node");

const setInternalStateToPassive = audioNode => {
  if (!_globals.ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
    throw new Error('The AudioNode is not stored.');
  }

  _globals.ACTIVE_AUDIO_NODE_STORE.delete(audioNode);

  (0, _getEventListenersOfAudioNode.getEventListenersOfAudioNode)(audioNode).forEach(eventListener => eventListener(false));
};

exports.setInternalStateToPassive = setInternalStateToPassive;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","./get-event-listeners-of-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setInternalStateToPassiveWhenNecessary = void 0;

var _audioWorkletNode = require("../guards/audio-worklet-node");

var _setInternalStateToPassive = require("./set-internal-state-to-passive");

// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.
const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {
  if (!(0, _audioWorkletNode.isAudioWorkletNode)(audioNode) && activeInputs.every(connections => connections.size === 0)) {
    (0, _setInternalStateToPassive.setInternalStateToPassive)(audioNode);
  }
};

exports.setInternalStateToPassiveWhenNecessary = setInternalStateToPassiveWhenNecessary;
},{"../guards/audio-worklet-node":"../node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js","./set-internal-state-to-passive":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/add-connection-to-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAddConnectionToAudioNode = void 0;

var _deletePassiveInputConnectionToAudioNode = require("../helpers/delete-passive-input-connection-to-audio-node");

var _setInternalStateToActive = require("../helpers/set-internal-state-to-active");

var _setInternalStateToPassiveWhenNecessary = require("../helpers/set-internal-state-to-passive-when-necessary");

const createAddConnectionToAudioNode = (addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode) => {
  const tailTimeTimeoutIds = new WeakMap();
  return (source, destination, output, input, isOffline) => {
    const {
      activeInputs,
      passiveInputs
    } = getAudioNodeConnections(destination);
    const {
      outputs
    } = getAudioNodeConnections(source);
    const eventListeners = getEventListenersOfAudioNode(source);

    const eventListener = isActive => {
      const nativeDestinationAudioNode = getNativeAudioNode(destination);
      const nativeSourceAudioNode = getNativeAudioNode(source);

      if (isActive) {
        const partialConnection = (0, _deletePassiveInputConnectionToAudioNode.deletePassiveInputConnectionToAudioNode)(passiveInputs, source, output, input);
        addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);

        if (!isOffline && !isPartOfACycle(source)) {
          connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);
        }

        if (isPassiveAudioNode(destination)) {
          (0, _setInternalStateToActive.setInternalStateToActive)(destination);
        }
      } else {
        const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);
        addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);

        if (!isOffline && !isPartOfACycle(source)) {
          disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);
        }

        const tailTime = getAudioNodeTailTime(destination);

        if (tailTime === 0) {
          if (isActiveAudioNode(destination)) {
            (0, _setInternalStateToPassiveWhenNecessary.setInternalStateToPassiveWhenNecessary)(destination, activeInputs);
          }
        } else {
          const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);

          if (tailTimeTimeoutId !== undefined) {
            clearTimeout(tailTimeTimeoutId);
          }

          tailTimeTimeoutIds.set(destination, setTimeout(() => {
            if (isActiveAudioNode(destination)) {
              (0, _setInternalStateToPassiveWhenNecessary.setInternalStateToPassiveWhenNecessary)(destination, activeInputs);
            }
          }, tailTime * 1000));
        }
      }
    };

    if (insertElementInSet(outputs, [destination, output, input], outputConnection => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {
      eventListeners.add(eventListener);

      if (isActiveAudioNode(source)) {
        addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);
      } else {
        addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);
      }

      return true;
    }

    return false;
  };
};

exports.createAddConnectionToAudioNode = createAddConnectionToAudioNode;
},{"../helpers/delete-passive-input-connection-to-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-node.js","../helpers/set-internal-state-to-active":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js","../helpers/set-internal-state-to-passive-when-necessary":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/add-passive-input-connection-to-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAddPassiveInputConnectionToAudioNode = void 0;

const createAddPassiveInputConnectionToAudioNode = insertElementInSet => {
  return (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {
    const passiveInputConnections = passiveInputs.get(source);

    if (passiveInputConnections === undefined) {
      passiveInputs.set(source, new Set([[output, input, eventListener]]));
    } else {
      insertElementInSet(passiveInputConnections, [output, input, eventListener], passiveInputConnection => passiveInputConnection[0] === output && passiveInputConnection[1] === input, ignoreDuplicates);
    }
  };
};

exports.createAddPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAddSilentConnection = void 0;

const createAddSilentConnection = createNativeGainNode => {
  return (nativeContext, nativeAudioScheduledSourceNode) => {
    const nativeGainNode = createNativeGainNode(nativeContext, {
      channelCount: 1,
      channelCountMode: 'explicit',
      channelInterpretation: 'discrete',
      gain: 0
    });
    nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);

    const disconnect = () => {
      nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);
      nativeAudioScheduledSourceNode.disconnect(nativeGainNode);
      nativeGainNode.disconnect();
    };

    nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);
  };
};

exports.createAddSilentConnection = createAddSilentConnection;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAddUnrenderedAudioWorkletNode = void 0;

const createAddUnrenderedAudioWorkletNode = getUnrenderedAudioWorkletNodes => {
  return (nativeContext, audioWorkletNode) => {
    getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);
  };
};

exports.createAddUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/analyser-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAnalyserNodeConstructor = void 0;
const DEFAULT_OPTIONS = {
  channelCount: 2,
  channelCountMode: 'max',
  channelInterpretation: 'speakers',
  fftSize: 2048,
  maxDecibels: -30,
  minDecibels: -100,
  smoothingTimeConstant: 0.8
};

const createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext) => {
  return class AnalyserNode extends audionNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);
      const analyserNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null;
      super(context, false, nativeAnalyserNode, analyserNodeRenderer);
      this._nativeAnalyserNode = nativeAnalyserNode;
    }

    get fftSize() {
      return this._nativeAnalyserNode.fftSize;
    }

    set fftSize(value) {
      this._nativeAnalyserNode.fftSize = value;
    }

    get frequencyBinCount() {
      return this._nativeAnalyserNode.frequencyBinCount;
    }

    get maxDecibels() {
      return this._nativeAnalyserNode.maxDecibels;
    }

    set maxDecibels(value) {
      // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.
      const maxDecibels = this._nativeAnalyserNode.maxDecibels;
      this._nativeAnalyserNode.maxDecibels = value;

      if (!(value > this._nativeAnalyserNode.minDecibels)) {
        this._nativeAnalyserNode.maxDecibels = maxDecibels;
        throw createIndexSizeError();
      }
    }

    get minDecibels() {
      return this._nativeAnalyserNode.minDecibels;
    }

    set minDecibels(value) {
      // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.
      const minDecibels = this._nativeAnalyserNode.minDecibels;
      this._nativeAnalyserNode.minDecibels = value;

      if (!(this._nativeAnalyserNode.maxDecibels > value)) {
        this._nativeAnalyserNode.minDecibels = minDecibels;
        throw createIndexSizeError();
      }
    }

    get smoothingTimeConstant() {
      return this._nativeAnalyserNode.smoothingTimeConstant;
    }

    set smoothingTimeConstant(value) {
      this._nativeAnalyserNode.smoothingTimeConstant = value;
    }

    getByteFrequencyData(array) {
      this._nativeAnalyserNode.getByteFrequencyData(array);
    }

    getByteTimeDomainData(array) {
      this._nativeAnalyserNode.getByteTimeDomainData(array);
    }

    getFloatFrequencyData(array) {
      this._nativeAnalyserNode.getFloatFrequencyData(array);
    }

    getFloatTimeDomainData(array) {
      this._nativeAnalyserNode.getFloatTimeDomainData(array);
    }

  };
};

exports.createAnalyserNodeConstructor = createAnalyserNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isOwnedByContext = void 0;

const isOwnedByContext = (nativeAudioNode, nativeContext) => {
  return nativeAudioNode.context === nativeContext;
};

exports.isOwnedByContext = isOwnedByContext;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/analyser-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAnalyserNodeRendererFactory = void 0;

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createAnalyserNodeRendererFactory = (createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeAnalyserNodes = new WeakMap();

    const createAnalyserNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAnalyserNode = getNativeAudioNode(proxy); // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.

      const nativeAnalyserNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeAnalyserNode, nativeOfflineAudioContext);

      if (!nativeAnalyserNodeIsOwnedByContext) {
        const options = {
          channelCount: nativeAnalyserNode.channelCount,
          channelCountMode: nativeAnalyserNode.channelCountMode,
          channelInterpretation: nativeAnalyserNode.channelInterpretation,
          fftSize: nativeAnalyserNode.fftSize,
          maxDecibels: nativeAnalyserNode.maxDecibels,
          minDecibels: nativeAnalyserNode.minDecibels,
          smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant
        };
        nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);
      }

      renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);
      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode);
      return nativeAnalyserNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);

        if (renderedNativeAnalyserNode !== undefined) {
          return Promise.resolve(renderedNativeAnalyserNode);
        }

        return createAnalyserNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createAnalyserNodeRendererFactory = createAnalyserNodeRendererFactory;
},{"../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testAudioBufferCopyChannelMethodsOutOfBoundsSupport = void 0;

const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = nativeAudioBuffer => {
  try {
    nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);
  } catch {
    return false;
  }

  return true;
};

exports.testAudioBufferCopyChannelMethodsOutOfBoundsSupport = testAudioBufferCopyChannelMethodsOutOfBoundsSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIndexSizeError = void 0;

const createIndexSizeError = () => new DOMException('', 'IndexSizeError');

exports.createIndexSizeError = createIndexSizeError;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapAudioBufferGetChannelDataMethod = void 0;

var _indexSizeError = require("../factories/index-size-error");

const wrapAudioBufferGetChannelDataMethod = audioBuffer => {
  audioBuffer.getChannelData = (getChannelData => {
    return channel => {
      try {
        return getChannelData.call(audioBuffer, channel);
      } catch (err) {
        if (err.code === 12) {
          throw (0, _indexSizeError.createIndexSizeError)();
        }

        throw err;
      }
    };
  })(audioBuffer.getChannelData);
};

exports.wrapAudioBufferGetChannelDataMethod = wrapAudioBufferGetChannelDataMethod;
},{"../factories/index-size-error":"../node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioBufferConstructor = void 0;

var _testAudioBufferCopyChannelMethodsOutOfBoundsSupport = require("../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support");

var _wrapAudioBufferGetChannelDataMethod = require("../helpers/wrap-audio-buffer-get-channel-data-method");

const DEFAULT_OPTIONS = {
  numberOfChannels: 1
};

const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {
  let nativeOfflineAudioContext = null;
  return class AudioBuffer {
    constructor(options) {
      if (nativeOfflineAudioContextConstructor === null) {
        throw new Error('Missing the native OfflineAudioContext constructor.');
      }

      const {
        length,
        numberOfChannels,
        sampleRate
      } = { ...DEFAULT_OPTIONS,
        ...options
      };

      if (nativeOfflineAudioContext === null) {
        nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);
      }
      /*
       * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the
       * factory function. But since Firefox also supports the constructor everything should be fine.
       */


      const audioBuffer = nativeAudioBufferConstructor !== null && cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor({
        length,
        numberOfChannels,
        sampleRate
      }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate); // Bug #99: Safari does not throw an error when the numberOfChannels is zero.

      if (audioBuffer.numberOfChannels === 0) {
        throw createNotSupportedError();
      } // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
      // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.


      if (typeof audioBuffer.copyFromChannel !== 'function') {
        wrapAudioBufferCopyChannelMethods(audioBuffer);
        (0, _wrapAudioBufferGetChannelDataMethod.wrapAudioBufferGetChannelDataMethod)(audioBuffer); // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.
      } else if (!cacheTestResult(_testAudioBufferCopyChannelMethodsOutOfBoundsSupport.testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => (0, _testAudioBufferCopyChannelMethodsOutOfBoundsSupport.testAudioBufferCopyChannelMethodsOutOfBoundsSupport)(audioBuffer))) {
        wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);
      }

      audioBufferStore.add(audioBuffer);
      /*
       * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native
       * (Offline)AudioContexts.
       */

      return audioBuffer;
    }

    static [Symbol.hasInstance](instance) {
      return instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore.has(instance);
    }

  };
};

exports.createAudioBufferConstructor = createAudioBufferConstructor;
},{"../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js","../helpers/wrap-audio-buffer-get-channel-data-method":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js"}],"../node_modules/standardized-audio-context/build/es2019/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MOST_POSITIVE_SINGLE_FLOAT = exports.MOST_NEGATIVE_SINGLE_FLOAT = void 0;
const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;
exports.MOST_NEGATIVE_SINGLE_FLOAT = MOST_NEGATIVE_SINGLE_FLOAT;
const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;
exports.MOST_POSITIVE_SINGLE_FLOAT = MOST_POSITIVE_SINGLE_FLOAT;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isActiveAudioNode = void 0;

var _globals = require("../globals");

const isActiveAudioNode = audioNode => _globals.ACTIVE_AUDIO_NODE_STORE.has(audioNode);

exports.isActiveAudioNode = isActiveAudioNode;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioBufferSourceNodeConstructor = void 0;

var _constants = require("../constants");

var _isActiveAudioNode = require("../helpers/is-active-audio-node");

var _setInternalStateToActive = require("../helpers/set-internal-state-to-active");

var _setInternalStateToPassive = require("../helpers/set-internal-state-to-passive");

const DEFAULT_OPTIONS = {
  buffer: null,
  channelCount: 2,
  channelCountMode: 'max',
  channelInterpretation: 'speakers',
  // Bug #149: Safari does not yet support the detune AudioParam.
  loop: false,
  loopEnd: 0,
  loopStart: 0,
  playbackRate: 1
};

const createAudioBufferSourceNodeConstructor = (audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {
  return class AudioBufferSourceNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer() : null;
      super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);
      this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;
      this._isBufferNullified = false;
      this._isBufferSet = mergedOptions.buffer !== null;
      this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;
      this._onended = null; // Bug #73: Safari does not export the correct values for maxValue and minValue.

      this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, _constants.MOST_POSITIVE_SINGLE_FLOAT, _constants.MOST_NEGATIVE_SINGLE_FLOAT);
    }

    get buffer() {
      if (this._isBufferNullified) {
        return null;
      }

      return this._nativeAudioBufferSourceNode.buffer;
    }

    set buffer(value) {
      this._nativeAudioBufferSourceNode.buffer = value; // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.

      if (value !== null) {
        if (this._isBufferSet) {
          throw createInvalidStateError();
        }

        this._isBufferSet = true;
      }
    }

    get loop() {
      return this._nativeAudioBufferSourceNode.loop;
    }

    set loop(value) {
      this._nativeAudioBufferSourceNode.loop = value;
    }

    get loopEnd() {
      return this._nativeAudioBufferSourceNode.loopEnd;
    }

    set loopEnd(value) {
      this._nativeAudioBufferSourceNode.loopEnd = value;
    }

    get loopStart() {
      return this._nativeAudioBufferSourceNode.loopStart;
    }

    set loopStart(value) {
      this._nativeAudioBufferSourceNode.loopStart = value;
    }

    get onended() {
      return this._onended;
    }

    set onended(value) {
      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;
      this._nativeAudioBufferSourceNode.onended = wrappedListener;
      const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;
      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
    }

    get playbackRate() {
      return this._playbackRate;
    }

    start(when = 0, offset = 0, duration) {
      this._nativeAudioBufferSourceNode.start(when, offset, duration);

      if (this._audioBufferSourceNodeRenderer !== null) {
        this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];
      }

      if (this.context.state !== 'closed') {
        (0, _setInternalStateToActive.setInternalStateToActive)(this);

        const resetInternalStateToPassive = () => {
          this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);

          if ((0, _isActiveAudioNode.isActiveAudioNode)(this)) {
            (0, _setInternalStateToPassive.setInternalStateToPassive)(this);
          }
        };

        this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);
      }
    }

    stop(when = 0) {
      this._nativeAudioBufferSourceNode.stop(when);

      if (this._audioBufferSourceNodeRenderer !== null) {
        this._audioBufferSourceNodeRenderer.stop = when;
      }
    }

  };
};

exports.createAudioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor;
},{"../constants":"../node_modules/standardized-audio-context/build/es2019/constants.js","../helpers/is-active-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","../helpers/set-internal-state-to-active":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js","../helpers/set-internal-state-to-passive":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioBufferSourceNodeRendererFactory = void 0;

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createAudioBufferSourceNodeRendererFactory = (connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeAudioBufferSourceNodes = new WeakMap();
    let start = null;
    let stop = null;

    const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioBufferSourceNode = getNativeAudioNode(proxy);
      /*
       * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created
       * again.
       */

      const nativeAudioBufferSourceNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeAudioBufferSourceNode, nativeOfflineAudioContext);

      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
        const options = {
          buffer: nativeAudioBufferSourceNode.buffer,
          channelCount: nativeAudioBufferSourceNode.channelCount,
          channelCountMode: nativeAudioBufferSourceNode.channelCountMode,
          channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,
          // Bug #149: Safari does not yet support the detune AudioParam.
          loop: nativeAudioBufferSourceNode.loop,
          loopEnd: nativeAudioBufferSourceNode.loopEnd,
          loopStart: nativeAudioBufferSourceNode.loopStart,
          playbackRate: nativeAudioBufferSourceNode.playbackRate.value
        };
        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);

        if (start !== null) {
          nativeAudioBufferSourceNode.start(...start);
        }

        if (stop !== null) {
          nativeAudioBufferSourceNode.stop(stop);
        }
      }

      renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);

      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
        // Bug #149: Safari does not yet support the detune AudioParam.
        await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
      } else {
        // Bug #149: Safari does not yet support the detune AudioParam.
        await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
      }

      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);
      return nativeAudioBufferSourceNode;
    };

    return {
      set start(value) {
        start = value;
      },

      set stop(value) {
        stop = value;
      },

      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);

        if (renderedNativeAudioBufferSourceNode !== undefined) {
          return Promise.resolve(renderedNativeAudioBufferSourceNode);
        }

        return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createAudioBufferSourceNodeRendererFactory = createAudioBufferSourceNodeRendererFactory;
},{"../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/guards/audio-buffer-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAudioBufferSourceNode = void 0;

const isAudioBufferSourceNode = audioNode => {
  return 'playbackRate' in audioNode;
};

exports.isAudioBufferSourceNode = isAudioBufferSourceNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/guards/biquad-filter-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBiquadFilterNode = void 0;

const isBiquadFilterNode = audioNode => {
  return 'frequency' in audioNode && 'gain' in audioNode;
};

exports.isBiquadFilterNode = isBiquadFilterNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/guards/constant-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isConstantSourceNode = void 0;

const isConstantSourceNode = audioNode => {
  return 'offset' in audioNode;
};

exports.isConstantSourceNode = isConstantSourceNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/guards/gain-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isGainNode = void 0;

const isGainNode = audioNode => {
  return !('frequency' in audioNode) && 'gain' in audioNode;
};

exports.isGainNode = isGainNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/guards/oscillator-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isOscillatorNode = void 0;

const isOscillatorNode = audioNode => {
  return 'detune' in audioNode && 'frequency' in audioNode;
};

exports.isOscillatorNode = isOscillatorNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/guards/stereo-panner-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isStereoPannerNode = void 0;

const isStereoPannerNode = audioNode => {
  return 'pan' in audioNode;
};

exports.isStereoPannerNode = isStereoPannerNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAudioNodeConnections = void 0;

var _globals = require("../globals");

var _getValueForKey = require("./get-value-for-key");

const getAudioNodeConnections = audioNode => {
  return (0, _getValueForKey.getValueForKey)(_globals.AUDIO_NODE_CONNECTIONS_STORE, audioNode);
};

exports.getAudioNodeConnections = getAudioNodeConnections;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","./get-value-for-key":"../node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAudioParamConnections = void 0;

var _globals = require("../globals");

var _getValueForKey = require("./get-value-for-key");

const getAudioParamConnections = audioParam => {
  return (0, _getValueForKey.getValueForKey)(_globals.AUDIO_PARAM_CONNECTIONS_STORE, audioParam);
};

exports.getAudioParamConnections = getAudioParamConnections;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","./get-value-for-key":"../node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/deactivate-active-audio-node-input-connections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deactivateActiveAudioNodeInputConnections = void 0;

var _audioBufferSourceNode = require("../guards/audio-buffer-source-node");

var _audioWorkletNode = require("../guards/audio-worklet-node");

var _biquadFilterNode = require("../guards/biquad-filter-node");

var _constantSourceNode = require("../guards/constant-source-node");

var _gainNode = require("../guards/gain-node");

var _oscillatorNode = require("../guards/oscillator-node");

var _stereoPannerNode = require("../guards/stereo-panner-node");

var _getAudioNodeConnections = require("./get-audio-node-connections");

var _getAudioParamConnections = require("./get-audio-param-connections");

var _isActiveAudioNode = require("./is-active-audio-node");

var _setInternalStateToPassive = require("./set-internal-state-to-passive");

const deactivateActiveAudioNodeInputConnections = (audioNode, trace) => {
  const {
    activeInputs
  } = (0, _getAudioNodeConnections.getAudioNodeConnections)(audioNode);
  activeInputs.forEach(connections => connections.forEach(([source]) => {
    if (!trace.includes(audioNode)) {
      deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);
    }
  }));
  const audioParams = (0, _audioBufferSourceNode.isAudioBufferSourceNode)(audioNode) ? [// Bug #149: Safari does not yet support the detune AudioParam.
  audioNode.playbackRate] : (0, _audioWorkletNode.isAudioWorkletNode)(audioNode) ? Array.from(audioNode.parameters.values()) : (0, _biquadFilterNode.isBiquadFilterNode)(audioNode) ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain] : (0, _constantSourceNode.isConstantSourceNode)(audioNode) ? [audioNode.offset] : (0, _gainNode.isGainNode)(audioNode) ? [audioNode.gain] : (0, _oscillatorNode.isOscillatorNode)(audioNode) ? [audioNode.detune, audioNode.frequency] : (0, _stereoPannerNode.isStereoPannerNode)(audioNode) ? [audioNode.pan] : [];

  for (const audioParam of audioParams) {
    const audioParamConnections = (0, _getAudioParamConnections.getAudioParamConnections)(audioParam);

    if (audioParamConnections !== undefined) {
      audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));
    }
  }

  if ((0, _isActiveAudioNode.isActiveAudioNode)(audioNode)) {
    (0, _setInternalStateToPassive.setInternalStateToPassive)(audioNode);
  }
};

exports.deactivateActiveAudioNodeInputConnections = deactivateActiveAudioNodeInputConnections;
},{"../guards/audio-buffer-source-node":"../node_modules/standardized-audio-context/build/es2019/guards/audio-buffer-source-node.js","../guards/audio-worklet-node":"../node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js","../guards/biquad-filter-node":"../node_modules/standardized-audio-context/build/es2019/guards/biquad-filter-node.js","../guards/constant-source-node":"../node_modules/standardized-audio-context/build/es2019/guards/constant-source-node.js","../guards/gain-node":"../node_modules/standardized-audio-context/build/es2019/guards/gain-node.js","../guards/oscillator-node":"../node_modules/standardized-audio-context/build/es2019/guards/oscillator-node.js","../guards/stereo-panner-node":"../node_modules/standardized-audio-context/build/es2019/guards/stereo-panner-node.js","./get-audio-node-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js","./get-audio-param-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js","./is-active-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","./set-internal-state-to-passive":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/deactivate-audio-graph.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deactivateAudioGraph = void 0;

var _deactivateActiveAudioNodeInputConnections = require("./deactivate-active-audio-node-input-connections");

const deactivateAudioGraph = context => {
  (0, _deactivateActiveAudioNodeInputConnections.deactivateActiveAudioNodeInputConnections)(context.destination, []);
};

exports.deactivateAudioGraph = deactivateAudioGraph;
},{"./deactivate-active-audio-node-input-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/deactivate-active-audio-node-input-connections.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isValidLatencyHint = void 0;

const isValidLatencyHint = latencyHint => {
  return latencyHint === undefined || typeof latencyHint === 'number' || typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback');
};

exports.isValidLatencyHint = isValidLatencyHint;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioContextConstructor = void 0;

var _deactivateAudioGraph = require("../helpers/deactivate-audio-graph");

var _isValidLatencyHint = require("../helpers/is-valid-latency-hint");

const createAudioContextConstructor = (baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) => {
  return class AudioContext extends baseAudioContextConstructor {
    constructor(options = {}) {
      if (nativeAudioContextConstructor === null) {
        throw new Error('Missing the native AudioContext constructor.');
      }

      let nativeAudioContext;

      try {
        nativeAudioContext = new nativeAudioContextConstructor(options);
      } catch (err) {
        // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.
        if (err.code === 12 && err.message === 'sampleRate is not in range') {
          throw createNotSupportedError();
        }

        throw err;
      } // Bug #131 Safari returns null when there are four other AudioContexts running already.


      if (nativeAudioContext === null) {
        throw createUnknownError();
      } // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.


      if (!(0, _isValidLatencyHint.isValidLatencyHint)(options.latencyHint)) {
        throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
      } // Bug #150 Safari does not support setting the sampleRate.


      if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {
        throw createNotSupportedError();
      }

      super(nativeAudioContext, 2);
      const {
        latencyHint
      } = options;
      const {
        sampleRate
      } = nativeAudioContext; // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.

      this._baseLatency = typeof nativeAudioContext.baseLatency === 'number' ? nativeAudioContext.baseLatency : latencyHint === 'balanced' ? 512 / sampleRate : latencyHint === 'interactive' || latencyHint === undefined ? 256 / sampleRate : latencyHint === 'playback' ? 1024 / sampleRate :
      /*
       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a
       * ScriptProcessorNode.
       */
      Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;
      this._nativeAudioContext = nativeAudioContext; // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.

      if (nativeAudioContextConstructor.name === 'webkitAudioContext') {
        this._nativeGainNode = nativeAudioContext.createGain();
        this._nativeOscillatorNode = nativeAudioContext.createOscillator();
        this._nativeGainNode.gain.value = 1e-37;

        this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);

        this._nativeOscillatorNode.start();
      } else {
        this._nativeGainNode = null;
        this._nativeOscillatorNode = null;
      }

      this._state = null;
      /*
       * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes
       * to 'running'.
       */

      if (nativeAudioContext.state === 'running') {
        this._state = 'suspended';

        const revokeState = () => {
          if (this._state === 'suspended') {
            this._state = null;
          }

          nativeAudioContext.removeEventListener('statechange', revokeState);
        };

        nativeAudioContext.addEventListener('statechange', revokeState);
      }
    }

    get baseLatency() {
      return this._baseLatency;
    }

    get state() {
      return this._state !== null ? this._state : this._nativeAudioContext.state;
    }

    close() {
      // Bug #35: Firefox does not throw an error if the AudioContext was closed before.
      if (this.state === 'closed') {
        return this._nativeAudioContext.close().then(() => {
          throw createInvalidStateError();
        });
      } // Bug #34: If the state was set to suspended before it should be revoked now.


      if (this._state === 'suspended') {
        this._state = null;
      }

      return this._nativeAudioContext.close().then(() => {
        if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {
          this._nativeOscillatorNode.stop();

          this._nativeGainNode.disconnect();

          this._nativeOscillatorNode.disconnect();
        }

        (0, _deactivateAudioGraph.deactivateAudioGraph)(this);
      });
    }

    createMediaElementSource(mediaElement) {
      return new mediaElementAudioSourceNodeConstructor(this, {
        mediaElement
      });
    }

    createMediaStreamDestination() {
      return new mediaStreamAudioDestinationNodeConstructor(this);
    }

    createMediaStreamSource(mediaStream) {
      return new mediaStreamAudioSourceNodeConstructor(this, {
        mediaStream
      });
    }

    createMediaStreamTrackSource(mediaStreamTrack) {
      return new mediaStreamTrackAudioSourceNodeConstructor(this, {
        mediaStreamTrack
      });
    }

    resume() {
      if (this._state === 'suspended') {
        return new Promise((resolve, reject) => {
          const resolvePromise = () => {
            this._nativeAudioContext.removeEventListener('statechange', resolvePromise);

            if (this._nativeAudioContext.state === 'running') {
              resolve();
            } else {
              this.resume().then(resolve, reject);
            }
          };

          this._nativeAudioContext.addEventListener('statechange', resolvePromise);
        });
      }

      return this._nativeAudioContext.resume().catch(err => {
        // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.
        // Bug #56: Safari invokes the catch handler but without an error.
        if (err === undefined || err.code === 15) {
          throw createInvalidStateError();
        }

        throw err;
      });
    }

    suspend() {
      return this._nativeAudioContext.suspend().catch(err => {
        // Bug #56: Safari invokes the catch handler but without an error.
        if (err === undefined) {
          throw createInvalidStateError();
        }

        throw err;
      });
    }

  };
};

exports.createAudioContextConstructor = createAudioContextConstructor;
},{"../helpers/deactivate-audio-graph":"../node_modules/standardized-audio-context/build/es2019/helpers/deactivate-audio-graph.js","../helpers/is-valid-latency-hint":"../node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioDestinationNodeConstructor = void 0;

const createAudioDestinationNodeConstructor = (audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) => {
  return class AudioDestinationNode extends audioNodeConstructor {
    constructor(context, channelCount) {
      const nativeContext = getNativeContext(context);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);
      const audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null;
      super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);
      this._isNodeOfNativeOfflineAudioContext = isOffline;
      this._nativeAudioDestinationNode = nativeAudioDestinationNode;
    }

    get channelCount() {
      return this._nativeAudioDestinationNode.channelCount;
    }

    set channelCount(value) {
      // Bug #52: Chrome, Edge & Safari do not throw an exception at all.
      // Bug #54: Firefox does throw an IndexSizeError.
      if (this._isNodeOfNativeOfflineAudioContext) {
        throw createInvalidStateError();
      } // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.


      if (value > this._nativeAudioDestinationNode.maxChannelCount) {
        throw createIndexSizeError();
      }

      this._nativeAudioDestinationNode.channelCount = value;
    }

    get channelCountMode() {
      return this._nativeAudioDestinationNode.channelCountMode;
    }

    set channelCountMode(value) {
      // Bug #53: No browser does throw an exception yet.
      if (this._isNodeOfNativeOfflineAudioContext) {
        throw createInvalidStateError();
      }

      this._nativeAudioDestinationNode.channelCountMode = value;
    }

    get maxChannelCount() {
      return this._nativeAudioDestinationNode.maxChannelCount;
    }

  };
};

exports.createAudioDestinationNodeConstructor = createAudioDestinationNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioDestinationNodeRenderer = void 0;

const createAudioDestinationNodeRenderer = renderInputsOfAudioNode => {
  const renderedNativeAudioDestinationNodes = new WeakMap();

  const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext) => {
    const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;
    renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);
    await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);
    return nativeAudioDestinationNode;
  };

  return {
    render(proxy, nativeOfflineAudioContext) {
      const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);

      if (renderedNativeAudioDestinationNode !== undefined) {
        return Promise.resolve(renderedNativeAudioDestinationNode);
      }

      return createAudioDestinationNode(proxy, nativeOfflineAudioContext);
    }

  };
};

exports.createAudioDestinationNodeRenderer = createAudioDestinationNodeRenderer;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioListenerFactory = void 0;

var _constants = require("../constants");

const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors) => {
  return (context, nativeContext) => {
    const nativeListener = nativeContext.listener; // Bug #117: Only Chrome & Edge support the new interface already.

    const createFakeAudioParams = () => {
      const buffer = new Float32Array(1);
      const channelMergerNode = createNativeChannelMergerNode(nativeContext, {
        channelCount: 1,
        channelCountMode: 'explicit',
        channelInterpretation: 'speakers',
        numberOfInputs: 9
      });
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      let isScriptProcessorNodeCreated = false;
      let lastOrientation = [0, 0, -1, 0, 1, 0];
      let lastPosition = [0, 0, 0];

      const createScriptProcessorNode = () => {
        if (isScriptProcessorNodeCreated) {
          return;
        }

        isScriptProcessorNodeCreated = true;
        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0); // tslint:disable-next-line:deprecation

        scriptProcessorNode.onaudioprocess = ({
          inputBuffer
        }) => {
          const orientation = [getFirstSample(inputBuffer, buffer, 0), getFirstSample(inputBuffer, buffer, 1), getFirstSample(inputBuffer, buffer, 2), getFirstSample(inputBuffer, buffer, 3), getFirstSample(inputBuffer, buffer, 4), getFirstSample(inputBuffer, buffer, 5)];

          if (orientation.some((value, index) => value !== lastOrientation[index])) {
            nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation

            lastOrientation = orientation;
          }

          const positon = [getFirstSample(inputBuffer, buffer, 6), getFirstSample(inputBuffer, buffer, 7), getFirstSample(inputBuffer, buffer, 8)];

          if (positon.some((value, index) => value !== lastPosition[index])) {
            nativeListener.setPosition(...positon); // tslint:disable-line:deprecation

            lastPosition = positon;
          }
        };

        channelMergerNode.connect(scriptProcessorNode);
      };

      const createSetOrientation = index => value => {
        if (value !== lastOrientation[index]) {
          lastOrientation[index] = value;
          nativeListener.setOrientation(...lastOrientation); // tslint:disable-line:deprecation
        }
      };

      const createSetPosition = index => value => {
        if (value !== lastPosition[index]) {
          lastPosition[index] = value;
          nativeListener.setPosition(...lastPosition); // tslint:disable-line:deprecation
        }
      };

      const createFakeAudioParam = (input, initialValue, setValue) => {
        const constantSourceNode = createNativeConstantSourceNode(nativeContext, {
          channelCount: 1,
          channelCountMode: 'explicit',
          channelInterpretation: 'discrete',
          offset: initialValue
        });
        constantSourceNode.connect(channelMergerNode, 0, input); // @todo This should be stopped when the context is closed.

        constantSourceNode.start();
        Object.defineProperty(constantSourceNode.offset, 'defaultValue', {
          get() {
            return initialValue;
          }

        });
        /*
         * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and
         * minValue for GainNodes.
         */

        const audioParam = createAudioParam({
          context
        }, isOffline, constantSourceNode.offset, _constants.MOST_POSITIVE_SINGLE_FLOAT, _constants.MOST_NEGATIVE_SINGLE_FLOAT);
        overwriteAccessors(audioParam, 'value', get => () => get.call(audioParam), set => value => {
          try {
            set.call(audioParam, value);
          } catch (err) {
            if (err.code !== 9) {
              throw err;
            }
          }

          createScriptProcessorNode();

          if (isOffline) {
            // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.
            setValue(value);
          }
        });

        audioParam.cancelAndHoldAtTime = (cancelAndHoldAtTime => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError();
            };
          }

          return (...args) => {
            const value = cancelAndHoldAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.cancelAndHoldAtTime);

        audioParam.cancelScheduledValues = (cancelScheduledValues => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError();
            };
          }

          return (...args) => {
            const value = cancelScheduledValues.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.cancelScheduledValues);

        audioParam.exponentialRampToValueAtTime = (exponentialRampToValueAtTime => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError();
            };
          }

          return (...args) => {
            const value = exponentialRampToValueAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.exponentialRampToValueAtTime);

        audioParam.linearRampToValueAtTime = (linearRampToValueAtTime => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError();
            };
          }

          return (...args) => {
            const value = linearRampToValueAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.linearRampToValueAtTime);

        audioParam.setTargetAtTime = (setTargetAtTime => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError();
            };
          }

          return (...args) => {
            const value = setTargetAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.setTargetAtTime);

        audioParam.setValueAtTime = (setValueAtTime => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError();
            };
          }

          return (...args) => {
            const value = setValueAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.setValueAtTime);

        audioParam.setValueCurveAtTime = (setValueCurveAtTime => {
          if (isOffline) {
            return () => {
              throw createNotSupportedError();
            };
          }

          return (...args) => {
            const value = setValueCurveAtTime.apply(audioParam, args);
            createScriptProcessorNode();
            return value;
          };
        })(audioParam.setValueCurveAtTime);

        return audioParam;
      };

      return {
        forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),
        forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),
        forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),
        positionX: createFakeAudioParam(6, 0, createSetPosition(0)),
        positionY: createFakeAudioParam(7, 0, createSetPosition(1)),
        positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),
        upX: createFakeAudioParam(3, 0, createSetOrientation(3)),
        upY: createFakeAudioParam(4, 1, createSetOrientation(4)),
        upZ: createFakeAudioParam(5, 0, createSetOrientation(5))
      };
    };

    const {
      forwardX,
      forwardY,
      forwardZ,
      positionX,
      positionY,
      positionZ,
      upX,
      upY,
      upZ
    } = nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;
    return {
      get forwardX() {
        return forwardX;
      },

      get forwardY() {
        return forwardY;
      },

      get forwardZ() {
        return forwardZ;
      },

      get positionX() {
        return positionX;
      },

      get positionY() {
        return positionY;
      },

      get positionZ() {
        return positionZ;
      },

      get upX() {
        return upX;
      },

      get upY() {
        return upY;
      },

      get upZ() {
        return upZ;
      }

    };
  };
};

exports.createAudioListenerFactory = createAudioListenerFactory;
},{"../constants":"../node_modules/standardized-audio-context/build/es2019/constants.js"}],"../node_modules/standardized-audio-context/build/es2019/guards/audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAudioNode = void 0;

const isAudioNode = audioNodeOrAudioParam => {
  return 'context' in audioNodeOrAudioParam;
};

exports.isAudioNode = isAudioNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAudioNodeOutputConnection = void 0;

var _audioNode = require("./audio-node");

const isAudioNodeOutputConnection = outputConnection => {
  return (0, _audioNode.isAudioNode)(outputConnection[0]);
};

exports.isAudioNodeOutputConnection = isAudioNodeOutputConnection;
},{"./audio-node":"../node_modules/standardized-audio-context/build/es2019/guards/audio-node.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.insertElementInSet = void 0;

const insertElementInSet = (set, element, predicate, ignoreDuplicates) => {
  for (const lmnt of set) {
    if (predicate(lmnt)) {
      if (ignoreDuplicates) {
        return false;
      }

      throw Error('The set contains at least one similar element.');
    }
  }

  set.add(element);
  return true;
};

exports.insertElementInSet = insertElementInSet;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/add-active-input-connection-to-audio-param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addActiveInputConnectionToAudioParam = void 0;

var _insertElementInSet = require("./insert-element-in-set");

const addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {
  (0, _insertElementInSet.insertElementInSet)(activeInputs, [source, output, eventListener], activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);
};

exports.addActiveInputConnectionToAudioParam = addActiveInputConnectionToAudioParam;
},{"./insert-element-in-set":"../node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/add-passive-input-connection-to-audio-param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addPassiveInputConnectionToAudioParam = void 0;

var _insertElementInSet = require("./insert-element-in-set");

const addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {
  const passiveInputConnections = passiveInputs.get(source);

  if (passiveInputConnections === undefined) {
    passiveInputs.set(source, new Set([[output, eventListener]]));
  } else {
    (0, _insertElementInSet.insertElementInSet)(passiveInputConnections, [output, eventListener], passiveInputConnection => passiveInputConnection[0] === output, ignoreDuplicates);
  }
};

exports.addPassiveInputConnectionToAudioParam = addPassiveInputConnectionToAudioParam;
},{"./insert-element-in-set":"../node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js"}],"../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNativeAudioNodeFaker = void 0;

const isNativeAudioNodeFaker = nativeAudioNodeOrNativeAudioNodeFaker => {
  return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;
};

exports.isNativeAudioNodeFaker = isNativeAudioNodeFaker;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectNativeAudioNodeToNativeAudioNode = void 0;

var _nativeAudioNodeFaker = require("../guards/native-audio-node-faker");

const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {
  if ((0, _nativeAudioNodeFaker.isNativeAudioNodeFaker)(nativeDestinationAudioNode)) {
    const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];
    nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);
    return [fakeNativeDestinationAudioNode, output, 0];
  }

  nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);
  return [nativeDestinationAudioNode, output, input];
};

exports.connectNativeAudioNodeToNativeAudioNode = connectNativeAudioNodeToNativeAudioNode;
},{"../guards/native-audio-node-faker":"../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteActiveInputConnection = void 0;

const deleteActiveInputConnection = (activeInputConnections, source, output) => {
  for (const activeInputConnection of activeInputConnections) {
    if (activeInputConnection[0] === source && activeInputConnection[1] === output) {
      activeInputConnections.delete(activeInputConnection);
      return activeInputConnection;
    }
  }

  return null;
};

exports.deleteActiveInputConnection = deleteActiveInputConnection;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection-to-audio-param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteActiveInputConnectionToAudioParam = void 0;

var _pickElementFromSet = require("./pick-element-from-set");

const deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {
  return (0, _pickElementFromSet.pickElementFromSet)(activeInputs, activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output);
};

exports.deleteActiveInputConnectionToAudioParam = deleteActiveInputConnectionToAudioParam;
},{"./pick-element-from-set":"../node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteEventListenerOfAudioNode = void 0;

var _getEventListenersOfAudioNode = require("./get-event-listeners-of-audio-node");

const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {
  const eventListeners = (0, _getEventListenersOfAudioNode.getEventListenersOfAudioNode)(audioNode);

  if (!eventListeners.delete(eventListener)) {
    throw new Error('Missing the expected event listener.');
  }
};

exports.deleteEventListenerOfAudioNode = deleteEventListenerOfAudioNode;
},{"./get-event-listeners-of-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deletePassiveInputConnectionToAudioParam = void 0;

var _getValueForKey = require("./get-value-for-key");

var _pickElementFromSet = require("./pick-element-from-set");

const deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {
  const passiveInputConnections = (0, _getValueForKey.getValueForKey)(passiveInputs, source);
  const matchingConnection = (0, _pickElementFromSet.pickElementFromSet)(passiveInputConnections, passiveInputConnection => passiveInputConnection[0] === output);

  if (passiveInputConnections.size === 0) {
    passiveInputs.delete(source);
  }

  return matchingConnection;
};

exports.deletePassiveInputConnectionToAudioParam = deletePassiveInputConnectionToAudioParam;
},{"./get-value-for-key":"../node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js","./pick-element-from-set":"../node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.disconnectNativeAudioNodeFromNativeAudioNode = void 0;

var _nativeAudioNodeFaker = require("../guards/native-audio-node-faker");

const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {
  if ((0, _nativeAudioNodeFaker.isNativeAudioNodeFaker)(nativeDestinationAudioNode)) {
    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);
  } else {
    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);
  }
};

exports.disconnectNativeAudioNodeFromNativeAudioNode = disconnectNativeAudioNodeFromNativeAudioNode;
},{"../guards/native-audio-node-faker":"../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNativeAudioNode = void 0;

var _globals = require("../globals");

var _getValueForKey = require("./get-value-for-key");

const getNativeAudioNode = audioNode => {
  return (0, _getValueForKey.getValueForKey)(_globals.AUDIO_NODE_STORE, audioNode);
};

exports.getNativeAudioNode = getNativeAudioNode;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","./get-value-for-key":"../node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNativeAudioParam = void 0;

var _globals = require("../globals");

var _getValueForKey = require("./get-value-for-key");

const getNativeAudioParam = audioParam => {
  return (0, _getValueForKey.getValueForKey)(_globals.AUDIO_PARAM_STORE, audioParam);
};

exports.getNativeAudioParam = getNativeAudioParam;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","./get-value-for-key":"../node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPartOfACycle = void 0;

var _globals = require("../globals");

const isPartOfACycle = audioNode => {
  return _globals.CYCLE_COUNTERS.has(audioNode);
};

exports.isPartOfACycle = isPartOfACycle;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPassiveAudioNode = void 0;

var _globals = require("../globals");

const isPassiveAudioNode = audioNode => {
  return !_globals.ACTIVE_AUDIO_NODE_STORE.has(audioNode);
};

exports.isPassiveAudioNode = isPassiveAudioNode;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testAudioNodeDisconnectMethodSupport = void 0;

const testAudioNodeDisconnectMethodSupport = (nativeAudioContext, nativeAudioWorkletNodeConstructor) => {
  return new Promise(resolve => {
    /*
     * This bug existed in Safari up until v14.0.2. Since AudioWorklets were not supported in Safari until v14.1 the presence of the
     * constructor for an AudioWorkletNode can be used here to skip the test.
     */
    if (nativeAudioWorkletNodeConstructor !== null) {
      resolve(true);
    } else {
      const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1); // tslint:disable-line deprecation

      const dummy = nativeAudioContext.createGain(); // Bug #95: Safari does not play one sample buffers.

      const ones = nativeAudioContext.createBuffer(1, 2, 44100);
      const channelData = ones.getChannelData(0);
      channelData[0] = 1;
      channelData[1] = 1;
      const source = nativeAudioContext.createBufferSource();
      source.buffer = ones;
      source.loop = true;
      source.connect(analyzer).connect(nativeAudioContext.destination);
      source.connect(dummy);
      source.disconnect(dummy); // tslint:disable-next-line:deprecation

      analyzer.onaudioprocess = event => {
        const chnnlDt = event.inputBuffer.getChannelData(0); // tslint:disable-line deprecation

        if (Array.prototype.some.call(chnnlDt, sample => sample === 1)) {
          resolve(true);
        } else {
          resolve(false);
        }

        source.stop();
        analyzer.onaudioprocess = null; // tslint:disable-line:deprecation

        source.disconnect(analyzer);
        analyzer.disconnect(nativeAudioContext.destination);
      };

      source.start();
    }
  });
};

exports.testAudioNodeDisconnectMethodSupport = testAudioNodeDisconnectMethodSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visitEachAudioNodeOnce = void 0;

const visitEachAudioNodeOnce = (cycles, visitor) => {
  const counts = new Map();

  for (const cycle of cycles) {
    for (const audioNode of cycle) {
      const count = counts.get(audioNode);
      counts.set(audioNode, count === undefined ? 1 : count + 1);
    }
  }

  counts.forEach((count, audioNode) => visitor(audioNode, count));
};

exports.visitEachAudioNodeOnce = visitEachAudioNodeOnce;
},{}],"../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNativeAudioNode = void 0;

const isNativeAudioNode = nativeAudioNodeOrAudioParam => {
  return 'context' in nativeAudioNodeOrAudioParam;
};

exports.isNativeAudioNode = isNativeAudioNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapAudioNodeDisconnectMethod = void 0;

var _nativeAudioNode = require("../guards/native-audio-node");

const wrapAudioNodeDisconnectMethod = nativeAudioNode => {
  const connections = new Map();

  nativeAudioNode.connect = (connect => {
    // tslint:disable-next-line:invalid-void no-inferrable-types
    return (destination, output = 0, input = 0) => {
      const returnValue = (0, _nativeAudioNode.isNativeAudioNode)(destination) ? connect(destination, output, input) : connect(destination, output); // Save the new connection only if the calls to connect above didn't throw an error.

      const connectionsToDestination = connections.get(destination);

      if (connectionsToDestination === undefined) {
        connections.set(destination, [{
          input,
          output
        }]);
      } else {
        if (connectionsToDestination.every(connection => connection.input !== input || connection.output !== output)) {
          connectionsToDestination.push({
            input,
            output
          });
        }
      }

      return returnValue;
    };
  })(nativeAudioNode.connect.bind(nativeAudioNode));

  nativeAudioNode.disconnect = (disconnect => {
    return (destinationOrOutput, output, input) => {
      disconnect.apply(nativeAudioNode);

      if (destinationOrOutput === undefined) {
        connections.clear();
      } else if (typeof destinationOrOutput === 'number') {
        for (const [destination, connectionsToDestination] of connections) {
          const filteredConnections = connectionsToDestination.filter(connection => connection.output !== destinationOrOutput);

          if (filteredConnections.length === 0) {
            connections.delete(destination);
          } else {
            connections.set(destination, filteredConnections);
          }
        }
      } else if (connections.has(destinationOrOutput)) {
        if (output === undefined) {
          connections.delete(destinationOrOutput);
        } else {
          const connectionsToDestination = connections.get(destinationOrOutput);

          if (connectionsToDestination !== undefined) {
            const filteredConnections = connectionsToDestination.filter(connection => connection.output !== output && (connection.input !== input || input === undefined));

            if (filteredConnections.length === 0) {
              connections.delete(destinationOrOutput);
            } else {
              connections.set(destinationOrOutput, filteredConnections);
            }
          }
        }
      }

      for (const [destination, connectionsToDestination] of connections) {
        connectionsToDestination.forEach(connection => {
          if ((0, _nativeAudioNode.isNativeAudioNode)(destination)) {
            nativeAudioNode.connect(destination, connection.output, connection.input);
          } else {
            nativeAudioNode.connect(destination, connection.output);
          }
        });
      }
    };
  })(nativeAudioNode.disconnect);
};

exports.wrapAudioNodeDisconnectMethod = wrapAudioNodeDisconnectMethod;
},{"../guards/native-audio-node":"../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioNodeConstructor = void 0;

var _globals = require("../globals");

var _audioNode = require("../guards/audio-node");

var _audioNodeOutputConnection = require("../guards/audio-node-output-connection");

var _addActiveInputConnectionToAudioParam = require("../helpers/add-active-input-connection-to-audio-param");

var _addPassiveInputConnectionToAudioParam = require("../helpers/add-passive-input-connection-to-audio-param");

var _connectNativeAudioNodeToNativeAudioNode = require("../helpers/connect-native-audio-node-to-native-audio-node");

var _deleteActiveInputConnection = require("../helpers/delete-active-input-connection");

var _deleteActiveInputConnectionToAudioParam = require("../helpers/delete-active-input-connection-to-audio-param");

var _deleteEventListenersOfAudioNode = require("../helpers/delete-event-listeners-of-audio-node");

var _deletePassiveInputConnectionToAudioNode = require("../helpers/delete-passive-input-connection-to-audio-node");

var _deletePassiveInputConnectionToAudioParam = require("../helpers/delete-passive-input-connection-to-audio-param");

var _disconnectNativeAudioNodeFromNativeAudioNode = require("../helpers/disconnect-native-audio-node-from-native-audio-node");

var _getAudioNodeConnections = require("../helpers/get-audio-node-connections");

var _getAudioParamConnections = require("../helpers/get-audio-param-connections");

var _getEventListenersOfAudioNode = require("../helpers/get-event-listeners-of-audio-node");

var _getNativeAudioNode = require("../helpers/get-native-audio-node");

var _getNativeAudioParam = require("../helpers/get-native-audio-param");

var _insertElementInSet = require("../helpers/insert-element-in-set");

var _isActiveAudioNode = require("../helpers/is-active-audio-node");

var _isPartOfACycle = require("../helpers/is-part-of-a-cycle");

var _isPassiveAudioNode = require("../helpers/is-passive-audio-node");

var _setInternalStateToActive = require("../helpers/set-internal-state-to-active");

var _setInternalStateToPassiveWhenNecessary = require("../helpers/set-internal-state-to-passive-when-necessary");

var _testAudioNodeDisconnectMethodSupport = require("../helpers/test-audio-node-disconnect-method-support");

var _visitEachAudioNodeOnce = require("../helpers/visit-each-audio-node-once");

var _wrapAudioNodeDisconnectMethod = require("../helpers/wrap-audio-node-disconnect-method");

const addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {
  const {
    activeInputs,
    passiveInputs
  } = (0, _getAudioParamConnections.getAudioParamConnections)(destination);
  const {
    outputs
  } = (0, _getAudioNodeConnections.getAudioNodeConnections)(source);
  const eventListeners = (0, _getEventListenersOfAudioNode.getEventListenersOfAudioNode)(source);

  const eventListener = isActive => {
    const nativeAudioNode = (0, _getNativeAudioNode.getNativeAudioNode)(source);
    const nativeAudioParam = (0, _getNativeAudioParam.getNativeAudioParam)(destination);

    if (isActive) {
      const partialConnection = (0, _deletePassiveInputConnectionToAudioParam.deletePassiveInputConnectionToAudioParam)(passiveInputs, source, output);
      (0, _addActiveInputConnectionToAudioParam.addActiveInputConnectionToAudioParam)(activeInputs, source, partialConnection, false);

      if (!isOffline && !(0, _isPartOfACycle.isPartOfACycle)(source)) {
        nativeAudioNode.connect(nativeAudioParam, output);
      }
    } else {
      const partialConnection = (0, _deleteActiveInputConnectionToAudioParam.deleteActiveInputConnectionToAudioParam)(activeInputs, source, output);
      (0, _addPassiveInputConnectionToAudioParam.addPassiveInputConnectionToAudioParam)(passiveInputs, partialConnection, false);

      if (!isOffline && !(0, _isPartOfACycle.isPartOfACycle)(source)) {
        nativeAudioNode.disconnect(nativeAudioParam, output);
      }
    }
  };

  if ((0, _insertElementInSet.insertElementInSet)(outputs, [destination, output], outputConnection => outputConnection[0] === destination && outputConnection[1] === output, true)) {
    eventListeners.add(eventListener);

    if ((0, _isActiveAudioNode.isActiveAudioNode)(source)) {
      (0, _addActiveInputConnectionToAudioParam.addActiveInputConnectionToAudioParam)(activeInputs, source, [output, eventListener], true);
    } else {
      (0, _addPassiveInputConnectionToAudioParam.addPassiveInputConnectionToAudioParam)(passiveInputs, [source, output, eventListener], true);
    }

    return true;
  }

  return false;
};

const deleteInputConnectionOfAudioNode = (source, destination, output, input) => {
  const {
    activeInputs,
    passiveInputs
  } = (0, _getAudioNodeConnections.getAudioNodeConnections)(destination);
  const activeInputConnection = (0, _deleteActiveInputConnection.deleteActiveInputConnection)(activeInputs[input], source, output);

  if (activeInputConnection === null) {
    const passiveInputConnection = (0, _deletePassiveInputConnectionToAudioNode.deletePassiveInputConnectionToAudioNode)(passiveInputs, source, output, input);
    return [passiveInputConnection[2], false];
  }

  return [activeInputConnection[2], true];
};

const deleteInputConnectionOfAudioParam = (source, destination, output) => {
  const {
    activeInputs,
    passiveInputs
  } = (0, _getAudioParamConnections.getAudioParamConnections)(destination);
  const activeInputConnection = (0, _deleteActiveInputConnection.deleteActiveInputConnection)(activeInputs, source, output);

  if (activeInputConnection === null) {
    const passiveInputConnection = (0, _deletePassiveInputConnectionToAudioParam.deletePassiveInputConnectionToAudioParam)(passiveInputs, source, output);
    return [passiveInputConnection[1], false];
  }

  return [activeInputConnection[2], true];
};

const deleteInputsOfAudioNode = (source, isOffline, destination, output, input) => {
  const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);

  if (listener !== null) {
    (0, _deleteEventListenersOfAudioNode.deleteEventListenerOfAudioNode)(source, listener);

    if (isActive && !isOffline && !(0, _isPartOfACycle.isPartOfACycle)(source)) {
      (0, _disconnectNativeAudioNodeFromNativeAudioNode.disconnectNativeAudioNodeFromNativeAudioNode)((0, _getNativeAudioNode.getNativeAudioNode)(source), (0, _getNativeAudioNode.getNativeAudioNode)(destination), output, input);
    }
  }

  if ((0, _isActiveAudioNode.isActiveAudioNode)(destination)) {
    const {
      activeInputs
    } = (0, _getAudioNodeConnections.getAudioNodeConnections)(destination);
    (0, _setInternalStateToPassiveWhenNecessary.setInternalStateToPassiveWhenNecessary)(destination, activeInputs);
  }
};

const deleteInputsOfAudioParam = (source, isOffline, destination, output) => {
  const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);

  if (listener !== null) {
    (0, _deleteEventListenersOfAudioNode.deleteEventListenerOfAudioNode)(source, listener);

    if (isActive && !isOffline && !(0, _isPartOfACycle.isPartOfACycle)(source)) {
      (0, _getNativeAudioNode.getNativeAudioNode)(source).disconnect((0, _getNativeAudioParam.getNativeAudioParam)(destination), output);
    }
  }
};

const deleteAnyConnection = (source, isOffline) => {
  const audioNodeConnectionsOfSource = (0, _getAudioNodeConnections.getAudioNodeConnections)(source);
  const destinations = [];

  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
    if ((0, _audioNodeOutputConnection.isAudioNodeOutputConnection)(outputConnection)) {
      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
    } else {
      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
    }

    destinations.push(outputConnection[0]);
  }

  audioNodeConnectionsOfSource.outputs.clear();
  return destinations;
};

const deleteConnectionAtOutput = (source, isOffline, output) => {
  const audioNodeConnectionsOfSource = (0, _getAudioNodeConnections.getAudioNodeConnections)(source);
  const destinations = [];

  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
    if (outputConnection[1] === output) {
      if ((0, _audioNodeOutputConnection.isAudioNodeOutputConnection)(outputConnection)) {
        deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
      } else {
        deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
      }

      destinations.push(outputConnection[0]);
      audioNodeConnectionsOfSource.outputs.delete(outputConnection);
    }
  }

  return destinations;
};

const deleteConnectionToDestination = (source, isOffline, destination, output, input) => {
  const audioNodeConnectionsOfSource = (0, _getAudioNodeConnections.getAudioNodeConnections)(source);
  return Array.from(audioNodeConnectionsOfSource.outputs).filter(outputConnection => outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input)).map(outputConnection => {
    if ((0, _audioNodeOutputConnection.isAudioNodeOutputConnection)(outputConnection)) {
      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
    } else {
      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
    }

    audioNodeConnectionsOfSource.outputs.delete(outputConnection);
    return outputConnection[0];
  });
};

const createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor) => {
  return class AudioNode extends eventTargetConstructor {
    constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {
      super(nativeAudioNode);
      this._context = context;
      this._nativeAudioNode = nativeAudioNode;
      const nativeContext = getNativeContext(context); // Bug #12: Safari does not support to disconnect a specific destination.

      if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(_testAudioNodeDisconnectMethodSupport.testAudioNodeDisconnectMethodSupport, () => {
        return (0, _testAudioNodeDisconnectMethodSupport.testAudioNodeDisconnectMethodSupport)(nativeContext, nativeAudioWorkletNodeConstructor);
      })) {
        (0, _wrapAudioNodeDisconnectMethod.wrapAudioNodeDisconnectMethod)(nativeAudioNode);
      }

      _globals.AUDIO_NODE_STORE.set(this, nativeAudioNode);

      _globals.EVENT_LISTENERS.set(this, new Set());

      if (context.state !== 'closed' && isActive) {
        (0, _setInternalStateToActive.setInternalStateToActive)(this);
      }

      addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);
    }

    get channelCount() {
      return this._nativeAudioNode.channelCount;
    }

    set channelCount(value) {
      this._nativeAudioNode.channelCount = value;
    }

    get channelCountMode() {
      return this._nativeAudioNode.channelCountMode;
    }

    set channelCountMode(value) {
      this._nativeAudioNode.channelCountMode = value;
    }

    get channelInterpretation() {
      return this._nativeAudioNode.channelInterpretation;
    }

    set channelInterpretation(value) {
      this._nativeAudioNode.channelInterpretation = value;
    }

    get context() {
      return this._context;
    }

    get numberOfInputs() {
      return this._nativeAudioNode.numberOfInputs;
    }

    get numberOfOutputs() {
      return this._nativeAudioNode.numberOfOutputs;
    } // tslint:disable-next-line:invalid-void


    connect(destination, output = 0, input = 0) {
      // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.
      if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {
        throw createIndexSizeError();
      }

      const nativeContext = getNativeContext(this._context);
      const isOffline = isNativeOfflineAudioContext(nativeContext);

      if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {
        throw createInvalidAccessError();
      }

      if ((0, _audioNode.isAudioNode)(destination)) {
        const nativeDestinationAudioNode = (0, _getNativeAudioNode.getNativeAudioNode)(destination);

        try {
          const connection = (0, _connectNativeAudioNodeToNativeAudioNode.connectNativeAudioNodeToNativeAudioNode)(this._nativeAudioNode, nativeDestinationAudioNode, output, input);
          const isPassive = (0, _isPassiveAudioNode.isPassiveAudioNode)(this);

          if (isOffline || isPassive) {
            this._nativeAudioNode.disconnect(...connection);
          }

          if (this.context.state !== 'closed' && !isPassive && (0, _isPassiveAudioNode.isPassiveAudioNode)(destination)) {
            (0, _setInternalStateToActive.setInternalStateToActive)(destination);
          }
        } catch (err) {
          // Bug #41: Safari does not throw the correct exception so far.
          if (err.code === 12) {
            throw createInvalidAccessError();
          }

          throw err;
        }

        const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline); // Bug #164: Only Firefox detects cycles so far.

        if (isNewConnectionToAudioNode) {
          const cycles = detectCycles([this], destination);
          (0, _visitEachAudioNodeOnce.visitEachAudioNodeOnce)(cycles, createIncrementCycleCounter(isOffline));
        }

        return destination;
      }

      const nativeAudioParam = (0, _getNativeAudioParam.getNativeAudioParam)(destination);
      /*
       * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an
       * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify
       * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.
       */

      if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {
        throw createNotSupportedError();
      }

      try {
        this._nativeAudioNode.connect(nativeAudioParam, output);

        if (isOffline || (0, _isPassiveAudioNode.isPassiveAudioNode)(this)) {
          this._nativeAudioNode.disconnect(nativeAudioParam, output);
        }
      } catch (err) {
        // Bug #58: Safari doesn't throw an InvalidAccessError yet.
        if (err.code === 12) {
          throw createInvalidAccessError();
        }

        throw err;
      }

      const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline); // Bug #164: Only Firefox detects cycles so far.

      if (isNewConnectionToAudioParam) {
        const cycles = detectCycles([this], destination);
        (0, _visitEachAudioNodeOnce.visitEachAudioNodeOnce)(cycles, createIncrementCycleCounter(isOffline));
      }
    }

    disconnect(destinationOrOutput, output, input) {
      let destinations;
      const nativeContext = getNativeContext(this._context);
      const isOffline = isNativeOfflineAudioContext(nativeContext);

      if (destinationOrOutput === undefined) {
        destinations = deleteAnyConnection(this, isOffline);
      } else if (typeof destinationOrOutput === 'number') {
        if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {
          throw createIndexSizeError();
        }

        destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);
      } else {
        if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {
          throw createIndexSizeError();
        }

        if ((0, _audioNode.isAudioNode)(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {
          throw createIndexSizeError();
        }

        destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);

        if (destinations.length === 0) {
          throw createInvalidAccessError();
        }
      } // Bug #164: Only Firefox detects cycles so far.


      for (const destination of destinations) {
        const cycles = detectCycles([this], destination);
        (0, _visitEachAudioNodeOnce.visitEachAudioNodeOnce)(cycles, decrementCycleCounter);
      }
    }

  };
};

exports.createAudioNodeConstructor = createAudioNodeConstructor;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","../guards/audio-node":"../node_modules/standardized-audio-context/build/es2019/guards/audio-node.js","../guards/audio-node-output-connection":"../node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js","../helpers/add-active-input-connection-to-audio-param":"../node_modules/standardized-audio-context/build/es2019/helpers/add-active-input-connection-to-audio-param.js","../helpers/add-passive-input-connection-to-audio-param":"../node_modules/standardized-audio-context/build/es2019/helpers/add-passive-input-connection-to-audio-param.js","../helpers/connect-native-audio-node-to-native-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js","../helpers/delete-active-input-connection":"../node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection.js","../helpers/delete-active-input-connection-to-audio-param":"../node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection-to-audio-param.js","../helpers/delete-event-listeners-of-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js","../helpers/delete-passive-input-connection-to-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-node.js","../helpers/delete-passive-input-connection-to-audio-param":"../node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-param.js","../helpers/disconnect-native-audio-node-from-native-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js","../helpers/get-audio-node-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js","../helpers/get-audio-param-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js","../helpers/get-event-listeners-of-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js","../helpers/get-native-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js","../helpers/get-native-audio-param":"../node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js","../helpers/insert-element-in-set":"../node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js","../helpers/is-active-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","../helpers/is-part-of-a-cycle":"../node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js","../helpers/is-passive-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js","../helpers/set-internal-state-to-active":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js","../helpers/set-internal-state-to-passive-when-necessary":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js","../helpers/test-audio-node-disconnect-method-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js","../helpers/visit-each-audio-node-once":"../node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js","../helpers/wrap-audio-node-disconnect-method":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioParamFactory = void 0;

var _automationEvents = require("automation-events");

const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible) => {
  return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {
    const automationEventList = new _automationEvents.AutomationEventList(nativeAudioParam.defaultValue);
    const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;
    const audioParam = {
      get defaultValue() {
        return nativeAudioParam.defaultValue;
      },

      get maxValue() {
        return maxValue === null ? nativeAudioParam.maxValue : maxValue;
      },

      get minValue() {
        return minValue === null ? nativeAudioParam.minValue : minValue;
      },

      get value() {
        return nativeAudioParam.value;
      },

      set value(value) {
        nativeAudioParam.value = value; // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().

        audioParam.setValueAtTime(value, audioNode.context.currentTime);
      },

      cancelAndHoldAtTime(cancelTime) {
        // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().
        if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }

          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));
          nativeAudioParam.cancelAndHoldAtTime(cancelTime);
        } else {
          const previousLastEvent = Array.from(automationEventList).pop();

          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }

          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));
          const currentLastEvent = Array.from(automationEventList).pop();
          nativeAudioParam.cancelScheduledValues(cancelTime);

          if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {
            if (currentLastEvent.type === 'exponentialRampToValue') {
              nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
            } else if (currentLastEvent.type === 'linearRampToValue') {
              nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
            } else if (currentLastEvent.type === 'setValue') {
              nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);
            } else if (currentLastEvent.type === 'setValueCurve') {
              nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);
            }
          }
        }

        return audioParam;
      },

      cancelScheduledValues(cancelTime) {
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }

        automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));
        nativeAudioParam.cancelScheduledValues(cancelTime);
        return audioParam;
      },

      exponentialRampToValueAtTime(value, endTime) {
        // Bug #45: Safari does not throw an error yet.
        if (value === 0) {
          throw new RangeError();
        } // Bug #187: Safari does not throw an error yet.


        if (!Number.isFinite(endTime) || endTime < 0) {
          throw new RangeError();
        }

        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }

        automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));
        nativeAudioParam.exponentialRampToValueAtTime(value, endTime);
        return audioParam;
      },

      linearRampToValueAtTime(value, endTime) {
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }

        automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));
        nativeAudioParam.linearRampToValueAtTime(value, endTime);
        return audioParam;
      },

      setTargetAtTime(target, startTime, timeConstant) {
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }

        automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));
        nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);
        return audioParam;
      },

      setValueAtTime(value, startTime) {
        if (audioParamRenderer === null) {
          automationEventList.flush(audioNode.context.currentTime);
        }

        automationEventList.add(createSetValueAutomationEvent(value, startTime));
        nativeAudioParam.setValueAtTime(value, startTime);
        return audioParam;
      },

      setValueCurveAtTime(values, startTime, duration) {
        // Bug 183: Safari only accepts a Float32Array.
        const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);
        /*
         * Bug #152: Safari does not correctly interpolate the values of the curve.
         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the
         * existence of the webkitAudioContext is used as a workaround here.
         */

        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {
          const endTime = startTime + duration;
          const sampleRate = audioNode.context.sampleRate;
          const firstSample = Math.ceil(startTime * sampleRate);
          const lastSample = Math.floor(endTime * sampleRate);
          const numberOfInterpolatedValues = lastSample - firstSample;
          const interpolatedValues = new Float32Array(numberOfInterpolatedValues);

          for (let i = 0; i < numberOfInterpolatedValues; i += 1) {
            const theoreticIndex = (convertedValues.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);
            const lowerIndex = Math.floor(theoreticIndex);
            const upperIndex = Math.ceil(theoreticIndex);
            interpolatedValues[i] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];
          }

          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }

          automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));
          nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);
          const timeOfLastSample = lastSample / sampleRate;

          if (timeOfLastSample < endTime) {
            setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);
          }

          setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);
        } else {
          if (audioParamRenderer === null) {
            automationEventList.flush(audioNode.context.currentTime);
          }

          automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));
          nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);
        }

        return audioParam;
      }

    };
    audioParamStore.set(audioParam, nativeAudioParam);
    audioParamAudioNodeStore.set(audioParam, audioNode);
    addAudioParamConnections(audioParam, audioParamRenderer);
    return audioParam;
  };
};

exports.createAudioParamFactory = createAudioParamFactory;
},{"automation-events":"../node_modules/automation-events/build/es5/bundle.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioParamRenderer = void 0;

const createAudioParamRenderer = automationEventList => {
  return {
    replay(audioParam) {
      for (const automationEvent of automationEventList) {
        if (automationEvent.type === 'exponentialRampToValue') {
          const {
            endTime,
            value
          } = automationEvent;
          audioParam.exponentialRampToValueAtTime(value, endTime);
        } else if (automationEvent.type === 'linearRampToValue') {
          const {
            endTime,
            value
          } = automationEvent;
          audioParam.linearRampToValueAtTime(value, endTime);
        } else if (automationEvent.type === 'setTarget') {
          const {
            startTime,
            target,
            timeConstant
          } = automationEvent;
          audioParam.setTargetAtTime(target, startTime, timeConstant);
        } else if (automationEvent.type === 'setValue') {
          const {
            startTime,
            value
          } = automationEvent;
          audioParam.setValueAtTime(value, startTime);
        } else if (automationEvent.type === 'setValueCurve') {
          const {
            duration,
            startTime,
            values
          } = automationEvent;
          audioParam.setValueCurveAtTime(values, startTime, duration);
        } else {
          throw new Error("Can't apply an unknown automation.");
        }
      }
    }

  };
};

exports.createAudioParamRenderer = createAudioParamRenderer;
},{}],"../node_modules/standardized-audio-context/build/es2019/read-only-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReadOnlyMap = void 0;

class ReadOnlyMap {
  constructor(parameters) {
    this._map = new Map(parameters);
  }

  get size() {
    return this._map.size;
  }

  entries() {
    return this._map.entries();
  }

  forEach(callback, thisArg = null) {
    return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));
  }

  get(name) {
    return this._map.get(name);
  }

  has(name) {
    return this._map.has(name);
  }

  keys() {
    return this._map.keys();
  }

  values() {
    return this._map.values();
  }

}

exports.ReadOnlyMap = ReadOnlyMap;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioWorkletNodeConstructor = void 0;

var _globals = require("../globals");

var _readOnlyMap = require("../read-only-map");

const DEFAULT_OPTIONS = {
  channelCount: 2,
  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.
  channelCountMode: 'explicit',
  channelInterpretation: 'speakers',
  numberOfInputs: 1,
  numberOfOutputs: 1,
  parameterData: {},
  processorOptions: {}
};

const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) => {
  return class AudioWorkletNode extends audioNodeConstructor {
    constructor(context, name, options) {
      var _a;

      const nativeContext = getNativeContext(context);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS,
        ...options
      }); // Bug #191: Safari doesn't throw an error if the options aren't clonable.

      testAudioWorkletNodeOptionsClonability(mergedOptions);

      const nodeNameToProcessorConstructorMap = _globals.NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);

      const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name); // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.

      const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed' ? nativeContext : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;
      const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);
      const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;
      /*
       * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor
       * returns false.
       */

      super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);
      const parameters = [];
      nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {
        const audioParam = createAudioParam(this, isOffline, nativeAudioParam);
        parameters.push([nm, audioParam]);
      });
      this._nativeAudioWorkletNode = nativeAudioWorkletNode;
      this._onprocessorerror = null;
      this._parameters = new _readOnlyMap.ReadOnlyMap(parameters);
      /*
       * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to
       * the destination.
       */

      if (isOffline) {
        addUnrenderedAudioWorkletNode(nativeContext, this);
      }

      const {
        activeInputs
      } = getAudioNodeConnections(this);
      setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);
    }

    get onprocessorerror() {
      return this._onprocessorerror;
    }

    set onprocessorerror(value) {
      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;
      this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;
      const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;
      this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;
    }

    get parameters() {
      if (this._parameters === null) {
        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
        return this._nativeAudioWorkletNode.parameters;
      }

      return this._parameters;
    }

    get port() {
      return this._nativeAudioWorkletNode.port;
    }

  };
};

exports.createAudioWorkletNodeConstructor = createAudioWorkletNodeConstructor;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","../read-only-map":"../node_modules/standardized-audio-context/build/es2019/read-only-map.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyFromChannel = copyFromChannel;

function copyFromChannel(audioBuffer, // @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }
parent, key, channelNumber, bufferOffset) {
  if (typeof audioBuffer.copyFromChannel === 'function') {
    // The byteLength will be 0 when the ArrayBuffer was transferred.
    if (parent[key].byteLength === 0) {
      parent[key] = new Float32Array(128);
    }

    audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset); // Bug #5: Safari does not support copyFromChannel().
  } else {
    const channelData = audioBuffer.getChannelData(channelNumber); // The byteLength will be 0 when the ArrayBuffer was transferred.

    if (parent[key].byteLength === 0) {
      parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);
    } else {
      const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);
      parent[key].set(slicedInput);
    }
  }
}
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyToChannel = void 0;

const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {
  if (typeof audioBuffer.copyToChannel === 'function') {
    // The byteLength will be 0 when the ArrayBuffer was transferred.
    if (parent[key].byteLength !== 0) {
      audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);
    } // Bug #5: Safari does not support copyToChannel().

  } else {
    // The byteLength will be 0 when the ArrayBuffer was transferred.
    if (parent[key].byteLength !== 0) {
      audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);
    }
  }
};

exports.copyToChannel = copyToChannel;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNestedArrays = void 0;

const createNestedArrays = (x, y) => {
  const arrays = [];

  for (let i = 0; i < x; i += 1) {
    const array = [];
    const length = typeof y === 'number' ? y : y[i];

    for (let j = 0; j < length; j += 1) {
      array.push(new Float32Array(128));
    }

    arrays.push(array);
  }

  return arrays;
};

exports.createNestedArrays = createNestedArrays;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAudioWorkletProcessor = void 0;

var _globals = require("../globals");

var _getNativeAudioNode = require("./get-native-audio-node");

var _getValueForKey = require("./get-value-for-key");

const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {
  const nodeToProcessorMap = (0, _getValueForKey.getValueForKey)(_globals.NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);
  const nativeAudioWorkletNode = (0, _getNativeAudioNode.getNativeAudioNode)(proxy);
  return (0, _getValueForKey.getValueForKey)(nodeToProcessorMap, nativeAudioWorkletNode);
};

exports.getAudioWorkletProcessor = getAudioWorkletProcessor;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","./get-native-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js","./get-value-for-key":"../node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioWorkletNodeRendererFactory = void 0;

var _copyFromChannel = require("../helpers/copy-from-channel");

var _copyToChannel = require("../helpers/copy-to-channel");

var _createNestedArrays = require("../helpers/create-nested-arrays");

var _getAudioNodeConnections = require("../helpers/get-audio-node-connections");

var _getAudioWorkletProcessor = require("../helpers/get-audio-worklet-processor");

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {
  // Ceil the length to the next full render quantum.
  // Bug #17: Safari does not yet expose the length.
  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;
  const numberOfInputChannels = options.channelCount * options.numberOfInputs;
  const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);

  if (processorConstructor === undefined) {
    throw new Error('Missing the processor constructor.');
  }

  const audioNodeConnections = (0, _getAudioNodeConnections.getAudioNodeConnections)(proxy);
  const audioWorkletProcessor = await (0, _getAudioWorkletProcessor.getAudioWorkletProcessor)(nativeOfflineAudioContext, proxy);
  const inputs = (0, _createNestedArrays.createNestedArrays)(options.numberOfInputs, options.channelCount);
  const outputs = (0, _createNestedArrays.createNestedArrays)(options.numberOfOutputs, outputChannelCount);
  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs,
    [name]: new Float32Array(128)
  }), {});

  for (let i = 0; i < length; i += 128) {
    if (options.numberOfInputs > 0 && renderedBuffer !== null) {
      for (let j = 0; j < options.numberOfInputs; j += 1) {
        for (let k = 0; k < options.channelCount; k += 1) {
          (0, _copyFromChannel.copyFromChannel)(renderedBuffer, inputs[j], k, k, i);
        }
      }
    }

    if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {
      processorConstructor.parameterDescriptors.forEach(({
        name
      }, index) => {
        (0, _copyFromChannel.copyFromChannel)(renderedBuffer, parameters, name, numberOfInputChannels + index, i);
      });
    }

    for (let j = 0; j < options.numberOfInputs; j += 1) {
      for (let k = 0; k < outputChannelCount[j]; k += 1) {
        // The byteLength will be 0 when the ArrayBuffer was transferred.
        if (outputs[j][k].byteLength === 0) {
          outputs[j][k] = new Float32Array(128);
        }
      }
    }

    try {
      const potentiallyEmptyInputs = inputs.map((input, index) => {
        if (audioNodeConnections.activeInputs[index].size === 0) {
          return [];
        }

        return input;
      });
      const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));

      if (processedBuffer !== null) {
        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {
          for (let k = 0; k < outputChannelCount[j]; k += 1) {
            (0, _copyToChannel.copyToChannel)(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);
          }

          outputChannelSplitterNodeOutput += outputChannelCount[j];
        }
      }

      if (!activeSourceFlag) {
        break;
      }
    } catch (error) {
      proxy.dispatchEvent(new ErrorEvent('processorerror', {
        colno: error.colno,
        filename: error.filename,
        lineno: error.lineno,
        message: error.message
      }));
      break;
    }
  }

  return processedBuffer;
};

const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {
  return (name, options, processorConstructor) => {
    const renderedNativeAudioNodes = new WeakMap();
    let processedBufferPromise = null;

    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioWorkletNode = getNativeAudioNode(proxy);
      let nativeOutputNodes = null;
      const nativeAudioWorkletNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeAudioWorkletNode, nativeOfflineAudioContext);
      const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.

      if (nativeAudioWorkletNodeConstructor === null) {
        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {
          channelCount: Math.max(1, numberOfOutputChannels),
          channelCountMode: 'explicit',
          channelInterpretation: 'discrete',
          numberOfOutputs: Math.max(1, numberOfOutputChannels)
        });
        const outputChannelMergerNodes = [];

        for (let i = 0; i < proxy.numberOfOutputs; i += 1) {
          outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {
            channelCount: 1,
            channelCountMode: 'explicit',
            channelInterpretation: 'speakers',
            numberOfInputs: outputChannelCount[i]
          }));
        }

        const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {
          channelCount: options.channelCount,
          channelCountMode: options.channelCountMode,
          channelInterpretation: options.channelInterpretation,
          gain: 1
        });
        outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);
        outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);
        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];
      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {
        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);
      }

      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);

      if (nativeOutputNodes !== null) {
        if (processedBufferPromise === null) {
          if (processorConstructor === undefined) {
            throw new Error('Missing the processor constructor.');
          }

          if (nativeOfflineAudioContextConstructor === null) {
            throw new Error('Missing the native OfflineAudioContext constructor.');
          } // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.


          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;
          const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;
          const numberOfChannels = numberOfInputChannels + numberOfParameters;

          const renderBuffer = async () => {
            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.
            // Bug #17: Safari does not yet expose the length.
            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);
            const gainNodes = [];
            const inputChannelSplitterNodes = [];

            for (let i = 0; i < options.numberOfInputs; i += 1) {
              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {
                channelCount: options.channelCount,
                channelCountMode: options.channelCountMode,
                channelInterpretation: options.channelInterpretation,
                gain: 1
              }));
              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {
                channelCount: options.channelCount,
                channelCountMode: 'explicit',
                channelInterpretation: 'discrete',
                numberOfOutputs: options.channelCount
              }));
            }

            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async audioParam => {
              const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {
                channelCount: 1,
                channelCountMode: 'explicit',
                channelInterpretation: 'discrete',
                offset: audioParam.value
              });
              await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);
              return constantSourceNode;
            }));
            const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {
              channelCount: 1,
              channelCountMode: 'explicit',
              channelInterpretation: 'speakers',
              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
            });

            for (let i = 0; i < options.numberOfInputs; i += 1) {
              gainNodes[i].connect(inputChannelSplitterNodes[i]);

              for (let j = 0; j < options.channelCount; j += 1) {
                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);
              }
            }

            for (const [index, constantSourceNode] of constantSourceNodes.entries()) {
              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);
              constantSourceNode.start(0);
            }

            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);
            await Promise.all(gainNodes.map(gainNode => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode)));
            return renderNativeOfflineAudioContext(partialOfflineAudioContext);
          };

          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);
        }

        const processedBuffer = await processedBufferPromise;
        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {
          buffer: null,
          channelCount: 2,
          channelCountMode: 'max',
          channelInterpretation: 'speakers',
          loop: false,
          loopEnd: 0,
          loopStart: 0,
          playbackRate: 1
        });
        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;

        if (processedBuffer !== null) {
          audioBufferSourceNode.buffer = processedBuffer;
          audioBufferSourceNode.start(0);
        }

        audioBufferSourceNode.connect(outputChannelSplitterNode);

        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {
          const outputChannelMergerNode = outputChannelMergerNodes[i];

          for (let j = 0; j < outputChannelCount[i]; j += 1) {
            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);
          }

          outputChannelSplitterNodeOutput += outputChannelCount[i];
        }

        return outputGainNode;
      }

      if (!nativeAudioWorkletNodeIsOwnedByContext) {
        for (const [nm, audioParam] of proxy.parameters.entries()) {
          await renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
          nativeAudioWorkletNode.parameters.get(nm));
        }
      } else {
        for (const [nm, audioParam] of proxy.parameters.entries()) {
          await connectAudioParam(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
          nativeAudioWorkletNode.parameters.get(nm));
        }
      }

      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);
      return nativeAudioWorkletNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);
        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);

        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {
          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);
        }

        return createAudioNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createAudioWorkletNodeRendererFactory = createAudioWorkletNodeRendererFactory;
},{"../helpers/copy-from-channel":"../node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js","../helpers/copy-to-channel":"../node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js","../helpers/create-nested-arrays":"../node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js","../helpers/get-audio-node-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js","../helpers/get-audio-worklet-processor":"../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js","../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/base-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBaseAudioContextConstructor = void 0;

const createBaseAudioContextConstructor = (addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) => {
  return class BaseAudioContext extends minimalBaseAudioContextConstructor {
    constructor(_nativeContext, numberOfChannels) {
      super(_nativeContext, numberOfChannels);
      this._nativeContext = _nativeContext;
      this._audioWorklet = addAudioWorkletModule === undefined ? undefined : {
        addModule: (moduleURL, options) => {
          return addAudioWorkletModule(this, moduleURL, options);
        }
      };
    }

    get audioWorklet() {
      return this._audioWorklet;
    }

    createAnalyser() {
      return new analyserNodeConstructor(this);
    }

    createBiquadFilter() {
      return new biquadFilterNodeConstructor(this);
    }

    createBuffer(numberOfChannels, length, sampleRate) {
      return new audioBufferConstructor({
        length,
        numberOfChannels,
        sampleRate
      });
    }

    createBufferSource() {
      return new audioBufferSourceNodeConstructor(this);
    }

    createChannelMerger(numberOfInputs = 6) {
      return new channelMergerNodeConstructor(this, {
        numberOfInputs
      });
    }

    createChannelSplitter(numberOfOutputs = 6) {
      return new channelSplitterNodeConstructor(this, {
        numberOfOutputs
      });
    }

    createConstantSource() {
      return new constantSourceNodeConstructor(this);
    }

    createConvolver() {
      return new convolverNodeConstructor(this);
    }

    createDelay(maxDelayTime = 1) {
      return new delayNodeConstructor(this, {
        maxDelayTime
      });
    }

    createDynamicsCompressor() {
      return new dynamicsCompressorNodeConstructor(this);
    }

    createGain() {
      return new gainNodeConstructor(this);
    }

    createIIRFilter(feedforward, feedback) {
      return new iIRFilterNodeConstructor(this, {
        feedback,
        feedforward
      });
    }

    createOscillator() {
      return new oscillatorNodeConstructor(this);
    }

    createPanner() {
      return new pannerNodeConstructor(this);
    }

    createPeriodicWave(real, imag, constraints = {
      disableNormalization: false
    }) {
      return new periodicWaveConstructor(this, { ...constraints,
        imag,
        real
      });
    }

    createStereoPanner() {
      return new stereoPannerNodeConstructor(this);
    }

    createWaveShaper() {
      return new waveShaperNodeConstructor(this);
    }

    decodeAudioData(audioData, successCallback, errorCallback) {
      return decodeAudioData(this._nativeContext, audioData).then(audioBuffer => {
        if (typeof successCallback === 'function') {
          successCallback(audioBuffer);
        }

        return audioBuffer;
      }, err => {
        if (typeof errorCallback === 'function') {
          errorCallback(err);
        }

        throw err;
      });
    }

  };
};

exports.createBaseAudioContextConstructor = createBaseAudioContextConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBiquadFilterNodeConstructor = void 0;

var _constants = require("../constants");

const DEFAULT_OPTIONS = {
  Q: 1,
  channelCount: 2,
  channelCountMode: 'max',
  channelInterpretation: 'speakers',
  detune: 0,
  frequency: 350,
  gain: 0,
  type: 'lowpass'
};

const createBiquadFilterNodeConstructor = (audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {
  return class BiquadFilterNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const biquadFilterNodeRenderer = isOffline ? createBiquadFilterNodeRenderer() : null;
      super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer); // Bug #80: Safari does not export the correct values for maxValue and minValue.

      this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, _constants.MOST_POSITIVE_SINGLE_FLOAT, _constants.MOST_NEGATIVE_SINGLE_FLOAT); // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.

      this._detune = createAudioParam(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(_constants.MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(_constants.MOST_POSITIVE_SINGLE_FLOAT)); // Bug #77: Firefox & Safari do not export the correct value for minValue.

      this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0); // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.

      this._gain = createAudioParam(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(_constants.MOST_POSITIVE_SINGLE_FLOAT), _constants.MOST_NEGATIVE_SINGLE_FLOAT);
      this._nativeBiquadFilterNode = nativeBiquadFilterNode; // @todo Determine a meaningful tail-time instead of just using one second.

      setAudioNodeTailTime(this, 1);
    }

    get detune() {
      return this._detune;
    }

    get frequency() {
      return this._frequency;
    }

    get gain() {
      return this._gain;
    }

    get Q() {
      return this._Q;
    }

    get type() {
      return this._nativeBiquadFilterNode.type;
    }

    set type(value) {
      this._nativeBiquadFilterNode.type = value;
    }

    getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
      // Bug #189: Safari does throw an InvalidStateError.
      try {
        this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
      } catch (err) {
        if (err.code === 11) {
          throw createInvalidAccessError();
        }

        throw err;
      } // Bug #68: Safari does not throw an error if the parameters differ in their length.


      if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
        throw createInvalidAccessError();
      }
    }

  };
};

exports.createBiquadFilterNodeConstructor = createBiquadFilterNodeConstructor;
},{"../constants":"../node_modules/standardized-audio-context/build/es2019/constants.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBiquadFilterNodeRendererFactory = void 0;

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createBiquadFilterNodeRendererFactory = (connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeBiquadFilterNodes = new WeakMap();

    const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeBiquadFilterNode = getNativeAudioNode(proxy);
      /*
       * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created
       * again.
       */

      const nativeBiquadFilterNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeBiquadFilterNode, nativeOfflineAudioContext);

      if (!nativeBiquadFilterNodeIsOwnedByContext) {
        const options = {
          Q: nativeBiquadFilterNode.Q.value,
          channelCount: nativeBiquadFilterNode.channelCount,
          channelCountMode: nativeBiquadFilterNode.channelCountMode,
          channelInterpretation: nativeBiquadFilterNode.channelInterpretation,
          detune: nativeBiquadFilterNode.detune.value,
          frequency: nativeBiquadFilterNode.frequency.value,
          gain: nativeBiquadFilterNode.gain.value,
          type: nativeBiquadFilterNode.type
        };
        nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);
      }

      renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);

      if (!nativeBiquadFilterNodeIsOwnedByContext) {
        await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
        await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
        await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
        await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
      } else {
        await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
        await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
        await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
        await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
      }

      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);
      return nativeBiquadFilterNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);

        if (renderedNativeBiquadFilterNode !== undefined) {
          return Promise.resolve(renderedNativeBiquadFilterNode);
        }

        return createBiquadFilterNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createBiquadFilterNodeRendererFactory = createBiquadFilterNodeRendererFactory;
},{"../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCacheTestResult = void 0;

const createCacheTestResult = (ongoingTests, testResults) => {
  return (tester, test) => {
    const cachedTestResult = testResults.get(tester);

    if (cachedTestResult !== undefined) {
      return cachedTestResult;
    }

    const ongoingTest = ongoingTests.get(tester);

    if (ongoingTest !== undefined) {
      return ongoingTest;
    }

    try {
      const synchronousTestResult = test();

      if (synchronousTestResult instanceof Promise) {
        ongoingTests.set(tester, synchronousTestResult);
        return synchronousTestResult.catch(() => false).then(finalTestResult => {
          ongoingTests.delete(tester);
          testResults.set(tester, finalTestResult);
          return finalTestResult;
        });
      }

      testResults.set(tester, synchronousTestResult);
      return synchronousTestResult;
    } catch {
      testResults.set(tester, false);
      return false;
    }
  };
};

exports.createCacheTestResult = createCacheTestResult;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createChannelMergerNodeConstructor = void 0;
const DEFAULT_OPTIONS = {
  channelCount: 1,
  channelCountMode: 'explicit',
  channelInterpretation: 'speakers',
  numberOfInputs: 6
};

const createChannelMergerNodeConstructor = (audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext) => {
  return class ChannelMergerNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);
      const channelMergerNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null;
      super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);
    }

  };
};

exports.createChannelMergerNodeConstructor = createChannelMergerNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createChannelMergerNodeRendererFactory = void 0;

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeAudioNodes = new WeakMap();

    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioNode = getNativeAudioNode(proxy); // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.

      const nativeAudioNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeAudioNode, nativeOfflineAudioContext);

      if (!nativeAudioNodeIsOwnedByContext) {
        const options = {
          channelCount: nativeAudioNode.channelCount,
          channelCountMode: nativeAudioNode.channelCountMode,
          channelInterpretation: nativeAudioNode.channelInterpretation,
          numberOfInputs: nativeAudioNode.numberOfInputs
        };
        nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);
      }

      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);
      return nativeAudioNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);

        if (renderedNativeAudioNode !== undefined) {
          return Promise.resolve(renderedNativeAudioNode);
        }

        return createAudioNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createChannelMergerNodeRendererFactory = createChannelMergerNodeRendererFactory;
},{"../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createChannelSplitterNodeConstructor = void 0;
const DEFAULT_OPTIONS = {
  channelCount: 6,
  channelCountMode: 'explicit',
  channelInterpretation: 'discrete',
  numberOfOutputs: 6
};

const createChannelSplitterNodeConstructor = (audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions) => {
  return class ChannelSplitterNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = sanitizeChannelSplitterOptions({ ...DEFAULT_OPTIONS,
        ...options
      });
      const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);
      const channelSplitterNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null;
      super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);
    }

  };
};

exports.createChannelSplitterNodeConstructor = createChannelSplitterNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createChannelSplitterNodeRendererFactory = void 0;

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeAudioNodes = new WeakMap();

    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioNode = getNativeAudioNode(proxy); // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.

      const nativeAudioNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeAudioNode, nativeOfflineAudioContext);

      if (!nativeAudioNodeIsOwnedByContext) {
        const options = {
          channelCount: nativeAudioNode.channelCount,
          channelCountMode: nativeAudioNode.channelCountMode,
          channelInterpretation: nativeAudioNode.channelInterpretation,
          numberOfOutputs: nativeAudioNode.numberOfOutputs
        };
        nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);
      }

      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);
      return nativeAudioNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);

        if (renderedNativeAudioNode !== undefined) {
          return Promise.resolve(renderedNativeAudioNode);
        }

        return createAudioNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createChannelSplitterNodeRendererFactory = createChannelSplitterNodeRendererFactory;
},{"../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConnectAudioParam = void 0;

const createConnectAudioParam = renderInputsOfAudioParam => {
  return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
    return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);
  };
};

exports.createConnectAudioParam = createConnectAudioParam;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConnectMultipleOutputs = void 0;

var _nativeAudioNode = require("../guards/native-audio-node");

const createConnectMultipleOutputs = createIndexSizeError => {
  return (outputAudioNodes, destination, output = 0, input = 0) => {
    const outputAudioNode = outputAudioNodes[output];

    if (outputAudioNode === undefined) {
      throw createIndexSizeError();
    }

    if ((0, _nativeAudioNode.isNativeAudioNode)(destination)) {
      return outputAudioNode.connect(destination, 0, input);
    }

    return outputAudioNode.connect(destination, 0);
  };
};

exports.createConnectMultipleOutputs = createConnectMultipleOutputs;
},{"../guards/native-audio-node":"../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConnectedNativeAudioBufferSourceNodeFactory = void 0;

const createConnectedNativeAudioBufferSourceNodeFactory = createNativeAudioBufferSourceNode => {
  return (nativeContext, nativeAudioNode) => {
    const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {
      buffer: null,
      channelCount: 2,
      channelCountMode: 'max',
      channelInterpretation: 'speakers',
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      playbackRate: 1
    });
    const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);
    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
    nativeAudioBufferSourceNode.loop = true;
    nativeAudioBufferSourceNode.connect(nativeAudioNode);
    nativeAudioBufferSourceNode.start();
    return () => {
      nativeAudioBufferSourceNode.stop();
      nativeAudioBufferSourceNode.disconnect(nativeAudioNode);
    };
  };
};

exports.createConnectedNativeAudioBufferSourceNodeFactory = createConnectedNativeAudioBufferSourceNodeFactory;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConstantSourceNodeConstructor = void 0;

var _constants = require("../constants");

var _isActiveAudioNode = require("../helpers/is-active-audio-node");

var _setInternalStateToActive = require("../helpers/set-internal-state-to-active");

var _setInternalStateToPassive = require("../helpers/set-internal-state-to-passive");

const DEFAULT_OPTIONS = {
  channelCount: 2,
  channelCountMode: 'max',
  channelInterpretation: 'speakers',
  offset: 1
};

const createConstantSourceNodeConstructor = (audioNodeConstructor, createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {
  return class ConstantSourceNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const constantSourceNodeRenderer = isOffline ? createConstantSourceNodeRendererFactory() : null;
      super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);
      this._constantSourceNodeRenderer = constantSourceNodeRenderer;
      this._nativeConstantSourceNode = nativeConstantSourceNode;
      /*
       * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and minValue
       * for GainNodes.
       */

      this._offset = createAudioParam(this, isOffline, nativeConstantSourceNode.offset, _constants.MOST_POSITIVE_SINGLE_FLOAT, _constants.MOST_NEGATIVE_SINGLE_FLOAT);
      this._onended = null;
    }

    get offset() {
      return this._offset;
    }

    get onended() {
      return this._onended;
    }

    set onended(value) {
      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;
      this._nativeConstantSourceNode.onended = wrappedListener;
      const nativeOnEnded = this._nativeConstantSourceNode.onended;
      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
    }

    start(when = 0) {
      this._nativeConstantSourceNode.start(when);

      if (this._constantSourceNodeRenderer !== null) {
        this._constantSourceNodeRenderer.start = when;
      }

      if (this.context.state !== 'closed') {
        (0, _setInternalStateToActive.setInternalStateToActive)(this);

        const resetInternalStateToPassive = () => {
          this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive);

          if ((0, _isActiveAudioNode.isActiveAudioNode)(this)) {
            (0, _setInternalStateToPassive.setInternalStateToPassive)(this);
          }
        };

        this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);
      }
    }

    stop(when = 0) {
      this._nativeConstantSourceNode.stop(when);

      if (this._constantSourceNodeRenderer !== null) {
        this._constantSourceNodeRenderer.stop = when;
      }
    }

  };
};

exports.createConstantSourceNodeConstructor = createConstantSourceNodeConstructor;
},{"../constants":"../node_modules/standardized-audio-context/build/es2019/constants.js","../helpers/is-active-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","../helpers/set-internal-state-to-active":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js","../helpers/set-internal-state-to-passive":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConstantSourceNodeRendererFactory = void 0;

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createConstantSourceNodeRendererFactory = (connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeConstantSourceNodes = new WeakMap();
    let start = null;
    let stop = null;

    const createConstantSourceNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeConstantSourceNode = getNativeAudioNode(proxy);
      /*
       * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created
       * again.
       */

      const nativeConstantSourceNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeConstantSourceNode, nativeOfflineAudioContext);

      if (!nativeConstantSourceNodeIsOwnedByContext) {
        const options = {
          channelCount: nativeConstantSourceNode.channelCount,
          channelCountMode: nativeConstantSourceNode.channelCountMode,
          channelInterpretation: nativeConstantSourceNode.channelInterpretation,
          offset: nativeConstantSourceNode.offset.value
        };
        nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);

        if (start !== null) {
          nativeConstantSourceNode.start(start);
        }

        if (stop !== null) {
          nativeConstantSourceNode.stop(stop);
        }
      }

      renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);

      if (!nativeConstantSourceNodeIsOwnedByContext) {
        await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
      } else {
        await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
      }

      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);
      return nativeConstantSourceNode;
    };

    return {
      set start(value) {
        start = value;
      },

      set stop(value) {
        stop = value;
      },

      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);

        if (renderedNativeConstantSourceNode !== undefined) {
          return Promise.resolve(renderedNativeConstantSourceNode);
        }

        return createConstantSourceNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createConstantSourceNodeRendererFactory = createConstantSourceNodeRendererFactory;
},{"../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConvertNumberToUnsignedLong = void 0;

const createConvertNumberToUnsignedLong = unit32Array => {
  return value => {
    unit32Array[0] = value;
    return unit32Array[0];
  };
};

exports.createConvertNumberToUnsignedLong = createConvertNumberToUnsignedLong;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/convolver-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConvolverNodeConstructor = void 0;
const DEFAULT_OPTIONS = {
  buffer: null,
  channelCount: 2,
  channelCountMode: 'clamped-max',
  channelInterpretation: 'speakers',
  disableNormalization: false
};

const createConvolverNodeConstructor = (audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {
  return class ConvolverNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const convolverNodeRenderer = isOffline ? createConvolverNodeRenderer() : null;
      super(context, false, nativeConvolverNode, convolverNodeRenderer);
      this._isBufferNullified = false;
      this._nativeConvolverNode = nativeConvolverNode;

      if (mergedOptions.buffer !== null) {
        setAudioNodeTailTime(this, mergedOptions.buffer.duration);
      }
    }

    get buffer() {
      if (this._isBufferNullified) {
        return null;
      }

      return this._nativeConvolverNode.buffer;
    }

    set buffer(value) {
      this._nativeConvolverNode.buffer = value; // Bug #115: Safari does not allow to set the buffer to null.

      if (value === null && this._nativeConvolverNode.buffer !== null) {
        const nativeContext = this._nativeConvolverNode.context;
        this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, 44100);
        this._isBufferNullified = true;
        setAudioNodeTailTime(this, 0);
      } else {
        this._isBufferNullified = false;
        setAudioNodeTailTime(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);
      }
    }

    get normalize() {
      return this._nativeConvolverNode.normalize;
    }

    set normalize(value) {
      this._nativeConvolverNode.normalize = value;
    }

  };
};

exports.createConvolverNodeConstructor = createConvolverNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/convolver-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createConvolverNodeRendererFactory = void 0;

var _nativeAudioNodeFaker = require("../guards/native-audio-node-faker");

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createConvolverNodeRendererFactory = (createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeConvolverNodes = new WeakMap();

    const createConvolverNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeConvolverNode = getNativeAudioNode(proxy); // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.

      const nativeConvolverNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeConvolverNode, nativeOfflineAudioContext);

      if (!nativeConvolverNodeIsOwnedByContext) {
        const options = {
          buffer: nativeConvolverNode.buffer,
          channelCount: nativeConvolverNode.channelCount,
          channelCountMode: nativeConvolverNode.channelCountMode,
          channelInterpretation: nativeConvolverNode.channelInterpretation,
          disableNormalization: !nativeConvolverNode.normalize
        };
        nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);
      }

      renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);

      if ((0, _nativeAudioNodeFaker.isNativeAudioNodeFaker)(nativeConvolverNode)) {
        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);
      }

      return nativeConvolverNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);

        if (renderedNativeConvolverNode !== undefined) {
          return Promise.resolve(renderedNativeConvolverNode);
        }

        return createConvolverNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createConvolverNodeRendererFactory = createConvolverNodeRendererFactory;
},{"../guards/native-audio-node-faker":"../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js","../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/create-native-offline-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCreateNativeOfflineAudioContext = void 0;

const createCreateNativeOfflineAudioContext = (createNotSupportedError, nativeOfflineAudioContextConstructor) => {
  return (numberOfChannels, length, sampleRate) => {
    if (nativeOfflineAudioContextConstructor === null) {
      throw new Error('Missing the native OfflineAudioContext constructor.');
    }

    try {
      return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);
    } catch (err) {
      // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.
      if (err.name === 'SyntaxError') {
        throw createNotSupportedError();
      }

      throw err;
    }
  };
};

exports.createCreateNativeOfflineAudioContext = createCreateNativeOfflineAudioContext;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/data-clone-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDataCloneError = void 0;

const createDataCloneError = () => new DOMException('', 'DataCloneError');

exports.createDataCloneError = createDataCloneError;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/detach-array-buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.detachArrayBuffer = void 0;

const detachArrayBuffer = arrayBuffer => {
  const {
    port1,
    port2
  } = new MessageChannel();
  return new Promise(resolve => {
    const closeAndResolve = () => {
      port2.onmessage = null;
      port1.close();
      port2.close();
      resolve();
    };

    port2.onmessage = () => closeAndResolve();

    try {
      port1.postMessage(arrayBuffer, [arrayBuffer]);
    } finally {
      closeAndResolve();
    }
  });
};

exports.detachArrayBuffer = detachArrayBuffer;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDecodeAudioData = void 0;

var _detachArrayBuffer = require("../helpers/detach-array-buffer");

var _wrapAudioBufferGetChannelDataMethod = require("../helpers/wrap-audio-buffer-get-channel-data-method");

const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {
  return (anyContext, audioData) => {
    const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext); // Bug #43: Only Chrome and Edge do throw a DataCloneError.

    if (detachedArrayBuffers.has(audioData)) {
      const err = createDataCloneError();
      return Promise.reject(err);
    } // The audioData parameter maybe of a type which can't be added to a WeakSet.


    try {
      detachedArrayBuffers.add(audioData);
    } catch {// Ignore errors.
    } // Bug #21: Safari does not support promises yet.


    if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {
      return nativeContext.decodeAudioData(audioData).then(audioBuffer => {
        // Bug #133: Safari does neuter the ArrayBuffer.
        (0, _detachArrayBuffer.detachArrayBuffer)(audioData).catch(() => {// Ignore errors.
        }); // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.

        if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {
          wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);
        }

        audioBufferStore.add(audioBuffer);
        return audioBuffer;
      });
    } // Bug #21: Safari does not return a Promise yet.


    return new Promise((resolve, reject) => {
      const complete = async () => {
        // Bug #133: Safari does neuter the ArrayBuffer.
        try {
          await (0, _detachArrayBuffer.detachArrayBuffer)(audioData);
        } catch {// Ignore errors.
        }
      };

      const fail = err => {
        reject(err);
        complete();
      }; // Bug #26: Safari throws a synchronous error.


      try {
        // Bug #1: Safari requires a successCallback.
        nativeContext.decodeAudioData(audioData, audioBuffer => {
          // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
          // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.
          if (typeof audioBuffer.copyFromChannel !== 'function') {
            wrapAudioBufferCopyChannelMethods(audioBuffer);
            (0, _wrapAudioBufferGetChannelDataMethod.wrapAudioBufferGetChannelDataMethod)(audioBuffer);
          }

          audioBufferStore.add(audioBuffer);
          complete().then(() => resolve(audioBuffer));
        }, err => {
          // Bug #4: Safari returns null instead of an error.
          if (err === null) {
            fail(createEncodingError());
          } else {
            fail(err);
          }
        });
      } catch (err) {
        fail(err);
      }
    });
  };
};

exports.createDecodeAudioData = createDecodeAudioData;
},{"../helpers/detach-array-buffer":"../node_modules/standardized-audio-context/build/es2019/helpers/detach-array-buffer.js","../helpers/wrap-audio-buffer-get-channel-data-method":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDecrementCycleCounter = void 0;

var _audioNodeOutputConnection = require("../guards/audio-node-output-connection");

const createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) => {
  return (audioNode, count) => {
    const cycleCounter = cycleCounters.get(audioNode);

    if (cycleCounter === undefined) {
      throw new Error('Missing the expected cycle count.');
    }

    const nativeContext = getNativeContext(audioNode.context);
    const isOffline = isNativeOfflineAudioContext(nativeContext);

    if (cycleCounter === count) {
      cycleCounters.delete(audioNode);

      if (!isOffline && isActiveAudioNode(audioNode)) {
        const nativeSourceAudioNode = getNativeAudioNode(audioNode);
        const {
          outputs
        } = getAudioNodeConnections(audioNode);

        for (const output of outputs) {
          if ((0, _audioNodeOutputConnection.isAudioNodeOutputConnection)(output)) {
            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);
            connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
          } else {
            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);
            nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);
          }
        }
      }
    } else {
      cycleCounters.set(audioNode, cycleCounter - count);
    }
  };
};

exports.createDecrementCycleCounter = createDecrementCycleCounter;
},{"../guards/audio-node-output-connection":"../node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/delay-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDelayNodeConstructor = void 0;
const DEFAULT_OPTIONS = {
  channelCount: 2,
  channelCountMode: 'max',
  channelInterpretation: 'speakers',
  delayTime: 0,
  maxDelayTime: 1
};

const createDelayNodeConstructor = (audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {
  return class DelayNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const delayNodeRenderer = isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null;
      super(context, false, nativeDelayNode, delayNodeRenderer);
      this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime);
      setAudioNodeTailTime(this, mergedOptions.maxDelayTime);
    }

    get delayTime() {
      return this._delayTime;
    }

  };
};

exports.createDelayNodeConstructor = createDelayNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/delay-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDelayNodeRendererFactory = void 0;

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createDelayNodeRendererFactory = (connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {
  return maxDelayTime => {
    const renderedNativeDelayNodes = new WeakMap();

    const createDelayNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeDelayNode = getNativeAudioNode(proxy); // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.

      const nativeDelayNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeDelayNode, nativeOfflineAudioContext);

      if (!nativeDelayNodeIsOwnedByContext) {
        const options = {
          channelCount: nativeDelayNode.channelCount,
          channelCountMode: nativeDelayNode.channelCountMode,
          channelInterpretation: nativeDelayNode.channelInterpretation,
          delayTime: nativeDelayNode.delayTime.value,
          maxDelayTime
        };
        nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);
      }

      renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);

      if (!nativeDelayNodeIsOwnedByContext) {
        await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
      } else {
        await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
      }

      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode);
      return nativeDelayNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);

        if (renderedNativeDelayNode !== undefined) {
          return Promise.resolve(renderedNativeDelayNode);
        }

        return createDelayNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createDelayNodeRendererFactory = createDelayNodeRendererFactory;
},{"../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/delete-active-input-connection-to-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDeleteActiveInputConnectionToAudioNode = void 0;

const createDeleteActiveInputConnectionToAudioNode = pickElementFromSet => {
  return (activeInputs, source, output, input) => {
    return pickElementFromSet(activeInputs[input], activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output);
  };
};

exports.createDeleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDeleteUnrenderedAudioWorkletNode = void 0;

const createDeleteUnrenderedAudioWorkletNode = getUnrenderedAudioWorkletNodes => {
  return (nativeContext, audioWorkletNode) => {
    getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);
  };
};

exports.createDeleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/guards/delay-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDelayNode = void 0;

const isDelayNode = audioNode => {
  return 'delayTime' in audioNode;
};

exports.isDelayNode = isDelayNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDetectCycles = void 0;

var _audioNode = require("../guards/audio-node");

var _delayNode = require("../guards/delay-node");

const createDetectCycles = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {
  return function detectCycles(chain, nextLink) {
    const audioNode = (0, _audioNode.isAudioNode)(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);

    if ((0, _delayNode.isDelayNode)(audioNode)) {
      return [];
    }

    if (chain[0] === audioNode) {
      return [chain];
    }

    if (chain.includes(audioNode)) {
      return [];
    }

    const {
      outputs
    } = getAudioNodeConnections(audioNode);
    return Array.from(outputs).map(outputConnection => detectCycles([...chain, audioNode], outputConnection[0])).reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);
  };
};

exports.createDetectCycles = createDetectCycles;
},{"../guards/audio-node":"../node_modules/standardized-audio-context/build/es2019/guards/audio-node.js","../guards/delay-node":"../node_modules/standardized-audio-context/build/es2019/guards/delay-node.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDisconnectMultipleOutputs = void 0;

var _nativeAudioNode = require("../guards/native-audio-node");

const getOutputAudioNodeAtIndex = (createIndexSizeError, outputAudioNodes, output) => {
  const outputAudioNode = outputAudioNodes[output];

  if (outputAudioNode === undefined) {
    throw createIndexSizeError();
  }

  return outputAudioNode;
};

const createDisconnectMultipleOutputs = createIndexSizeError => {
  return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {
    if (destinationOrOutput === undefined) {
      return outputAudioNodes.forEach(outputAudioNode => outputAudioNode.disconnect());
    }

    if (typeof destinationOrOutput === 'number') {
      return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();
    }

    if ((0, _nativeAudioNode.isNativeAudioNode)(destinationOrOutput)) {
      if (output === undefined) {
        return outputAudioNodes.forEach(outputAudioNode => outputAudioNode.disconnect(destinationOrOutput));
      }

      if (input === undefined) {
        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);
      }

      return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);
    }

    if (output === undefined) {
      return outputAudioNodes.forEach(outputAudioNode => outputAudioNode.disconnect(destinationOrOutput));
    }

    return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);
  };
};

exports.createDisconnectMultipleOutputs = createDisconnectMultipleOutputs;
},{"../guards/native-audio-node":"../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDynamicsCompressorNodeConstructor = void 0;
const DEFAULT_OPTIONS = {
  attack: 0.003,
  channelCount: 2,
  channelCountMode: 'clamped-max',
  channelInterpretation: 'speakers',
  knee: 30,
  ratio: 12,
  release: 0.25,
  threshold: -24
};

const createDynamicsCompressorNodeConstructor = (audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {
  return class DynamicsCompressorNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const dynamicsCompressorNodeRenderer = isOffline ? createDynamicsCompressorNodeRenderer() : null;
      super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);
      this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack);
      this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee);
      this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;
      this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio);
      this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release);
      this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold);
      setAudioNodeTailTime(this, 0.006);
    }

    get attack() {
      return this._attack;
    } // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.


    get channelCount() {
      return this._nativeDynamicsCompressorNode.channelCount;
    }

    set channelCount(value) {
      const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;
      this._nativeDynamicsCompressorNode.channelCount = value;

      if (value > 2) {
        this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;
        throw createNotSupportedError();
      }
    }
    /*
     * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be
     * overwritten here.
     */


    get channelCountMode() {
      return this._nativeDynamicsCompressorNode.channelCountMode;
    }

    set channelCountMode(value) {
      const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;
      this._nativeDynamicsCompressorNode.channelCountMode = value;

      if (value === 'max') {
        this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;
        throw createNotSupportedError();
      }
    }

    get knee() {
      return this._knee;
    }

    get ratio() {
      return this._ratio;
    }

    get reduction() {
      // Bug #111: Safari returns an AudioParam instead of a number.
      if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {
        return this._nativeDynamicsCompressorNode.reduction.value;
      }

      return this._nativeDynamicsCompressorNode.reduction;
    }

    get release() {
      return this._release;
    }

    get threshold() {
      return this._threshold;
    }

  };
};

exports.createDynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDynamicsCompressorNodeRendererFactory = void 0;

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createDynamicsCompressorNodeRendererFactory = (connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeDynamicsCompressorNodes = new WeakMap();

    const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeDynamicsCompressorNode = getNativeAudioNode(proxy);
      /*
       * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be
       * created again.
       */

      const nativeDynamicsCompressorNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeDynamicsCompressorNode, nativeOfflineAudioContext);

      if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
        const options = {
          attack: nativeDynamicsCompressorNode.attack.value,
          channelCount: nativeDynamicsCompressorNode.channelCount,
          channelCountMode: nativeDynamicsCompressorNode.channelCountMode,
          channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,
          knee: nativeDynamicsCompressorNode.knee.value,
          ratio: nativeDynamicsCompressorNode.ratio.value,
          release: nativeDynamicsCompressorNode.release.value,
          threshold: nativeDynamicsCompressorNode.threshold.value
        };
        nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);
      }

      renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);

      if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
        await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
        await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
        await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
        await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
        await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
      } else {
        await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
        await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
        await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
        await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
        await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
      }

      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);
      return nativeDynamicsCompressorNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);

        if (renderedNativeDynamicsCompressorNode !== undefined) {
          return Promise.resolve(renderedNativeDynamicsCompressorNode);
        }

        return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createDynamicsCompressorNodeRendererFactory = createDynamicsCompressorNodeRendererFactory;
},{"../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/encoding-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEncodingError = void 0;

const createEncodingError = () => new DOMException('', 'EncodingError');

exports.createEncodingError = createEncodingError;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEvaluateSource = void 0;

const createEvaluateSource = window => {
  return source => new Promise((resolve, reject) => {
    if (window === null) {
      // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.
      reject(new SyntaxError());
      return;
    }

    const head = window.document.head;

    if (head === null) {
      // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.
      reject(new SyntaxError());
    } else {
      const script = window.document.createElement('script'); // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.

      const blob = new Blob([source], {
        type: 'application/javascript'
      });
      const url = URL.createObjectURL(blob);
      const originalOnErrorHandler = window.onerror;

      const removeErrorEventListenerAndRevokeUrl = () => {
        window.onerror = originalOnErrorHandler;
        URL.revokeObjectURL(url);
      };

      window.onerror = (message, src, lineno, colno, error) => {
        // @todo Edge thinks the source is the one of the html document.
        if (src === url || src === window.location.href && lineno === 1 && colno === 1) {
          removeErrorEventListenerAndRevokeUrl();
          reject(error);
          return false;
        }

        if (originalOnErrorHandler !== null) {
          return originalOnErrorHandler(message, src, lineno, colno, error);
        }
      };

      script.onerror = () => {
        removeErrorEventListenerAndRevokeUrl(); // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.

        reject(new SyntaxError());
      };

      script.onload = () => {
        removeErrorEventListenerAndRevokeUrl();
        resolve();
      };

      script.src = url;
      script.type = 'module';
      head.appendChild(script);
    }
  });
};

exports.createEvaluateSource = createEvaluateSource;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEventTargetConstructor = void 0;

const createEventTargetConstructor = wrapEventListener => {
  return class EventTarget {
    constructor(_nativeEventTarget) {
      this._nativeEventTarget = _nativeEventTarget;
      this._listeners = new WeakMap();
    }

    addEventListener(type, listener, options) {
      if (listener !== null) {
        let wrappedEventListener = this._listeners.get(listener);

        if (wrappedEventListener === undefined) {
          wrappedEventListener = wrapEventListener(this, listener);

          if (typeof listener === 'function') {
            this._listeners.set(listener, wrappedEventListener);
          }
        }

        this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);
      }
    }

    dispatchEvent(event) {
      return this._nativeEventTarget.dispatchEvent(event);
    }

    removeEventListener(type, listener, options) {
      const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);

      this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);
    }

  };
};

exports.createEventTargetConstructor = createEventTargetConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createExposeCurrentFrameAndCurrentTime = void 0;

const createExposeCurrentFrameAndCurrentTime = window => {
  return (currentTime, sampleRate, fn) => {
    Object.defineProperties(window, {
      currentFrame: {
        configurable: true,

        get() {
          return Math.round(currentTime * sampleRate);
        }

      },
      currentTime: {
        configurable: true,

        get() {
          return currentTime;
        }

      }
    });

    try {
      return fn();
    } finally {
      if (window !== null) {
        delete window.currentFrame;
        delete window.currentTime;
      }
    }
  };
};

exports.createExposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFetchSource = void 0;

const createFetchSource = createAbortError => {
  return async url => {
    try {
      const response = await fetch(url);

      if (response.ok) {
        return [await response.text(), response.url];
      }
    } catch {// Ignore errors.
    } // tslint:disable-line:no-empty


    throw createAbortError();
  };
};

exports.createFetchSource = createFetchSource;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/gain-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGainNodeConstructor = void 0;

var _constants = require("../constants");

const DEFAULT_OPTIONS = {
  channelCount: 2,
  channelCountMode: 'max',
  channelInterpretation: 'speakers',
  gain: 1
};

const createGainNodeConstructor = (audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext) => {
  return class GainNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const gainNodeRenderer = isOffline ? createGainNodeRenderer() : null;
      super(context, false, nativeGainNode, gainNodeRenderer); // Bug #74: Safari does not export the correct values for maxValue and minValue.

      this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, _constants.MOST_POSITIVE_SINGLE_FLOAT, _constants.MOST_NEGATIVE_SINGLE_FLOAT);
    }

    get gain() {
      return this._gain;
    }

  };
};

exports.createGainNodeConstructor = createGainNodeConstructor;
},{"../constants":"../node_modules/standardized-audio-context/build/es2019/constants.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/gain-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGainNodeRendererFactory = void 0;

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createGainNodeRendererFactory = (connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeGainNodes = new WeakMap();

    const createGainNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeGainNode = getNativeAudioNode(proxy); // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.

      const nativeGainNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeGainNode, nativeOfflineAudioContext);

      if (!nativeGainNodeIsOwnedByContext) {
        const options = {
          channelCount: nativeGainNode.channelCount,
          channelCountMode: nativeGainNode.channelCountMode,
          channelInterpretation: nativeGainNode.channelInterpretation,
          gain: nativeGainNode.gain.value
        };
        nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);
      }

      renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);

      if (!nativeGainNodeIsOwnedByContext) {
        await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
      } else {
        await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
      }

      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);
      return nativeGainNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);

        if (renderedNativeGainNode !== undefined) {
          return Promise.resolve(renderedNativeGainNode);
        }

        return createGainNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createGainNodeRendererFactory = createGainNodeRendererFactory;
},{"../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/get-active-audio-worklet-node-inputs.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetActiveAudioWorkletNodeInputs = void 0;

const createGetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore, getValueForKey) => {
  return nativeAudioWorkletNode => getValueForKey(activeAudioWorkletNodeInputsStore, nativeAudioWorkletNode);
};

exports.createGetActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetAudioNodeRenderer = void 0;

const createGetAudioNodeRenderer = getAudioNodeConnections => {
  return audioNode => {
    const audioNodeConnections = getAudioNodeConnections(audioNode);

    if (audioNodeConnections.renderer === null) {
      throw new Error('Missing the renderer of the given AudioNode in the audio graph.');
    }

    return audioNodeConnections.renderer;
  };
};

exports.createGetAudioNodeRenderer = createGetAudioNodeRenderer;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-tail-time.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetAudioNodeTailTime = void 0;

const createGetAudioNodeTailTime = audioNodeTailTimeStore => {
  return audioNode => {
    var _a;

    return (_a = audioNodeTailTimeStore.get(audioNode)) !== null && _a !== void 0 ? _a : 0;
  };
};

exports.createGetAudioNodeTailTime = createGetAudioNodeTailTime;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetAudioParamRenderer = void 0;

const createGetAudioParamRenderer = getAudioParamConnections => {
  return audioParam => {
    const audioParamConnections = getAudioParamConnections(audioParam);

    if (audioParamConnections.renderer === null) {
      throw new Error('Missing the renderer of the given AudioParam in the audio graph.');
    }

    return audioParamConnections.renderer;
  };
};

exports.createGetAudioParamRenderer = createGetAudioParamRenderer;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/get-backup-offline-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetBackupOfflineAudioContext = void 0;

const createGetBackupOfflineAudioContext = backupOfflineAudioContextStore => {
  return nativeContext => {
    return backupOfflineAudioContextStore.get(nativeContext);
  };
};

exports.createGetBackupOfflineAudioContext = createGetBackupOfflineAudioContext;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createInvalidStateError = void 0;

const createInvalidStateError = () => new DOMException('', 'InvalidStateError');

exports.createInvalidStateError = createInvalidStateError;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetNativeContext = void 0;

var _invalidStateError = require("./invalid-state-error");

const createGetNativeContext = contextStore => {
  return context => {
    const nativeContext = contextStore.get(context);

    if (nativeContext === undefined) {
      throw (0, _invalidStateError.createInvalidStateError)();
    }

    return nativeContext;
  };
};

exports.createGetNativeContext = createGetNativeContext;
},{"./invalid-state-error":"../node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/get-or-create-backup-offline-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetOrCreateBackupOfflineAudioContext = void 0;

const createGetOrCreateBackupOfflineAudioContext = (backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor) => {
  return nativeContext => {
    let backupOfflineAudioContext = backupOfflineAudioContextStore.get(nativeContext);

    if (backupOfflineAudioContext !== undefined) {
      return backupOfflineAudioContext;
    }

    if (nativeOfflineAudioContextConstructor === null) {
      throw new Error('Missing the native OfflineAudioContext constructor.');
    } // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.


    backupOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);
    backupOfflineAudioContextStore.set(nativeContext, backupOfflineAudioContext);
    return backupOfflineAudioContext;
  };
};

exports.createGetOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetUnrenderedAudioWorkletNodes = void 0;

const createGetUnrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore => {
  return nativeContext => {
    const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);

    if (unrenderedAudioWorkletNodes === undefined) {
      throw new Error('The context has no set of AudioWorkletNodes.');
    }

    return unrenderedAudioWorkletNodes;
  };
};

exports.createGetUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createInvalidAccessError = void 0;

const createInvalidAccessError = () => new DOMException('', 'InvalidAccessError');

exports.createInvalidAccessError = createInvalidAccessError;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapIIRFilterNodeGetFrequencyResponseMethod = void 0;

var _invalidAccessError = require("../factories/invalid-access-error");

const wrapIIRFilterNodeGetFrequencyResponseMethod = nativeIIRFilterNode => {
  nativeIIRFilterNode.getFrequencyResponse = (getFrequencyResponse => {
    return (frequencyHz, magResponse, phaseResponse) => {
      if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
        throw (0, _invalidAccessError.createInvalidAccessError)();
      }

      return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);
    };
  })(nativeIIRFilterNode.getFrequencyResponse);
};

exports.wrapIIRFilterNodeGetFrequencyResponseMethod = wrapIIRFilterNodeGetFrequencyResponseMethod;
},{"../factories/invalid-access-error":"../node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIIRFilterNodeConstructor = void 0;

var _wrapIirFilterNodeGetFrequencyResponseMethod = require("../helpers/wrap-iir-filter-node-get-frequency-response-method");

const DEFAULT_OPTIONS = {
  channelCount: 2,
  channelCountMode: 'max',
  channelInterpretation: 'speakers'
};

const createIIRFilterNodeConstructor = (audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {
  return class IIRFilterNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);
      const iirFilterNodeRenderer = isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null;
      super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer); // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.
      // @todo Write a test which allows other browsers to remain unpatched.

      (0, _wrapIirFilterNodeGetFrequencyResponseMethod.wrapIIRFilterNodeGetFrequencyResponseMethod)(nativeIIRFilterNode);
      this._nativeIIRFilterNode = nativeIIRFilterNode; // @todo Determine a meaningful tail-time instead of just using one second.

      setAudioNodeTailTime(this, 1);
    }

    getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
      return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
    }

  };
};

exports.createIIRFilterNodeConstructor = createIIRFilterNodeConstructor;
},{"../helpers/wrap-iir-filter-node-get-frequency-response-method":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterBuffer = void 0;

// This implementation as shamelessly inspired by source code of
// tslint:disable-next-line:max-line-length
// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.
const filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) => {
  const inputLength = input.length;
  let i = bufferIndex;

  for (let j = 0; j < inputLength; j += 1) {
    let y = feedforward[0] * input[j];

    for (let k = 1; k < minLength; k += 1) {
      const x = i - k & bufferLength - 1; // tslint:disable-line:no-bitwise

      y += feedforward[k] * xBuffer[x];
      y -= feedback[k] * yBuffer[x];
    }

    for (let k = minLength; k < feedforwardLength; k += 1) {
      y += feedforward[k] * xBuffer[i - k & bufferLength - 1]; // tslint:disable-line:no-bitwise
    }

    for (let k = minLength; k < feedbackLength; k += 1) {
      y -= feedback[k] * yBuffer[i - k & bufferLength - 1]; // tslint:disable-line:no-bitwise
    }

    xBuffer[i] = input[j];
    yBuffer[i] = y;
    i = i + 1 & bufferLength - 1; // tslint:disable-line:no-bitwise

    output[j] = y;
  }

  return i;
};

exports.filterBuffer = filterBuffer;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIIRFilterNodeRendererFactory = void 0;

var _filterBuffer = require("../helpers/filter-buffer");

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {
  const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
  const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
  const feedbackLength = convertedFeedback.length;
  const feedforwardLength = convertedFeedforward.length;
  const minLength = Math.min(feedbackLength, feedforwardLength);

  if (convertedFeedback[0] !== 1) {
    for (let i = 0; i < feedbackLength; i += 1) {
      convertedFeedforward[i] /= convertedFeedback[0];
    }

    for (let i = 1; i < feedforwardLength; i += 1) {
      convertedFeedback[i] /= convertedFeedback[0];
    }
  }

  const bufferLength = 32;
  const xBuffer = new Float32Array(bufferLength);
  const yBuffer = new Float32Array(bufferLength);
  const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
  const numberOfChannels = renderedBuffer.numberOfChannels;

  for (let i = 0; i < numberOfChannels; i += 1) {
    const input = renderedBuffer.getChannelData(i);
    const output = filteredBuffer.getChannelData(i);
    xBuffer.fill(0);
    yBuffer.fill(0);
    (0, _filterBuffer.filterBuffer)(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);
  }

  return filteredBuffer;
};

const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {
  return (feedback, feedforward) => {
    const renderedNativeAudioNodes = new WeakMap();
    let filteredBufferPromise = null;

    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeAudioBufferSourceNode = null;
      let nativeIIRFilterNode = getNativeAudioNode(proxy); // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.

      const nativeIIRFilterNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeIIRFilterNode, nativeOfflineAudioContext); // Bug #9: Safari does not support IIRFilterNodes.

      if (nativeOfflineAudioContext.createIIRFilter === undefined) {
        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {
          buffer: null,
          channelCount: 2,
          channelCountMode: 'max',
          channelInterpretation: 'speakers',
          loop: false,
          loopEnd: 0,
          loopStart: 0,
          playbackRate: 1
        });
      } else if (!nativeIIRFilterNodeIsOwnedByContext) {
        // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.
        nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);
      }

      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);

      if (nativeAudioBufferSourceNode !== null) {
        if (filteredBufferPromise === null) {
          if (nativeOfflineAudioContextConstructor === null) {
            throw new Error('Missing the native OfflineAudioContext constructor.');
          }

          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor( // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.
          proxy.context.destination.channelCount, // Bug #17: Safari does not yet expose the length.
          proxy.context.length, nativeOfflineAudioContext.sampleRate);

          filteredBufferPromise = (async () => {
            await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);
            const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);
            return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);
          })();
        }

        const filteredBuffer = await filteredBufferPromise;
        nativeAudioBufferSourceNode.buffer = filteredBuffer;
        nativeAudioBufferSourceNode.start(0);
        return nativeAudioBufferSourceNode;
      }

      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);
      return nativeIIRFilterNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);

        if (renderedNativeAudioNode !== undefined) {
          return Promise.resolve(renderedNativeAudioNode);
        }

        return createAudioNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createIIRFilterNodeRendererFactory = createIIRFilterNodeRendererFactory;
},{"../helpers/filter-buffer":"../node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js","../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIncrementCycleCounterFactory = void 0;

var _audioNodeOutputConnection = require("../guards/audio-node-output-connection");

const createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) => {
  return isOffline => {
    return (audioNode, count) => {
      const cycleCounter = cycleCounters.get(audioNode);

      if (cycleCounter === undefined) {
        if (!isOffline && isActiveAudioNode(audioNode)) {
          const nativeSourceAudioNode = getNativeAudioNode(audioNode);
          const {
            outputs
          } = getAudioNodeConnections(audioNode);

          for (const output of outputs) {
            if ((0, _audioNodeOutputConnection.isAudioNodeOutputConnection)(output)) {
              const nativeDestinationAudioNode = getNativeAudioNode(output[0]);
              disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
            } else {
              const nativeDestinationAudioParam = getNativeAudioParam(output[0]);
              nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);
            }
          }
        }

        cycleCounters.set(audioNode, count);
      } else {
        cycleCounters.set(audioNode, cycleCounter + count);
      }
    };
  };
};

exports.createIncrementCycleCounterFactory = createIncrementCycleCounterFactory;
},{"../guards/audio-node-output-connection":"../node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsAnyAudioContext = void 0;

const createIsAnyAudioContext = (contextStore, isNativeAudioContext) => {
  return anything => {
    const nativeContext = contextStore.get(anything);
    return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);
  };
};

exports.createIsAnyAudioContext = createIsAnyAudioContext;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsAnyAudioNode = void 0;

const createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode) => {
  return anything => audioNodeStore.has(anything) || isNativeAudioNode(anything);
};

exports.createIsAnyAudioNode = createIsAnyAudioNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsAnyAudioParam = void 0;

const createIsAnyAudioParam = (audioParamStore, isNativeAudioParam) => {
  return anything => audioParamStore.has(anything) || isNativeAudioParam(anything);
};

exports.createIsAnyAudioParam = createIsAnyAudioParam;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/is-any-offline-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsAnyOfflineAudioContext = void 0;

const createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext) => {
  return anything => {
    const nativeContext = contextStore.get(anything);
    return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);
  };
};

exports.createIsAnyOfflineAudioContext = createIsAnyOfflineAudioContext;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsNativeAudioContext = void 0;

const createIsNativeAudioContext = nativeAudioContextConstructor => {
  return anything => {
    return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;
  };
};

exports.createIsNativeAudioContext = createIsNativeAudioContext;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsNativeAudioNode = void 0;

const createIsNativeAudioNode = window => {
  return anything => {
    return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;
  };
};

exports.createIsNativeAudioNode = createIsNativeAudioNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsNativeAudioParam = void 0;

const createIsNativeAudioParam = window => {
  return anything => {
    return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;
  };
};

exports.createIsNativeAudioParam = createIsNativeAudioParam;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/is-native-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsNativeContext = void 0;

const createIsNativeContext = (isNativeAudioContext, isNativeOfflineAudioContext) => {
  return anything => {
    return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);
  };
};

exports.createIsNativeContext = createIsNativeContext;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsNativeOfflineAudioContext = void 0;

const createIsNativeOfflineAudioContext = nativeOfflineAudioContextConstructor => {
  return anything => {
    return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;
  };
};

exports.createIsNativeOfflineAudioContext = createIsNativeOfflineAudioContext;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsSecureContext = void 0;

const createIsSecureContext = window => window !== null && window.isSecureContext;

exports.createIsSecureContext = createIsSecureContext;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/is-supported-promise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsSupportedPromise = void 0;

const createIsSupportedPromise = async (cacheTestResult, testAudioBufferCopyChannelMethodsSubarraySupport, testAudioContextCloseMethodSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextOptionsSupport, testAudioNodeConnectMethodSupport, testAudioWorkletProcessorNoOutputsSupport, testChannelMergerNodeChannelCountSupport, testConstantSourceNodeAccurateSchedulingSupport, testConvolverNodeBufferReassignabilitySupport, testConvolverNodeChannelCountSupport, testDomExceptionContrucorSupport, testIsSecureContextSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testStereoPannerNodeDefaultValueSupport, testTransferablesSupport) => {
  if (cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, testAudioBufferCopyChannelMethodsSubarraySupport) && cacheTestResult(testAudioContextCloseMethodSupport, testAudioContextCloseMethodSupport) && cacheTestResult(testAudioContextOptionsSupport, testAudioContextOptionsSupport) && cacheTestResult(testAudioNodeConnectMethodSupport, testAudioNodeConnectMethodSupport) && cacheTestResult(testChannelMergerNodeChannelCountSupport, testChannelMergerNodeChannelCountSupport) && cacheTestResult(testConstantSourceNodeAccurateSchedulingSupport, testConstantSourceNodeAccurateSchedulingSupport) && cacheTestResult(testConvolverNodeBufferReassignabilitySupport, testConvolverNodeBufferReassignabilitySupport) && cacheTestResult(testConvolverNodeChannelCountSupport, testConvolverNodeChannelCountSupport) && cacheTestResult(testDomExceptionContrucorSupport, testDomExceptionContrucorSupport) && cacheTestResult(testIsSecureContextSupport, testIsSecureContextSupport) && cacheTestResult(testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport)) {
    const results = await Promise.all([cacheTestResult(testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport), cacheTestResult(testAudioWorkletProcessorNoOutputsSupport, testAudioWorkletProcessorNoOutputsSupport), cacheTestResult(testStereoPannerNodeDefaultValueSupport, testStereoPannerNodeDefaultValueSupport), cacheTestResult(testTransferablesSupport, testTransferablesSupport)]);
    return results.every(result => result);
  }

  return false;
};

exports.createIsSupportedPromise = createIsSupportedPromise;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/media-element-audio-source-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMediaElementAudioSourceNodeConstructor = void 0;

const createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {
  return class MediaElementAudioSourceNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options); // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.

      if (isNativeOfflineAudioContext(nativeContext)) {
        throw TypeError();
      }

      super(context, true, nativeMediaElementAudioSourceNode, null);
      this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;
    }

    get mediaElement() {
      return this._nativeMediaElementAudioSourceNode.mediaElement;
    }

  };
};

exports.createMediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-destination-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMediaStreamAudioDestinationNodeConstructor = void 0;
const DEFAULT_OPTIONS = {
  channelCount: 2,
  channelCountMode: 'explicit',
  channelInterpretation: 'speakers'
};

const createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext) => {
  return class MediaStreamAudioDestinationNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context); // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.

      if (isNativeOfflineAudioContext(nativeContext)) {
        throw new TypeError();
      }

      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);
      super(context, false, nativeMediaStreamAudioDestinationNode, null);
      this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;
    }

    get stream() {
      return this._nativeMediaStreamAudioDestinationNode.stream;
    }

  };
};

exports.createMediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMediaStreamAudioSourceNodeConstructor = void 0;

const createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {
  return class MediaStreamAudioSourceNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options); // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.

      if (isNativeOfflineAudioContext(nativeContext)) {
        throw new TypeError();
      }

      super(context, true, nativeMediaStreamAudioSourceNode, null);
      this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;
    }

    get mediaStream() {
      return this._nativeMediaStreamAudioSourceNode.mediaStream;
    }

  };
};

exports.createMediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/media-stream-track-audio-source-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMediaStreamTrackAudioSourceNodeConstructor = void 0;

const createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext) => {
  return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);
      super(context, true, nativeMediaStreamTrackAudioSourceNode, null);
    }

  };
};

exports.createMediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/minimal-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMinimalAudioContextConstructor = void 0;

var _deactivateAudioGraph = require("../helpers/deactivate-audio-graph");

var _isValidLatencyHint = require("../helpers/is-valid-latency-hint");

const createMinimalAudioContextConstructor = (createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) => {
  return class MinimalAudioContext extends minimalBaseAudioContextConstructor {
    constructor(options = {}) {
      if (nativeAudioContextConstructor === null) {
        throw new Error('Missing the native AudioContext constructor.');
      }

      let nativeAudioContext;

      try {
        nativeAudioContext = new nativeAudioContextConstructor(options);
      } catch (err) {
        // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.
        if (err.code === 12 && err.message === 'sampleRate is not in range') {
          throw createNotSupportedError();
        }

        throw err;
      } // Bug #131 Safari returns null when there are four other AudioContexts running already.


      if (nativeAudioContext === null) {
        throw createUnknownError();
      } // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.


      if (!(0, _isValidLatencyHint.isValidLatencyHint)(options.latencyHint)) {
        throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
      } // Bug #150 Safari does not support setting the sampleRate.


      if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {
        throw createNotSupportedError();
      }

      super(nativeAudioContext, 2);
      const {
        latencyHint
      } = options;
      const {
        sampleRate
      } = nativeAudioContext; // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.

      this._baseLatency = typeof nativeAudioContext.baseLatency === 'number' ? nativeAudioContext.baseLatency : latencyHint === 'balanced' ? 512 / sampleRate : latencyHint === 'interactive' || latencyHint === undefined ? 256 / sampleRate : latencyHint === 'playback' ? 1024 / sampleRate :
      /*
       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a
       * ScriptProcessorNode.
       */
      Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;
      this._nativeAudioContext = nativeAudioContext; // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.

      if (nativeAudioContextConstructor.name === 'webkitAudioContext') {
        this._nativeGainNode = nativeAudioContext.createGain();
        this._nativeOscillatorNode = nativeAudioContext.createOscillator();
        this._nativeGainNode.gain.value = 1e-37;

        this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);

        this._nativeOscillatorNode.start();
      } else {
        this._nativeGainNode = null;
        this._nativeOscillatorNode = null;
      }

      this._state = null;
      /*
       * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes
       * to 'running'.
       */

      if (nativeAudioContext.state === 'running') {
        this._state = 'suspended';

        const revokeState = () => {
          if (this._state === 'suspended') {
            this._state = null;
          }

          nativeAudioContext.removeEventListener('statechange', revokeState);
        };

        nativeAudioContext.addEventListener('statechange', revokeState);
      }
    }

    get baseLatency() {
      return this._baseLatency;
    }

    get state() {
      return this._state !== null ? this._state : this._nativeAudioContext.state;
    }

    close() {
      // Bug #35: Firefox does not throw an error if the AudioContext was closed before.
      if (this.state === 'closed') {
        return this._nativeAudioContext.close().then(() => {
          throw createInvalidStateError();
        });
      } // Bug #34: If the state was set to suspended before it should be revoked now.


      if (this._state === 'suspended') {
        this._state = null;
      }

      return this._nativeAudioContext.close().then(() => {
        if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {
          this._nativeOscillatorNode.stop();

          this._nativeGainNode.disconnect();

          this._nativeOscillatorNode.disconnect();
        }

        (0, _deactivateAudioGraph.deactivateAudioGraph)(this);
      });
    }

    resume() {
      if (this._state === 'suspended') {
        return new Promise((resolve, reject) => {
          const resolvePromise = () => {
            this._nativeAudioContext.removeEventListener('statechange', resolvePromise);

            if (this._nativeAudioContext.state === 'running') {
              resolve();
            } else {
              this.resume().then(resolve, reject);
            }
          };

          this._nativeAudioContext.addEventListener('statechange', resolvePromise);
        });
      }

      return this._nativeAudioContext.resume().catch(err => {
        // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.
        // Bug #56: Safari invokes the catch handler but without an error.
        if (err === undefined || err.code === 15) {
          throw createInvalidStateError();
        }

        throw err;
      });
    }

    suspend() {
      return this._nativeAudioContext.suspend().catch(err => {
        // Bug #56: Safari invokes the catch handler but without an error.
        if (err === undefined) {
          throw createInvalidStateError();
        }

        throw err;
      });
    }

  };
};

exports.createMinimalAudioContextConstructor = createMinimalAudioContextConstructor;
},{"../helpers/deactivate-audio-graph":"../node_modules/standardized-audio-context/build/es2019/helpers/deactivate-audio-graph.js","../helpers/is-valid-latency-hint":"../node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMinimalBaseAudioContextConstructor = void 0;

var _globals = require("../globals");

const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener) => {
  return class MinimalBaseAudioContext extends eventTargetConstructor {
    constructor(_nativeContext, numberOfChannels) {
      super(_nativeContext);
      this._nativeContext = _nativeContext;

      _globals.CONTEXT_STORE.set(this, _nativeContext);

      if (isNativeOfflineAudioContext(_nativeContext)) {
        unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());
      }

      this._destination = new audioDestinationNodeConstructor(this, numberOfChannels);
      this._listener = createAudioListener(this, _nativeContext);
      this._onstatechange = null;
    }

    get currentTime() {
      return this._nativeContext.currentTime;
    }

    get destination() {
      return this._destination;
    }

    get listener() {
      return this._listener;
    }

    get onstatechange() {
      return this._onstatechange;
    }

    set onstatechange(value) {
      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;
      this._nativeContext.onstatechange = wrappedListener;
      const nativeOnStateChange = this._nativeContext.onstatechange;
      this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;
    }

    get sampleRate() {
      return this._nativeContext.sampleRate;
    }

    get state() {
      return this._nativeContext.state;
    }

  };
};

exports.createMinimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testPromiseSupport = void 0;

const testPromiseSupport = nativeContext => {
  // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.
  const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);

  try {
    // Bug #1: Safari requires a successCallback.
    const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {// Ignore the success callback.
    });

    if (promise === undefined) {
      return false;
    }

    promise.catch(() => {// Ignore rejected errors.
    });
    return true;
  } catch {// Ignore errors.
  }

  return false;
};

exports.testPromiseSupport = testPromiseSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/minimal-offline-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMinimalOfflineAudioContextConstructor = void 0;

var _deactivateAudioGraph = require("../helpers/deactivate-audio-graph");

var _testPromiseSupport = require("../helpers/test-promise-support");

const DEFAULT_OPTIONS = {
  numberOfChannels: 1
};

const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {
  return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {
    constructor(options) {
      const {
        length,
        numberOfChannels,
        sampleRate
      } = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.

      if (!cacheTestResult(_testPromiseSupport.testPromiseSupport, () => (0, _testPromiseSupport.testPromiseSupport)(nativeOfflineAudioContext))) {
        nativeOfflineAudioContext.addEventListener('statechange', (() => {
          let i = 0;

          const delayStateChangeEvent = event => {
            if (this._state === 'running') {
              if (i > 0) {
                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);
                event.stopImmediatePropagation();

                this._waitForThePromiseToSettle(event);
              } else {
                i += 1;
              }
            }
          };

          return delayStateChangeEvent;
        })());
      }

      super(nativeOfflineAudioContext, numberOfChannels);
      this._length = length;
      this._nativeOfflineAudioContext = nativeOfflineAudioContext;
      this._state = null;
    }

    get length() {
      // Bug #17: Safari does not yet expose the length.
      if (this._nativeOfflineAudioContext.length === undefined) {
        return this._length;
      }

      return this._nativeOfflineAudioContext.length;
    }

    get state() {
      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
    }

    startRendering() {
      /*
       * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore
       * the state of the nativeOfflineAudioContext might no transition to running immediately.
       */
      if (this._state === 'running') {
        return Promise.reject(createInvalidStateError());
      }

      this._state = 'running';
      return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {
        this._state = null;
        (0, _deactivateAudioGraph.deactivateAudioGraph)(this);
      });
    }

    _waitForThePromiseToSettle(event) {
      if (this._state === null) {
        this._nativeOfflineAudioContext.dispatchEvent(event);
      } else {
        setTimeout(() => this._waitForThePromiseToSettle(event));
      }
    }

  };
};

exports.createMinimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor;
},{"../helpers/deactivate-audio-graph":"../node_modules/standardized-audio-context/build/es2019/helpers/deactivate-audio-graph.js","../helpers/test-promise-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMonitorConnections = void 0;

const createMonitorConnections = (insertElementInSet, isNativeAudioNode) => {
  return (nativeAudioNode, whenConnected, whenDisconnected) => {
    const connections = new Set();

    nativeAudioNode.connect = (connect => {
      // tslint:disable-next-line:invalid-void no-inferrable-types
      return (destination, output = 0, input = 0) => {
        const wasDisconnected = connections.size === 0;

        if (isNativeAudioNode(destination)) {
          // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.
          connect.call(nativeAudioNode, destination, output, input);
          insertElementInSet(connections, [destination, output, input], connection => connection[0] === destination && connection[1] === output && connection[2] === input, true);

          if (wasDisconnected) {
            whenConnected();
          }

          return destination;
        }

        connect.call(nativeAudioNode, destination, output);
        insertElementInSet(connections, [destination, output], connection => connection[0] === destination && connection[1] === output, true);

        if (wasDisconnected) {
          whenConnected();
        }

        return;
      };
    })(nativeAudioNode.connect);

    nativeAudioNode.disconnect = (disconnect => {
      return (destinationOrOutput, output, input) => {
        const wasConnected = connections.size > 0;

        if (destinationOrOutput === undefined) {
          disconnect.apply(nativeAudioNode);
          connections.clear();
        } else if (typeof destinationOrOutput === 'number') {
          // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.
          disconnect.call(nativeAudioNode, destinationOrOutput);

          for (const connection of connections) {
            if (connection[1] === destinationOrOutput) {
              connections.delete(connection);
            }
          }
        } else {
          if (isNativeAudioNode(destinationOrOutput)) {
            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.
            disconnect.call(nativeAudioNode, destinationOrOutput, output, input);
          } else {
            // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.
            disconnect.call(nativeAudioNode, destinationOrOutput, output);
          }

          for (const connection of connections) {
            if (connection[0] === destinationOrOutput && (output === undefined || connection[1] === output) && (input === undefined || connection[2] === input)) {
              connections.delete(connection);
            }
          }
        }

        const isDisconnected = connections.size === 0;

        if (wasConnected && isDisconnected) {
          whenDisconnected();
        }
      };
    })(nativeAudioNode.disconnect);

    return nativeAudioNode;
  };
};

exports.createMonitorConnections = createMonitorConnections;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assignNativeAudioNodeOption = void 0;

const assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {
  const value = options[option];

  if (value !== undefined && value !== nativeAudioNode[option]) {
    nativeAudioNode[option] = value;
  }
};

exports.assignNativeAudioNodeOption = assignNativeAudioNodeOption;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assignNativeAudioNodeOptions = void 0;

var _assignNativeAudioNodeOption = require("./assign-native-audio-node-option");

const assignNativeAudioNodeOptions = (nativeAudioNode, options) => {
  (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeAudioNode, options, 'channelCount');
  (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeAudioNode, options, 'channelCountMode');
  (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeAudioNode, options, 'channelInterpretation');
};

exports.assignNativeAudioNodeOptions = assignNativeAudioNodeOptions;
},{"./assign-native-audio-node-option":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testAnalyserNodeGetFloatTimeDomainDataMethodSupport = void 0;

const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = nativeAnalyserNode => {
  return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';
};

exports.testAnalyserNodeGetFloatTimeDomainDataMethodSupport = testAnalyserNodeGetFloatTimeDomainDataMethodSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapAnalyserNodeGetFloatTimeDomainDataMethod = void 0;

const wrapAnalyserNodeGetFloatTimeDomainDataMethod = nativeAnalyserNode => {
  nativeAnalyserNode.getFloatTimeDomainData = array => {
    const byteTimeDomainData = new Uint8Array(array.length);
    nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);
    const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);

    for (let i = 0; i < length; i += 1) {
      array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;
    }

    return array;
  };
};

exports.wrapAnalyserNodeGetFloatTimeDomainDataMethod = wrapAnalyserNodeGetFloatTimeDomainDataMethod;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-analyser-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeAnalyserNodeFactory = void 0;

var _assignNativeAudioNodeOption = require("../helpers/assign-native-audio-node-option");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

var _testAnalyserNodeGetFloatTimeDomainDataMethodSupport = require("../helpers/test-analyser-node-get-float-time-domain-data-method-support");

var _wrapAnalyserNodeGetFloatTimeDomainDataMethod = require("../helpers/wrap-analyser-node-get-float-time-domain-data-method");

const createNativeAnalyserNodeFactory = (cacheTestResult, createIndexSizeError) => {
  return (nativeContext, options) => {
    const nativeAnalyserNode = nativeContext.createAnalyser(); // Bug #37: Firefox does not create an AnalyserNode with the default properties.

    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeAnalyserNode, options); // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.

    if (!(options.maxDecibels > options.minDecibels)) {
      throw createIndexSizeError();
    }

    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeAnalyserNode, options, 'fftSize');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeAnalyserNode, options, 'maxDecibels');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeAnalyserNode, options, 'minDecibels');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeAnalyserNode, options, 'smoothingTimeConstant'); // Bug #36: Safari does not support getFloatTimeDomainData() yet.

    if (!cacheTestResult(_testAnalyserNodeGetFloatTimeDomainDataMethodSupport.testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => (0, _testAnalyserNodeGetFloatTimeDomainDataMethodSupport.testAnalyserNodeGetFloatTimeDomainDataMethodSupport)(nativeAnalyserNode))) {
      (0, _wrapAnalyserNodeGetFloatTimeDomainDataMethod.wrapAnalyserNodeGetFloatTimeDomainDataMethod)(nativeAnalyserNode);
    }

    return nativeAnalyserNode;
  };
};

exports.createNativeAnalyserNodeFactory = createNativeAnalyserNodeFactory;
},{"../helpers/assign-native-audio-node-option":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","../helpers/test-analyser-node-get-float-time-domain-data-method-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js","../helpers/wrap-analyser-node-get-float-time-domain-data-method":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeAudioBufferConstructor = void 0;

const createNativeAudioBufferConstructor = window => {
  if (window === null) {
    return null;
  }

  if (window.hasOwnProperty('AudioBuffer')) {
    return window.AudioBuffer;
  }

  return null;
};

exports.createNativeAudioBufferConstructor = createNativeAudioBufferConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assignNativeAudioNodeAudioParamValue = void 0;

const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {
  const value = options[audioParam];

  if (value !== undefined && value !== nativeAudioNode[audioParam].value) {
    nativeAudioNode[audioParam].value = value;
  }
};

exports.assignNativeAudioNodeAudioParamValue = assignNativeAudioNodeAudioParamValue;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = void 0;

var _invalidStateError = require("../factories/invalid-state-error");

const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = nativeAudioBufferSourceNode => {
  nativeAudioBufferSourceNode.start = (start => {
    let isScheduled = false;
    return (when = 0, offset = 0, duration) => {
      if (isScheduled) {
        throw (0, _invalidStateError.createInvalidStateError)();
      }

      start.call(nativeAudioBufferSourceNode, when, offset, duration);
      isScheduled = true;
    };
  })(nativeAudioBufferSourceNode.start);
};

exports.wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = wrapAudioBufferSourceNodeStartMethodConsecutiveCalls;
},{"../factories/invalid-state-error":"../node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapAudioScheduledSourceNodeStartMethodNegativeParameters = void 0;

const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = nativeAudioScheduledSourceNode => {
  nativeAudioScheduledSourceNode.start = (start => {
    return (when = 0, offset = 0, duration) => {
      if (typeof duration === 'number' && duration < 0 || offset < 0 || when < 0) {
        throw new RangeError("The parameters can't be negative.");
      } // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.


      start.call(nativeAudioScheduledSourceNode, when, offset, duration);
    };
  })(nativeAudioScheduledSourceNode.start);
};

exports.wrapAudioScheduledSourceNodeStartMethodNegativeParameters = wrapAudioScheduledSourceNodeStartMethodNegativeParameters;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapAudioScheduledSourceNodeStopMethodNegativeParameters = void 0;

const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = nativeAudioScheduledSourceNode => {
  nativeAudioScheduledSourceNode.stop = (stop => {
    return (when = 0) => {
      if (when < 0) {
        throw new RangeError("The parameter can't be negative.");
      }

      stop.call(nativeAudioScheduledSourceNode, when);
    };
  })(nativeAudioScheduledSourceNode.stop);
};

exports.wrapAudioScheduledSourceNodeStopMethodNegativeParameters = wrapAudioScheduledSourceNodeStopMethodNegativeParameters;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeAudioBufferSourceNodeFactory = void 0;

var _assignNativeAudioNodeAudioParamValue = require("../helpers/assign-native-audio-node-audio-param-value");

var _assignNativeAudioNodeOption = require("../helpers/assign-native-audio-node-option");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

var _wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = require("../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls");

var _wrapAudioScheduledSourceNodeStartMethodNegativeParameters = require("../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters");

var _wrapAudioScheduledSourceNodeStopMethodNegativeParameters = require("../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters");

const createNativeAudioBufferSourceNodeFactory = (addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {
  return (nativeContext, options) => {
    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeAudioBufferSourceNode, options);
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeAudioBufferSourceNode, options, 'playbackRate');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeAudioBufferSourceNode, options, 'buffer'); // Bug #149: Safari does not yet support the detune AudioParam.

    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeAudioBufferSourceNode, options, 'loop');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeAudioBufferSourceNode, options, 'loopEnd');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeAudioBufferSourceNode, options, 'loopStart'); // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.

    if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {
      (0, _wrapAudioBufferSourceNodeStartMethodConsecutiveCalls.wrapAudioBufferSourceNodeStartMethodConsecutiveCalls)(nativeAudioBufferSourceNode);
    } // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.


    if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {
      wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);
    } // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.


    if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))) {
      wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);
    } // Bug #44: Safari does not throw a RangeError yet.


    if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {
      (0, _wrapAudioScheduledSourceNodeStartMethodNegativeParameters.wrapAudioScheduledSourceNodeStartMethodNegativeParameters)(nativeAudioBufferSourceNode);
    } // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.


    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);
    } // Bug #44: Only Firefox does not throw a RangeError yet.


    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {
      (0, _wrapAudioScheduledSourceNodeStopMethodNegativeParameters.wrapAudioScheduledSourceNodeStopMethodNegativeParameters)(nativeAudioBufferSourceNode);
    } // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.


    addSilentConnection(nativeContext, nativeAudioBufferSourceNode);
    return nativeAudioBufferSourceNode;
  };
};

exports.createNativeAudioBufferSourceNodeFactory = createNativeAudioBufferSourceNodeFactory;
},{"../helpers/assign-native-audio-node-audio-param-value":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","../helpers/assign-native-audio-node-option":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js","../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeAudioContextConstructor = void 0;

const createNativeAudioContextConstructor = window => {
  if (window === null) {
    return null;
  }

  if (window.hasOwnProperty('AudioContext')) {
    return window.AudioContext;
  }

  return window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;
};

exports.createNativeAudioContextConstructor = createNativeAudioContextConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeAudioDestinationNodeFactory = void 0;

const createNativeAudioDestinationNodeFactory = (createNativeGainNode, overwriteAccessors) => {
  return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {
    const nativeAudioDestinationNode = nativeContext.destination; // Bug #132: Safari does not have the correct channelCount.

    if (nativeAudioDestinationNode.channelCount !== channelCount) {
      try {
        nativeAudioDestinationNode.channelCount = channelCount;
      } catch {// Bug #169: Safari throws an error on each attempt to change the channelCount.
      }
    } // Bug #83: Safari does not have the correct channelCountMode.


    if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {
      nativeAudioDestinationNode.channelCountMode = 'explicit';
    } // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.


    if (nativeAudioDestinationNode.maxChannelCount === 0) {
      Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {
        value: channelCount
      });
    } // Bug #168: No browser does yet have an AudioDestinationNode with an output.


    const gainNode = createNativeGainNode(nativeContext, {
      channelCount,
      channelCountMode: nativeAudioDestinationNode.channelCountMode,
      channelInterpretation: nativeAudioDestinationNode.channelInterpretation,
      gain: 1
    });
    overwriteAccessors(gainNode, 'channelCount', get => () => get.call(gainNode), set => value => {
      set.call(gainNode, value);

      try {
        nativeAudioDestinationNode.channelCount = value;
      } catch (err) {
        // Bug #169: Safari throws an error on each attempt to change the channelCount.
        if (value > nativeAudioDestinationNode.maxChannelCount) {
          throw err;
        }
      }
    });
    overwriteAccessors(gainNode, 'channelCountMode', get => () => get.call(gainNode), set => value => {
      set.call(gainNode, value);
      nativeAudioDestinationNode.channelCountMode = value;
    });
    overwriteAccessors(gainNode, 'channelInterpretation', get => () => get.call(gainNode), set => value => {
      set.call(gainNode, value);
      nativeAudioDestinationNode.channelInterpretation = value;
    });
    Object.defineProperty(gainNode, 'maxChannelCount', {
      get: () => nativeAudioDestinationNode.maxChannelCount
    }); // @todo This should be disconnected when the context is closed.

    gainNode.connect(nativeAudioDestinationNode);
    return gainNode;
  };
};

exports.createNativeAudioDestinationNodeFactory = createNativeAudioDestinationNodeFactory;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeAudioWorkletNodeConstructor = void 0;

const createNativeAudioWorkletNodeConstructor = window => {
  if (window === null) {
    return null;
  }

  return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;
};

exports.createNativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testClonabilityOfAudioWorkletNodeOptions = void 0;

const testClonabilityOfAudioWorkletNodeOptions = audioWorkletNodeOptions => {
  const {
    port1
  } = new MessageChannel();

  try {
    // This will throw an error if the audioWorkletNodeOptions are not clonable.
    port1.postMessage(audioWorkletNodeOptions);
  } finally {
    port1.close();
  }
};

exports.testClonabilityOfAudioWorkletNodeOptions = testClonabilityOfAudioWorkletNodeOptions;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeAudioWorkletNodeFactory = void 0;

var _testClonabilityOfAudioWorkletNodeOptions = require("../helpers/test-clonability-of-audio-worklet-node-options");

const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) => {
  return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {
    if (nativeAudioWorkletNodeConstructor !== null) {
      try {
        const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeContext, name, options);
        const patchedEventListeners = new Map();
        let onprocessorerror = null;
        Object.defineProperties(nativeAudioWorkletNode, {
          /*
           * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some
           * browsers have no native implementation to achieve a consistent behavior.
           */
          channelCount: {
            get: () => options.channelCount,
            set: () => {
              throw createInvalidStateError();
            }
          },
          channelCountMode: {
            get: () => 'explicit',
            set: () => {
              throw createInvalidStateError();
            }
          },
          // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.
          onprocessorerror: {
            get: () => onprocessorerror,
            set: value => {
              if (typeof onprocessorerror === 'function') {
                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);
              }

              onprocessorerror = typeof value === 'function' ? value : null;

              if (typeof onprocessorerror === 'function') {
                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);
              }
            }
          }
        });

        nativeAudioWorkletNode.addEventListener = (addEventListener => {
          return (...args) => {
            if (args[0] === 'processorerror') {
              const unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;

              if (unpatchedEventListener !== null) {
                const patchedEventListener = patchedEventListeners.get(args[1]);

                if (patchedEventListener !== undefined) {
                  args[1] = patchedEventListener;
                } else {
                  args[1] = event => {
                    // Bug #178: Chrome and Edge do fire an event of type error.
                    if (event.type === 'error') {
                      Object.defineProperties(event, {
                        type: {
                          value: 'processorerror'
                        }
                      });
                      unpatchedEventListener(event);
                    } else {
                      unpatchedEventListener(new ErrorEvent(args[0], { ...event
                      }));
                    }
                  };

                  patchedEventListeners.set(unpatchedEventListener, args[1]);
                }
              }
            } // Bug #178: Chrome and Edge do fire an event of type error.


            addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);
            return addEventListener.call(nativeAudioWorkletNode, ...args);
          };
        })(nativeAudioWorkletNode.addEventListener);

        nativeAudioWorkletNode.removeEventListener = (removeEventListener => {
          return (...args) => {
            if (args[0] === 'processorerror') {
              const patchedEventListener = patchedEventListeners.get(args[1]);

              if (patchedEventListener !== undefined) {
                patchedEventListeners.delete(args[1]);
                args[1] = patchedEventListener;
              }
            } // Bug #178: Chrome and Edge do fire an event of type error.


            removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);
            return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);
          };
        })(nativeAudioWorkletNode.removeEventListener);
        /*
         * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but
         * has an output.
         */


        if (options.numberOfOutputs !== 0) {
          const nativeGainNode = createNativeGainNode(nativeContext, {
            channelCount: 1,
            channelCountMode: 'explicit',
            channelInterpretation: 'discrete',
            gain: 0
          });
          nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);

          const whenConnected = () => nativeGainNode.disconnect();

          const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination); // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.


          return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);
        }

        return nativeAudioWorkletNode;
      } catch (err) {
        // Bug #60: Chrome & Edge throw an InvalidStateError instead of a NotSupportedError.
        if (err.code === 11) {
          throw createNotSupportedError();
        }

        throw err;
      }
    } // Bug #61: Only Chrome & Edge have an implementation of the AudioWorkletNode yet.


    if (processorConstructor === undefined) {
      throw createNotSupportedError();
    }

    (0, _testClonabilityOfAudioWorkletNodeOptions.testClonabilityOfAudioWorkletNodeOptions)(options);
    return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);
  };
};

exports.createNativeAudioWorkletNodeFactory = createNativeAudioWorkletNodeFactory;
},{"../helpers/test-clonability-of-audio-worklet-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeBufferSize = void 0;

const computeBufferSize = (baseLatency, sampleRate) => {
  if (baseLatency === null) {
    return 512;
  }

  return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));
};

exports.computeBufferSize = computeBufferSize;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneAudioWorkletNodeOptions = void 0;

const cloneAudioWorkletNodeOptions = audioWorkletNodeOptions => {
  return new Promise((resolve, reject) => {
    const {
      port1,
      port2
    } = new MessageChannel();

    port1.onmessage = ({
      data
    }) => {
      port1.close();
      port2.close();
      resolve(data);
    };

    port1.onmessageerror = ({
      data
    }) => {
      port1.close();
      port2.close();
      reject(data);
    }; // This will throw an error if the audioWorkletNodeOptions are not clonable.


    port2.postMessage(audioWorkletNodeOptions);
  });
};

exports.cloneAudioWorkletNodeOptions = cloneAudioWorkletNodeOptions;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioWorkletProcessorPromise = void 0;

var _cloneAudioWorkletNodeOptions = require("./clone-audio-worklet-node-options");

const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {
  const clonedAudioWorkletNodeOptions = await (0, _cloneAudioWorkletNodeOptions.cloneAudioWorkletNodeOptions)(audioWorkletNodeOptions);
  return new processorConstructor(clonedAudioWorkletNodeOptions);
};

exports.createAudioWorkletProcessorPromise = createAudioWorkletProcessorPromise;
},{"./clone-audio-worklet-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioWorkletProcessor = void 0;

var _globals = require("../globals");

var _createAudioWorkletProcessorPromise = require("./create-audio-worklet-processor-promise");

const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {
  let nodeToProcessorMap = _globals.NODE_TO_PROCESSOR_MAPS.get(nativeContext);

  if (nodeToProcessorMap === undefined) {
    nodeToProcessorMap = new WeakMap();

    _globals.NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);
  }

  const audioWorkletProcessorPromise = (0, _createAudioWorkletProcessorPromise.createAudioWorkletProcessorPromise)(processorConstructor, audioWorkletNodeOptions);
  nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);
  return audioWorkletProcessorPromise;
};

exports.createAudioWorkletProcessor = createAudioWorkletProcessor;
},{"../globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","./create-audio-worklet-processor-promise":"../node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeAudioWorkletNodeFakerFactory = void 0;

var _constants = require("../constants");

var _computeBufferSize = require("../helpers/compute-buffer-size");

var _copyFromChannel = require("../helpers/copy-from-channel");

var _copyToChannel = require("../helpers/copy-to-channel");

var _createAudioWorkletProcessor = require("../helpers/create-audio-worklet-processor");

var _createNestedArrays = require("../helpers/create-nested-arrays");

var _readOnlyMap = require("../read-only-map");

const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) => {
  return (nativeContext, baseLatency, processorConstructor, options) => {
    if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {
      throw createNotSupportedError();
    }

    const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.

    if (outputChannelCount.some(channelCount => channelCount < 1)) {
      throw createNotSupportedError();
    }

    if (outputChannelCount.length !== options.numberOfOutputs) {
      throw createIndexSizeError();
    } // Bug #61: This is not part of the standard but required for the faker to work.


    if (options.channelCountMode !== 'explicit') {
      throw createNotSupportedError();
    }

    const numberOfInputChannels = options.channelCount * options.numberOfInputs;
    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length; // Bug #61: This is not part of the standard but required for the faker to work.

    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {
      throw createNotSupportedError();
    }

    const messageChannel = new MessageChannel();
    const gainNodes = [];
    const inputChannelSplitterNodes = [];

    for (let i = 0; i < options.numberOfInputs; i += 1) {
      gainNodes.push(createNativeGainNode(nativeContext, {
        channelCount: options.channelCount,
        channelCountMode: options.channelCountMode,
        channelInterpretation: options.channelInterpretation,
        gain: 1
      }));
      inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {
        channelCount: options.channelCount,
        channelCountMode: 'explicit',
        channelInterpretation: 'discrete',
        numberOfOutputs: options.channelCount
      }));
    }

    const constantSourceNodes = [];

    if (processorConstructor.parameterDescriptors !== undefined) {
      for (const {
        defaultValue,
        maxValue,
        minValue,
        name
      } of processorConstructor.parameterDescriptors) {
        const constantSourceNode = createNativeConstantSourceNode(nativeContext, {
          channelCount: 1,
          channelCountMode: 'explicit',
          channelInterpretation: 'discrete',
          offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue
        });
        Object.defineProperties(constantSourceNode.offset, {
          defaultValue: {
            get: () => defaultValue === undefined ? 0 : defaultValue
          },
          maxValue: {
            get: () => maxValue === undefined ? _constants.MOST_POSITIVE_SINGLE_FLOAT : maxValue
          },
          minValue: {
            get: () => minValue === undefined ? _constants.MOST_NEGATIVE_SINGLE_FLOAT : minValue
          }
        });
        constantSourceNodes.push(constantSourceNode);
      }
    }

    const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {
      channelCount: 1,
      channelCountMode: 'explicit',
      channelInterpretation: 'speakers',
      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
    });
    const bufferSize = (0, _computeBufferSize.computeBufferSize)(baseLatency, nativeContext.sampleRate);
    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.
    Math.max(1, numberOfOutputChannels));
    const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {
      channelCount: Math.max(1, numberOfOutputChannels),
      channelCountMode: 'explicit',
      channelInterpretation: 'discrete',
      numberOfOutputs: Math.max(1, numberOfOutputChannels)
    });
    const outputChannelMergerNodes = [];

    for (let i = 0; i < options.numberOfOutputs; i += 1) {
      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {
        channelCount: 1,
        channelCountMode: 'explicit',
        channelInterpretation: 'speakers',
        numberOfInputs: outputChannelCount[i]
      }));
    }

    for (let i = 0; i < options.numberOfInputs; i += 1) {
      gainNodes[i].connect(inputChannelSplitterNodes[i]);

      for (let j = 0; j < options.channelCount; j += 1) {
        inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);
      }
    }

    const parameterMap = new _readOnlyMap.ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map(({
      name
    }, index) => {
      const constantSourceNode = constantSourceNodes[index];
      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);
      constantSourceNode.start(0);
      return [name, constantSourceNode.offset];
    }));
    inputChannelMergerNode.connect(scriptProcessorNode);
    let channelInterpretation = options.channelInterpretation;
    let onprocessorerror = null; // Bug #87: Expose at least one output to make this node connectable.

    const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;
    const nativeAudioWorkletNodeFaker = {
      get bufferSize() {
        return bufferSize;
      },

      get channelCount() {
        return options.channelCount;
      },

      set channelCount(_) {
        // Bug #61: This is not part of the standard but required for the faker to work.
        throw createInvalidStateError();
      },

      get channelCountMode() {
        return options.channelCountMode;
      },

      set channelCountMode(_) {
        // Bug #61: This is not part of the standard but required for the faker to work.
        throw createInvalidStateError();
      },

      get channelInterpretation() {
        return channelInterpretation;
      },

      set channelInterpretation(value) {
        for (const gainNode of gainNodes) {
          gainNode.channelInterpretation = value;
        }

        channelInterpretation = value;
      },

      get context() {
        return scriptProcessorNode.context;
      },

      get inputs() {
        return gainNodes;
      },

      get numberOfInputs() {
        return options.numberOfInputs;
      },

      get numberOfOutputs() {
        return options.numberOfOutputs;
      },

      get onprocessorerror() {
        return onprocessorerror;
      },

      set onprocessorerror(value) {
        if (typeof onprocessorerror === 'function') {
          nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);
        }

        onprocessorerror = typeof value === 'function' ? value : null;

        if (typeof onprocessorerror === 'function') {
          nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);
        }
      },

      get parameters() {
        return parameterMap;
      },

      get port() {
        return messageChannel.port2;
      },

      addEventListener(...args) {
        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
      },

      connect: connectMultipleOutputs.bind(null, outputAudioNodes),
      disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),

      dispatchEvent(...args) {
        return scriptProcessorNode.dispatchEvent(args[0]);
      },

      removeEventListener(...args) {
        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
      }

    };
    const patchedEventListeners = new Map();

    messageChannel.port1.addEventListener = (addEventListener => {
      return (...args) => {
        if (args[0] === 'message') {
          const unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;

          if (unpatchedEventListener !== null) {
            const patchedEventListener = patchedEventListeners.get(args[1]);

            if (patchedEventListener !== undefined) {
              args[1] = patchedEventListener;
            } else {
              args[1] = event => {
                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));
              };

              patchedEventListeners.set(unpatchedEventListener, args[1]);
            }
          }
        }

        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);
      };
    })(messageChannel.port1.addEventListener);

    messageChannel.port1.removeEventListener = (removeEventListener => {
      return (...args) => {
        if (args[0] === 'message') {
          const patchedEventListener = patchedEventListeners.get(args[1]);

          if (patchedEventListener !== undefined) {
            patchedEventListeners.delete(args[1]);
            args[1] = patchedEventListener;
          }
        }

        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);
      };
    })(messageChannel.port1.removeEventListener);

    let onmessage = null;
    Object.defineProperty(messageChannel.port1, 'onmessage', {
      get: () => onmessage,
      set: value => {
        if (typeof onmessage === 'function') {
          messageChannel.port1.removeEventListener('message', onmessage);
        }

        onmessage = typeof value === 'function' ? value : null;

        if (typeof onmessage === 'function') {
          messageChannel.port1.addEventListener('message', onmessage);
          messageChannel.port1.start();
        }
      }
    });
    processorConstructor.prototype.port = messageChannel.port1;
    let audioWorkletProcessor = null;
    const audioWorkletProcessorPromise = (0, _createAudioWorkletProcessor.createAudioWorkletProcessor)(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);
    audioWorkletProcessorPromise.then(dWrkltPrcssr => audioWorkletProcessor = dWrkltPrcssr);
    const inputs = (0, _createNestedArrays.createNestedArrays)(options.numberOfInputs, options.channelCount);
    const outputs = (0, _createNestedArrays.createNestedArrays)(options.numberOfOutputs, outputChannelCount);
    const parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, {
      name
    }) => ({ ...prmtrs,
      [name]: new Float32Array(128)
    }), {});
    let isActive = true;

    const disconnectOutputsGraph = () => {
      if (options.numberOfOutputs > 0) {
        scriptProcessorNode.disconnect(outputChannelSplitterNode);
      }

      for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {
        const outputChannelMergerNode = outputChannelMergerNodes[i];

        for (let j = 0; j < outputChannelCount[i]; j += 1) {
          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);
        }

        outputChannelSplitterNodeOutput += outputChannelCount[i];
      }
    };

    const activeInputIndexes = new Map(); // tslint:disable-next-line:deprecation

    scriptProcessorNode.onaudioprocess = ({
      inputBuffer,
      outputBuffer
    }) => {
      if (audioWorkletProcessor !== null) {
        const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);

        for (let i = 0; i < bufferSize; i += 128) {
          for (let j = 0; j < options.numberOfInputs; j += 1) {
            for (let k = 0; k < options.channelCount; k += 1) {
              (0, _copyFromChannel.copyFromChannel)(inputBuffer, inputs[j], k, k, i);
            }
          }

          if (processorConstructor.parameterDescriptors !== undefined) {
            processorConstructor.parameterDescriptors.forEach(({
              name
            }, index) => {
              (0, _copyFromChannel.copyFromChannel)(inputBuffer, parameters, name, numberOfInputChannels + index, i);
            });
          }

          for (let j = 0; j < options.numberOfInputs; j += 1) {
            for (let k = 0; k < outputChannelCount[j]; k += 1) {
              // The byteLength will be 0 when the ArrayBuffer was transferred.
              if (outputs[j][k].byteLength === 0) {
                outputs[j][k] = new Float32Array(128);
              }
            }
          }

          try {
            const potentiallyEmptyInputs = inputs.map((input, index) => {
              const activeInput = activeInputs[index];

              if (activeInput.size > 0) {
                activeInputIndexes.set(index, bufferSize / 128);
                return input;
              }

              const count = activeInputIndexes.get(index);

              if (count === undefined) {
                return [];
              }

              if (input.every(channelData => channelData.every(sample => sample === 0))) {
                if (count === 1) {
                  activeInputIndexes.delete(index);
                } else {
                  activeInputIndexes.set(index, count - 1);
                }
              }

              return input;
            });
            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));
            isActive = activeSourceFlag;

            for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {
              for (let k = 0; k < outputChannelCount[j]; k += 1) {
                (0, _copyToChannel.copyToChannel)(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);
              }

              outputChannelSplitterNodeOutput += outputChannelCount[j];
            }
          } catch (error) {
            isActive = false;
            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {
              colno: error.colno,
              filename: error.filename,
              lineno: error.lineno,
              message: error.message
            }));
          }

          if (!isActive) {
            for (let j = 0; j < options.numberOfInputs; j += 1) {
              gainNodes[j].disconnect(inputChannelSplitterNodes[j]);

              for (let k = 0; k < options.channelCount; k += 1) {
                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);
              }
            }

            if (processorConstructor.parameterDescriptors !== undefined) {
              const length = processorConstructor.parameterDescriptors.length;

              for (let j = 0; j < length; j += 1) {
                const constantSourceNode = constantSourceNodes[j];
                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);
                constantSourceNode.stop();
              }
            }

            inputChannelMergerNode.disconnect(scriptProcessorNode);
            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation

            if (isConnected) {
              disconnectOutputsGraph();
            } else {
              disconnectFakeGraph();
            }

            break;
          }
        }
      }
    };

    let isConnected = false; // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.

    const nativeGainNode = createNativeGainNode(nativeContext, {
      channelCount: 1,
      channelCountMode: 'explicit',
      channelInterpretation: 'discrete',
      gain: 0
    });

    const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);

    const disconnectFakeGraph = () => {
      scriptProcessorNode.disconnect(nativeGainNode);
      nativeGainNode.disconnect();
    };

    const whenConnected = () => {
      if (isActive) {
        disconnectFakeGraph();

        if (options.numberOfOutputs > 0) {
          scriptProcessorNode.connect(outputChannelSplitterNode);
        }

        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {
          const outputChannelMergerNode = outputChannelMergerNodes[i];

          for (let j = 0; j < outputChannelCount[i]; j += 1) {
            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);
          }

          outputChannelSplitterNodeOutput += outputChannelCount[i];
        }
      }

      isConnected = true;
    };

    const whenDisconnected = () => {
      if (isActive) {
        connectFakeGraph();
        disconnectOutputsGraph();
      }

      isConnected = false;
    };

    connectFakeGraph();
    return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);
  };
};

exports.createNativeAudioWorkletNodeFakerFactory = createNativeAudioWorkletNodeFakerFactory;
},{"../constants":"../node_modules/standardized-audio-context/build/es2019/constants.js","../helpers/compute-buffer-size":"../node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js","../helpers/copy-from-channel":"../node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js","../helpers/copy-to-channel":"../node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js","../helpers/create-audio-worklet-processor":"../node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js","../helpers/create-nested-arrays":"../node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js","../read-only-map":"../node_modules/standardized-audio-context/build/es2019/read-only-map.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-biquad-filter-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeBiquadFilterNode = void 0;

var _assignNativeAudioNodeAudioParamValue = require("../helpers/assign-native-audio-node-audio-param-value");

var _assignNativeAudioNodeOption = require("../helpers/assign-native-audio-node-option");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

const createNativeBiquadFilterNode = (nativeContext, options) => {
  const nativeBiquadFilterNode = nativeContext.createBiquadFilter();
  (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeBiquadFilterNode, options);
  (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeBiquadFilterNode, options, 'Q');
  (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeBiquadFilterNode, options, 'detune');
  (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeBiquadFilterNode, options, 'frequency');
  (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeBiquadFilterNode, options, 'gain');
  (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeBiquadFilterNode, options, 'type');
  return nativeBiquadFilterNode;
};

exports.createNativeBiquadFilterNode = createNativeBiquadFilterNode;
},{"../helpers/assign-native-audio-node-audio-param-value":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","../helpers/assign-native-audio-node-option":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeChannelMergerNodeFactory = void 0;

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

const createNativeChannelMergerNodeFactory = (nativeAudioContextConstructor, wrapChannelMergerNode) => {
  return (nativeContext, options) => {
    const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);
    /*
     * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.
     * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of
     * the webkitAudioContext is used as a workaround here.
     */

    if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {
      wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);
    }

    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeChannelMergerNode, options);
    return nativeChannelMergerNode;
  };
};

exports.createNativeChannelMergerNodeFactory = createNativeChannelMergerNodeFactory;
},{"../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapChannelSplitterNode = void 0;

var _invalidStateError = require("../factories/invalid-state-error");

const wrapChannelSplitterNode = channelSplitterNode => {
  const channelCount = channelSplitterNode.numberOfOutputs; // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.

  Object.defineProperty(channelSplitterNode, 'channelCount', {
    get: () => channelCount,
    set: value => {
      if (value !== channelCount) {
        throw (0, _invalidStateError.createInvalidStateError)();
      }
    }
  }); // Bug #30: Safari does not throw an error when attempting to change the channelCountMode to something other than explicit.

  Object.defineProperty(channelSplitterNode, 'channelCountMode', {
    get: () => 'explicit',
    set: value => {
      if (value !== 'explicit') {
        throw (0, _invalidStateError.createInvalidStateError)();
      }
    }
  }); // Bug #32: Safari does not throw an error when attempting to change the channelInterpretation to something other than discrete.

  Object.defineProperty(channelSplitterNode, 'channelInterpretation', {
    get: () => 'discrete',
    set: value => {
      if (value !== 'discrete') {
        throw (0, _invalidStateError.createInvalidStateError)();
      }
    }
  });
};

exports.wrapChannelSplitterNode = wrapChannelSplitterNode;
},{"../factories/invalid-state-error":"../node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeChannelSplitterNode = void 0;

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

var _wrapChannelSplitterNode = require("../helpers/wrap-channel-splitter-node");

const createNativeChannelSplitterNode = (nativeContext, options) => {
  const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs); // Bug #96: Safari does not have the correct channelCount.
  // Bug #29: Safari does not have the correct channelCountMode.
  // Bug #31: Safari does not have the correct channelInterpretation.

  (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeChannelSplitterNode, options); // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Edge & Firefox partially support the spec yet.

  (0, _wrapChannelSplitterNode.wrapChannelSplitterNode)(nativeChannelSplitterNode);
  return nativeChannelSplitterNode;
};

exports.createNativeChannelSplitterNode = createNativeChannelSplitterNode;
},{"../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","../helpers/wrap-channel-splitter-node":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeConstantSourceNodeFactory = void 0;

var _assignNativeAudioNodeAudioParamValue = require("../helpers/assign-native-audio-node-audio-param-value");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

var _wrapAudioScheduledSourceNodeStartMethodNegativeParameters = require("../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters");

var _wrapAudioScheduledSourceNodeStopMethodNegativeParameters = require("../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters");

const createNativeConstantSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) => {
  return (nativeContext, options) => {
    // Bug #62: Safari does not support ConstantSourceNodes.
    if (nativeContext.createConstantSource === undefined) {
      return createNativeConstantSourceNodeFaker(nativeContext, options);
    }

    const nativeConstantSourceNode = nativeContext.createConstantSource();
    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeConstantSourceNode, options);
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeConstantSourceNode, options, 'offset'); // Bug #44: Safari does not throw a RangeError yet.

    if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {
      (0, _wrapAudioScheduledSourceNodeStartMethodNegativeParameters.wrapAudioScheduledSourceNodeStartMethodNegativeParameters)(nativeConstantSourceNode);
    } // Bug #44: Only Firefox does not throw a RangeError yet.


    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {
      (0, _wrapAudioScheduledSourceNodeStopMethodNegativeParameters.wrapAudioScheduledSourceNodeStopMethodNegativeParameters)(nativeConstantSourceNode);
    } // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.


    addSilentConnection(nativeContext, nativeConstantSourceNode);
    return nativeConstantSourceNode;
  };
};

exports.createNativeConstantSourceNodeFactory = createNativeConstantSourceNodeFactory;
},{"../helpers/assign-native-audio-node-audio-param-value":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interceptConnections = void 0;

const interceptConnections = (original, interceptor) => {
  original.connect = interceptor.connect.bind(interceptor);
  original.disconnect = interceptor.disconnect.bind(interceptor);
  return original;
};

exports.interceptConnections = interceptConnections;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeConstantSourceNodeFakerFactory = void 0;

var _interceptConnections = require("../helpers/intercept-connections");

const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {
  return (nativeContext, {
    offset,
    ...audioNodeOptions
  }) => {
    const audioBuffer = nativeContext.createBuffer(1, 2, 44100);
    const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {
      buffer: null,
      channelCount: 2,
      channelCountMode: 'max',
      channelInterpretation: 'speakers',
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      playbackRate: 1
    });
    const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,
      gain: offset
    }); // Bug #5: Safari does not support copyFromChannel() and copyToChannel().

    const channelData = audioBuffer.getChannelData(0); // Bug #95: Safari does not play or loop one sample buffers.

    channelData[0] = 1;
    channelData[1] = 1;
    audioBufferSourceNode.buffer = audioBuffer;
    audioBufferSourceNode.loop = true;
    const nativeConstantSourceNodeFaker = {
      get bufferSize() {
        return undefined;
      },

      get channelCount() {
        return gainNode.channelCount;
      },

      set channelCount(value) {
        gainNode.channelCount = value;
      },

      get channelCountMode() {
        return gainNode.channelCountMode;
      },

      set channelCountMode(value) {
        gainNode.channelCountMode = value;
      },

      get channelInterpretation() {
        return gainNode.channelInterpretation;
      },

      set channelInterpretation(value) {
        gainNode.channelInterpretation = value;
      },

      get context() {
        return gainNode.context;
      },

      get inputs() {
        return [];
      },

      get numberOfInputs() {
        return audioBufferSourceNode.numberOfInputs;
      },

      get numberOfOutputs() {
        return gainNode.numberOfOutputs;
      },

      get offset() {
        return gainNode.gain;
      },

      get onended() {
        return audioBufferSourceNode.onended;
      },

      set onended(value) {
        audioBufferSourceNode.onended = value;
      },

      addEventListener(...args) {
        return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);
      },

      dispatchEvent(...args) {
        return audioBufferSourceNode.dispatchEvent(args[0]);
      },

      removeEventListener(...args) {
        return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);
      },

      start(when = 0) {
        audioBufferSourceNode.start.call(audioBufferSourceNode, when);
      },

      stop(when = 0) {
        audioBufferSourceNode.stop.call(audioBufferSourceNode, when);
      }

    };

    const whenConnected = () => audioBufferSourceNode.connect(gainNode);

    const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode); // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.


    addSilentConnection(nativeContext, audioBufferSourceNode);
    return monitorConnections((0, _interceptConnections.interceptConnections)(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);
  };
};

exports.createNativeConstantSourceNodeFakerFactory = createNativeConstantSourceNodeFakerFactory;
},{"../helpers/intercept-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeConvolverNodeFactory = void 0;

var _assignNativeAudioNodeOption = require("../helpers/assign-native-audio-node-option");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

const createNativeConvolverNodeFactory = (createNotSupportedError, overwriteAccessors) => {
  return (nativeContext, options) => {
    const nativeConvolverNode = nativeContext.createConvolver();
    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeConvolverNode, options); // The normalize property needs to be set before setting the buffer.

    if (options.disableNormalization === nativeConvolverNode.normalize) {
      nativeConvolverNode.normalize = !options.disableNormalization;
    }

    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeConvolverNode, options, 'buffer'); // Bug #113: Safari does allow to set the channelCount to a value larger than 2.

    if (options.channelCount > 2) {
      throw createNotSupportedError();
    }

    overwriteAccessors(nativeConvolverNode, 'channelCount', get => () => get.call(nativeConvolverNode), set => value => {
      if (value > 2) {
        throw createNotSupportedError();
      }

      return set.call(nativeConvolverNode, value);
    }); // Bug #114: Safari allows to set the channelCountMode to 'max'.

    if (options.channelCountMode === 'max') {
      throw createNotSupportedError();
    }

    overwriteAccessors(nativeConvolverNode, 'channelCountMode', get => () => get.call(nativeConvolverNode), set => value => {
      if (value === 'max') {
        throw createNotSupportedError();
      }

      return set.call(nativeConvolverNode, value);
    });
    return nativeConvolverNode;
  };
};

exports.createNativeConvolverNodeFactory = createNativeConvolverNodeFactory;
},{"../helpers/assign-native-audio-node-option":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-delay-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeDelayNode = void 0;

var _assignNativeAudioNodeAudioParamValue = require("../helpers/assign-native-audio-node-audio-param-value");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

const createNativeDelayNode = (nativeContext, options) => {
  const nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);
  (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeDelayNode, options);
  (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeDelayNode, options, 'delayTime');
  return nativeDelayNode;
};

exports.createNativeDelayNode = createNativeDelayNode;
},{"../helpers/assign-native-audio-node-audio-param-value":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-dynamics-compressor-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeDynamicsCompressorNodeFactory = void 0;

var _assignNativeAudioNodeAudioParamValue = require("../helpers/assign-native-audio-node-audio-param-value");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

const createNativeDynamicsCompressorNodeFactory = createNotSupportedError => {
  return (nativeContext, options) => {
    const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();
    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeDynamicsCompressorNode, options); // Bug #108: Safari allows a channelCount of three and above.

    if (options.channelCount > 2) {
      throw createNotSupportedError();
    } // Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max'.


    if (options.channelCountMode === 'max') {
      throw createNotSupportedError();
    }

    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeDynamicsCompressorNode, options, 'attack');
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeDynamicsCompressorNode, options, 'knee');
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeDynamicsCompressorNode, options, 'ratio');
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeDynamicsCompressorNode, options, 'release');
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeDynamicsCompressorNode, options, 'threshold');
    return nativeDynamicsCompressorNode;
  };
};

exports.createNativeDynamicsCompressorNodeFactory = createNativeDynamicsCompressorNodeFactory;
},{"../helpers/assign-native-audio-node-audio-param-value":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-gain-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeGainNode = void 0;

var _assignNativeAudioNodeAudioParamValue = require("../helpers/assign-native-audio-node-audio-param-value");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

const createNativeGainNode = (nativeContext, options) => {
  const nativeGainNode = nativeContext.createGain();
  (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeGainNode, options);
  (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeGainNode, options, 'gain');
  return nativeGainNode;
};

exports.createNativeGainNode = createNativeGainNode;
},{"../helpers/assign-native-audio-node-audio-param-value":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeIIRFilterNodeFactory = void 0;

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

const createNativeIIRFilterNodeFactory = createNativeIIRFilterNodeFaker => {
  return (nativeContext, baseLatency, options) => {
    // Bug #9: Safari does not support IIRFilterNodes.
    if (nativeContext.createIIRFilter === undefined) {
      return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);
    } // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.


    const nativeIIRFilterNode = nativeContext.createIIRFilter(options.feedforward, options.feedback);
    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeIIRFilterNode, options);
    return nativeIIRFilterNode;
  };
};

exports.createNativeIIRFilterNodeFactory = createNativeIIRFilterNodeFactory;
},{"../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeIIRFilterNodeFakerFactory = void 0;

var _computeBufferSize = require("../helpers/compute-buffer-size");

var _filterBuffer = require("../helpers/filter-buffer");

var _interceptConnections = require("../helpers/intercept-connections");

function divide(a, b) {
  const denominator = b[0] * b[0] + b[1] * b[1];
  return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
}

function multiply(a, b) {
  return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];
}

function evaluatePolynomial(coefficient, z) {
  let result = [0, 0];

  for (let i = coefficient.length - 1; i >= 0; i -= 1) {
    result = multiply(result, z);
    result[0] += coefficient[i];
  }

  return result;
}

const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) => {
  return (nativeContext, baseLatency, {
    channelCount,
    channelCountMode,
    channelInterpretation,
    feedback,
    feedforward
  }) => {
    const bufferSize = (0, _computeBufferSize.computeBufferSize)(baseLatency, nativeContext.sampleRate);
    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
    const feedbackLength = convertedFeedback.length;
    const feedforwardLength = convertedFeedforward.length;
    const minLength = Math.min(feedbackLength, feedforwardLength);

    if (feedbackLength === 0 || feedbackLength > 20) {
      throw createNotSupportedError();
    }

    if (convertedFeedback[0] === 0) {
      throw createInvalidStateError();
    }

    if (feedforwardLength === 0 || feedforwardLength > 20) {
      throw createNotSupportedError();
    }

    if (convertedFeedforward[0] === 0) {
      throw createInvalidStateError();
    }

    if (convertedFeedback[0] !== 1) {
      for (let i = 0; i < feedforwardLength; i += 1) {
        convertedFeedforward[i] /= convertedFeedback[0];
      }

      for (let i = 1; i < feedbackLength; i += 1) {
        convertedFeedback[i] /= convertedFeedback[0];
      }
    }

    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);
    scriptProcessorNode.channelCount = channelCount;
    scriptProcessorNode.channelCountMode = channelCountMode;
    scriptProcessorNode.channelInterpretation = channelInterpretation;
    const bufferLength = 32;
    const bufferIndexes = [];
    const xBuffers = [];
    const yBuffers = [];

    for (let i = 0; i < channelCount; i += 1) {
      bufferIndexes.push(0);
      const xBuffer = new Float32Array(bufferLength);
      const yBuffer = new Float32Array(bufferLength);
      xBuffer.fill(0);
      yBuffer.fill(0);
      xBuffers.push(xBuffer);
      yBuffers.push(yBuffer);
    } // tslint:disable-next-line:deprecation


    scriptProcessorNode.onaudioprocess = event => {
      const inputBuffer = event.inputBuffer;
      const outputBuffer = event.outputBuffer;
      const numberOfChannels = inputBuffer.numberOfChannels;

      for (let i = 0; i < numberOfChannels; i += 1) {
        const input = inputBuffer.getChannelData(i);
        const output = outputBuffer.getChannelData(i);
        bufferIndexes[i] = (0, _filterBuffer.filterBuffer)(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);
      }
    };

    const nyquist = nativeContext.sampleRate / 2;
    const nativeIIRFilterNodeFaker = {
      get bufferSize() {
        return bufferSize;
      },

      get channelCount() {
        return scriptProcessorNode.channelCount;
      },

      set channelCount(value) {
        scriptProcessorNode.channelCount = value;
      },

      get channelCountMode() {
        return scriptProcessorNode.channelCountMode;
      },

      set channelCountMode(value) {
        scriptProcessorNode.channelCountMode = value;
      },

      get channelInterpretation() {
        return scriptProcessorNode.channelInterpretation;
      },

      set channelInterpretation(value) {
        scriptProcessorNode.channelInterpretation = value;
      },

      get context() {
        return scriptProcessorNode.context;
      },

      get inputs() {
        return [scriptProcessorNode];
      },

      get numberOfInputs() {
        return scriptProcessorNode.numberOfInputs;
      },

      get numberOfOutputs() {
        return scriptProcessorNode.numberOfOutputs;
      },

      addEventListener(...args) {
        // @todo Dissallow adding an audioprocess listener.
        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
      },

      dispatchEvent(...args) {
        return scriptProcessorNode.dispatchEvent(args[0]);
      },

      getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
        if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
          throw createInvalidAccessError();
        }

        const length = frequencyHz.length;

        for (let i = 0; i < length; i += 1) {
          const omega = -Math.PI * (frequencyHz[i] / nyquist);
          const z = [Math.cos(omega), Math.sin(omega)];
          const numerator = evaluatePolynomial(convertedFeedforward, z);
          const denominator = evaluatePolynomial(convertedFeedback, z);
          const response = divide(numerator, denominator);
          magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);
          phaseResponse[i] = Math.atan2(response[1], response[0]);
        }
      },

      removeEventListener(...args) {
        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
      }

    };
    return (0, _interceptConnections.interceptConnections)(nativeIIRFilterNodeFaker, scriptProcessorNode);
  };
};

exports.createNativeIIRFilterNodeFakerFactory = createNativeIIRFilterNodeFakerFactory;
},{"../helpers/compute-buffer-size":"../node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js","../helpers/filter-buffer":"../node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js","../helpers/intercept-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-media-element-audio-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeMediaElementAudioSourceNode = void 0;

const createNativeMediaElementAudioSourceNode = (nativeAudioContext, options) => {
  return nativeAudioContext.createMediaElementSource(options.mediaElement);
};

exports.createNativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-destination-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeMediaStreamAudioDestinationNode = void 0;

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

const createNativeMediaStreamAudioDestinationNode = (nativeAudioContext, options) => {
  const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();
  (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeMediaStreamAudioDestinationNode, options); // Bug #174: Safari does expose a wrong numberOfOutputs.

  if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {
    Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', {
      get: () => 0
    });
  }

  return nativeMediaStreamAudioDestinationNode;
};

exports.createNativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode;
},{"../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeMediaStreamAudioSourceNode = void 0;

const createNativeMediaStreamAudioSourceNode = (nativeAudioContext, {
  mediaStream
}) => {
  const audioStreamTracks = mediaStream.getAudioTracks();
  /*
   * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.
   * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.
   */

  audioStreamTracks.sort((a, b) => a.id < b.id ? -1 : a.id > b.id ? 1 : 0);
  const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);
  const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));
  /*
   * Bug #151 & #159: The given mediaStream gets reconstructed before it gets passed to the native node which is why the accessor needs
   * to be overwritten as it would otherwise expose the reconstructed version.
   */

  Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', {
    value: mediaStream
  });
  return nativeMediaStreamAudioSourceNode;
};

exports.createNativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeMediaStreamTrackAudioSourceNodeFactory = void 0;

const createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError, isNativeOfflineAudioContext) => {
  return (nativeAudioContext, {
    mediaStreamTrack
  }) => {
    // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.
    if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {
      return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);
    }

    const mediaStream = new MediaStream([mediaStreamTrack]);
    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream); // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.

    if (mediaStreamTrack.kind !== 'audio') {
      throw createInvalidStateError();
    } // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.


    if (isNativeOfflineAudioContext(nativeAudioContext)) {
      throw new TypeError();
    }

    return nativeMediaStreamAudioSourceNode;
  };
};

exports.createNativeMediaStreamTrackAudioSourceNodeFactory = createNativeMediaStreamTrackAudioSourceNodeFactory;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeOfflineAudioContextConstructor = void 0;

const createNativeOfflineAudioContextConstructor = window => {
  if (window === null) {
    return null;
  }

  if (window.hasOwnProperty('OfflineAudioContext')) {
    return window.OfflineAudioContext;
  }

  return window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;
};

exports.createNativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-oscillator-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeOscillatorNodeFactory = void 0;

var _assignNativeAudioNodeAudioParamValue = require("../helpers/assign-native-audio-node-audio-param-value");

var _assignNativeAudioNodeOption = require("../helpers/assign-native-audio-node-option");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

var _wrapAudioScheduledSourceNodeStartMethodNegativeParameters = require("../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters");

var _wrapAudioScheduledSourceNodeStopMethodNegativeParameters = require("../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters");

const createNativeOscillatorNodeFactory = (addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {
  return (nativeContext, options) => {
    const nativeOscillatorNode = nativeContext.createOscillator();
    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeOscillatorNode, options);
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeOscillatorNode, options, 'detune');
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeOscillatorNode, options, 'frequency');

    if (options.periodicWave !== undefined) {
      nativeOscillatorNode.setPeriodicWave(options.periodicWave);
    } else {
      (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeOscillatorNode, options, 'type');
    } // Bug #44: Only Chrome & Edge throw a RangeError yet.


    if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {
      (0, _wrapAudioScheduledSourceNodeStartMethodNegativeParameters.wrapAudioScheduledSourceNodeStartMethodNegativeParameters)(nativeOscillatorNode);
    } // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.


    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {
      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);
    } // Bug #44: Only Firefox does not throw a RangeError yet.


    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {
      (0, _wrapAudioScheduledSourceNodeStopMethodNegativeParameters.wrapAudioScheduledSourceNodeStopMethodNegativeParameters)(nativeOscillatorNode);
    } // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.


    addSilentConnection(nativeContext, nativeOscillatorNode);
    return nativeOscillatorNode;
  };
};

exports.createNativeOscillatorNodeFactory = createNativeOscillatorNodeFactory;
},{"../helpers/assign-native-audio-node-audio-param-value":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","../helpers/assign-native-audio-node-option":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativePannerNodeFactory = void 0;

var _assignNativeAudioNodeAudioParamValue = require("../helpers/assign-native-audio-node-audio-param-value");

var _assignNativeAudioNodeOption = require("../helpers/assign-native-audio-node-option");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

const createNativePannerNodeFactory = createNativePannerNodeFaker => {
  return (nativeContext, options) => {
    const nativePannerNode = nativeContext.createPanner(); // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.

    if (nativePannerNode.orientationX === undefined) {
      return createNativePannerNodeFaker(nativeContext, options);
    }

    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativePannerNode, options);
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativePannerNode, options, 'orientationX');
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativePannerNode, options, 'orientationY');
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativePannerNode, options, 'orientationZ');
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativePannerNode, options, 'positionX');
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativePannerNode, options, 'positionY');
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativePannerNode, options, 'positionZ');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativePannerNode, options, 'coneInnerAngle');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativePannerNode, options, 'coneOuterAngle');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativePannerNode, options, 'coneOuterGain');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativePannerNode, options, 'distanceModel');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativePannerNode, options, 'maxDistance');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativePannerNode, options, 'panningModel');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativePannerNode, options, 'refDistance');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativePannerNode, options, 'rolloffFactor');
    return nativePannerNode;
  };
};

exports.createNativePannerNodeFactory = createNativePannerNodeFactory;
},{"../helpers/assign-native-audio-node-audio-param-value":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","../helpers/assign-native-audio-node-option":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativePannerNodeFakerFactory = void 0;

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

var _interceptConnections = require("../helpers/intercept-connections");

const createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections) => {
  return (nativeContext, {
    coneInnerAngle,
    coneOuterAngle,
    coneOuterGain,
    distanceModel,
    maxDistance,
    orientationX,
    orientationY,
    orientationZ,
    panningModel,
    positionX,
    positionY,
    positionZ,
    refDistance,
    rolloffFactor,
    ...audioNodeOptions
  }) => {
    const pannerNode = nativeContext.createPanner(); // Bug #125: Safari does not throw an error yet.

    if (audioNodeOptions.channelCount > 2) {
      throw createNotSupportedError();
    } // Bug #126: Safari does not throw an error yet.


    if (audioNodeOptions.channelCountMode === 'max') {
      throw createNotSupportedError();
    }

    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(pannerNode, audioNodeOptions);
    const SINGLE_CHANNEL_OPTIONS = {
      channelCount: 1,
      channelCountMode: 'explicit',
      channelInterpretation: 'discrete'
    };
    const channelMergerNode = createNativeChannelMergerNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      channelInterpretation: 'speakers',
      numberOfInputs: 6
    });
    const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,
      gain: 1
    });
    const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 1
    });
    const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 0
    });
    const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 0
    });
    const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 0
    });
    const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 0
    });
    const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 0
    });
    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);
    const waveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      curve: new Float32Array([1, 1]),
      oversample: 'none'
    });
    let lastOrientation = [orientationX, orientationY, orientationZ];
    let lastPosition = [positionX, positionY, positionZ];
    const buffer = new Float32Array(1); // tslint:disable-next-line:deprecation

    scriptProcessorNode.onaudioprocess = ({
      inputBuffer
    }) => {
      const orientation = [getFirstSample(inputBuffer, buffer, 0), getFirstSample(inputBuffer, buffer, 1), getFirstSample(inputBuffer, buffer, 2)];

      if (orientation.some((value, index) => value !== lastOrientation[index])) {
        pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation

        lastOrientation = orientation;
      }

      const positon = [getFirstSample(inputBuffer, buffer, 3), getFirstSample(inputBuffer, buffer, 4), getFirstSample(inputBuffer, buffer, 5)];

      if (positon.some((value, index) => value !== lastPosition[index])) {
        pannerNode.setPosition(...positon); // tslint:disable-line:deprecation

        lastPosition = positon;
      }
    };

    Object.defineProperty(orientationYGainNode.gain, 'defaultValue', {
      get: () => 0
    });
    Object.defineProperty(orientationZGainNode.gain, 'defaultValue', {
      get: () => 0
    });
    Object.defineProperty(positionXGainNode.gain, 'defaultValue', {
      get: () => 0
    });
    Object.defineProperty(positionYGainNode.gain, 'defaultValue', {
      get: () => 0
    });
    Object.defineProperty(positionZGainNode.gain, 'defaultValue', {
      get: () => 0
    });
    const nativePannerNodeFaker = {
      get bufferSize() {
        return undefined;
      },

      get channelCount() {
        return pannerNode.channelCount;
      },

      set channelCount(value) {
        // Bug #125: Safari does not throw an error yet.
        if (value > 2) {
          throw createNotSupportedError();
        }

        inputGainNode.channelCount = value;
        pannerNode.channelCount = value;
      },

      get channelCountMode() {
        return pannerNode.channelCountMode;
      },

      set channelCountMode(value) {
        // Bug #126: Safari does not throw an error yet.
        if (value === 'max') {
          throw createNotSupportedError();
        }

        inputGainNode.channelCountMode = value;
        pannerNode.channelCountMode = value;
      },

      get channelInterpretation() {
        return pannerNode.channelInterpretation;
      },

      set channelInterpretation(value) {
        inputGainNode.channelInterpretation = value;
        pannerNode.channelInterpretation = value;
      },

      get coneInnerAngle() {
        return pannerNode.coneInnerAngle;
      },

      set coneInnerAngle(value) {
        pannerNode.coneInnerAngle = value;
      },

      get coneOuterAngle() {
        return pannerNode.coneOuterAngle;
      },

      set coneOuterAngle(value) {
        pannerNode.coneOuterAngle = value;
      },

      get coneOuterGain() {
        return pannerNode.coneOuterGain;
      },

      set coneOuterGain(value) {
        // Bug #127: Safari does not throw an InvalidStateError yet.
        if (value < 0 || value > 1) {
          throw createInvalidStateError();
        }

        pannerNode.coneOuterGain = value;
      },

      get context() {
        return pannerNode.context;
      },

      get distanceModel() {
        return pannerNode.distanceModel;
      },

      set distanceModel(value) {
        pannerNode.distanceModel = value;
      },

      get inputs() {
        return [inputGainNode];
      },

      get maxDistance() {
        return pannerNode.maxDistance;
      },

      set maxDistance(value) {
        // Bug #128: Safari does not throw an error yet.
        if (value < 0) {
          throw new RangeError();
        }

        pannerNode.maxDistance = value;
      },

      get numberOfInputs() {
        return pannerNode.numberOfInputs;
      },

      get numberOfOutputs() {
        return pannerNode.numberOfOutputs;
      },

      get orientationX() {
        return orientationXGainNode.gain;
      },

      get orientationY() {
        return orientationYGainNode.gain;
      },

      get orientationZ() {
        return orientationZGainNode.gain;
      },

      get panningModel() {
        return pannerNode.panningModel;
      },

      set panningModel(value) {
        pannerNode.panningModel = value;
      },

      get positionX() {
        return positionXGainNode.gain;
      },

      get positionY() {
        return positionYGainNode.gain;
      },

      get positionZ() {
        return positionZGainNode.gain;
      },

      get refDistance() {
        return pannerNode.refDistance;
      },

      set refDistance(value) {
        // Bug #129: Safari does not throw an error yet.
        if (value < 0) {
          throw new RangeError();
        }

        pannerNode.refDistance = value;
      },

      get rolloffFactor() {
        return pannerNode.rolloffFactor;
      },

      set rolloffFactor(value) {
        // Bug #130: Safari does not throw an error yet.
        if (value < 0) {
          throw new RangeError();
        }

        pannerNode.rolloffFactor = value;
      },

      addEventListener(...args) {
        return inputGainNode.addEventListener(args[0], args[1], args[2]);
      },

      dispatchEvent(...args) {
        return inputGainNode.dispatchEvent(args[0]);
      },

      removeEventListener(...args) {
        return inputGainNode.removeEventListener(args[0], args[1], args[2]);
      }

    };

    if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {
      nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;
    }

    if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {
      nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;
    }

    if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {
      nativePannerNodeFaker.coneOuterGain = coneOuterGain;
    }

    if (distanceModel !== nativePannerNodeFaker.distanceModel) {
      nativePannerNodeFaker.distanceModel = distanceModel;
    }

    if (maxDistance !== nativePannerNodeFaker.maxDistance) {
      nativePannerNodeFaker.maxDistance = maxDistance;
    }

    if (orientationX !== nativePannerNodeFaker.orientationX.value) {
      nativePannerNodeFaker.orientationX.value = orientationX;
    }

    if (orientationY !== nativePannerNodeFaker.orientationY.value) {
      nativePannerNodeFaker.orientationY.value = orientationY;
    }

    if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {
      nativePannerNodeFaker.orientationZ.value = orientationZ;
    }

    if (panningModel !== nativePannerNodeFaker.panningModel) {
      nativePannerNodeFaker.panningModel = panningModel;
    }

    if (positionX !== nativePannerNodeFaker.positionX.value) {
      nativePannerNodeFaker.positionX.value = positionX;
    }

    if (positionY !== nativePannerNodeFaker.positionY.value) {
      nativePannerNodeFaker.positionY.value = positionY;
    }

    if (positionZ !== nativePannerNodeFaker.positionZ.value) {
      nativePannerNodeFaker.positionZ.value = positionZ;
    }

    if (refDistance !== nativePannerNodeFaker.refDistance) {
      nativePannerNodeFaker.refDistance = refDistance;
    }

    if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {
      nativePannerNodeFaker.rolloffFactor = rolloffFactor;
    }

    if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {
      pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation
    }

    if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {
      pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation
    }

    const whenConnected = () => {
      inputGainNode.connect(pannerNode); // Bug #119: Safari does not fully support the WaveShaperNode.

      connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);
      waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);
      waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);
      waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);
      waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);
      waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);
      waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);
      channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);
    };

    const whenDisconnected = () => {
      inputGainNode.disconnect(pannerNode); // Bug #119: Safari does not fully support the WaveShaperNode.

      disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);
      waveShaperNode.disconnect(orientationXGainNode);
      orientationXGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(orientationYGainNode);
      orientationYGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(orientationZGainNode);
      orientationZGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(positionXGainNode);
      positionXGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(positionYGainNode);
      positionYGainNode.disconnect(channelMergerNode);
      waveShaperNode.disconnect(positionZGainNode);
      positionZGainNode.disconnect(channelMergerNode);
      channelMergerNode.disconnect(scriptProcessorNode);
      scriptProcessorNode.disconnect(nativeContext.destination);
    };

    return monitorConnections((0, _interceptConnections.interceptConnections)(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);
  };
};

exports.createNativePannerNodeFakerFactory = createNativePannerNodeFakerFactory;
},{"../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","../helpers/intercept-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-periodic-wave-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativePeriodicWaveFactory = void 0;

const createNativePeriodicWaveFactory = createIndexSizeError => {
  return (nativeContext, {
    disableNormalization,
    imag,
    real
  }) => {
    // Bug #180: Safari does not allow to use ordinary arrays.
    const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);
    const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);
    const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, {
      disableNormalization
    }); // Bug #181: Safari does not throw an IndexSizeError so far if the given arrays have less than two values.

    if (Array.from(imag).length < 2) {
      throw createIndexSizeError();
    }

    return nativePeriodicWave;
  };
};

exports.createNativePeriodicWaveFactory = createNativePeriodicWaveFactory;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeScriptProcessorNode = void 0;

const createNativeScriptProcessorNode = (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {
  return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels); // tslint:disable-line deprecation
};

exports.createNativeScriptProcessorNode = createNativeScriptProcessorNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeStereoPannerNodeFactory = void 0;

var _assignNativeAudioNodeAudioParamValue = require("../helpers/assign-native-audio-node-audio-param-value");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

const createNativeStereoPannerNodeFactory = (createNativeStereoPannerNodeFaker, createNotSupportedError) => {
  return (nativeContext, options) => {
    const channelCountMode = options.channelCountMode;
    /*
     * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari
     * which supports it and therefore it can't be supported at all.
     */

    if (channelCountMode === 'clamped-max') {
      throw createNotSupportedError();
    } // Bug #105: Safari does not support the StereoPannerNode.


    if (nativeContext.createStereoPanner === undefined) {
      return createNativeStereoPannerNodeFaker(nativeContext, options);
    }

    const nativeStereoPannerNode = nativeContext.createStereoPanner();
    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeStereoPannerNode, options);
    (0, _assignNativeAudioNodeAudioParamValue.assignNativeAudioNodeAudioParamValue)(nativeStereoPannerNode, options, 'pan');
    /*
     * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari
     * which supports it and therefore it can't be supported at all.
     */

    Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {
      get: () => channelCountMode,
      set: value => {
        if (value !== channelCountMode) {
          throw createNotSupportedError();
        }
      }
    });
    return nativeStereoPannerNode;
  };
};

exports.createNativeStereoPannerNodeFactory = createNativeStereoPannerNodeFactory;
},{"../helpers/assign-native-audio-node-audio-param-value":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeStereoPannerNodeFakerFactory = void 0;

var _interceptConnections = require("../helpers/intercept-connections");

const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) => {
  // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.
  const CURVE_SIZE = 16385;
  const DC_CURVE = new Float32Array([1, 1]);
  const HALF_PI = Math.PI / 2;
  const SINGLE_CHANNEL_OPTIONS = {
    channelCount: 1,
    channelCountMode: 'explicit',
    channelInterpretation: 'discrete'
  };
  const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS,
    oversample: 'none'
  };

  const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
    const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);

    for (let i = 0; i < CURVE_SIZE; i += 1) {
      const x = i / (CURVE_SIZE - 1) * HALF_PI;
      leftWaveShaperCurve[i] = Math.cos(x);
      rightWaveShaperCurve[i] = Math.sin(x);
    }

    const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 0
    }); // Bug #119: Safari does not fully support the WaveShaperNode.

    const leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: leftWaveShaperCurve
    }); // Bug #119: Safari does not fully support the WaveShaperNode.

    const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: DC_CURVE
    });
    const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 0
    }); // Bug #119: Safari does not fully support the WaveShaperNode.

    const rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: rightWaveShaperCurve
    });
    return {
      connectGraph() {
        inputGainNode.connect(leftGainNode);
        inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        inputGainNode.connect(rightGainNode);
        panWaveShaperNode.connect(panGainNode);
        panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
        panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
        leftWaveShaperNode.connect(leftGainNode.gain);
        rightWaveShaperNode.connect(rightGainNode.gain);
        leftGainNode.connect(channelMergerNode, 0, 0);
        rightGainNode.connect(channelMergerNode, 0, 1);
      },

      disconnectGraph() {
        inputGainNode.disconnect(leftGainNode);
        inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        inputGainNode.disconnect(rightGainNode);
        panWaveShaperNode.disconnect(panGainNode);
        panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
        panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
        leftWaveShaperNode.disconnect(leftGainNode.gain);
        rightWaveShaperNode.disconnect(rightGainNode.gain);
        leftGainNode.disconnect(channelMergerNode, 0, 0);
        rightGainNode.disconnect(channelMergerNode, 0, 1);
      }

    };
  };

  const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
    const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
    const centerIndex = Math.floor(CURVE_SIZE / 2);

    for (let i = 0; i < CURVE_SIZE; i += 1) {
      if (i > centerIndex) {
        const x = (i - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;
        leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);
        leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);
        rightInputForLeftOutputWaveShaperCurve[i] = 0;
        rightInputForRightOutputWaveShaperCurve[i] = 1;
      } else {
        const x = i / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;
        leftInputForLeftOutputWaveShaperCurve[i] = 1;
        leftInputForRightOutputWaveShaperCurve[i] = 0;
        rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);
        rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);
      }
    }

    const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {
      channelCount: 2,
      channelCountMode: 'explicit',
      channelInterpretation: 'discrete',
      numberOfOutputs: 2
    });
    const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 0
    }); // Bug #119: Safari does not fully support the WaveShaperNode.

    const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: leftInputForLeftOutputWaveShaperCurve
    });
    const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 0
    }); // Bug #119: Safari does not fully support the WaveShaperNode.

    const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: leftInputForRightOutputWaveShaperCurve
    }); // Bug #119: Safari does not fully support the WaveShaperNode.

    const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: DC_CURVE
    });
    const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 0
    }); // Bug #119: Safari does not fully support the WaveShaperNode.

    const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: rightInputForLeftOutputWaveShaperCurve
    });
    const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,
      gain: 0
    }); // Bug #119: Safari does not fully support the WaveShaperNode.

    const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
      curve: rightInputForRightOutputWaveShaperCurve
    });
    return {
      connectGraph() {
        inputGainNode.connect(channelSplitterNode);
        inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);
        channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);
        channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);
        channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);
        panWaveShaperNode.connect(panGainNode);
        panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
        panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
        leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);
        leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);
        rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);
        rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);
        leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
        rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
        leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
        rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
      },

      disconnectGraph() {
        inputGainNode.disconnect(channelSplitterNode);
        inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
        channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);
        channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);
        channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);
        channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);
        panWaveShaperNode.disconnect(panGainNode);
        panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
        panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
        panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
        leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);
        leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);
        rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);
        rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);
        leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
        rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
        leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
        rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
      }

    };
  };

  const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {
    if (channelCount === 1) {
      return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);
    }

    if (channelCount === 2) {
      return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);
    }

    throw createNotSupportedError();
  };

  return (nativeContext, {
    channelCount,
    channelCountMode,
    pan,
    ...audioNodeOptions
  }) => {
    if (channelCountMode === 'max') {
      throw createNotSupportedError();
    }

    const channelMergerNode = createNativeChannelMergerNode(nativeContext, { ...audioNodeOptions,
      channelCount: 1,
      channelCountMode,
      numberOfInputs: 2
    });
    const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,
      channelCount,
      channelCountMode,
      gain: 1
    });
    const panGainNode = createNativeGainNode(nativeContext, {
      channelCount: 1,
      channelCountMode: 'explicit',
      channelInterpretation: 'discrete',
      gain: pan
    });
    let {
      connectGraph,
      disconnectGraph
    } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);
    Object.defineProperty(panGainNode.gain, 'defaultValue', {
      get: () => 0
    });
    Object.defineProperty(panGainNode.gain, 'maxValue', {
      get: () => 1
    });
    Object.defineProperty(panGainNode.gain, 'minValue', {
      get: () => -1
    });
    const nativeStereoPannerNodeFakerFactory = {
      get bufferSize() {
        return undefined;
      },

      get channelCount() {
        return inputGainNode.channelCount;
      },

      set channelCount(value) {
        if (inputGainNode.channelCount !== value) {
          if (isConnected) {
            disconnectGraph();
          }

          ({
            connectGraph,
            disconnectGraph
          } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));

          if (isConnected) {
            connectGraph();
          }
        }

        inputGainNode.channelCount = value;
      },

      get channelCountMode() {
        return inputGainNode.channelCountMode;
      },

      set channelCountMode(value) {
        if (value === 'clamped-max' || value === 'max') {
          throw createNotSupportedError();
        }

        inputGainNode.channelCountMode = value;
      },

      get channelInterpretation() {
        return inputGainNode.channelInterpretation;
      },

      set channelInterpretation(value) {
        inputGainNode.channelInterpretation = value;
      },

      get context() {
        return inputGainNode.context;
      },

      get inputs() {
        return [inputGainNode];
      },

      get numberOfInputs() {
        return inputGainNode.numberOfInputs;
      },

      get numberOfOutputs() {
        return inputGainNode.numberOfOutputs;
      },

      get pan() {
        return panGainNode.gain;
      },

      addEventListener(...args) {
        return inputGainNode.addEventListener(args[0], args[1], args[2]);
      },

      dispatchEvent(...args) {
        return inputGainNode.dispatchEvent(args[0]);
      },

      removeEventListener(...args) {
        return inputGainNode.removeEventListener(args[0], args[1], args[2]);
      }

    };
    let isConnected = false;

    const whenConnected = () => {
      connectGraph();
      isConnected = true;
    };

    const whenDisconnected = () => {
      disconnectGraph();
      isConnected = false;
    };

    return monitorConnections((0, _interceptConnections.interceptConnections)(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);
  };
};

exports.createNativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory;
},{"../helpers/intercept-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeWaveShaperNodeFactory = void 0;

var _assignNativeAudioNodeOption = require("../helpers/assign-native-audio-node-option");

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors) => {
  return (nativeContext, options) => {
    const nativeWaveShaperNode = nativeContext.createWaveShaper();
    /*
     * Bug #119: Safari does not correctly map the values.
     * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of
     * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround
     * isn't necessary anymore since v14.0.2 of Safari.
     */

    if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext' && nativeContext.createGain().gain.automationRate === undefined) {
      return createNativeWaveShaperNodeFaker(nativeContext, options);
    }

    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(nativeWaveShaperNode, options);
    const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve); // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.

    if (curve !== null && curve.length < 2) {
      throw createInvalidStateError();
    } // Only values of type Float32Array can be assigned to the curve property.


    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeWaveShaperNode, {
      curve
    }, 'curve');
    (0, _assignNativeAudioNodeOption.assignNativeAudioNodeOption)(nativeWaveShaperNode, options, 'oversample');
    let disconnectNativeAudioBufferSourceNode = null;
    let isConnected = false;
    overwriteAccessors(nativeWaveShaperNode, 'curve', get => () => get.call(nativeWaveShaperNode), set => value => {
      set.call(nativeWaveShaperNode, value);

      if (isConnected) {
        if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {
          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);
        } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {
          disconnectNativeAudioBufferSourceNode();
          disconnectNativeAudioBufferSourceNode = null;
        }
      }

      return value;
    });

    const whenConnected = () => {
      isConnected = true;

      if (isDCCurve(nativeWaveShaperNode.curve)) {
        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);
      }
    };

    const whenDisconnected = () => {
      isConnected = false;

      if (disconnectNativeAudioBufferSourceNode !== null) {
        disconnectNativeAudioBufferSourceNode();
        disconnectNativeAudioBufferSourceNode = null;
      }
    };

    return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);
  };
};

exports.createNativeWaveShaperNodeFactory = createNativeWaveShaperNodeFactory;
},{"../helpers/assign-native-audio-node-option":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNativeWaveShaperNodeFakerFactory = void 0;

var _assignNativeAudioNodeOptions = require("../helpers/assign-native-audio-node-options");

var _interceptConnections = require("../helpers/intercept-connections");

const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections) => {
  return (nativeContext, {
    curve,
    oversample,
    ...audioNodeOptions
  }) => {
    const negativeWaveShaperNode = nativeContext.createWaveShaper();
    const positiveWaveShaperNode = nativeContext.createWaveShaper();
    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(negativeWaveShaperNode, audioNodeOptions);
    (0, _assignNativeAudioNodeOptions.assignNativeAudioNodeOptions)(positiveWaveShaperNode, audioNodeOptions);
    const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,
      gain: 1
    });
    const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,
      gain: -1
    });
    const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,
      gain: 1
    });
    const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,
      gain: -1
    });
    let disconnectNativeAudioBufferSourceNode = null;
    let isConnected = false;
    let unmodifiedCurve = null;
    const nativeWaveShaperNodeFaker = {
      get bufferSize() {
        return undefined;
      },

      get channelCount() {
        return negativeWaveShaperNode.channelCount;
      },

      set channelCount(value) {
        inputGainNode.channelCount = value;
        invertGainNode.channelCount = value;
        negativeWaveShaperNode.channelCount = value;
        outputGainNode.channelCount = value;
        positiveWaveShaperNode.channelCount = value;
        revertGainNode.channelCount = value;
      },

      get channelCountMode() {
        return negativeWaveShaperNode.channelCountMode;
      },

      set channelCountMode(value) {
        inputGainNode.channelCountMode = value;
        invertGainNode.channelCountMode = value;
        negativeWaveShaperNode.channelCountMode = value;
        outputGainNode.channelCountMode = value;
        positiveWaveShaperNode.channelCountMode = value;
        revertGainNode.channelCountMode = value;
      },

      get channelInterpretation() {
        return negativeWaveShaperNode.channelInterpretation;
      },

      set channelInterpretation(value) {
        inputGainNode.channelInterpretation = value;
        invertGainNode.channelInterpretation = value;
        negativeWaveShaperNode.channelInterpretation = value;
        outputGainNode.channelInterpretation = value;
        positiveWaveShaperNode.channelInterpretation = value;
        revertGainNode.channelInterpretation = value;
      },

      get context() {
        return negativeWaveShaperNode.context;
      },

      get curve() {
        return unmodifiedCurve;
      },

      set curve(value) {
        // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.
        if (value !== null && value.length < 2) {
          throw createInvalidStateError();
        }

        if (value === null) {
          negativeWaveShaperNode.curve = value;
          positiveWaveShaperNode.curve = value;
        } else {
          const curveLength = value.length;
          const negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);
          const positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);
          negativeCurve[0] = value[0];
          positiveCurve[0] = -value[curveLength - 1];
          const length = Math.ceil((curveLength + 1) / 2);
          const centerIndex = (curveLength + 1) / 2 - 1;

          for (let i = 1; i < length; i += 1) {
            const theoreticIndex = i / length * centerIndex;
            const lowerIndex = Math.floor(theoreticIndex);
            const upperIndex = Math.ceil(theoreticIndex);
            negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];
            positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];
          }

          negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;
          negativeWaveShaperNode.curve = negativeCurve;
          positiveWaveShaperNode.curve = positiveCurve;
        }

        unmodifiedCurve = value;

        if (isConnected) {
          if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {
            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);
          } else if (disconnectNativeAudioBufferSourceNode !== null) {
            disconnectNativeAudioBufferSourceNode();
            disconnectNativeAudioBufferSourceNode = null;
          }
        }
      },

      get inputs() {
        return [inputGainNode];
      },

      get numberOfInputs() {
        return negativeWaveShaperNode.numberOfInputs;
      },

      get numberOfOutputs() {
        return negativeWaveShaperNode.numberOfOutputs;
      },

      get oversample() {
        return negativeWaveShaperNode.oversample;
      },

      set oversample(value) {
        negativeWaveShaperNode.oversample = value;
        positiveWaveShaperNode.oversample = value;
      },

      addEventListener(...args) {
        return inputGainNode.addEventListener(args[0], args[1], args[2]);
      },

      dispatchEvent(...args) {
        return inputGainNode.dispatchEvent(args[0]);
      },

      removeEventListener(...args) {
        return inputGainNode.removeEventListener(args[0], args[1], args[2]);
      }

    };

    if (curve !== null) {
      // Only values of type Float32Array can be assigned to the curve property.
      nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);
    }

    if (oversample !== nativeWaveShaperNodeFaker.oversample) {
      nativeWaveShaperNodeFaker.oversample = oversample;
    }

    const whenConnected = () => {
      inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);
      inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);
      isConnected = true;

      if (isDCCurve(unmodifiedCurve)) {
        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);
      }
    };

    const whenDisconnected = () => {
      inputGainNode.disconnect(negativeWaveShaperNode);
      negativeWaveShaperNode.disconnect(outputGainNode);
      inputGainNode.disconnect(invertGainNode);
      invertGainNode.disconnect(positiveWaveShaperNode);
      positiveWaveShaperNode.disconnect(revertGainNode);
      revertGainNode.disconnect(outputGainNode);
      isConnected = false;

      if (disconnectNativeAudioBufferSourceNode !== null) {
        disconnectNativeAudioBufferSourceNode();
        disconnectNativeAudioBufferSourceNode = null;
      }
    };

    return monitorConnections((0, _interceptConnections.interceptConnections)(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);
  };
};

exports.createNativeWaveShaperNodeFakerFactory = createNativeWaveShaperNodeFakerFactory;
},{"../helpers/assign-native-audio-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","../helpers/intercept-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNotSupportedError = void 0;

const createNotSupportedError = () => new DOMException('', 'NotSupportedError');

exports.createNotSupportedError = createNotSupportedError;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/offline-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOfflineAudioContextConstructor = void 0;

var _deactivateAudioGraph = require("../helpers/deactivate-audio-graph");

var _testPromiseSupport = require("../helpers/test-promise-support");

const DEFAULT_OPTIONS = {
  numberOfChannels: 1
};

const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {
  return class OfflineAudioContext extends baseAudioContextConstructor {
    constructor(a, b, c) {
      let options;

      if (typeof a === 'number' && b !== undefined && c !== undefined) {
        options = {
          length: b,
          numberOfChannels: a,
          sampleRate: c
        };
      } else if (typeof a === 'object') {
        options = a;
      } else {
        throw new Error('The given parameters are not valid.');
      }

      const {
        length,
        numberOfChannels,
        sampleRate
      } = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.

      if (!cacheTestResult(_testPromiseSupport.testPromiseSupport, () => (0, _testPromiseSupport.testPromiseSupport)(nativeOfflineAudioContext))) {
        nativeOfflineAudioContext.addEventListener('statechange', (() => {
          let i = 0;

          const delayStateChangeEvent = event => {
            if (this._state === 'running') {
              if (i > 0) {
                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);
                event.stopImmediatePropagation();

                this._waitForThePromiseToSettle(event);
              } else {
                i += 1;
              }
            }
          };

          return delayStateChangeEvent;
        })());
      }

      super(nativeOfflineAudioContext, numberOfChannels);
      this._length = length;
      this._nativeOfflineAudioContext = nativeOfflineAudioContext;
      this._state = null;
    }

    get length() {
      // Bug #17: Safari does not yet expose the length.
      if (this._nativeOfflineAudioContext.length === undefined) {
        return this._length;
      }

      return this._nativeOfflineAudioContext.length;
    }

    get state() {
      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
    }

    startRendering() {
      /*
       * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore
       * the state of the nativeOfflineAudioContext might no transition to running immediately.
       */
      if (this._state === 'running') {
        return Promise.reject(createInvalidStateError());
      }

      this._state = 'running';
      return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {
        this._state = null;
        (0, _deactivateAudioGraph.deactivateAudioGraph)(this);
      });
    }

    _waitForThePromiseToSettle(event) {
      if (this._state === null) {
        this._nativeOfflineAudioContext.dispatchEvent(event);
      } else {
        setTimeout(() => this._waitForThePromiseToSettle(event));
      }
    }

  };
};

exports.createOfflineAudioContextConstructor = createOfflineAudioContextConstructor;
},{"../helpers/deactivate-audio-graph":"../node_modules/standardized-audio-context/build/es2019/helpers/deactivate-audio-graph.js","../helpers/test-promise-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOscillatorNodeConstructor = void 0;

var _isActiveAudioNode = require("../helpers/is-active-audio-node");

var _setInternalStateToActive = require("../helpers/set-internal-state-to-active");

var _setInternalStateToPassive = require("../helpers/set-internal-state-to-passive");

const DEFAULT_OPTIONS = {
  channelCount: 2,
  channelCountMode: 'max',
  channelInterpretation: 'speakers',
  detune: 0,
  frequency: 440,
  periodicWave: undefined,
  type: 'sine'
};

const createOscillatorNodeConstructor = (audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {
  return class OscillatorNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const oscillatorNodeRenderer = isOffline ? createOscillatorNodeRenderer() : null;
      const nyquist = context.sampleRate / 2;
      super(context, false, nativeOscillatorNode, oscillatorNodeRenderer); // Bug #81: Firefox & Safari do not export the correct values for maxValue and minValue.

      this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600); // Bug #76: Safari does not export the correct values for maxValue and minValue.

      this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);
      this._nativeOscillatorNode = nativeOscillatorNode;
      this._onended = null;
      this._oscillatorNodeRenderer = oscillatorNodeRenderer;

      if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {
        this._oscillatorNodeRenderer.periodicWave = mergedOptions.periodicWave;
      }
    }

    get detune() {
      return this._detune;
    }

    get frequency() {
      return this._frequency;
    }

    get onended() {
      return this._onended;
    }

    set onended(value) {
      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;
      this._nativeOscillatorNode.onended = wrappedListener;
      const nativeOnEnded = this._nativeOscillatorNode.onended;
      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
    }

    get type() {
      return this._nativeOscillatorNode.type;
    }

    set type(value) {
      this._nativeOscillatorNode.type = value;

      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.periodicWave = null;
      }
    }

    setPeriodicWave(periodicWave) {
      this._nativeOscillatorNode.setPeriodicWave(periodicWave);

      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.periodicWave = periodicWave;
      }
    }

    start(when = 0) {
      this._nativeOscillatorNode.start(when);

      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.start = when;
      }

      if (this.context.state !== 'closed') {
        (0, _setInternalStateToActive.setInternalStateToActive)(this);

        const resetInternalStateToPassive = () => {
          this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive);

          if ((0, _isActiveAudioNode.isActiveAudioNode)(this)) {
            (0, _setInternalStateToPassive.setInternalStateToPassive)(this);
          }
        };

        this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);
      }
    }

    stop(when = 0) {
      this._nativeOscillatorNode.stop(when);

      if (this._oscillatorNodeRenderer !== null) {
        this._oscillatorNodeRenderer.stop = when;
      }
    }

  };
};

exports.createOscillatorNodeConstructor = createOscillatorNodeConstructor;
},{"../helpers/is-active-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","../helpers/set-internal-state-to-active":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js","../helpers/set-internal-state-to-passive":"../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOscillatorNodeRendererFactory = void 0;

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createOscillatorNodeRendererFactory = (connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeOscillatorNodes = new WeakMap();
    let periodicWave = null;
    let start = null;
    let stop = null;

    const createOscillatorNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeOscillatorNode = getNativeAudioNode(proxy); // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.

      const nativeOscillatorNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeOscillatorNode, nativeOfflineAudioContext);

      if (!nativeOscillatorNodeIsOwnedByContext) {
        const options = {
          channelCount: nativeOscillatorNode.channelCount,
          channelCountMode: nativeOscillatorNode.channelCountMode,
          channelInterpretation: nativeOscillatorNode.channelInterpretation,
          detune: nativeOscillatorNode.detune.value,
          frequency: nativeOscillatorNode.frequency.value,
          periodicWave: periodicWave === null ? undefined : periodicWave,
          type: nativeOscillatorNode.type
        };
        nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);

        if (start !== null) {
          nativeOscillatorNode.start(start);
        }

        if (stop !== null) {
          nativeOscillatorNode.stop(stop);
        }
      }

      renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);

      if (!nativeOscillatorNodeIsOwnedByContext) {
        await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
        await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
      } else {
        await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
        await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
      }

      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode);
      return nativeOscillatorNode;
    };

    return {
      set periodicWave(value) {
        periodicWave = value;
      },

      set start(value) {
        start = value;
      },

      set stop(value) {
        stop = value;
      },

      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);

        if (renderedNativeOscillatorNode !== undefined) {
          return Promise.resolve(renderedNativeOscillatorNode);
        }

        return createOscillatorNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createOscillatorNodeRendererFactory = createOscillatorNodeRendererFactory;
},{"../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/panner-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPannerNodeConstructor = void 0;

var _constants = require("../constants");

const DEFAULT_OPTIONS = {
  channelCount: 2,
  channelCountMode: 'clamped-max',
  channelInterpretation: 'speakers',
  coneInnerAngle: 360,
  coneOuterAngle: 360,
  coneOuterGain: 0,
  distanceModel: 'inverse',
  maxDistance: 10000,
  orientationX: 1,
  orientationY: 0,
  orientationZ: 0,
  panningModel: 'equalpower',
  positionX: 0,
  positionY: 0,
  positionZ: 0,
  refDistance: 1,
  rolloffFactor: 1
};

const createPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {
  return class PannerNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const pannerNodeRenderer = isOffline ? createPannerNodeRenderer() : null;
      super(context, false, nativePannerNode, pannerNodeRenderer);
      this._nativePannerNode = nativePannerNode; // Bug #74: Safari does not export the correct values for maxValue and minValue.

      this._orientationX = createAudioParam(this, isOffline, nativePannerNode.orientationX, _constants.MOST_POSITIVE_SINGLE_FLOAT, _constants.MOST_NEGATIVE_SINGLE_FLOAT);
      this._orientationY = createAudioParam(this, isOffline, nativePannerNode.orientationY, _constants.MOST_POSITIVE_SINGLE_FLOAT, _constants.MOST_NEGATIVE_SINGLE_FLOAT);
      this._orientationZ = createAudioParam(this, isOffline, nativePannerNode.orientationZ, _constants.MOST_POSITIVE_SINGLE_FLOAT, _constants.MOST_NEGATIVE_SINGLE_FLOAT);
      this._positionX = createAudioParam(this, isOffline, nativePannerNode.positionX, _constants.MOST_POSITIVE_SINGLE_FLOAT, _constants.MOST_NEGATIVE_SINGLE_FLOAT);
      this._positionY = createAudioParam(this, isOffline, nativePannerNode.positionY, _constants.MOST_POSITIVE_SINGLE_FLOAT, _constants.MOST_NEGATIVE_SINGLE_FLOAT);
      this._positionZ = createAudioParam(this, isOffline, nativePannerNode.positionZ, _constants.MOST_POSITIVE_SINGLE_FLOAT, _constants.MOST_NEGATIVE_SINGLE_FLOAT); // @todo Determine a meaningful tail-time instead of just using one second.

      setAudioNodeTailTime(this, 1);
    }

    get coneInnerAngle() {
      return this._nativePannerNode.coneInnerAngle;
    }

    set coneInnerAngle(value) {
      this._nativePannerNode.coneInnerAngle = value;
    }

    get coneOuterAngle() {
      return this._nativePannerNode.coneOuterAngle;
    }

    set coneOuterAngle(value) {
      this._nativePannerNode.coneOuterAngle = value;
    }

    get coneOuterGain() {
      return this._nativePannerNode.coneOuterGain;
    }

    set coneOuterGain(value) {
      this._nativePannerNode.coneOuterGain = value;
    }

    get distanceModel() {
      return this._nativePannerNode.distanceModel;
    }

    set distanceModel(value) {
      this._nativePannerNode.distanceModel = value;
    }

    get maxDistance() {
      return this._nativePannerNode.maxDistance;
    }

    set maxDistance(value) {
      this._nativePannerNode.maxDistance = value;
    }

    get orientationX() {
      return this._orientationX;
    }

    get orientationY() {
      return this._orientationY;
    }

    get orientationZ() {
      return this._orientationZ;
    }

    get panningModel() {
      return this._nativePannerNode.panningModel;
    }

    set panningModel(value) {
      this._nativePannerNode.panningModel = value;
    }

    get positionX() {
      return this._positionX;
    }

    get positionY() {
      return this._positionY;
    }

    get positionZ() {
      return this._positionZ;
    }

    get refDistance() {
      return this._nativePannerNode.refDistance;
    }

    set refDistance(value) {
      this._nativePannerNode.refDistance = value;
    }

    get rolloffFactor() {
      return this._nativePannerNode.rolloffFactor;
    }

    set rolloffFactor(value) {
      this._nativePannerNode.rolloffFactor = value;
    }

  };
};

exports.createPannerNodeConstructor = createPannerNodeConstructor;
},{"../constants":"../node_modules/standardized-audio-context/build/es2019/constants.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/panner-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPannerNodeRendererFactory = void 0;

var _nativeAudioNodeFaker = require("../guards/native-audio-node-faker");

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createPannerNodeRendererFactory = (connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {
  return () => {
    const renderedNativeAudioNodes = new WeakMap();
    let renderedBufferPromise = null;

    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeGainNode = null;
      let nativePannerNode = getNativeAudioNode(proxy);
      const commonAudioNodeOptions = {
        channelCount: nativePannerNode.channelCount,
        channelCountMode: nativePannerNode.channelCountMode,
        channelInterpretation: nativePannerNode.channelInterpretation
      };
      const commonNativePannerNodeOptions = { ...commonAudioNodeOptions,
        coneInnerAngle: nativePannerNode.coneInnerAngle,
        coneOuterAngle: nativePannerNode.coneOuterAngle,
        coneOuterGain: nativePannerNode.coneOuterGain,
        distanceModel: nativePannerNode.distanceModel,
        maxDistance: nativePannerNode.maxDistance,
        panningModel: nativePannerNode.panningModel,
        refDistance: nativePannerNode.refDistance,
        rolloffFactor: nativePannerNode.rolloffFactor
      }; // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.

      const nativePannerNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativePannerNode, nativeOfflineAudioContext); // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.

      if ('bufferSize' in nativePannerNode) {
        nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,
          gain: 1
        });
      } else if (!nativePannerNodeIsOwnedByContext) {
        const options = { ...commonNativePannerNodeOptions,
          orientationX: nativePannerNode.orientationX.value,
          orientationY: nativePannerNode.orientationY.value,
          orientationZ: nativePannerNode.orientationZ.value,
          positionX: nativePannerNode.positionX.value,
          positionY: nativePannerNode.positionY.value,
          positionZ: nativePannerNode.positionZ.value
        };
        nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);
      }

      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);

      if (nativeGainNode !== null) {
        if (renderedBufferPromise === null) {
          if (nativeOfflineAudioContextConstructor === null) {
            throw new Error('Missing the native OfflineAudioContext constructor.');
          }

          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(6, // Bug #17: Safari does not yet expose the length.
          proxy.context.length, nativeOfflineAudioContext.sampleRate);
          const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {
            channelCount: 1,
            channelCountMode: 'explicit',
            channelInterpretation: 'speakers',
            numberOfInputs: 6
          });
          nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);

          renderedBufferPromise = (async () => {
            const nativeConstantSourceNodes = await Promise.all([proxy.orientationX, proxy.orientationY, proxy.orientationZ, proxy.positionX, proxy.positionY, proxy.positionZ].map(async (audioParam, index) => {
              const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {
                channelCount: 1,
                channelCountMode: 'explicit',
                channelInterpretation: 'discrete',
                offset: index === 0 ? 1 : 0
              });
              await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);
              return nativeConstantSourceNode;
            }));

            for (let i = 0; i < 6; i += 1) {
              nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);
              nativeConstantSourceNodes[i].start(0);
            }

            return renderNativeOfflineAudioContext(partialOfflineAudioContext);
          })();
        }

        const renderedBuffer = await renderedBufferPromise;
        const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,
          gain: 1
        });
        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode);
        const channelDatas = [];

        for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {
          channelDatas.push(renderedBuffer.getChannelData(i));
        }

        let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];
        let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];
        let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,
          gain: 1
        });
        let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, { ...commonNativePannerNodeOptions,
          orientationX: lastOrientation[0],
          orientationY: lastOrientation[1],
          orientationZ: lastOrientation[2],
          positionX: lastPosition[0],
          positionY: lastPosition[1],
          positionZ: lastPosition[2]
        });
        inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
        partialPannerNode.connect(nativeGainNode);

        for (let i = 128; i < renderedBuffer.length; i += 128) {
          const orientation = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];
          const positon = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];

          if (orientation.some((value, index) => value !== lastOrientation[index]) || positon.some((value, index) => value !== lastPosition[index])) {
            lastOrientation = orientation;
            lastPosition = positon;
            const currentTime = i / nativeOfflineAudioContext.sampleRate;
            gateGainNode.gain.setValueAtTime(0, currentTime);
            gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,
              gain: 0
            });
            partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, { ...commonNativePannerNodeOptions,
              orientationX: lastOrientation[0],
              orientationY: lastOrientation[1],
              orientationZ: lastOrientation[2],
              positionX: lastPosition[0],
              positionY: lastPosition[1],
              positionZ: lastPosition[2]
            });
            gateGainNode.gain.setValueAtTime(1, currentTime);
            inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
            partialPannerNode.connect(nativeGainNode);
          }
        }

        return nativeGainNode;
      }

      if (!nativePannerNodeIsOwnedByContext) {
        await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
        await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
        await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
        await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
        await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
        await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
      } else {
        await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
        await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
        await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
        await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
        await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
        await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
      }

      if ((0, _nativeAudioNodeFaker.isNativeAudioNodeFaker)(nativePannerNode)) {
        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode);
      }

      return nativePannerNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);

        if (renderedNativeGainNodeOrNativePannerNode !== undefined) {
          return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);
        }

        return createAudioNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createPannerNodeRendererFactory = createPannerNodeRendererFactory;
},{"../guards/native-audio-node-faker":"../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js","../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/periodic-wave-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPeriodicWaveConstructor = void 0;
const DEFAULT_OPTIONS = {
  disableNormalization: false
};

const createPeriodicWaveConstructor = (createNativePeriodicWave, getNativeContext, periodicWaveStore, sanitizePeriodicWaveOptions) => {
  return class PeriodicWave {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = sanitizePeriodicWaveOptions({ ...DEFAULT_OPTIONS,
        ...options
      });
      const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);
      periodicWaveStore.add(periodicWave); // This does violate all good pratices but it is used here to simplify the handling of periodic waves.

      return periodicWave;
    }

    static [Symbol.hasInstance](instance) {
      return instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype || periodicWaveStore.has(instance);
    }

  };
};

exports.createPeriodicWaveConstructor = createPeriodicWaveConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/render-automation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRenderAutomation = void 0;

const createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam) => {
  return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
    const audioParamRenderer = getAudioParamRenderer(audioParam);
    audioParamRenderer.replay(nativeAudioParam);
    return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);
  };
};

exports.createRenderAutomation = createRenderAutomation;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRenderInputsOfAudioNode = void 0;

const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {
  return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {
    const audioNodeConnections = getAudioNodeConnections(audioNode);
    await Promise.all(audioNodeConnections.activeInputs.map((connections, input) => Array.from(connections).map(async ([source, output]) => {
      const audioNodeRenderer = getAudioNodeRenderer(source);
      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);
      const destination = audioNode.context.destination;

      if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {
        renderedNativeAudioNode.connect(nativeAudioNode, output, input);
      }
    })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));
  };
};

exports.createRenderInputsOfAudioNode = createRenderInputsOfAudioNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRenderInputsOfAudioParam = void 0;

const createRenderInputsOfAudioParam = (getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) => {
  return async (audioParam, nativeOfflineAudioContext, nativeAudioParam) => {
    const audioParamConnections = getAudioParamConnections(audioParam);
    await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {
      const audioNodeRenderer = getAudioNodeRenderer(source);
      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);

      if (!isPartOfACycle(source)) {
        renderedNativeAudioNode.connect(nativeAudioParam, output);
      }
    }));
  };
};

exports.createRenderInputsOfAudioParam = createRenderInputsOfAudioParam;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRenderNativeOfflineAudioContext = void 0;

var _testPromiseSupport = require("../helpers/test-promise-support");

const createRenderNativeOfflineAudioContext = (cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) => {
  return nativeOfflineAudioContext => {
    // Bug #21: Safari does not support promises yet.
    if (cacheTestResult(_testPromiseSupport.testPromiseSupport, () => (0, _testPromiseSupport.testPromiseSupport)(nativeOfflineAudioContext))) {
      // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.
      return Promise.resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then(isOfflineAudioContextCurrentTimeSupported => {
        if (!isOfflineAudioContextCurrentTimeSupported) {
          const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);

          nativeOfflineAudioContext.oncomplete = () => {
            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation

            scriptProcessorNode.disconnect();
          };

          scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation


          scriptProcessorNode.connect(nativeOfflineAudioContext.destination);
        }

        return nativeOfflineAudioContext.startRendering();
      });
    }

    return new Promise(resolve => {
      // Bug #48: Safari does not render an OfflineAudioContext without any connected node.
      const gainNode = createNativeGainNode(nativeOfflineAudioContext, {
        channelCount: 1,
        channelCountMode: 'explicit',
        channelInterpretation: 'discrete',
        gain: 0
      });

      nativeOfflineAudioContext.oncomplete = event => {
        gainNode.disconnect();
        resolve(event.renderedBuffer);
      };

      gainNode.connect(nativeOfflineAudioContext.destination);
      nativeOfflineAudioContext.startRendering();
    });
  };
};

exports.createRenderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext;
},{"../helpers/test-promise-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/set-active-audio-worklet-node-inputs.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSetActiveAudioWorkletNodeInputs = void 0;

const createSetActiveAudioWorkletNodeInputs = activeAudioWorkletNodeInputsStore => {
  return (nativeAudioWorkletNode, activeInputs) => {
    activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode, activeInputs);
  };
};

exports.createSetActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/set-audio-node-tail-time.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSetAudioNodeTailTime = void 0;

const createSetAudioNodeTailTime = audioNodeTailTimeStore => {
  return (audioNode, tailTime) => audioNodeTailTimeStore.set(audioNode, tailTime);
};

exports.createSetAudioNodeTailTime = createSetAudioNodeTailTime;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStartRendering = void 0;

var _wrapAudioBufferGetChannelDataMethod = require("../helpers/wrap-audio-buffer-get-channel-data-method");

const createStartRendering = (audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {
  return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination).render(destination, nativeOfflineAudioContext)
  /*
   * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the
   * destination.
   */
  .then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map(audioWorkletNode => getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext)))).then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext)).then(audioBuffer => {
    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.
    if (typeof audioBuffer.copyFromChannel !== 'function') {
      wrapAudioBufferCopyChannelMethods(audioBuffer);
      (0, _wrapAudioBufferGetChannelDataMethod.wrapAudioBufferGetChannelDataMethod)(audioBuffer); // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.
    } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {
      wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);
    }

    audioBufferStore.add(audioBuffer);
    return audioBuffer;
  });
};

exports.createStartRendering = createStartRendering;
},{"../helpers/wrap-audio-buffer-get-channel-data-method":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStereoPannerNodeConstructor = void 0;
const DEFAULT_OPTIONS = {
  channelCount: 2,

  /*
   * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent
   * behavior.
   */
  channelCountMode: 'explicit',
  channelInterpretation: 'speakers',
  pan: 0
};

const createStereoPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {
  return class StereoPannerNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const stereoPannerNodeRenderer = isOffline ? createStereoPannerNodeRenderer() : null;
      super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);
      this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan);
    }

    get pan() {
      return this._pan;
    }

  };
};

exports.createStereoPannerNodeConstructor = createStereoPannerNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStereoPannerNodeRendererFactory = void 0;

var _nativeAudioNodeFaker = require("../guards/native-audio-node-faker");

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createStereoPannerNodeRendererFactory = (connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeStereoPannerNodes = new WeakMap();

    const createStereoPannerNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeStereoPannerNode = getNativeAudioNode(proxy);
      /*
       * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created
       * again.
       */

      const nativeStereoPannerNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeStereoPannerNode, nativeOfflineAudioContext);

      if (!nativeStereoPannerNodeIsOwnedByContext) {
        const options = {
          channelCount: nativeStereoPannerNode.channelCount,
          channelCountMode: nativeStereoPannerNode.channelCountMode,
          channelInterpretation: nativeStereoPannerNode.channelInterpretation,
          pan: nativeStereoPannerNode.pan.value
        };
        nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);
      }

      renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);

      if (!nativeStereoPannerNodeIsOwnedByContext) {
        await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
      } else {
        await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
      }

      if ((0, _nativeAudioNodeFaker.isNativeAudioNodeFaker)(nativeStereoPannerNode)) {
        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);
      }

      return nativeStereoPannerNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);

        if (renderedNativeStereoPannerNode !== undefined) {
          return Promise.resolve(renderedNativeStereoPannerNode);
        }

        return createStereoPannerNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createStereoPannerNodeRendererFactory = createStereoPannerNodeRendererFactory;
},{"../guards/native-audio-node-faker":"../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js","../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestAudioBufferConstructorSupport = void 0;

// Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.
const createTestAudioBufferConstructorSupport = nativeAudioBufferConstructor => {
  return () => {
    if (nativeAudioBufferConstructor === null) {
      return false;
    }

    try {
      new nativeAudioBufferConstructor({
        length: 1,
        sampleRate: 44100
      }); // tslint:disable-line:no-unused-expression
    } catch {
      return false;
    }

    return true;
  };
};

exports.createTestAudioBufferConstructorSupport = createTestAudioBufferConstructorSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-copy-channel-methods-subarray-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestAudioBufferCopyChannelMethodsSubarraySupport = void 0;

/*
 * Firefox up to version 67 didn't fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those methods
 * is enough to know if the other one is supported as well.
 */
const createTestAudioBufferCopyChannelMethodsSubarraySupport = nativeOfflineAudioContextConstructor => {
  return () => {
    if (nativeOfflineAudioContextConstructor === null) {
      return false;
    }

    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);
    const nativeAudioBuffer = nativeOfflineAudioContext.createBuffer(1, 1, 44100); // Bug #5: Safari does not support copyFromChannel() and copyToChannel().

    if (nativeAudioBuffer.copyToChannel === undefined) {
      return true;
    }

    const source = new Float32Array(2);

    try {
      nativeAudioBuffer.copyFromChannel(source, 0, 0);
    } catch {
      return false;
    }

    return true;
  };
};

exports.createTestAudioBufferCopyChannelMethodsSubarraySupport = createTestAudioBufferCopyChannelMethodsSubarraySupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-close-method-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestAudioContextCloseMethodSupport = void 0;

const createTestAudioContextCloseMethodSupport = nativeAudioContextConstructor => {
  return () => {
    if (nativeAudioContextConstructor === null) {
      return false;
    } // Try to check the prototype before constructing the AudioContext.


    if (nativeAudioContextConstructor.prototype !== undefined && nativeAudioContextConstructor.prototype.close !== undefined) {
      return true;
    }

    const audioContext = new nativeAudioContextConstructor();
    const isAudioContextClosable = audioContext.close !== undefined;

    try {
      audioContext.close();
    } catch {// Ignore errors.
    }

    return isAudioContextClosable;
  };
};

exports.createTestAudioContextCloseMethodSupport = createTestAudioContextCloseMethodSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-decode-audio-data-method-type-error-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestAudioContextDecodeAudioDataMethodTypeErrorSupport = void 0;

/**
 * Edge up to version 14, Firefox up to version 52, Safari up to version 9 and maybe other browsers
 * did not refuse to decode invalid parameters with a TypeError.
 */
const createTestAudioContextDecodeAudioDataMethodTypeErrorSupport = nativeOfflineAudioContextConstructor => {
  return () => {
    if (nativeOfflineAudioContextConstructor === null) {
      return Promise.resolve(false);
    }

    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100); // Bug #21: Safari does not support promises yet.

    return new Promise(resolve => {
      let isPending = true;

      const resolvePromise = err => {
        if (isPending) {
          isPending = false;
          offlineAudioContext.startRendering();
          resolve(err instanceof TypeError);
        }
      };

      let promise; // Bug #26: Safari throws a synchronous error.

      try {
        promise = offlineAudioContext // Bug #1: Safari requires a successCallback.
        .decodeAudioData(null, () => {// Ignore the success callback.
        }, resolvePromise);
      } catch (err) {
        resolvePromise(err);
      } // Bug #21: Safari does not support promises yet.


      if (promise !== undefined) {
        // Bug #6: Chrome, Edge and Firefox do not call the errorCallback.
        promise.catch(resolvePromise);
      }
    });
  };
};

exports.createTestAudioContextDecodeAudioDataMethodTypeErrorSupport = createTestAudioContextDecodeAudioDataMethodTypeErrorSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-options-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestAudioContextOptionsSupport = void 0;

const createTestAudioContextOptionsSupport = nativeAudioContextConstructor => {
  return () => {
    if (nativeAudioContextConstructor === null) {
      return false;
    }

    let audioContext;

    try {
      audioContext = new nativeAudioContextConstructor({
        latencyHint: 'balanced'
      });
    } catch {
      return false;
    }

    audioContext.close();
    return true;
  };
};

exports.createTestAudioContextOptionsSupport = createTestAudioContextOptionsSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-node-connect-method-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestAudioNodeConnectMethodSupport = void 0;

// Safari up to version 12.0 (but not v12.1) didn't return the destination in case it was an AudioNode.
const createTestAudioNodeConnectMethodSupport = nativeOfflineAudioContextConstructor => {
  return () => {
    if (nativeOfflineAudioContextConstructor === null) {
      return false;
    }

    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);
    const nativeGainNode = nativeOfflineAudioContext.createGain();
    const isSupported = nativeGainNode.connect(nativeGainNode) === nativeGainNode;
    nativeGainNode.disconnect(nativeGainNode);
    return isSupported;
  };
};

exports.createTestAudioNodeConnectMethodSupport = createTestAudioNodeConnectMethodSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-no-outputs-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestAudioWorkletProcessorNoOutputsSupport = void 0;

/**
 * Chrome version 66 and 67 did not call the process() function of an AudioWorkletProcessor if it had no outputs. AudioWorklet support was
 * enabled by default in version 66.
 */
const createTestAudioWorkletProcessorNoOutputsSupport = (nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) => {
  return async () => {
    // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.
    if (nativeAudioWorkletNodeConstructor === null) {
      return true;
    }

    if (nativeOfflineAudioContextConstructor === null) {
      return false;
    }

    const blob = new Blob(['let c,p;class A extends AudioWorkletProcessor{constructor(){super();this.port.onmessage=(e)=>{p=e.data;p.onmessage=()=>{p.postMessage(c);p.close()};this.port.postMessage(0)}}process(){c=1}}registerProcessor("a",A)'], {
      type: 'application/javascript; charset=utf-8'
    });
    const messageChannel = new MessageChannel(); // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.

    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);
    const url = URL.createObjectURL(blob);
    let isCallingProcess = false;

    try {
      await offlineAudioContext.audioWorklet.addModule(url);
      const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', {
        numberOfOutputs: 0
      });
      const oscillator = offlineAudioContext.createOscillator();
      await new Promise(resolve => {
        audioWorkletNode.port.onmessage = () => resolve();

        audioWorkletNode.port.postMessage(messageChannel.port2, [messageChannel.port2]);
      });

      audioWorkletNode.port.onmessage = () => isCallingProcess = true;

      oscillator.connect(audioWorkletNode);
      oscillator.start(0);
      await offlineAudioContext.startRendering();
      isCallingProcess = await new Promise(resolve => {
        messageChannel.port1.onmessage = ({
          data
        }) => resolve(data === 1);

        messageChannel.port1.postMessage(0);
      });
    } catch {// Ignore errors.
    } finally {
      messageChannel.port1.close();
      URL.revokeObjectURL(url);
    }

    return isCallingProcess;
  };
};

exports.createTestAudioWorkletProcessorNoOutputsSupport = createTestAudioWorkletProcessorNoOutputsSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-post-message-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestAudioWorkletProcessorPostMessageSupport = void 0;

// Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.
const createTestAudioWorkletProcessorPostMessageSupport = (nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) => {
  return async () => {
    // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.
    if (nativeAudioWorkletNodeConstructor === null) {
      return true;
    }

    if (nativeOfflineAudioContextConstructor === null) {
      return false;
    }

    const blob = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
      type: 'application/javascript; charset=utf-8'
    }); // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.

    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);
    const url = URL.createObjectURL(blob);
    let isEmittingMessageEvents = false;
    let isEmittingProcessorErrorEvents = false;

    try {
      await offlineAudioContext.audioWorklet.addModule(url);
      const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', {
        numberOfOutputs: 0
      });
      const oscillator = offlineAudioContext.createOscillator();

      audioWorkletNode.port.onmessage = () => isEmittingMessageEvents = true;

      audioWorkletNode.onprocessorerror = () => isEmittingProcessorErrorEvents = true;

      oscillator.connect(audioWorkletNode);
      oscillator.start(0);
      await offlineAudioContext.startRendering();
    } catch {// Ignore errors.
    } finally {
      URL.revokeObjectURL(url);
    }

    return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;
  };
};

exports.createTestAudioWorkletProcessorPostMessageSupport = createTestAudioWorkletProcessorPostMessageSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-channel-merger-node-channel-count-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestChannelMergerNodeChannelCountSupport = void 0;

/**
 * Firefox up to version 69 did not throw an error when setting a different channelCount or channelCountMode.
 */
const createTestChannelMergerNodeChannelCountSupport = nativeOfflineAudioContextConstructor => {
  return () => {
    if (nativeOfflineAudioContextConstructor === null) {
      return false;
    }

    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);
    const nativeChannelMergerNode = offlineAudioContext.createChannelMerger();
    /**
     * Bug #15: Safari does not return the default properties. It still needs to be patched. This test is supposed to test the support
     * in other browsers.
     */

    if (nativeChannelMergerNode.channelCountMode === 'max') {
      return true;
    }

    try {
      nativeChannelMergerNode.channelCount = 2;
    } catch {
      return true;
    }

    return false;
  };
};

exports.createTestChannelMergerNodeChannelCountSupport = createTestChannelMergerNodeChannelCountSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-constant-source-node-accurate-scheduling-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestConstantSourceNodeAccurateSchedulingSupport = void 0;

const createTestConstantSourceNodeAccurateSchedulingSupport = nativeOfflineAudioContextConstructor => {
  return () => {
    if (nativeOfflineAudioContextConstructor === null) {
      return false;
    }

    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100); // Bug #62: Safari does not support ConstantSourceNodes.

    if (nativeOfflineAudioContext.createConstantSource === undefined) {
      return true;
    }

    const nativeConstantSourceNode = nativeOfflineAudioContext.createConstantSource();
    /*
     * @todo This is using bug #75 to detect bug #70. That works because both bugs were unique to
     * the implementation of Firefox right now, but it could probably be done in a better way.
     */

    return nativeConstantSourceNode.offset.maxValue !== Number.POSITIVE_INFINITY;
  };
};

exports.createTestConstantSourceNodeAccurateSchedulingSupport = createTestConstantSourceNodeAccurateSchedulingSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-buffer-reassignability-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestConvolverNodeBufferReassignabilitySupport = void 0;

// Opera up to version 57 did not allow to reassign the buffer of a ConvolverNode.
const createTestConvolverNodeBufferReassignabilitySupport = nativeOfflineAudioContextConstructor => {
  return () => {
    if (nativeOfflineAudioContextConstructor === null) {
      return false;
    }

    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);
    const nativeConvolverNode = offlineAudioContext.createConvolver();
    nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);

    try {
      nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);
    } catch {
      return false;
    }

    return true;
  };
};

exports.createTestConvolverNodeBufferReassignabilitySupport = createTestConvolverNodeBufferReassignabilitySupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-channel-count-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestConvolverNodeChannelCountSupport = void 0;

// Chrome up to version v80, Edge up to version v80 and Opera up to version v67 did not allow to set the channelCount property of a ConvolverNode to 1. They also did not allow to set the channelCountMode to 'explicit'.
const createTestConvolverNodeChannelCountSupport = nativeOfflineAudioContextConstructor => {
  return () => {
    if (nativeOfflineAudioContextConstructor === null) {
      return false;
    }

    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);
    const nativeConvolverNode = offlineAudioContext.createConvolver();

    try {
      nativeConvolverNode.channelCount = 1;
    } catch {
      return false;
    }

    return true;
  };
};

exports.createTestConvolverNodeChannelCountSupport = createTestConvolverNodeChannelCountSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-is-secure-context-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestIsSecureContextSupport = void 0;

const createTestIsSecureContextSupport = window => {
  return () => window !== null && window.hasOwnProperty('isSecureContext');
};

exports.createTestIsSecureContextSupport = createTestIsSecureContextSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport = void 0;

// Firefox up to version 68 did not throw an error when creating a MediaStreamAudioSourceNode with a mediaStream that had no audio track.
const createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport = nativeAudioContextConstructor => {
  return () => {
    if (nativeAudioContextConstructor === null) {
      return false;
    }

    const audioContext = new nativeAudioContextConstructor();

    try {
      audioContext.createMediaStreamSource(new MediaStream());
      return false;
    } catch (err) {
      return true;
    } finally {
      audioContext.close();
    }
  };
};

exports.createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport = createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestOfflineAudioContextCurrentTimeSupport = void 0;

const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode, nativeOfflineAudioContextConstructor) => {
  return () => {
    if (nativeOfflineAudioContextConstructor === null) {
      return Promise.resolve(false);
    }

    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100); // Bug #48: Safari does not render an OfflineAudioContext without any connected node.

    const gainNode = createNativeGainNode(nativeOfflineAudioContext, {
      channelCount: 1,
      channelCountMode: 'explicit',
      channelInterpretation: 'discrete',
      gain: 0
    }); // Bug #21: Safari does not support promises yet.

    return new Promise(resolve => {
      nativeOfflineAudioContext.oncomplete = () => {
        gainNode.disconnect();
        resolve(nativeOfflineAudioContext.currentTime !== 0);
      };

      nativeOfflineAudioContext.startRendering();
    });
  };
};

exports.createTestOfflineAudioContextCurrentTimeSupport = createTestOfflineAudioContextCurrentTimeSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/test-stereo-panner-node-default-value-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTestStereoPannerNodeDefaultValueSupport = void 0;

/**
 * Firefox up to version 62 did not kick off the processing of the StereoPannerNode if the value of pan was zero.
 */
const createTestStereoPannerNodeDefaultValueSupport = nativeOfflineAudioContextConstructor => {
  return () => {
    if (nativeOfflineAudioContextConstructor === null) {
      return Promise.resolve(false);
    }

    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);
    /*
     * Bug #105: Safari does not support the StereoPannerNode. Therefore the returned value should normally be false but the faker does
     * support the tested behaviour.
     */

    if (nativeOfflineAudioContext.createStereoPanner === undefined) {
      return Promise.resolve(true);
    } // Bug #62: Safari does not support ConstantSourceNodes.


    if (nativeOfflineAudioContext.createConstantSource === undefined) {
      return Promise.resolve(true);
    }

    const constantSourceNode = nativeOfflineAudioContext.createConstantSource();
    const stereoPanner = nativeOfflineAudioContext.createStereoPanner();
    constantSourceNode.channelCount = 1;
    constantSourceNode.offset.value = 1;
    stereoPanner.channelCount = 1;
    constantSourceNode.start();
    constantSourceNode.connect(stereoPanner).connect(nativeOfflineAudioContext.destination);
    return nativeOfflineAudioContext.startRendering().then(buffer => buffer.getChannelData(0)[0] !== 1);
  };
};

exports.createTestStereoPannerNodeDefaultValueSupport = createTestStereoPannerNodeDefaultValueSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createUnknownError = void 0;

const createUnknownError = () => new DOMException('', 'UnknownError');

exports.createUnknownError = createUnknownError;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWaveShaperNodeConstructor = void 0;
const DEFAULT_OPTIONS = {
  channelCount: 2,
  channelCountMode: 'max',
  channelInterpretation: 'speakers',
  curve: null,
  oversample: 'none'
};

const createWaveShaperNodeConstructor = (audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) => {
  return class WaveShaperNode extends audioNodeConstructor {
    constructor(context, options) {
      const nativeContext = getNativeContext(context);
      const mergedOptions = { ...DEFAULT_OPTIONS,
        ...options
      };
      const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);
      const isOffline = isNativeOfflineAudioContext(nativeContext);
      const waveShaperNodeRenderer = isOffline ? createWaveShaperNodeRenderer() : null; // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.

      super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);
      this._isCurveNullified = false;
      this._nativeWaveShaperNode = nativeWaveShaperNode; // @todo Determine a meaningful tail-time instead of just using one second.

      setAudioNodeTailTime(this, 1);
    }

    get curve() {
      if (this._isCurveNullified) {
        return null;
      }

      return this._nativeWaveShaperNode.curve;
    }

    set curve(value) {
      // Bug #103: Safari does not allow to set the curve to null.
      if (value === null) {
        this._isCurveNullified = true;
        this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
      } else {
        // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.
        // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.
        if (value.length < 2) {
          throw createInvalidStateError();
        }

        this._isCurveNullified = false;
        this._nativeWaveShaperNode.curve = value;
      }
    }

    get oversample() {
      return this._nativeWaveShaperNode.oversample;
    }

    set oversample(value) {
      this._nativeWaveShaperNode.oversample = value;
    }

  };
};

exports.createWaveShaperNodeConstructor = createWaveShaperNodeConstructor;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWaveShaperNodeRendererFactory = void 0;

var _nativeAudioNodeFaker = require("../guards/native-audio-node-faker");

var _isOwnedByContext = require("../helpers/is-owned-by-context");

const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) => {
  return () => {
    const renderedNativeWaveShaperNodes = new WeakMap();

    const createWaveShaperNode = async (proxy, nativeOfflineAudioContext) => {
      let nativeWaveShaperNode = getNativeAudioNode(proxy); // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.

      const nativeWaveShaperNodeIsOwnedByContext = (0, _isOwnedByContext.isOwnedByContext)(nativeWaveShaperNode, nativeOfflineAudioContext);

      if (!nativeWaveShaperNodeIsOwnedByContext) {
        const options = {
          channelCount: nativeWaveShaperNode.channelCount,
          channelCountMode: nativeWaveShaperNode.channelCountMode,
          channelInterpretation: nativeWaveShaperNode.channelInterpretation,
          curve: nativeWaveShaperNode.curve,
          oversample: nativeWaveShaperNode.oversample
        };
        nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);
      }

      renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);

      if ((0, _nativeAudioNodeFaker.isNativeAudioNodeFaker)(nativeWaveShaperNode)) {
        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);
      } else {
        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);
      }

      return nativeWaveShaperNode;
    };

    return {
      render(proxy, nativeOfflineAudioContext) {
        const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);

        if (renderedNativeWaveShaperNode !== undefined) {
          return Promise.resolve(renderedNativeWaveShaperNode);
        }

        return createWaveShaperNode(proxy, nativeOfflineAudioContext);
      }

    };
  };
};

exports.createWaveShaperNodeRendererFactory = createWaveShaperNodeRendererFactory;
},{"../guards/native-audio-node-faker":"../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js","../helpers/is-owned-by-context":"../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"}],"../node_modules/standardized-audio-context/build/es2019/factories/window.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWindow = void 0;

const createWindow = () => typeof window === 'undefined' ? null : window;

exports.createWindow = createWindow;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWrapAudioBufferCopyChannelMethods = void 0;

const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {
  return audioBuffer => {
    audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
      const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);
      const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);

      if (channelNumber >= audioBuffer.numberOfChannels) {
        throw createIndexSizeError();
      }

      const audioBufferLength = audioBuffer.length;
      const channelData = audioBuffer.getChannelData(channelNumber);
      const destinationLength = destination.length;

      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {
        destination[i] = channelData[i + bufferOffset];
      }
    };

    audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
      const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);
      const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);

      if (channelNumber >= audioBuffer.numberOfChannels) {
        throw createIndexSizeError();
      }

      const audioBufferLength = audioBuffer.length;
      const channelData = audioBuffer.getChannelData(channelNumber);
      const sourceLength = source.length;

      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {
        channelData[i + bufferOffset] = source[i];
      }
    };
  };
};

exports.createWrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWrapAudioBufferCopyChannelMethodsOutOfBounds = void 0;

const createWrapAudioBufferCopyChannelMethodsOutOfBounds = convertNumberToUnsignedLong => {
  return audioBuffer => {
    audioBuffer.copyFromChannel = (copyFromChannel => {
      return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
        const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);
        const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);

        if (bufferOffset < audioBuffer.length) {
          return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);
        }
      };
    })(audioBuffer.copyFromChannel);

    audioBuffer.copyToChannel = (copyToChannel => {
      return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
        const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);
        const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);

        if (bufferOffset < audioBuffer.length) {
          return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);
        }
      };
    })(audioBuffer.copyToChannel);
  };
};

exports.createWrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = void 0;

const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = overwriteAccessors => {
  return (nativeAudioBufferSourceNode, nativeContext) => {
    const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);

    if (nativeAudioBufferSourceNode.buffer === null) {
      nativeAudioBufferSourceNode.buffer = nullifiedBuffer;
    }

    overwriteAccessors(nativeAudioBufferSourceNode, 'buffer', get => () => {
      const value = get.call(nativeAudioBufferSourceNode);
      return value === nullifiedBuffer ? null : value;
    }, set => value => {
      return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);
    });
  };
};

exports.createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer;
},{}],"../node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWrapChannelMergerNode = void 0;

const createWrapChannelMergerNode = (createInvalidStateError, monitorConnections) => {
  return (nativeContext, channelMergerNode) => {
    // Bug #15: Safari does not return the default properties.
    channelMergerNode.channelCount = 1;
    channelMergerNode.channelCountMode = 'explicit'; // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.

    Object.defineProperty(channelMergerNode, 'channelCount', {
      get: () => 1,
      set: () => {
        throw createInvalidStateError();
      }
    });
    Object.defineProperty(channelMergerNode, 'channelCountMode', {
      get: () => 'explicit',
      set: () => {
        throw createInvalidStateError();
      }
    }); // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.

    const audioBufferSourceNode = nativeContext.createBufferSource();

    const whenConnected = () => {
      const length = channelMergerNode.numberOfInputs;

      for (let i = 0; i < length; i += 1) {
        audioBufferSourceNode.connect(channelMergerNode, 0, i);
      }
    };

    const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);

    monitorConnections(channelMergerNode, whenConnected, whenDisconnected);
  };
};

exports.createWrapChannelMergerNode = createWrapChannelMergerNode;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/get-first-sample.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFirstSample = void 0;

const getFirstSample = (audioBuffer, buffer, channelNumber) => {
  // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
  if (audioBuffer.copyFromChannel === undefined) {
    return audioBuffer.getChannelData(channelNumber)[0];
  }

  audioBuffer.copyFromChannel(buffer, channelNumber);
  return buffer[0];
};

exports.getFirstSample = getFirstSample;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/is-dc-curve.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDCCurve = void 0;

const isDCCurve = curve => {
  if (curve === null) {
    return false;
  }

  const length = curve.length;

  if (length % 2 !== 0) {
    return curve[Math.floor(length / 2)] !== 0;
  }

  return curve[length / 2 - 1] + curve[length / 2] !== 0;
};

exports.isDCCurve = isDCCurve;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.overwriteAccessors = void 0;

const overwriteAccessors = (object, property, createGetter, createSetter) => {
  let prototype = object;

  while (!prototype.hasOwnProperty(property)) {
    prototype = Object.getPrototypeOf(prototype);
  }

  const {
    get,
    set
  } = Object.getOwnPropertyDescriptor(prototype, property);
  Object.defineProperty(object, property, {
    get: createGetter(get),
    set: createSetter(set)
  });
};

exports.overwriteAccessors = overwriteAccessors;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/sanitize-audio-worklet-node-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sanitizeAudioWorkletNodeOptions = void 0;

const sanitizeAudioWorkletNodeOptions = options => {
  return { ...options,
    outputChannelCount: options.outputChannelCount !== undefined ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ?
    /*
     * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why
     * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That
     * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.
     */
    [options.channelCount] : Array.from({
      length: options.numberOfOutputs
    }, () => 1)
  };
};

exports.sanitizeAudioWorkletNodeOptions = sanitizeAudioWorkletNodeOptions;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/sanitize-channel-splitter-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sanitizeChannelSplitterOptions = void 0;

const sanitizeChannelSplitterOptions = options => {
  return { ...options,
    channelCount: options.numberOfOutputs
  };
};

exports.sanitizeChannelSplitterOptions = sanitizeChannelSplitterOptions;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/sanitize-periodic-wave-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sanitizePeriodicWaveOptions = void 0;

const sanitizePeriodicWaveOptions = options => {
  const {
    imag,
    real
  } = options;

  if (imag === undefined) {
    if (real === undefined) {
      return { ...options,
        imag: [0, 0],
        real: [0, 0]
      };
    }

    return { ...options,
      imag: Array.from(real, () => 0),
      real
    };
  }

  if (real === undefined) {
    return { ...options,
      imag,
      real: Array.from(imag, () => 0)
    };
  }

  return { ...options,
    imag,
    real
  };
};

exports.sanitizePeriodicWaveOptions = sanitizePeriodicWaveOptions;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/set-value-at-time-until-possible.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setValueAtTimeUntilPossible = void 0;

const setValueAtTimeUntilPossible = (audioParam, value, startTime) => {
  try {
    audioParam.setValueAtTime(value, startTime);
  } catch (err) {
    if (err.code !== 9) {
      throw err;
    }

    setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);
  }
};

exports.setValueAtTimeUntilPossible = setValueAtTimeUntilPossible;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = void 0;

const testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = nativeContext => {
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  nativeAudioBufferSourceNode.start();

  try {
    nativeAudioBufferSourceNode.start();
  } catch {
    return true;
  }

  return false;
};

exports.testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testAudioBufferSourceNodeStartMethodOffsetClampingSupport = void 0;

const testAudioBufferSourceNodeStartMethodOffsetClampingSupport = nativeContext => {
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
  nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;

  try {
    nativeAudioBufferSourceNode.start(0, 1);
  } catch {
    return false;
  }

  return true;
};

exports.testAudioBufferSourceNodeStartMethodOffsetClampingSupport = testAudioBufferSourceNodeStartMethodOffsetClampingSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = void 0;

const testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = nativeContext => {
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  nativeAudioBufferSourceNode.start();

  try {
    nativeAudioBufferSourceNode.stop();
  } catch {
    return false;
  }

  return true;
};

exports.testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = testAudioBufferSourceNodeStopMethodNullifiedBufferSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = void 0;

const testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = nativeContext => {
  const nativeAudioBufferSourceNode = nativeContext.createOscillator();

  try {
    nativeAudioBufferSourceNode.start(-1);
  } catch (err) {
    return err instanceof RangeError;
  }

  return false;
};

exports.testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = testAudioScheduledSourceNodeStartMethodNegativeParametersSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = void 0;

const testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = nativeContext => {
  const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
  nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
  nativeAudioBufferSourceNode.start();
  nativeAudioBufferSourceNode.stop();

  try {
    nativeAudioBufferSourceNode.stop();
    return true;
  } catch {
    return false;
  }
};

exports.testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = void 0;

const testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = nativeContext => {
  const nativeAudioBufferSourceNode = nativeContext.createOscillator();

  try {
    nativeAudioBufferSourceNode.stop(-1);
  } catch (err) {
    return err instanceof RangeError;
  }

  return false;
};

exports.testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = testAudioScheduledSourceNodeStopMethodNegativeParametersSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-worklet-node-options-clonability.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testAudioWorkletNodeOptionsClonability = void 0;

const testAudioWorkletNodeOptionsClonability = audioWorkletNodeOptions => {
  const {
    port1,
    port2
  } = new MessageChannel();

  try {
    // This will throw an error if the audioWorkletNodeOptions are not clonable.
    port1.postMessage(audioWorkletNodeOptions);
  } finally {
    port1.close();
    port2.close();
  }
};

exports.testAudioWorkletNodeOptionsClonability = testAudioWorkletNodeOptionsClonability;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-dom-exception-constructor-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testDomExceptionConstructorSupport = void 0;

/*
 * Bug #122: Edge up to version v18 did not allow to construct a DOMException'. It also had a couple more bugs but since this is easy to
 * test it's used here as a placeholder.
 *
 * Bug #27: Edge up to version v18 did reject an invalid arrayBuffer passed to decodeAudioData() with a DOMException.
 *
 * Bug #50: Edge up to version v18 did not allow to create AudioNodes on a closed context.
 *
 * Bug #57: Edge up to version v18 did not throw an error when assigning the type of an OscillatorNode to 'custom'.
 *
 * Bug #63: Edge up to version v18 did not expose the mediaElement property of a MediaElementAudioSourceNode.
 *
 * Bug #64: Edge up to version v18 did not support the MediaStreamAudioDestinationNode.
 *
 * Bug #71: Edge up to version v18 did not allow to set the buffer of an AudioBufferSourceNode to null.
 *
 * Bug #93: Edge up to version v18 did set the sampleRate of an AudioContext to zero when it was closed.
 *
 * Bug #101: Edge up to version v18 refused to execute decodeAudioData() on a closed context.
 *
 * Bug #106: Edge up to version v18 did not expose the maxValue and minValue properties of the pan AudioParam of a StereoPannerNode.
 *
 * Bug #110: Edge up to version v18 did not expose the maxValue and minValue properties of the attack, knee, ratio, release and threshold AudioParams of a DynamicsCompressorNode.
 *
 * Bug #123: Edge up to version v18 did not support HRTF as the panningModel for a PannerNode.
 *
 * Bug #145: Edge up to version v18 did throw an IndexSizeError when an OfflineAudioContext was created with a sampleRate of zero.
 *
 * Bug #161: Edge up to version v18 did not expose the maxValue and minValue properties of the delayTime AudioParam of a DelayNode.
 */
const testDomExceptionConstructorSupport = () => {
  try {
    new DOMException(); // tslint:disable-line:no-unused-expression
  } catch {
    return false;
  }

  return true;
};

exports.testDomExceptionConstructorSupport = testDomExceptionConstructorSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/test-transferables-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testTransferablesSupport = void 0;

// Safari at version 11 did not support transferables.
const testTransferablesSupport = () => new Promise(resolve => {
  const arrayBuffer = new ArrayBuffer(0);
  const {
    port1,
    port2
  } = new MessageChannel();

  port1.onmessage = ({
    data
  }) => resolve(data !== null);

  port2.postMessage(arrayBuffer, [arrayBuffer]);
});

exports.testTransferablesSupport = testTransferablesSupport;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapAudioBufferSourceNodeStartMethodOffsetClamping = void 0;

const wrapAudioBufferSourceNodeStartMethodOffsetClamping = nativeAudioBufferSourceNode => {
  nativeAudioBufferSourceNode.start = (start => {
    return (when = 0, offset = 0, duration) => {
      const buffer = nativeAudioBufferSourceNode.buffer; // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.

      const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset); // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.

      if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {
        start.call(nativeAudioBufferSourceNode, when, 0, 0);
      } else {
        start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);
      }
    };
  })(nativeAudioBufferSourceNode.start);
};

exports.wrapAudioBufferSourceNodeStartMethodOffsetClamping = wrapAudioBufferSourceNodeStartMethodOffsetClamping;
},{}],"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = void 0;

var _interceptConnections = require("./intercept-connections");

const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {
  const nativeGainNode = nativeContext.createGain();
  nativeAudioScheduledSourceNode.connect(nativeGainNode);

  const disconnectGainNode = (disconnect => {
    return () => {
      // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.
      disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);
      nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);
    };
  })(nativeAudioScheduledSourceNode.disconnect);

  nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);
  (0, _interceptConnections.interceptConnections)(nativeAudioScheduledSourceNode, nativeGainNode);

  nativeAudioScheduledSourceNode.stop = (stop => {
    let isStopped = false;
    return (when = 0) => {
      if (isStopped) {
        try {
          stop.call(nativeAudioScheduledSourceNode, when);
        } catch {
          nativeGainNode.gain.setValueAtTime(0, when);
        }
      } else {
        stop.call(nativeAudioScheduledSourceNode, when);
        isStopped = true;
      }
    };
  })(nativeAudioScheduledSourceNode.stop);
};

exports.wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls;
},{"./intercept-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js"}],"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapEventListener = void 0;

const wrapEventListener = (target, eventListener) => {
  return event => {
    const descriptor = {
      value: target
    };
    Object.defineProperties(event, {
      currentTarget: descriptor,
      target: descriptor
    });

    if (typeof eventListener === 'function') {
      return eventListener.call(target, event);
    }

    return eventListener.handleEvent.call(target, event);
  };
};

exports.wrapEventListener = wrapEventListener;
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/analyser-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/analyser-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-node-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-context-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-destination-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-listener.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-node-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-node-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-param-descriptor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-param-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-scheduled-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-scheduled-source-node-event-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node-event-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-processor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-processor-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/automation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/base-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/biquad-filter-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/biquad-filter-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/channel-merger-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/channel-splitter-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/common-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/common-offline-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-node-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/convolver-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/convolver-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/delay-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/delay-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/dynamics-compressor-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/dynamics-compressor-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/event-target.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/gain-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/gain-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/iir-filter-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/iir-filter-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/media-element-audio-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/media-element-audio-source-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-destination-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-source-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-track-audio-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-track-audio-source-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/minimal-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/minimal-base-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/minimal-base-audio-context-event-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/minimal-offline-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/native-audio-node-faker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/native-audio-worklet-node-faker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/native-constant-source-node-faker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/native-convolver-node-faker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/native-iir-filter-node-faker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/native-panner-node-faker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/native-stereo-panner-node-faker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/native-wave-shaper-node-faker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-completion-event.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-node-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/panner-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/panner-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave-constraints.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/read-only-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/stereo-panner-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/stereo-panner-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/wave-shaper-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/wave-shaper-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/worklet-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/interfaces/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _analyserNode = require("./analyser-node");

Object.keys(_analyserNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _analyserNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _analyserNode[key];
    }
  });
});

var _analyserOptions = require("./analyser-options");

Object.keys(_analyserOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _analyserOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _analyserOptions[key];
    }
  });
});

var _audioBuffer = require("./audio-buffer");

Object.keys(_audioBuffer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBuffer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBuffer[key];
    }
  });
});

var _audioBufferOptions = require("./audio-buffer-options");

Object.keys(_audioBufferOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferOptions[key];
    }
  });
});

var _audioBufferSourceNode = require("./audio-buffer-source-node");

Object.keys(_audioBufferSourceNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferSourceNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferSourceNode[key];
    }
  });
});

var _audioBufferSourceNodeRenderer = require("./audio-buffer-source-node-renderer");

Object.keys(_audioBufferSourceNodeRenderer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferSourceNodeRenderer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferSourceNodeRenderer[key];
    }
  });
});

var _audioBufferSourceOptions = require("./audio-buffer-source-options");

Object.keys(_audioBufferSourceOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferSourceOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferSourceOptions[key];
    }
  });
});

var _audioContext = require("./audio-context");

Object.keys(_audioContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioContext[key];
    }
  });
});

var _audioContextOptions = require("./audio-context-options");

Object.keys(_audioContextOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioContextOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioContextOptions[key];
    }
  });
});

var _audioDestinationNode = require("./audio-destination-node");

Object.keys(_audioDestinationNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioDestinationNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioDestinationNode[key];
    }
  });
});

var _audioListener = require("./audio-listener");

Object.keys(_audioListener).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioListener[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioListener[key];
    }
  });
});

var _audioNode = require("./audio-node");

Object.keys(_audioNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioNode[key];
    }
  });
});

var _audioNodeOptions = require("./audio-node-options");

Object.keys(_audioNodeOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioNodeOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioNodeOptions[key];
    }
  });
});

var _audioNodeRenderer = require("./audio-node-renderer");

Object.keys(_audioNodeRenderer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioNodeRenderer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioNodeRenderer[key];
    }
  });
});

var _audioParam = require("./audio-param");

Object.keys(_audioParam).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParam[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParam[key];
    }
  });
});

var _audioParamDescriptor = require("./audio-param-descriptor");

Object.keys(_audioParamDescriptor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParamDescriptor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParamDescriptor[key];
    }
  });
});

var _audioParamRenderer = require("./audio-param-renderer");

Object.keys(_audioParamRenderer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParamRenderer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParamRenderer[key];
    }
  });
});

var _audioScheduledSourceNode = require("./audio-scheduled-source-node");

Object.keys(_audioScheduledSourceNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioScheduledSourceNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioScheduledSourceNode[key];
    }
  });
});

var _audioScheduledSourceNodeEventMap = require("./audio-scheduled-source-node-event-map");

Object.keys(_audioScheduledSourceNodeEventMap).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioScheduledSourceNodeEventMap[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioScheduledSourceNodeEventMap[key];
    }
  });
});

var _audioWorklet = require("./audio-worklet");

Object.keys(_audioWorklet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioWorklet[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioWorklet[key];
    }
  });
});

var _audioWorkletNode = require("./audio-worklet-node");

Object.keys(_audioWorkletNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioWorkletNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioWorkletNode[key];
    }
  });
});

var _audioWorkletNodeEventMap = require("./audio-worklet-node-event-map");

Object.keys(_audioWorkletNodeEventMap).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioWorkletNodeEventMap[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioWorkletNodeEventMap[key];
    }
  });
});

var _audioWorkletNodeOptions = require("./audio-worklet-node-options");

Object.keys(_audioWorkletNodeOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioWorkletNodeOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioWorkletNodeOptions[key];
    }
  });
});

var _audioWorkletProcessor = require("./audio-worklet-processor");

Object.keys(_audioWorkletProcessor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioWorkletProcessor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioWorkletProcessor[key];
    }
  });
});

var _audioWorkletProcessorConstructor = require("./audio-worklet-processor-constructor");

Object.keys(_audioWorkletProcessorConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioWorkletProcessorConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioWorkletProcessorConstructor[key];
    }
  });
});

var _automation = require("./automation");

Object.keys(_automation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _automation[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _automation[key];
    }
  });
});

var _baseAudioContext = require("./base-audio-context");

Object.keys(_baseAudioContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _baseAudioContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _baseAudioContext[key];
    }
  });
});

var _biquadFilterNode = require("./biquad-filter-node");

Object.keys(_biquadFilterNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _biquadFilterNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _biquadFilterNode[key];
    }
  });
});

var _biquadFilterOptions = require("./biquad-filter-options");

Object.keys(_biquadFilterOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _biquadFilterOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _biquadFilterOptions[key];
    }
  });
});

var _channelMergerOptions = require("./channel-merger-options");

Object.keys(_channelMergerOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelMergerOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelMergerOptions[key];
    }
  });
});

var _channelSplitterOptions = require("./channel-splitter-options");

Object.keys(_channelSplitterOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelSplitterOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelSplitterOptions[key];
    }
  });
});

var _commonAudioContext = require("./common-audio-context");

Object.keys(_commonAudioContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _commonAudioContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _commonAudioContext[key];
    }
  });
});

var _commonOfflineAudioContext = require("./common-offline-audio-context");

Object.keys(_commonOfflineAudioContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _commonOfflineAudioContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _commonOfflineAudioContext[key];
    }
  });
});

var _constantSourceNode = require("./constant-source-node");

Object.keys(_constantSourceNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constantSourceNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constantSourceNode[key];
    }
  });
});

var _constantSourceNodeRenderer = require("./constant-source-node-renderer");

Object.keys(_constantSourceNodeRenderer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constantSourceNodeRenderer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constantSourceNodeRenderer[key];
    }
  });
});

var _constantSourceOptions = require("./constant-source-options");

Object.keys(_constantSourceOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constantSourceOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constantSourceOptions[key];
    }
  });
});

var _convolverNode = require("./convolver-node");

Object.keys(_convolverNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _convolverNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _convolverNode[key];
    }
  });
});

var _convolverOptions = require("./convolver-options");

Object.keys(_convolverOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _convolverOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _convolverOptions[key];
    }
  });
});

var _delayNode = require("./delay-node");

Object.keys(_delayNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _delayNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _delayNode[key];
    }
  });
});

var _delayOptions = require("./delay-options");

Object.keys(_delayOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _delayOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _delayOptions[key];
    }
  });
});

var _dynamicsCompressorNode = require("./dynamics-compressor-node");

Object.keys(_dynamicsCompressorNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _dynamicsCompressorNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dynamicsCompressorNode[key];
    }
  });
});

var _dynamicsCompressorOptions = require("./dynamics-compressor-options");

Object.keys(_dynamicsCompressorOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _dynamicsCompressorOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dynamicsCompressorOptions[key];
    }
  });
});

var _eventTarget = require("./event-target");

Object.keys(_eventTarget).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _eventTarget[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _eventTarget[key];
    }
  });
});

var _gainNode = require("./gain-node");

Object.keys(_gainNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _gainNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _gainNode[key];
    }
  });
});

var _gainOptions = require("./gain-options");

Object.keys(_gainOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _gainOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _gainOptions[key];
    }
  });
});

var _iirFilterNode = require("./iir-filter-node");

Object.keys(_iirFilterNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _iirFilterNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _iirFilterNode[key];
    }
  });
});

var _iirFilterOptions = require("./iir-filter-options");

Object.keys(_iirFilterOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _iirFilterOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _iirFilterOptions[key];
    }
  });
});

var _mediaElementAudioSourceNode = require("./media-element-audio-source-node");

Object.keys(_mediaElementAudioSourceNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaElementAudioSourceNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaElementAudioSourceNode[key];
    }
  });
});

var _mediaElementAudioSourceOptions = require("./media-element-audio-source-options");

Object.keys(_mediaElementAudioSourceOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaElementAudioSourceOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaElementAudioSourceOptions[key];
    }
  });
});

var _mediaStreamAudioDestinationNode = require("./media-stream-audio-destination-node");

Object.keys(_mediaStreamAudioDestinationNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamAudioDestinationNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamAudioDestinationNode[key];
    }
  });
});

var _mediaStreamAudioSourceNode = require("./media-stream-audio-source-node");

Object.keys(_mediaStreamAudioSourceNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamAudioSourceNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamAudioSourceNode[key];
    }
  });
});

var _mediaStreamAudioSourceOptions = require("./media-stream-audio-source-options");

Object.keys(_mediaStreamAudioSourceOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamAudioSourceOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamAudioSourceOptions[key];
    }
  });
});

var _mediaStreamTrackAudioSourceNode = require("./media-stream-track-audio-source-node");

Object.keys(_mediaStreamTrackAudioSourceNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamTrackAudioSourceNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamTrackAudioSourceNode[key];
    }
  });
});

var _mediaStreamTrackAudioSourceOptions = require("./media-stream-track-audio-source-options");

Object.keys(_mediaStreamTrackAudioSourceOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamTrackAudioSourceOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamTrackAudioSourceOptions[key];
    }
  });
});

var _minimalAudioContext = require("./minimal-audio-context");

Object.keys(_minimalAudioContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _minimalAudioContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _minimalAudioContext[key];
    }
  });
});

var _minimalBaseAudioContext = require("./minimal-base-audio-context");

Object.keys(_minimalBaseAudioContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _minimalBaseAudioContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _minimalBaseAudioContext[key];
    }
  });
});

var _minimalBaseAudioContextEventMap = require("./minimal-base-audio-context-event-map");

Object.keys(_minimalBaseAudioContextEventMap).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _minimalBaseAudioContextEventMap[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _minimalBaseAudioContextEventMap[key];
    }
  });
});

var _minimalOfflineAudioContext = require("./minimal-offline-audio-context");

Object.keys(_minimalOfflineAudioContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _minimalOfflineAudioContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _minimalOfflineAudioContext[key];
    }
  });
});

var _nativeAudioNodeFaker = require("./native-audio-node-faker");

Object.keys(_nativeAudioNodeFaker).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioNodeFaker[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioNodeFaker[key];
    }
  });
});

var _nativeAudioWorkletNodeFaker = require("./native-audio-worklet-node-faker");

Object.keys(_nativeAudioWorkletNodeFaker).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioWorkletNodeFaker[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioWorkletNodeFaker[key];
    }
  });
});

var _nativeConstantSourceNodeFaker = require("./native-constant-source-node-faker");

Object.keys(_nativeConstantSourceNodeFaker).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeConstantSourceNodeFaker[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeConstantSourceNodeFaker[key];
    }
  });
});

var _nativeConvolverNodeFaker = require("./native-convolver-node-faker");

Object.keys(_nativeConvolverNodeFaker).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeConvolverNodeFaker[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeConvolverNodeFaker[key];
    }
  });
});

var _nativeIirFilterNodeFaker = require("./native-iir-filter-node-faker");

Object.keys(_nativeIirFilterNodeFaker).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeIirFilterNodeFaker[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeIirFilterNodeFaker[key];
    }
  });
});

var _nativePannerNodeFaker = require("./native-panner-node-faker");

Object.keys(_nativePannerNodeFaker).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativePannerNodeFaker[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativePannerNodeFaker[key];
    }
  });
});

var _nativeStereoPannerNodeFaker = require("./native-stereo-panner-node-faker");

Object.keys(_nativeStereoPannerNodeFaker).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeStereoPannerNodeFaker[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeStereoPannerNodeFaker[key];
    }
  });
});

var _nativeWaveShaperNodeFaker = require("./native-wave-shaper-node-faker");

Object.keys(_nativeWaveShaperNodeFaker).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeWaveShaperNodeFaker[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeWaveShaperNodeFaker[key];
    }
  });
});

var _offlineAudioCompletionEvent = require("./offline-audio-completion-event");

Object.keys(_offlineAudioCompletionEvent).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _offlineAudioCompletionEvent[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _offlineAudioCompletionEvent[key];
    }
  });
});

var _offlineAudioContext = require("./offline-audio-context");

Object.keys(_offlineAudioContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _offlineAudioContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _offlineAudioContext[key];
    }
  });
});

var _offlineAudioContextConstructor = require("./offline-audio-context-constructor");

Object.keys(_offlineAudioContextConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _offlineAudioContextConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _offlineAudioContextConstructor[key];
    }
  });
});

var _offlineAudioContextOptions = require("./offline-audio-context-options");

Object.keys(_offlineAudioContextOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _offlineAudioContextOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _offlineAudioContextOptions[key];
    }
  });
});

var _oscillatorNode = require("./oscillator-node");

Object.keys(_oscillatorNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _oscillatorNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _oscillatorNode[key];
    }
  });
});

var _oscillatorNodeRenderer = require("./oscillator-node-renderer");

Object.keys(_oscillatorNodeRenderer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _oscillatorNodeRenderer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _oscillatorNodeRenderer[key];
    }
  });
});

var _oscillatorOptions = require("./oscillator-options");

Object.keys(_oscillatorOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _oscillatorOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _oscillatorOptions[key];
    }
  });
});

var _pannerNode = require("./panner-node");

Object.keys(_pannerNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _pannerNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pannerNode[key];
    }
  });
});

var _pannerOptions = require("./panner-options");

Object.keys(_pannerOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _pannerOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pannerOptions[key];
    }
  });
});

var _periodicWave = require("./periodic-wave");

Object.keys(_periodicWave).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _periodicWave[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _periodicWave[key];
    }
  });
});

var _periodicWaveConstraints = require("./periodic-wave-constraints");

Object.keys(_periodicWaveConstraints).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _periodicWaveConstraints[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _periodicWaveConstraints[key];
    }
  });
});

var _periodicWaveOptions = require("./periodic-wave-options");

Object.keys(_periodicWaveOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _periodicWaveOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _periodicWaveOptions[key];
    }
  });
});

var _readOnlyMap = require("./read-only-map");

Object.keys(_readOnlyMap).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _readOnlyMap[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _readOnlyMap[key];
    }
  });
});

var _stereoPannerNode = require("./stereo-panner-node");

Object.keys(_stereoPannerNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _stereoPannerNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stereoPannerNode[key];
    }
  });
});

var _stereoPannerOptions = require("./stereo-panner-options");

Object.keys(_stereoPannerOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _stereoPannerOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stereoPannerOptions[key];
    }
  });
});

var _waveShaperNode = require("./wave-shaper-node");

Object.keys(_waveShaperNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _waveShaperNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _waveShaperNode[key];
    }
  });
});

var _waveShaperOptions = require("./wave-shaper-options");

Object.keys(_waveShaperOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _waveShaperOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _waveShaperOptions[key];
    }
  });
});

var _workletOptions = require("./worklet-options");

Object.keys(_workletOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _workletOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _workletOptions[key];
    }
  });
});
},{"./analyser-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/analyser-node.js","./analyser-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/analyser-options.js","./audio-buffer":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer.js","./audio-buffer-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-options.js","./audio-buffer-source-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-node.js","./audio-buffer-source-node-renderer":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-node-renderer.js","./audio-buffer-source-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-options.js","./audio-context":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-context.js","./audio-context-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-context-options.js","./audio-destination-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-destination-node.js","./audio-listener":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-listener.js","./audio-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-node.js","./audio-node-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-node-options.js","./audio-node-renderer":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-node-renderer.js","./audio-param":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-param.js","./audio-param-descriptor":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-param-descriptor.js","./audio-param-renderer":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-param-renderer.js","./audio-scheduled-source-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-scheduled-source-node.js","./audio-scheduled-source-node-event-map":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-scheduled-source-node-event-map.js","./audio-worklet":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet.js","./audio-worklet-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node.js","./audio-worklet-node-event-map":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node-event-map.js","./audio-worklet-node-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node-options.js","./audio-worklet-processor":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-processor.js","./audio-worklet-processor-constructor":"../node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-processor-constructor.js","./automation":"../node_modules/standardized-audio-context/build/es2019/interfaces/automation.js","./base-audio-context":"../node_modules/standardized-audio-context/build/es2019/interfaces/base-audio-context.js","./biquad-filter-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/biquad-filter-node.js","./biquad-filter-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/biquad-filter-options.js","./channel-merger-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/channel-merger-options.js","./channel-splitter-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/channel-splitter-options.js","./common-audio-context":"../node_modules/standardized-audio-context/build/es2019/interfaces/common-audio-context.js","./common-offline-audio-context":"../node_modules/standardized-audio-context/build/es2019/interfaces/common-offline-audio-context.js","./constant-source-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-node.js","./constant-source-node-renderer":"../node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-node-renderer.js","./constant-source-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-options.js","./convolver-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/convolver-node.js","./convolver-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/convolver-options.js","./delay-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/delay-node.js","./delay-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/delay-options.js","./dynamics-compressor-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/dynamics-compressor-node.js","./dynamics-compressor-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/dynamics-compressor-options.js","./event-target":"../node_modules/standardized-audio-context/build/es2019/interfaces/event-target.js","./gain-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/gain-node.js","./gain-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/gain-options.js","./iir-filter-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/iir-filter-node.js","./iir-filter-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/iir-filter-options.js","./media-element-audio-source-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/media-element-audio-source-node.js","./media-element-audio-source-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/media-element-audio-source-options.js","./media-stream-audio-destination-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-destination-node.js","./media-stream-audio-source-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-source-node.js","./media-stream-audio-source-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-source-options.js","./media-stream-track-audio-source-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-track-audio-source-node.js","./media-stream-track-audio-source-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-track-audio-source-options.js","./minimal-audio-context":"../node_modules/standardized-audio-context/build/es2019/interfaces/minimal-audio-context.js","./minimal-base-audio-context":"../node_modules/standardized-audio-context/build/es2019/interfaces/minimal-base-audio-context.js","./minimal-base-audio-context-event-map":"../node_modules/standardized-audio-context/build/es2019/interfaces/minimal-base-audio-context-event-map.js","./minimal-offline-audio-context":"../node_modules/standardized-audio-context/build/es2019/interfaces/minimal-offline-audio-context.js","./native-audio-node-faker":"../node_modules/standardized-audio-context/build/es2019/interfaces/native-audio-node-faker.js","./native-audio-worklet-node-faker":"../node_modules/standardized-audio-context/build/es2019/interfaces/native-audio-worklet-node-faker.js","./native-constant-source-node-faker":"../node_modules/standardized-audio-context/build/es2019/interfaces/native-constant-source-node-faker.js","./native-convolver-node-faker":"../node_modules/standardized-audio-context/build/es2019/interfaces/native-convolver-node-faker.js","./native-iir-filter-node-faker":"../node_modules/standardized-audio-context/build/es2019/interfaces/native-iir-filter-node-faker.js","./native-panner-node-faker":"../node_modules/standardized-audio-context/build/es2019/interfaces/native-panner-node-faker.js","./native-stereo-panner-node-faker":"../node_modules/standardized-audio-context/build/es2019/interfaces/native-stereo-panner-node-faker.js","./native-wave-shaper-node-faker":"../node_modules/standardized-audio-context/build/es2019/interfaces/native-wave-shaper-node-faker.js","./offline-audio-completion-event":"../node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-completion-event.js","./offline-audio-context":"../node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context.js","./offline-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context-constructor.js","./offline-audio-context-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context-options.js","./oscillator-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-node.js","./oscillator-node-renderer":"../node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-node-renderer.js","./oscillator-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-options.js","./panner-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/panner-node.js","./panner-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/panner-options.js","./periodic-wave":"../node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave.js","./periodic-wave-constraints":"../node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave-constraints.js","./periodic-wave-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave-options.js","./read-only-map":"../node_modules/standardized-audio-context/build/es2019/interfaces/read-only-map.js","./stereo-panner-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/stereo-panner-node.js","./stereo-panner-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/stereo-panner-options.js","./wave-shaper-node":"../node_modules/standardized-audio-context/build/es2019/interfaces/wave-shaper-node.js","./wave-shaper-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/wave-shaper-options.js","./worklet-options":"../node_modules/standardized-audio-context/build/es2019/interfaces/worklet-options.js"}],"../node_modules/standardized-audio-context/build/es2019/types/abort-error-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/active-audio-worklet-node-inputs-store.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/active-input-connection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-active-input-connection-to-audio-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-active-input-connection-to-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-audio-node-connections-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-audio-node-connections-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-audio-param-connections-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-audio-param-connections-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-audio-worklet-module-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-audio-worklet-module-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-connection-to-audio-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-connection-to-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-passive-input-connection-to-audio-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-passive-input-connection-to-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-silent-connection-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-silent-connection-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-unrendered-audio-worklet-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/add-unrendered-audio-worklet-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/analyser-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/analyser-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/analyser-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/analyser-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/any-audio-buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/any-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-store.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-context-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-context-latency-category.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-context-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-listener-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-listener-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-node-connections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-node-connections-store.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-node-output-connection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-node-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-node-store.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-node-tail-time-store.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-param-audio-node-store.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-param-connections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-param-connections-store.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-param-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-param-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-param-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-param-output-connection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-param-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-param-store.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/backup-offline-audio-context-store.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/base-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/base-audio-context-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/biquad-filter-type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/channel-count-mode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/channel-interpretation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/cache-test-result-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/cache-test-result-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/connect-audio-param-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/connect-audio-param-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/connect-multiple-outputs-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/connect-multiple-outputs-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/connect-native-audio-node-to-native-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/connected-native-audio-buffer-source-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/connected-native-audio-buffer-source-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/constant-source-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/constant-source-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/context-store.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/convert-number-to-unsigned-long-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/convert-number-to-unsigned-long-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/convolver-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/convolver-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/convolver-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/convolver-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/create-native-offline-audio-context-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/create-native-offline-audio-context-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/cycle-counters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/data-clone-error-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/decode-audio-data-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/decode-audio-data-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/decode-error-callback.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/decode-success-callback.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/decrement-cycle-counter-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/decrement-cycle-counter-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/delay-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/delay-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/delay-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/delay-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/delete-active-input-connection-to-audio-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/delete-active-input-connection-to-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/delete-unrendered-audio-worklet-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/delete-unrendered-audio-worklet-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/detect-cycles-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/detect-cycles-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/disconnect-multiple-outputs-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/disconnect-multiple-outputs-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/disconnect-native-audio-node-from-native-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/distance-model-type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/encoding-error-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/error-event-handler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/evaluate-audio-worklet-global-scope-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/evaluate-source-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/evaluate-source-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/event-handler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/event-target-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/event-target-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/expose-current-frame-and-current-time-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/expose-current-frame-and-current-time-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/fetch-source-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/fetch-source-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/gain-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/gain-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/gain-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/gain-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-active-audio-worklet-node-inputs-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-active-audio-worklet-node-inputs-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-audio-node-connections-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-audio-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-audio-node-renderer-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-audio-node-tail-time-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-audio-node-tail-time-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-audio-param-connections-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-audio-param-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-audio-param-renderer-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-backup-offline-audio-context-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-backup-offline-audio-context-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-event-listeners-of-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-first-sample-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-native-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-native-audio-param-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-native-context-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-native-context-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-or-create-backup-offline-audio-context-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-or-create-backup-offline-audio-context-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-unrendered-audio-worklet-nodes-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-unrendered-audio-worklet-nodes-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/get-value-for-key-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/index-size-error-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/insert-element-in-set-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/internal-state-event-listener.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/invalid-access-error-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/invalid-state-error-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-active-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-context-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-context-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-param-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-param-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-any-offline-audio-context-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-any-offline-audio-context-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-dc-curve-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-context-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-context-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-param-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-param-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-native-context-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-native-context-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-native-offline-audio-context-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-native-offline-audio-context-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-part-of-a-cycle-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-passive-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-secure-context-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/is-supported-promise-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/media-element-audio-source-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/media-element-audio-source-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-destination-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-destination-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-source-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-source-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/media-stream-track-audio-source-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/media-stream-track-audio-source-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/minimal-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/minimal-audio-context-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/minimal-base-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/minimal-base-audio-context-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/minimal-offline-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/minimal-offline-audio-context-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/monitor-connections-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/monitor-connections-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-analyser-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-analyser-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-analyser-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-context-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-listener.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-param-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-faker-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-biquad-filter-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-biquad-filter-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-channel-splitter-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-channel-splitter-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-faker-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-convolver-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-convolver-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-convolver-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-delay-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-delay-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-event-target.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-gain-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-gain-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-faker-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-media-element-audio-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-media-element-audio-source-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-destination-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-destination-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-source-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-panner-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-panner-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-panner-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-panner-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-panner-node-faker-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-script-processor-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-script-processor-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-faker-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-faker-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-faker-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/not-supported-error-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/offline-audio-context-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/oscillator-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/oscillator-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/oscillator-type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/output-connection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/over-sample-type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/overwrite-accessors-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/panner-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/panner-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/panner-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/panner-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/panning-model-type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/passive-audio-node-input-connection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/passive-audio-param-input-connection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/periodic-wave-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/periodic-wave-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/pick-element-from-set-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/render-automation-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/render-automation-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-param-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-param-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/render-native-offline-audio-context-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/render-native-offline-audio-context-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/sanitize-audio-worklet-node-options-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/sanitize-channel-splitter-options-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/sanitize-periodic-wave-options-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/set-active-audio-worklet-node-inputs-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/set-active-audio-worklet-node-inputs-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/set-audio-node-tail-time-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/set-audio-node-tail-time-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/set-value-at-time-until-possible-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/start-rendering-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/start-rendering-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-audio-buffer-copy-channel-methods-subarray-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-audio-buffer-constructor-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-audio-context-close-method-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-audio-context-decode-audio-data-method-type-error-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-audio-context-options-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-audio-node-connect-method-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-node-options-clonability-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-processor-no-outputs-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-processor-post-message-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-channel-merger-node-channel-count-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-constant-source-node-accurate-scheduling-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-convolver-node-buffer-reassignability-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-convolver-node-channel-count-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-is-secure-context-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-offline-audio-context-current-time-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/test-stereo-panner-node-default-value-support-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/unknown-error-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/unrendered-audio-worklet-node-store.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/unrendered-audio-worklet-nodes.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-constructor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-constructor-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-renderer-factory-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-renderer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/window.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/window-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-out-of-bounds-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-out-of-bounds-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-start-method-offset-clamping-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-stop-method-nullified-buffer-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-stop-method-nullified-buffer-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-scheduled-source-node-stop-method-consecutive-calls-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wrap-channel-merger-node-factory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wrap-channel-merger-node-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/wrap-event-listener-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/standardized-audio-context/build/es2019/types/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _abortErrorFactory = require("./abort-error-factory");

Object.keys(_abortErrorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _abortErrorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _abortErrorFactory[key];
    }
  });
});

var _activeAudioWorkletNodeInputsStore = require("./active-audio-worklet-node-inputs-store");

Object.keys(_activeAudioWorkletNodeInputsStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _activeAudioWorkletNodeInputsStore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _activeAudioWorkletNodeInputsStore[key];
    }
  });
});

var _activeInputConnection = require("./active-input-connection");

Object.keys(_activeInputConnection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _activeInputConnection[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _activeInputConnection[key];
    }
  });
});

var _addActiveInputConnectionToAudioNodeFactory = require("./add-active-input-connection-to-audio-node-factory");

Object.keys(_addActiveInputConnectionToAudioNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addActiveInputConnectionToAudioNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addActiveInputConnectionToAudioNodeFactory[key];
    }
  });
});

var _addActiveInputConnectionToAudioNodeFunction = require("./add-active-input-connection-to-audio-node-function");

Object.keys(_addActiveInputConnectionToAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addActiveInputConnectionToAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addActiveInputConnectionToAudioNodeFunction[key];
    }
  });
});

var _addAudioNodeConnectionsFactory = require("./add-audio-node-connections-factory");

Object.keys(_addAudioNodeConnectionsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addAudioNodeConnectionsFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addAudioNodeConnectionsFactory[key];
    }
  });
});

var _addAudioNodeConnectionsFunction = require("./add-audio-node-connections-function");

Object.keys(_addAudioNodeConnectionsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addAudioNodeConnectionsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addAudioNodeConnectionsFunction[key];
    }
  });
});

var _addAudioParamConnectionsFactory = require("./add-audio-param-connections-factory");

Object.keys(_addAudioParamConnectionsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addAudioParamConnectionsFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addAudioParamConnectionsFactory[key];
    }
  });
});

var _addAudioParamConnectionsFunction = require("./add-audio-param-connections-function");

Object.keys(_addAudioParamConnectionsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addAudioParamConnectionsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addAudioParamConnectionsFunction[key];
    }
  });
});

var _addAudioWorkletModuleFactory = require("./add-audio-worklet-module-factory");

Object.keys(_addAudioWorkletModuleFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addAudioWorkletModuleFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addAudioWorkletModuleFactory[key];
    }
  });
});

var _addAudioWorkletModuleFunction = require("./add-audio-worklet-module-function");

Object.keys(_addAudioWorkletModuleFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addAudioWorkletModuleFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addAudioWorkletModuleFunction[key];
    }
  });
});

var _addConnectionToAudioNodeFactory = require("./add-connection-to-audio-node-factory");

Object.keys(_addConnectionToAudioNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addConnectionToAudioNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addConnectionToAudioNodeFactory[key];
    }
  });
});

var _addConnectionToAudioNodeFunction = require("./add-connection-to-audio-node-function");

Object.keys(_addConnectionToAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addConnectionToAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addConnectionToAudioNodeFunction[key];
    }
  });
});

var _addPassiveInputConnectionToAudioNodeFactory = require("./add-passive-input-connection-to-audio-node-factory");

Object.keys(_addPassiveInputConnectionToAudioNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addPassiveInputConnectionToAudioNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addPassiveInputConnectionToAudioNodeFactory[key];
    }
  });
});

var _addPassiveInputConnectionToAudioNodeFunction = require("./add-passive-input-connection-to-audio-node-function");

Object.keys(_addPassiveInputConnectionToAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addPassiveInputConnectionToAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addPassiveInputConnectionToAudioNodeFunction[key];
    }
  });
});

var _addSilentConnectionFactory = require("./add-silent-connection-factory");

Object.keys(_addSilentConnectionFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addSilentConnectionFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addSilentConnectionFactory[key];
    }
  });
});

var _addSilentConnectionFunction = require("./add-silent-connection-function");

Object.keys(_addSilentConnectionFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addSilentConnectionFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addSilentConnectionFunction[key];
    }
  });
});

var _addUnrenderedAudioWorkletNodeFactory = require("./add-unrendered-audio-worklet-node-factory");

Object.keys(_addUnrenderedAudioWorkletNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addUnrenderedAudioWorkletNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addUnrenderedAudioWorkletNodeFactory[key];
    }
  });
});

var _addUnrenderedAudioWorkletNodeFunction = require("./add-unrendered-audio-worklet-node-function");

Object.keys(_addUnrenderedAudioWorkletNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _addUnrenderedAudioWorkletNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _addUnrenderedAudioWorkletNodeFunction[key];
    }
  });
});

var _analyserNodeConstructor = require("./analyser-node-constructor");

Object.keys(_analyserNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _analyserNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _analyserNodeConstructor[key];
    }
  });
});

var _analyserNodeConstructorFactory = require("./analyser-node-constructor-factory");

Object.keys(_analyserNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _analyserNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _analyserNodeConstructorFactory[key];
    }
  });
});

var _analyserNodeRendererFactory = require("./analyser-node-renderer-factory");

Object.keys(_analyserNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _analyserNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _analyserNodeRendererFactory[key];
    }
  });
});

var _analyserNodeRendererFactoryFactory = require("./analyser-node-renderer-factory-factory");

Object.keys(_analyserNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _analyserNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _analyserNodeRendererFactoryFactory[key];
    }
  });
});

var _anyAudioBuffer = require("./any-audio-buffer");

Object.keys(_anyAudioBuffer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _anyAudioBuffer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _anyAudioBuffer[key];
    }
  });
});

var _anyContext = require("./any-context");

Object.keys(_anyContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _anyContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _anyContext[key];
    }
  });
});

var _audioBufferConstructor = require("./audio-buffer-constructor");

Object.keys(_audioBufferConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferConstructor[key];
    }
  });
});

var _audioBufferConstructorFactory = require("./audio-buffer-constructor-factory");

Object.keys(_audioBufferConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferConstructorFactory[key];
    }
  });
});

var _audioBufferSourceNodeConstructor = require("./audio-buffer-source-node-constructor");

Object.keys(_audioBufferSourceNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferSourceNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferSourceNodeConstructor[key];
    }
  });
});

var _audioBufferSourceNodeConstructorFactory = require("./audio-buffer-source-node-constructor-factory");

Object.keys(_audioBufferSourceNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferSourceNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferSourceNodeConstructorFactory[key];
    }
  });
});

var _audioBufferSourceNodeRenderer = require("./audio-buffer-source-node-renderer");

Object.keys(_audioBufferSourceNodeRenderer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferSourceNodeRenderer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferSourceNodeRenderer[key];
    }
  });
});

var _audioBufferSourceNodeRendererFactory = require("./audio-buffer-source-node-renderer-factory");

Object.keys(_audioBufferSourceNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferSourceNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferSourceNodeRendererFactory[key];
    }
  });
});

var _audioBufferSourceNodeRendererFactoryFactory = require("./audio-buffer-source-node-renderer-factory-factory");

Object.keys(_audioBufferSourceNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferSourceNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferSourceNodeRendererFactoryFactory[key];
    }
  });
});

var _audioBufferStore = require("./audio-buffer-store");

Object.keys(_audioBufferStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioBufferStore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioBufferStore[key];
    }
  });
});

var _audioContextConstructor = require("./audio-context-constructor");

Object.keys(_audioContextConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioContextConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioContextConstructor[key];
    }
  });
});

var _audioContextConstructorFactory = require("./audio-context-constructor-factory");

Object.keys(_audioContextConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioContextConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioContextConstructorFactory[key];
    }
  });
});

var _audioContextLatencyCategory = require("./audio-context-latency-category");

Object.keys(_audioContextLatencyCategory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioContextLatencyCategory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioContextLatencyCategory[key];
    }
  });
});

var _audioContextState = require("./audio-context-state");

Object.keys(_audioContextState).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioContextState[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioContextState[key];
    }
  });
});

var _audioDestinationNodeConstructor = require("./audio-destination-node-constructor");

Object.keys(_audioDestinationNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioDestinationNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioDestinationNodeConstructor[key];
    }
  });
});

var _audioDestinationNodeConstructorFactory = require("./audio-destination-node-constructor-factory");

Object.keys(_audioDestinationNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioDestinationNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioDestinationNodeConstructorFactory[key];
    }
  });
});

var _audioDestinationNodeRendererFactory = require("./audio-destination-node-renderer-factory");

Object.keys(_audioDestinationNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioDestinationNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioDestinationNodeRendererFactory[key];
    }
  });
});

var _audioListenerFactory = require("./audio-listener-factory");

Object.keys(_audioListenerFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioListenerFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioListenerFactory[key];
    }
  });
});

var _audioListenerFactoryFactory = require("./audio-listener-factory-factory");

Object.keys(_audioListenerFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioListenerFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioListenerFactoryFactory[key];
    }
  });
});

var _audioNodeConnections = require("./audio-node-connections");

Object.keys(_audioNodeConnections).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioNodeConnections[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioNodeConnections[key];
    }
  });
});

var _audioNodeConnectionsStore = require("./audio-node-connections-store");

Object.keys(_audioNodeConnectionsStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioNodeConnectionsStore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioNodeConnectionsStore[key];
    }
  });
});

var _audioNodeConstructor = require("./audio-node-constructor");

Object.keys(_audioNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioNodeConstructor[key];
    }
  });
});

var _audioNodeConstructorFactory = require("./audio-node-constructor-factory");

Object.keys(_audioNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioNodeConstructorFactory[key];
    }
  });
});

var _audioNodeOutputConnection = require("./audio-node-output-connection");

Object.keys(_audioNodeOutputConnection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioNodeOutputConnection[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioNodeOutputConnection[key];
    }
  });
});

var _audioNodeRenderer = require("./audio-node-renderer");

Object.keys(_audioNodeRenderer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioNodeRenderer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioNodeRenderer[key];
    }
  });
});

var _audioNodeStore = require("./audio-node-store");

Object.keys(_audioNodeStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioNodeStore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioNodeStore[key];
    }
  });
});

var _audioNodeTailTimeStore = require("./audio-node-tail-time-store");

Object.keys(_audioNodeTailTimeStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioNodeTailTimeStore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioNodeTailTimeStore[key];
    }
  });
});

var _audioParamAudioNodeStore = require("./audio-param-audio-node-store");

Object.keys(_audioParamAudioNodeStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParamAudioNodeStore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParamAudioNodeStore[key];
    }
  });
});

var _audioParamConnections = require("./audio-param-connections");

Object.keys(_audioParamConnections).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParamConnections[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParamConnections[key];
    }
  });
});

var _audioParamConnectionsStore = require("./audio-param-connections-store");

Object.keys(_audioParamConnectionsStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParamConnectionsStore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParamConnectionsStore[key];
    }
  });
});

var _audioParamFactory = require("./audio-param-factory");

Object.keys(_audioParamFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParamFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParamFactory[key];
    }
  });
});

var _audioParamFactoryFactory = require("./audio-param-factory-factory");

Object.keys(_audioParamFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParamFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParamFactoryFactory[key];
    }
  });
});

var _audioParamMap = require("./audio-param-map");

Object.keys(_audioParamMap).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParamMap[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParamMap[key];
    }
  });
});

var _audioParamOutputConnection = require("./audio-param-output-connection");

Object.keys(_audioParamOutputConnection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParamOutputConnection[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParamOutputConnection[key];
    }
  });
});

var _audioParamRendererFactory = require("./audio-param-renderer-factory");

Object.keys(_audioParamRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParamRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParamRendererFactory[key];
    }
  });
});

var _audioParamStore = require("./audio-param-store");

Object.keys(_audioParamStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioParamStore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioParamStore[key];
    }
  });
});

var _audioWorkletNodeConstructor = require("./audio-worklet-node-constructor");

Object.keys(_audioWorkletNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioWorkletNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioWorkletNodeConstructor[key];
    }
  });
});

var _audioWorkletNodeConstructorFactory = require("./audio-worklet-node-constructor-factory");

Object.keys(_audioWorkletNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioWorkletNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioWorkletNodeConstructorFactory[key];
    }
  });
});

var _audioWorkletNodeRendererFactory = require("./audio-worklet-node-renderer-factory");

Object.keys(_audioWorkletNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioWorkletNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioWorkletNodeRendererFactory[key];
    }
  });
});

var _audioWorkletNodeRendererFactoryFactory = require("./audio-worklet-node-renderer-factory-factory");

Object.keys(_audioWorkletNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _audioWorkletNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _audioWorkletNodeRendererFactoryFactory[key];
    }
  });
});

var _backupOfflineAudioContextStore = require("./backup-offline-audio-context-store");

Object.keys(_backupOfflineAudioContextStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _backupOfflineAudioContextStore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _backupOfflineAudioContextStore[key];
    }
  });
});

var _baseAudioContextConstructor = require("./base-audio-context-constructor");

Object.keys(_baseAudioContextConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _baseAudioContextConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _baseAudioContextConstructor[key];
    }
  });
});

var _baseAudioContextConstructorFactory = require("./base-audio-context-constructor-factory");

Object.keys(_baseAudioContextConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _baseAudioContextConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _baseAudioContextConstructorFactory[key];
    }
  });
});

var _biquadFilterNodeConstructor = require("./biquad-filter-node-constructor");

Object.keys(_biquadFilterNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _biquadFilterNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _biquadFilterNodeConstructor[key];
    }
  });
});

var _biquadFilterNodeConstructorFactory = require("./biquad-filter-node-constructor-factory");

Object.keys(_biquadFilterNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _biquadFilterNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _biquadFilterNodeConstructorFactory[key];
    }
  });
});

var _biquadFilterNodeRendererFactory = require("./biquad-filter-node-renderer-factory");

Object.keys(_biquadFilterNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _biquadFilterNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _biquadFilterNodeRendererFactory[key];
    }
  });
});

var _biquadFilterNodeRendererFactoryFactory = require("./biquad-filter-node-renderer-factory-factory");

Object.keys(_biquadFilterNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _biquadFilterNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _biquadFilterNodeRendererFactoryFactory[key];
    }
  });
});

var _biquadFilterType = require("./biquad-filter-type");

Object.keys(_biquadFilterType).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _biquadFilterType[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _biquadFilterType[key];
    }
  });
});

var _channelCountMode = require("./channel-count-mode");

Object.keys(_channelCountMode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelCountMode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelCountMode[key];
    }
  });
});

var _channelInterpretation = require("./channel-interpretation");

Object.keys(_channelInterpretation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelInterpretation[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelInterpretation[key];
    }
  });
});

var _channelMergerNodeConstructor = require("./channel-merger-node-constructor");

Object.keys(_channelMergerNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelMergerNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelMergerNodeConstructor[key];
    }
  });
});

var _channelMergerNodeConstructorFactory = require("./channel-merger-node-constructor-factory");

Object.keys(_channelMergerNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelMergerNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelMergerNodeConstructorFactory[key];
    }
  });
});

var _channelMergerNodeRendererFactory = require("./channel-merger-node-renderer-factory");

Object.keys(_channelMergerNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelMergerNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelMergerNodeRendererFactory[key];
    }
  });
});

var _channelMergerNodeRendererFactoryFactory = require("./channel-merger-node-renderer-factory-factory");

Object.keys(_channelMergerNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelMergerNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelMergerNodeRendererFactoryFactory[key];
    }
  });
});

var _channelSplitterNodeConstructor = require("./channel-splitter-node-constructor");

Object.keys(_channelSplitterNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelSplitterNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelSplitterNodeConstructor[key];
    }
  });
});

var _channelSplitterNodeConstructorFactory = require("./channel-splitter-node-constructor-factory");

Object.keys(_channelSplitterNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelSplitterNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelSplitterNodeConstructorFactory[key];
    }
  });
});

var _channelSplitterNodeRendererFactory = require("./channel-splitter-node-renderer-factory");

Object.keys(_channelSplitterNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelSplitterNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelSplitterNodeRendererFactory[key];
    }
  });
});

var _channelSplitterNodeRendererFactoryFactory = require("./channel-splitter-node-renderer-factory-factory");

Object.keys(_channelSplitterNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _channelSplitterNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _channelSplitterNodeRendererFactoryFactory[key];
    }
  });
});

var _cacheTestResultFactory = require("./cache-test-result-factory");

Object.keys(_cacheTestResultFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _cacheTestResultFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cacheTestResultFactory[key];
    }
  });
});

var _cacheTestResultFunction = require("./cache-test-result-function");

Object.keys(_cacheTestResultFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _cacheTestResultFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cacheTestResultFunction[key];
    }
  });
});

var _connectAudioParamFactory = require("./connect-audio-param-factory");

Object.keys(_connectAudioParamFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _connectAudioParamFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _connectAudioParamFactory[key];
    }
  });
});

var _connectAudioParamFunction = require("./connect-audio-param-function");

Object.keys(_connectAudioParamFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _connectAudioParamFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _connectAudioParamFunction[key];
    }
  });
});

var _connectMultipleOutputsFactory = require("./connect-multiple-outputs-factory");

Object.keys(_connectMultipleOutputsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _connectMultipleOutputsFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _connectMultipleOutputsFactory[key];
    }
  });
});

var _connectMultipleOutputsFunction = require("./connect-multiple-outputs-function");

Object.keys(_connectMultipleOutputsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _connectMultipleOutputsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _connectMultipleOutputsFunction[key];
    }
  });
});

var _connectNativeAudioNodeToNativeAudioNodeFunction = require("./connect-native-audio-node-to-native-audio-node-function");

Object.keys(_connectNativeAudioNodeToNativeAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _connectNativeAudioNodeToNativeAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _connectNativeAudioNodeToNativeAudioNodeFunction[key];
    }
  });
});

var _connectedNativeAudioBufferSourceNodeFactory = require("./connected-native-audio-buffer-source-node-factory");

Object.keys(_connectedNativeAudioBufferSourceNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _connectedNativeAudioBufferSourceNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _connectedNativeAudioBufferSourceNodeFactory[key];
    }
  });
});

var _connectedNativeAudioBufferSourceNodeFactoryFactory = require("./connected-native-audio-buffer-source-node-factory-factory");

Object.keys(_connectedNativeAudioBufferSourceNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _connectedNativeAudioBufferSourceNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _connectedNativeAudioBufferSourceNodeFactoryFactory[key];
    }
  });
});

var _constantSourceNodeConstructor = require("./constant-source-node-constructor");

Object.keys(_constantSourceNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constantSourceNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constantSourceNodeConstructor[key];
    }
  });
});

var _constantSourceNodeConstructorFactory = require("./constant-source-node-constructor-factory");

Object.keys(_constantSourceNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constantSourceNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constantSourceNodeConstructorFactory[key];
    }
  });
});

var _constantSourceNodeRenderer = require("./constant-source-node-renderer");

Object.keys(_constantSourceNodeRenderer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constantSourceNodeRenderer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constantSourceNodeRenderer[key];
    }
  });
});

var _constantSourceNodeRendererFactory = require("./constant-source-node-renderer-factory");

Object.keys(_constantSourceNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constantSourceNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constantSourceNodeRendererFactory[key];
    }
  });
});

var _constantSourceNodeRendererFactoryFactory = require("./constant-source-node-renderer-factory-factory");

Object.keys(_constantSourceNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constantSourceNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constantSourceNodeRendererFactoryFactory[key];
    }
  });
});

var _constructor = require("./constructor");

Object.keys(_constructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constructor[key];
    }
  });
});

var _context = require("./context");

Object.keys(_context).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _context[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _context[key];
    }
  });
});

var _contextStore = require("./context-store");

Object.keys(_contextStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _contextStore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _contextStore[key];
    }
  });
});

var _convertNumberToUnsignedLongFactory = require("./convert-number-to-unsigned-long-factory");

Object.keys(_convertNumberToUnsignedLongFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _convertNumberToUnsignedLongFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _convertNumberToUnsignedLongFactory[key];
    }
  });
});

var _convertNumberToUnsignedLongFunction = require("./convert-number-to-unsigned-long-function");

Object.keys(_convertNumberToUnsignedLongFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _convertNumberToUnsignedLongFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _convertNumberToUnsignedLongFunction[key];
    }
  });
});

var _convolverNodeConstructor = require("./convolver-node-constructor");

Object.keys(_convolverNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _convolverNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _convolverNodeConstructor[key];
    }
  });
});

var _convolverNodeConstructorFactory = require("./convolver-node-constructor-factory");

Object.keys(_convolverNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _convolverNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _convolverNodeConstructorFactory[key];
    }
  });
});

var _convolverNodeRendererFactory = require("./convolver-node-renderer-factory");

Object.keys(_convolverNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _convolverNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _convolverNodeRendererFactory[key];
    }
  });
});

var _convolverNodeRendererFactoryFactory = require("./convolver-node-renderer-factory-factory");

Object.keys(_convolverNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _convolverNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _convolverNodeRendererFactoryFactory[key];
    }
  });
});

var _createNativeOfflineAudioContextFactory = require("./create-native-offline-audio-context-factory");

Object.keys(_createNativeOfflineAudioContextFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _createNativeOfflineAudioContextFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _createNativeOfflineAudioContextFactory[key];
    }
  });
});

var _createNativeOfflineAudioContextFunction = require("./create-native-offline-audio-context-function");

Object.keys(_createNativeOfflineAudioContextFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _createNativeOfflineAudioContextFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _createNativeOfflineAudioContextFunction[key];
    }
  });
});

var _cycleCounters = require("./cycle-counters");

Object.keys(_cycleCounters).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _cycleCounters[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cycleCounters[key];
    }
  });
});

var _dataCloneErrorFactory = require("./data-clone-error-factory");

Object.keys(_dataCloneErrorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _dataCloneErrorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dataCloneErrorFactory[key];
    }
  });
});

var _decodeAudioDataFactory = require("./decode-audio-data-factory");

Object.keys(_decodeAudioDataFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _decodeAudioDataFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _decodeAudioDataFactory[key];
    }
  });
});

var _decodeAudioDataFunction = require("./decode-audio-data-function");

Object.keys(_decodeAudioDataFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _decodeAudioDataFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _decodeAudioDataFunction[key];
    }
  });
});

var _decodeErrorCallback = require("./decode-error-callback");

Object.keys(_decodeErrorCallback).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _decodeErrorCallback[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _decodeErrorCallback[key];
    }
  });
});

var _decodeSuccessCallback = require("./decode-success-callback");

Object.keys(_decodeSuccessCallback).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _decodeSuccessCallback[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _decodeSuccessCallback[key];
    }
  });
});

var _decrementCycleCounterFactory = require("./decrement-cycle-counter-factory");

Object.keys(_decrementCycleCounterFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _decrementCycleCounterFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _decrementCycleCounterFactory[key];
    }
  });
});

var _decrementCycleCounterFunction = require("./decrement-cycle-counter-function");

Object.keys(_decrementCycleCounterFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _decrementCycleCounterFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _decrementCycleCounterFunction[key];
    }
  });
});

var _delayNodeConstructor = require("./delay-node-constructor");

Object.keys(_delayNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _delayNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _delayNodeConstructor[key];
    }
  });
});

var _delayNodeConstructorFactory = require("./delay-node-constructor-factory");

Object.keys(_delayNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _delayNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _delayNodeConstructorFactory[key];
    }
  });
});

var _delayNodeRendererFactory = require("./delay-node-renderer-factory");

Object.keys(_delayNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _delayNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _delayNodeRendererFactory[key];
    }
  });
});

var _delayNodeRendererFactoryFactory = require("./delay-node-renderer-factory-factory");

Object.keys(_delayNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _delayNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _delayNodeRendererFactoryFactory[key];
    }
  });
});

var _deleteActiveInputConnectionToAudioNodeFactory = require("./delete-active-input-connection-to-audio-node-factory");

Object.keys(_deleteActiveInputConnectionToAudioNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _deleteActiveInputConnectionToAudioNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _deleteActiveInputConnectionToAudioNodeFactory[key];
    }
  });
});

var _deleteActiveInputConnectionToAudioNodeFunction = require("./delete-active-input-connection-to-audio-node-function");

Object.keys(_deleteActiveInputConnectionToAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _deleteActiveInputConnectionToAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _deleteActiveInputConnectionToAudioNodeFunction[key];
    }
  });
});

var _deleteUnrenderedAudioWorkletNodeFactory = require("./delete-unrendered-audio-worklet-node-factory");

Object.keys(_deleteUnrenderedAudioWorkletNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _deleteUnrenderedAudioWorkletNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _deleteUnrenderedAudioWorkletNodeFactory[key];
    }
  });
});

var _deleteUnrenderedAudioWorkletNodeFunction = require("./delete-unrendered-audio-worklet-node-function");

Object.keys(_deleteUnrenderedAudioWorkletNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _deleteUnrenderedAudioWorkletNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _deleteUnrenderedAudioWorkletNodeFunction[key];
    }
  });
});

var _detectCyclesFactory = require("./detect-cycles-factory");

Object.keys(_detectCyclesFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _detectCyclesFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _detectCyclesFactory[key];
    }
  });
});

var _detectCyclesFunction = require("./detect-cycles-function");

Object.keys(_detectCyclesFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _detectCyclesFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _detectCyclesFunction[key];
    }
  });
});

var _disconnectMultipleOutputsFactory = require("./disconnect-multiple-outputs-factory");

Object.keys(_disconnectMultipleOutputsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _disconnectMultipleOutputsFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _disconnectMultipleOutputsFactory[key];
    }
  });
});

var _disconnectMultipleOutputsFunction = require("./disconnect-multiple-outputs-function");

Object.keys(_disconnectMultipleOutputsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _disconnectMultipleOutputsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _disconnectMultipleOutputsFunction[key];
    }
  });
});

var _disconnectNativeAudioNodeFromNativeAudioNodeFunction = require("./disconnect-native-audio-node-from-native-audio-node-function");

Object.keys(_disconnectNativeAudioNodeFromNativeAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _disconnectNativeAudioNodeFromNativeAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _disconnectNativeAudioNodeFromNativeAudioNodeFunction[key];
    }
  });
});

var _distanceModelType = require("./distance-model-type");

Object.keys(_distanceModelType).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _distanceModelType[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _distanceModelType[key];
    }
  });
});

var _dynamicsCompressorNodeConstructor = require("./dynamics-compressor-node-constructor");

Object.keys(_dynamicsCompressorNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _dynamicsCompressorNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dynamicsCompressorNodeConstructor[key];
    }
  });
});

var _dynamicsCompressorNodeConstructorFactory = require("./dynamics-compressor-node-constructor-factory");

Object.keys(_dynamicsCompressorNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _dynamicsCompressorNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dynamicsCompressorNodeConstructorFactory[key];
    }
  });
});

var _dynamicsCompressorNodeRendererFactory = require("./dynamics-compressor-node-renderer-factory");

Object.keys(_dynamicsCompressorNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _dynamicsCompressorNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dynamicsCompressorNodeRendererFactory[key];
    }
  });
});

var _dynamicsCompressorNodeRendererFactoryFactory = require("./dynamics-compressor-node-renderer-factory-factory");

Object.keys(_dynamicsCompressorNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _dynamicsCompressorNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dynamicsCompressorNodeRendererFactoryFactory[key];
    }
  });
});

var _encodingErrorFactory = require("./encoding-error-factory");

Object.keys(_encodingErrorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _encodingErrorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _encodingErrorFactory[key];
    }
  });
});

var _errorEventHandler = require("./error-event-handler");

Object.keys(_errorEventHandler).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _errorEventHandler[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _errorEventHandler[key];
    }
  });
});

var _evaluateAudioWorkletGlobalScopeFunction = require("./evaluate-audio-worklet-global-scope-function");

Object.keys(_evaluateAudioWorkletGlobalScopeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _evaluateAudioWorkletGlobalScopeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _evaluateAudioWorkletGlobalScopeFunction[key];
    }
  });
});

var _evaluateSourceFactory = require("./evaluate-source-factory");

Object.keys(_evaluateSourceFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _evaluateSourceFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _evaluateSourceFactory[key];
    }
  });
});

var _evaluateSourceFunction = require("./evaluate-source-function");

Object.keys(_evaluateSourceFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _evaluateSourceFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _evaluateSourceFunction[key];
    }
  });
});

var _eventHandler = require("./event-handler");

Object.keys(_eventHandler).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _eventHandler[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _eventHandler[key];
    }
  });
});

var _eventTargetConstructor = require("./event-target-constructor");

Object.keys(_eventTargetConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _eventTargetConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _eventTargetConstructor[key];
    }
  });
});

var _eventTargetConstructorFactory = require("./event-target-constructor-factory");

Object.keys(_eventTargetConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _eventTargetConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _eventTargetConstructorFactory[key];
    }
  });
});

var _exposeCurrentFrameAndCurrentTimeFactory = require("./expose-current-frame-and-current-time-factory");

Object.keys(_exposeCurrentFrameAndCurrentTimeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _exposeCurrentFrameAndCurrentTimeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _exposeCurrentFrameAndCurrentTimeFactory[key];
    }
  });
});

var _exposeCurrentFrameAndCurrentTimeFunction = require("./expose-current-frame-and-current-time-function");

Object.keys(_exposeCurrentFrameAndCurrentTimeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _exposeCurrentFrameAndCurrentTimeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _exposeCurrentFrameAndCurrentTimeFunction[key];
    }
  });
});

var _fetchSourceFactory = require("./fetch-source-factory");

Object.keys(_fetchSourceFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _fetchSourceFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fetchSourceFactory[key];
    }
  });
});

var _fetchSourceFunction = require("./fetch-source-function");

Object.keys(_fetchSourceFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _fetchSourceFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fetchSourceFunction[key];
    }
  });
});

var _gainNodeConstructor = require("./gain-node-constructor");

Object.keys(_gainNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _gainNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _gainNodeConstructor[key];
    }
  });
});

var _gainNodeConstructorFactory = require("./gain-node-constructor-factory");

Object.keys(_gainNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _gainNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _gainNodeConstructorFactory[key];
    }
  });
});

var _gainNodeRendererFactory = require("./gain-node-renderer-factory");

Object.keys(_gainNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _gainNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _gainNodeRendererFactory[key];
    }
  });
});

var _gainNodeRendererFactoryFactory = require("./gain-node-renderer-factory-factory");

Object.keys(_gainNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _gainNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _gainNodeRendererFactoryFactory[key];
    }
  });
});

var _getActiveAudioWorkletNodeInputsFactory = require("./get-active-audio-worklet-node-inputs-factory");

Object.keys(_getActiveAudioWorkletNodeInputsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getActiveAudioWorkletNodeInputsFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getActiveAudioWorkletNodeInputsFactory[key];
    }
  });
});

var _getActiveAudioWorkletNodeInputsFunction = require("./get-active-audio-worklet-node-inputs-function");

Object.keys(_getActiveAudioWorkletNodeInputsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getActiveAudioWorkletNodeInputsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getActiveAudioWorkletNodeInputsFunction[key];
    }
  });
});

var _getAudioNodeConnectionsFunction = require("./get-audio-node-connections-function");

Object.keys(_getAudioNodeConnectionsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getAudioNodeConnectionsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getAudioNodeConnectionsFunction[key];
    }
  });
});

var _getAudioNodeRendererFactory = require("./get-audio-node-renderer-factory");

Object.keys(_getAudioNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getAudioNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getAudioNodeRendererFactory[key];
    }
  });
});

var _getAudioNodeRendererFunction = require("./get-audio-node-renderer-function");

Object.keys(_getAudioNodeRendererFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getAudioNodeRendererFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getAudioNodeRendererFunction[key];
    }
  });
});

var _getAudioNodeTailTimeFactory = require("./get-audio-node-tail-time-factory");

Object.keys(_getAudioNodeTailTimeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getAudioNodeTailTimeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getAudioNodeTailTimeFactory[key];
    }
  });
});

var _getAudioNodeTailTimeFunction = require("./get-audio-node-tail-time-function");

Object.keys(_getAudioNodeTailTimeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getAudioNodeTailTimeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getAudioNodeTailTimeFunction[key];
    }
  });
});

var _getAudioParamConnectionsFunction = require("./get-audio-param-connections-function");

Object.keys(_getAudioParamConnectionsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getAudioParamConnectionsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getAudioParamConnectionsFunction[key];
    }
  });
});

var _getAudioParamRendererFactory = require("./get-audio-param-renderer-factory");

Object.keys(_getAudioParamRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getAudioParamRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getAudioParamRendererFactory[key];
    }
  });
});

var _getAudioParamRendererFunction = require("./get-audio-param-renderer-function");

Object.keys(_getAudioParamRendererFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getAudioParamRendererFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getAudioParamRendererFunction[key];
    }
  });
});

var _getBackupOfflineAudioContextFactory = require("./get-backup-offline-audio-context-factory");

Object.keys(_getBackupOfflineAudioContextFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getBackupOfflineAudioContextFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getBackupOfflineAudioContextFactory[key];
    }
  });
});

var _getBackupOfflineAudioContextFunction = require("./get-backup-offline-audio-context-function");

Object.keys(_getBackupOfflineAudioContextFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getBackupOfflineAudioContextFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getBackupOfflineAudioContextFunction[key];
    }
  });
});

var _getEventListenersOfAudioNodeFunction = require("./get-event-listeners-of-audio-node-function");

Object.keys(_getEventListenersOfAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getEventListenersOfAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getEventListenersOfAudioNodeFunction[key];
    }
  });
});

var _getFirstSampleFunction = require("./get-first-sample-function");

Object.keys(_getFirstSampleFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getFirstSampleFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getFirstSampleFunction[key];
    }
  });
});

var _getNativeAudioNodeFunction = require("./get-native-audio-node-function");

Object.keys(_getNativeAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getNativeAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getNativeAudioNodeFunction[key];
    }
  });
});

var _getNativeAudioParamFunction = require("./get-native-audio-param-function");

Object.keys(_getNativeAudioParamFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getNativeAudioParamFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getNativeAudioParamFunction[key];
    }
  });
});

var _getNativeContextFactory = require("./get-native-context-factory");

Object.keys(_getNativeContextFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getNativeContextFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getNativeContextFactory[key];
    }
  });
});

var _getNativeContextFunction = require("./get-native-context-function");

Object.keys(_getNativeContextFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getNativeContextFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getNativeContextFunction[key];
    }
  });
});

var _getOrCreateBackupOfflineAudioContextFactory = require("./get-or-create-backup-offline-audio-context-factory");

Object.keys(_getOrCreateBackupOfflineAudioContextFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getOrCreateBackupOfflineAudioContextFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getOrCreateBackupOfflineAudioContextFactory[key];
    }
  });
});

var _getOrCreateBackupOfflineAudioContextFunction = require("./get-or-create-backup-offline-audio-context-function");

Object.keys(_getOrCreateBackupOfflineAudioContextFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getOrCreateBackupOfflineAudioContextFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getOrCreateBackupOfflineAudioContextFunction[key];
    }
  });
});

var _getUnrenderedAudioWorkletNodesFactory = require("./get-unrendered-audio-worklet-nodes-factory");

Object.keys(_getUnrenderedAudioWorkletNodesFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getUnrenderedAudioWorkletNodesFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getUnrenderedAudioWorkletNodesFactory[key];
    }
  });
});

var _getUnrenderedAudioWorkletNodesFunction = require("./get-unrendered-audio-worklet-nodes-function");

Object.keys(_getUnrenderedAudioWorkletNodesFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getUnrenderedAudioWorkletNodesFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getUnrenderedAudioWorkletNodesFunction[key];
    }
  });
});

var _getValueForKeyFunction = require("./get-value-for-key-function");

Object.keys(_getValueForKeyFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _getValueForKeyFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getValueForKeyFunction[key];
    }
  });
});

var _iirFilterNodeConstructor = require("./iir-filter-node-constructor");

Object.keys(_iirFilterNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _iirFilterNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _iirFilterNodeConstructor[key];
    }
  });
});

var _iirFilterNodeConstructorFactory = require("./iir-filter-node-constructor-factory");

Object.keys(_iirFilterNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _iirFilterNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _iirFilterNodeConstructorFactory[key];
    }
  });
});

var _iirFilterNodeRendererFactory = require("./iir-filter-node-renderer-factory");

Object.keys(_iirFilterNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _iirFilterNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _iirFilterNodeRendererFactory[key];
    }
  });
});

var _iirFilterNodeRendererFactoryFactory = require("./iir-filter-node-renderer-factory-factory");

Object.keys(_iirFilterNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _iirFilterNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _iirFilterNodeRendererFactoryFactory[key];
    }
  });
});

var _incrementCycleCounterFactory = require("./increment-cycle-counter-factory");

Object.keys(_incrementCycleCounterFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _incrementCycleCounterFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _incrementCycleCounterFactory[key];
    }
  });
});

var _incrementCycleCounterFactoryFactory = require("./increment-cycle-counter-factory-factory");

Object.keys(_incrementCycleCounterFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _incrementCycleCounterFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _incrementCycleCounterFactoryFactory[key];
    }
  });
});

var _incrementCycleCounterFunction = require("./increment-cycle-counter-function");

Object.keys(_incrementCycleCounterFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _incrementCycleCounterFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _incrementCycleCounterFunction[key];
    }
  });
});

var _indexSizeErrorFactory = require("./index-size-error-factory");

Object.keys(_indexSizeErrorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _indexSizeErrorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _indexSizeErrorFactory[key];
    }
  });
});

var _insertElementInSetFunction = require("./insert-element-in-set-function");

Object.keys(_insertElementInSetFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _insertElementInSetFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _insertElementInSetFunction[key];
    }
  });
});

var _internalStateEventListener = require("./internal-state-event-listener");

Object.keys(_internalStateEventListener).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _internalStateEventListener[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _internalStateEventListener[key];
    }
  });
});

var _invalidAccessErrorFactory = require("./invalid-access-error-factory");

Object.keys(_invalidAccessErrorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _invalidAccessErrorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _invalidAccessErrorFactory[key];
    }
  });
});

var _invalidStateErrorFactory = require("./invalid-state-error-factory");

Object.keys(_invalidStateErrorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _invalidStateErrorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _invalidStateErrorFactory[key];
    }
  });
});

var _isActiveAudioNodeFunction = require("./is-active-audio-node-function");

Object.keys(_isActiveAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isActiveAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isActiveAudioNodeFunction[key];
    }
  });
});

var _isAnyAudioContextFactory = require("./is-any-audio-context-factory");

Object.keys(_isAnyAudioContextFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isAnyAudioContextFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isAnyAudioContextFactory[key];
    }
  });
});

var _isAnyAudioContextFunction = require("./is-any-audio-context-function");

Object.keys(_isAnyAudioContextFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isAnyAudioContextFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isAnyAudioContextFunction[key];
    }
  });
});

var _isAnyAudioNodeFactory = require("./is-any-audio-node-factory");

Object.keys(_isAnyAudioNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isAnyAudioNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isAnyAudioNodeFactory[key];
    }
  });
});

var _isAnyAudioNodeFunction = require("./is-any-audio-node-function");

Object.keys(_isAnyAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isAnyAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isAnyAudioNodeFunction[key];
    }
  });
});

var _isAnyAudioParamFactory = require("./is-any-audio-param-factory");

Object.keys(_isAnyAudioParamFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isAnyAudioParamFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isAnyAudioParamFactory[key];
    }
  });
});

var _isAnyAudioParamFunction = require("./is-any-audio-param-function");

Object.keys(_isAnyAudioParamFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isAnyAudioParamFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isAnyAudioParamFunction[key];
    }
  });
});

var _isAnyOfflineAudioContextFactory = require("./is-any-offline-audio-context-factory");

Object.keys(_isAnyOfflineAudioContextFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isAnyOfflineAudioContextFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isAnyOfflineAudioContextFactory[key];
    }
  });
});

var _isAnyOfflineAudioContextFunction = require("./is-any-offline-audio-context-function");

Object.keys(_isAnyOfflineAudioContextFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isAnyOfflineAudioContextFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isAnyOfflineAudioContextFunction[key];
    }
  });
});

var _isDcCurveFunction = require("./is-dc-curve-function");

Object.keys(_isDcCurveFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isDcCurveFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isDcCurveFunction[key];
    }
  });
});

var _isNativeAudioContextFactory = require("./is-native-audio-context-factory");

Object.keys(_isNativeAudioContextFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isNativeAudioContextFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isNativeAudioContextFactory[key];
    }
  });
});

var _isNativeAudioContextFunction = require("./is-native-audio-context-function");

Object.keys(_isNativeAudioContextFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isNativeAudioContextFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isNativeAudioContextFunction[key];
    }
  });
});

var _isNativeAudioNodeFactory = require("./is-native-audio-node-factory");

Object.keys(_isNativeAudioNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isNativeAudioNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isNativeAudioNodeFactory[key];
    }
  });
});

var _isNativeAudioNodeFunction = require("./is-native-audio-node-function");

Object.keys(_isNativeAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isNativeAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isNativeAudioNodeFunction[key];
    }
  });
});

var _isNativeAudioParamFactory = require("./is-native-audio-param-factory");

Object.keys(_isNativeAudioParamFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isNativeAudioParamFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isNativeAudioParamFactory[key];
    }
  });
});

var _isNativeAudioParamFunction = require("./is-native-audio-param-function");

Object.keys(_isNativeAudioParamFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isNativeAudioParamFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isNativeAudioParamFunction[key];
    }
  });
});

var _isNativeContextFactory = require("./is-native-context-factory");

Object.keys(_isNativeContextFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isNativeContextFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isNativeContextFactory[key];
    }
  });
});

var _isNativeContextFunction = require("./is-native-context-function");

Object.keys(_isNativeContextFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isNativeContextFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isNativeContextFunction[key];
    }
  });
});

var _isNativeOfflineAudioContextFactory = require("./is-native-offline-audio-context-factory");

Object.keys(_isNativeOfflineAudioContextFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isNativeOfflineAudioContextFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isNativeOfflineAudioContextFactory[key];
    }
  });
});

var _isNativeOfflineAudioContextFunction = require("./is-native-offline-audio-context-function");

Object.keys(_isNativeOfflineAudioContextFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isNativeOfflineAudioContextFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isNativeOfflineAudioContextFunction[key];
    }
  });
});

var _isPartOfACycleFunction = require("./is-part-of-a-cycle-function");

Object.keys(_isPartOfACycleFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isPartOfACycleFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isPartOfACycleFunction[key];
    }
  });
});

var _isPassiveAudioNodeFunction = require("./is-passive-audio-node-function");

Object.keys(_isPassiveAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isPassiveAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isPassiveAudioNodeFunction[key];
    }
  });
});

var _isSecureContextFactory = require("./is-secure-context-factory");

Object.keys(_isSecureContextFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isSecureContextFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isSecureContextFactory[key];
    }
  });
});

var _isSupportedPromiseFactory = require("./is-supported-promise-factory");

Object.keys(_isSupportedPromiseFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _isSupportedPromiseFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isSupportedPromiseFactory[key];
    }
  });
});

var _mediaElementAudioSourceNodeConstructor = require("./media-element-audio-source-node-constructor");

Object.keys(_mediaElementAudioSourceNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaElementAudioSourceNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaElementAudioSourceNodeConstructor[key];
    }
  });
});

var _mediaElementAudioSourceNodeConstructorFactory = require("./media-element-audio-source-node-constructor-factory");

Object.keys(_mediaElementAudioSourceNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaElementAudioSourceNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaElementAudioSourceNodeConstructorFactory[key];
    }
  });
});

var _mediaStreamAudioDestinationNodeConstructor = require("./media-stream-audio-destination-node-constructor");

Object.keys(_mediaStreamAudioDestinationNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamAudioDestinationNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamAudioDestinationNodeConstructor[key];
    }
  });
});

var _mediaStreamAudioDestinationNodeConstructorFactory = require("./media-stream-audio-destination-node-constructor-factory");

Object.keys(_mediaStreamAudioDestinationNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamAudioDestinationNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamAudioDestinationNodeConstructorFactory[key];
    }
  });
});

var _mediaStreamAudioSourceNodeConstructor = require("./media-stream-audio-source-node-constructor");

Object.keys(_mediaStreamAudioSourceNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamAudioSourceNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamAudioSourceNodeConstructor[key];
    }
  });
});

var _mediaStreamAudioSourceNodeConstructorFactory = require("./media-stream-audio-source-node-constructor-factory");

Object.keys(_mediaStreamAudioSourceNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamAudioSourceNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamAudioSourceNodeConstructorFactory[key];
    }
  });
});

var _mediaStreamTrackAudioSourceNodeConstructor = require("./media-stream-track-audio-source-node-constructor");

Object.keys(_mediaStreamTrackAudioSourceNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamTrackAudioSourceNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamTrackAudioSourceNodeConstructor[key];
    }
  });
});

var _mediaStreamTrackAudioSourceNodeConstructorFactory = require("./media-stream-track-audio-source-node-constructor-factory");

Object.keys(_mediaStreamTrackAudioSourceNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mediaStreamTrackAudioSourceNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _mediaStreamTrackAudioSourceNodeConstructorFactory[key];
    }
  });
});

var _minimalAudioContextConstructor = require("./minimal-audio-context-constructor");

Object.keys(_minimalAudioContextConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _minimalAudioContextConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _minimalAudioContextConstructor[key];
    }
  });
});

var _minimalAudioContextConstructorFactory = require("./minimal-audio-context-constructor-factory");

Object.keys(_minimalAudioContextConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _minimalAudioContextConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _minimalAudioContextConstructorFactory[key];
    }
  });
});

var _minimalBaseAudioContextConstructor = require("./minimal-base-audio-context-constructor");

Object.keys(_minimalBaseAudioContextConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _minimalBaseAudioContextConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _minimalBaseAudioContextConstructor[key];
    }
  });
});

var _minimalBaseAudioContextConstructorFactory = require("./minimal-base-audio-context-constructor-factory");

Object.keys(_minimalBaseAudioContextConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _minimalBaseAudioContextConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _minimalBaseAudioContextConstructorFactory[key];
    }
  });
});

var _minimalOfflineAudioContextConstructor = require("./minimal-offline-audio-context-constructor");

Object.keys(_minimalOfflineAudioContextConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _minimalOfflineAudioContextConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _minimalOfflineAudioContextConstructor[key];
    }
  });
});

var _minimalOfflineAudioContextConstructorFactory = require("./minimal-offline-audio-context-constructor-factory");

Object.keys(_minimalOfflineAudioContextConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _minimalOfflineAudioContextConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _minimalOfflineAudioContextConstructorFactory[key];
    }
  });
});

var _monitorConnectionsFactory = require("./monitor-connections-factory");

Object.keys(_monitorConnectionsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _monitorConnectionsFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _monitorConnectionsFactory[key];
    }
  });
});

var _monitorConnectionsFunction = require("./monitor-connections-function");

Object.keys(_monitorConnectionsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _monitorConnectionsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _monitorConnectionsFunction[key];
    }
  });
});

var _nativeAnalyserNode = require("./native-analyser-node");

Object.keys(_nativeAnalyserNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAnalyserNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAnalyserNode[key];
    }
  });
});

var _nativeAnalyserNodeFactory = require("./native-analyser-node-factory");

Object.keys(_nativeAnalyserNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAnalyserNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAnalyserNodeFactory[key];
    }
  });
});

var _nativeAnalyserNodeFactoryFactory = require("./native-analyser-node-factory-factory");

Object.keys(_nativeAnalyserNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAnalyserNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAnalyserNodeFactoryFactory[key];
    }
  });
});

var _nativeAudioBuffer = require("./native-audio-buffer");

Object.keys(_nativeAudioBuffer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioBuffer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioBuffer[key];
    }
  });
});

var _nativeAudioBufferConstructor = require("./native-audio-buffer-constructor");

Object.keys(_nativeAudioBufferConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioBufferConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioBufferConstructor[key];
    }
  });
});

var _nativeAudioBufferConstructorFactory = require("./native-audio-buffer-constructor-factory");

Object.keys(_nativeAudioBufferConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioBufferConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioBufferConstructorFactory[key];
    }
  });
});

var _nativeAudioBufferSourceNode = require("./native-audio-buffer-source-node");

Object.keys(_nativeAudioBufferSourceNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioBufferSourceNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioBufferSourceNode[key];
    }
  });
});

var _nativeAudioBufferSourceNodeFactory = require("./native-audio-buffer-source-node-factory");

Object.keys(_nativeAudioBufferSourceNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioBufferSourceNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioBufferSourceNodeFactory[key];
    }
  });
});

var _nativeAudioBufferSourceNodeFactoryFactory = require("./native-audio-buffer-source-node-factory-factory");

Object.keys(_nativeAudioBufferSourceNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioBufferSourceNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioBufferSourceNodeFactoryFactory[key];
    }
  });
});

var _nativeAudioContext = require("./native-audio-context");

Object.keys(_nativeAudioContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioContext[key];
    }
  });
});

var _nativeAudioContextConstructor = require("./native-audio-context-constructor");

Object.keys(_nativeAudioContextConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioContextConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioContextConstructor[key];
    }
  });
});

var _nativeAudioContextConstructorFactory = require("./native-audio-context-constructor-factory");

Object.keys(_nativeAudioContextConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioContextConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioContextConstructorFactory[key];
    }
  });
});

var _nativeAudioDestinationNode = require("./native-audio-destination-node");

Object.keys(_nativeAudioDestinationNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioDestinationNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioDestinationNode[key];
    }
  });
});

var _nativeAudioDestinationNodeFactory = require("./native-audio-destination-node-factory");

Object.keys(_nativeAudioDestinationNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioDestinationNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioDestinationNodeFactory[key];
    }
  });
});

var _nativeAudioDestinationNodeFactoryFactory = require("./native-audio-destination-node-factory-factory");

Object.keys(_nativeAudioDestinationNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioDestinationNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioDestinationNodeFactoryFactory[key];
    }
  });
});

var _nativeAudioListener = require("./native-audio-listener");

Object.keys(_nativeAudioListener).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioListener[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioListener[key];
    }
  });
});

var _nativeAudioNode = require("./native-audio-node");

Object.keys(_nativeAudioNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioNode[key];
    }
  });
});

var _nativeAudioParam = require("./native-audio-param");

Object.keys(_nativeAudioParam).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioParam[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioParam[key];
    }
  });
});

var _nativeAudioParamMap = require("./native-audio-param-map");

Object.keys(_nativeAudioParamMap).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioParamMap[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioParamMap[key];
    }
  });
});

var _nativeAudioWorklet = require("./native-audio-worklet");

Object.keys(_nativeAudioWorklet).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioWorklet[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioWorklet[key];
    }
  });
});

var _nativeAudioWorkletNode = require("./native-audio-worklet-node");

Object.keys(_nativeAudioWorkletNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioWorkletNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioWorkletNode[key];
    }
  });
});

var _nativeAudioWorkletNodeConstructor = require("./native-audio-worklet-node-constructor");

Object.keys(_nativeAudioWorkletNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioWorkletNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioWorkletNodeConstructor[key];
    }
  });
});

var _nativeAudioWorkletNodeConstructorFactory = require("./native-audio-worklet-node-constructor-factory");

Object.keys(_nativeAudioWorkletNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioWorkletNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioWorkletNodeConstructorFactory[key];
    }
  });
});

var _nativeAudioWorkletNodeFactory = require("./native-audio-worklet-node-factory");

Object.keys(_nativeAudioWorkletNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioWorkletNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioWorkletNodeFactory[key];
    }
  });
});

var _nativeAudioWorkletNodeFactoryFactory = require("./native-audio-worklet-node-factory-factory");

Object.keys(_nativeAudioWorkletNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioWorkletNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioWorkletNodeFactoryFactory[key];
    }
  });
});

var _nativeAudioWorkletNodeFakerFactory = require("./native-audio-worklet-node-faker-factory");

Object.keys(_nativeAudioWorkletNodeFakerFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioWorkletNodeFakerFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioWorkletNodeFakerFactory[key];
    }
  });
});

var _nativeAudioWorkletNodeFakerFactoryFactory = require("./native-audio-worklet-node-faker-factory-factory");

Object.keys(_nativeAudioWorkletNodeFakerFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioWorkletNodeFakerFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioWorkletNodeFakerFactoryFactory[key];
    }
  });
});

var _nativeAudioWorkletNodeOptions = require("./native-audio-worklet-node-options");

Object.keys(_nativeAudioWorkletNodeOptions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeAudioWorkletNodeOptions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeAudioWorkletNodeOptions[key];
    }
  });
});

var _nativeBiquadFilterNode = require("./native-biquad-filter-node");

Object.keys(_nativeBiquadFilterNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeBiquadFilterNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeBiquadFilterNode[key];
    }
  });
});

var _nativeBiquadFilterNodeFactory = require("./native-biquad-filter-node-factory");

Object.keys(_nativeBiquadFilterNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeBiquadFilterNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeBiquadFilterNodeFactory[key];
    }
  });
});

var _nativeChannelMergerNode = require("./native-channel-merger-node");

Object.keys(_nativeChannelMergerNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeChannelMergerNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeChannelMergerNode[key];
    }
  });
});

var _nativeChannelMergerNodeFactory = require("./native-channel-merger-node-factory");

Object.keys(_nativeChannelMergerNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeChannelMergerNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeChannelMergerNodeFactory[key];
    }
  });
});

var _nativeChannelMergerNodeFactoryFactory = require("./native-channel-merger-node-factory-factory");

Object.keys(_nativeChannelMergerNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeChannelMergerNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeChannelMergerNodeFactoryFactory[key];
    }
  });
});

var _nativeChannelSplitterNode = require("./native-channel-splitter-node");

Object.keys(_nativeChannelSplitterNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeChannelSplitterNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeChannelSplitterNode[key];
    }
  });
});

var _nativeChannelSplitterNodeFactory = require("./native-channel-splitter-node-factory");

Object.keys(_nativeChannelSplitterNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeChannelSplitterNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeChannelSplitterNodeFactory[key];
    }
  });
});

var _nativeConstantSourceNode = require("./native-constant-source-node");

Object.keys(_nativeConstantSourceNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeConstantSourceNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeConstantSourceNode[key];
    }
  });
});

var _nativeConstantSourceNodeFactory = require("./native-constant-source-node-factory");

Object.keys(_nativeConstantSourceNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeConstantSourceNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeConstantSourceNodeFactory[key];
    }
  });
});

var _nativeConstantSourceNodeFactoryFactory = require("./native-constant-source-node-factory-factory");

Object.keys(_nativeConstantSourceNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeConstantSourceNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeConstantSourceNodeFactoryFactory[key];
    }
  });
});

var _nativeConstantSourceNodeFakerFactory = require("./native-constant-source-node-faker-factory");

Object.keys(_nativeConstantSourceNodeFakerFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeConstantSourceNodeFakerFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeConstantSourceNodeFakerFactory[key];
    }
  });
});

var _nativeConstantSourceNodeFakerFactoryFactory = require("./native-constant-source-node-faker-factory-factory");

Object.keys(_nativeConstantSourceNodeFakerFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeConstantSourceNodeFakerFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeConstantSourceNodeFakerFactoryFactory[key];
    }
  });
});

var _nativeContext = require("./native-context");

Object.keys(_nativeContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeContext[key];
    }
  });
});

var _nativeConvolverNode = require("./native-convolver-node");

Object.keys(_nativeConvolverNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeConvolverNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeConvolverNode[key];
    }
  });
});

var _nativeConvolverNodeFactory = require("./native-convolver-node-factory");

Object.keys(_nativeConvolverNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeConvolverNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeConvolverNodeFactory[key];
    }
  });
});

var _nativeConvolverNodeFactoryFactory = require("./native-convolver-node-factory-factory");

Object.keys(_nativeConvolverNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeConvolverNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeConvolverNodeFactoryFactory[key];
    }
  });
});

var _nativeDelayNodeFactory = require("./native-delay-node-factory");

Object.keys(_nativeDelayNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeDelayNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeDelayNodeFactory[key];
    }
  });
});

var _nativeDelayNode = require("./native-delay-node");

Object.keys(_nativeDelayNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeDelayNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeDelayNode[key];
    }
  });
});

var _nativeDynamicsCompressorNode = require("./native-dynamics-compressor-node");

Object.keys(_nativeDynamicsCompressorNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeDynamicsCompressorNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeDynamicsCompressorNode[key];
    }
  });
});

var _nativeDynamicsCompressorNodeFactory = require("./native-dynamics-compressor-node-factory");

Object.keys(_nativeDynamicsCompressorNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeDynamicsCompressorNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeDynamicsCompressorNodeFactory[key];
    }
  });
});

var _nativeDynamicsCompressorNodeFactoryFactory = require("./native-dynamics-compressor-node-factory-factory");

Object.keys(_nativeDynamicsCompressorNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeDynamicsCompressorNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeDynamicsCompressorNodeFactoryFactory[key];
    }
  });
});

var _nativeEventTarget = require("./native-event-target");

Object.keys(_nativeEventTarget).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeEventTarget[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeEventTarget[key];
    }
  });
});

var _nativeGainNode = require("./native-gain-node");

Object.keys(_nativeGainNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeGainNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeGainNode[key];
    }
  });
});

var _nativeGainNodeFactory = require("./native-gain-node-factory");

Object.keys(_nativeGainNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeGainNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeGainNodeFactory[key];
    }
  });
});

var _nativeIirFilterNode = require("./native-iir-filter-node");

Object.keys(_nativeIirFilterNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeIirFilterNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeIirFilterNode[key];
    }
  });
});

var _nativeIirFilterNodeFactory = require("./native-iir-filter-node-factory");

Object.keys(_nativeIirFilterNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeIirFilterNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeIirFilterNodeFactory[key];
    }
  });
});

var _nativeIirFilterNodeFactoryFactory = require("./native-iir-filter-node-factory-factory");

Object.keys(_nativeIirFilterNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeIirFilterNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeIirFilterNodeFactoryFactory[key];
    }
  });
});

var _nativeIirFilterNodeFakerFactory = require("./native-iir-filter-node-faker-factory");

Object.keys(_nativeIirFilterNodeFakerFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeIirFilterNodeFakerFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeIirFilterNodeFakerFactory[key];
    }
  });
});

var _nativeIirFilterNodeFakerFactoryFactory = require("./native-iir-filter-node-faker-factory-factory");

Object.keys(_nativeIirFilterNodeFakerFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeIirFilterNodeFakerFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeIirFilterNodeFakerFactoryFactory[key];
    }
  });
});

var _nativeMediaElementAudioSourceNode = require("./native-media-element-audio-source-node");

Object.keys(_nativeMediaElementAudioSourceNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeMediaElementAudioSourceNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeMediaElementAudioSourceNode[key];
    }
  });
});

var _nativeMediaElementAudioSourceNodeFactory = require("./native-media-element-audio-source-node-factory");

Object.keys(_nativeMediaElementAudioSourceNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeMediaElementAudioSourceNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeMediaElementAudioSourceNodeFactory[key];
    }
  });
});

var _nativeMediaStreamAudioDestinationNode = require("./native-media-stream-audio-destination-node");

Object.keys(_nativeMediaStreamAudioDestinationNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeMediaStreamAudioDestinationNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeMediaStreamAudioDestinationNode[key];
    }
  });
});

var _nativeMediaStreamAudioDestinationNodeFactory = require("./native-media-stream-audio-destination-node-factory");

Object.keys(_nativeMediaStreamAudioDestinationNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeMediaStreamAudioDestinationNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeMediaStreamAudioDestinationNodeFactory[key];
    }
  });
});

var _nativeMediaStreamAudioSourceNode = require("./native-media-stream-audio-source-node");

Object.keys(_nativeMediaStreamAudioSourceNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeMediaStreamAudioSourceNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeMediaStreamAudioSourceNode[key];
    }
  });
});

var _nativeMediaStreamAudioSourceNodeFactory = require("./native-media-stream-audio-source-node-factory");

Object.keys(_nativeMediaStreamAudioSourceNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeMediaStreamAudioSourceNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeMediaStreamAudioSourceNodeFactory[key];
    }
  });
});

var _nativeMediaStreamTrackAudioSourceNode = require("./native-media-stream-track-audio-source-node");

Object.keys(_nativeMediaStreamTrackAudioSourceNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeMediaStreamTrackAudioSourceNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeMediaStreamTrackAudioSourceNode[key];
    }
  });
});

var _nativeMediaStreamTrackAudioSourceNodeFactory = require("./native-media-stream-track-audio-source-node-factory");

Object.keys(_nativeMediaStreamTrackAudioSourceNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeMediaStreamTrackAudioSourceNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeMediaStreamTrackAudioSourceNodeFactory[key];
    }
  });
});

var _nativeMediaStreamTrackAudioSourceNodeFactoryFactory = require("./native-media-stream-track-audio-source-node-factory-factory");

Object.keys(_nativeMediaStreamTrackAudioSourceNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeMediaStreamTrackAudioSourceNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeMediaStreamTrackAudioSourceNodeFactoryFactory[key];
    }
  });
});

var _nativeOfflineAudioContext = require("./native-offline-audio-context");

Object.keys(_nativeOfflineAudioContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeOfflineAudioContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeOfflineAudioContext[key];
    }
  });
});

var _nativeOfflineAudioContextConstructor = require("./native-offline-audio-context-constructor");

Object.keys(_nativeOfflineAudioContextConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeOfflineAudioContextConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeOfflineAudioContextConstructor[key];
    }
  });
});

var _nativeOfflineAudioContextConstructorFactory = require("./native-offline-audio-context-constructor-factory");

Object.keys(_nativeOfflineAudioContextConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeOfflineAudioContextConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeOfflineAudioContextConstructorFactory[key];
    }
  });
});

var _nativeOscillatorNode = require("./native-oscillator-node");

Object.keys(_nativeOscillatorNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeOscillatorNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeOscillatorNode[key];
    }
  });
});

var _nativeOscillatorNodeFactory = require("./native-oscillator-node-factory");

Object.keys(_nativeOscillatorNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeOscillatorNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeOscillatorNodeFactory[key];
    }
  });
});

var _nativeOscillatorNodeFactoryFactory = require("./native-oscillator-node-factory-factory");

Object.keys(_nativeOscillatorNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeOscillatorNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeOscillatorNodeFactoryFactory[key];
    }
  });
});

var _nativePannerNode = require("./native-panner-node");

Object.keys(_nativePannerNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativePannerNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativePannerNode[key];
    }
  });
});

var _nativePannerNodeFactory = require("./native-panner-node-factory");

Object.keys(_nativePannerNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativePannerNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativePannerNodeFactory[key];
    }
  });
});

var _nativePannerNodeFactoryFactory = require("./native-panner-node-factory-factory");

Object.keys(_nativePannerNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativePannerNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativePannerNodeFactoryFactory[key];
    }
  });
});

var _nativePannerNodeFakerFactory = require("./native-panner-node-faker-factory");

Object.keys(_nativePannerNodeFakerFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativePannerNodeFakerFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativePannerNodeFakerFactory[key];
    }
  });
});

var _nativePannerNodeFakerFactoryFactory = require("./native-panner-node-faker-factory-factory");

Object.keys(_nativePannerNodeFakerFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativePannerNodeFakerFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativePannerNodeFakerFactoryFactory[key];
    }
  });
});

var _nativePeriodicWave = require("./native-periodic-wave");

Object.keys(_nativePeriodicWave).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativePeriodicWave[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativePeriodicWave[key];
    }
  });
});

var _nativePeriodicWaveFactory = require("./native-periodic-wave-factory");

Object.keys(_nativePeriodicWaveFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativePeriodicWaveFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativePeriodicWaveFactory[key];
    }
  });
});

var _nativePeriodicWaveFactoryFactory = require("./native-periodic-wave-factory-factory");

Object.keys(_nativePeriodicWaveFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativePeriodicWaveFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativePeriodicWaveFactoryFactory[key];
    }
  });
});

var _nativeScriptProcessorNode = require("./native-script-processor-node");

Object.keys(_nativeScriptProcessorNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeScriptProcessorNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeScriptProcessorNode[key];
    }
  });
});

var _nativeScriptProcessorNodeFactory = require("./native-script-processor-node-factory");

Object.keys(_nativeScriptProcessorNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeScriptProcessorNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeScriptProcessorNodeFactory[key];
    }
  });
});

var _nativeStereoPannerNode = require("./native-stereo-panner-node");

Object.keys(_nativeStereoPannerNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeStereoPannerNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeStereoPannerNode[key];
    }
  });
});

var _nativeStereoPannerNodeFactory = require("./native-stereo-panner-node-factory");

Object.keys(_nativeStereoPannerNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeStereoPannerNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeStereoPannerNodeFactory[key];
    }
  });
});

var _nativeStereoPannerNodeFactoryFactory = require("./native-stereo-panner-node-factory-factory");

Object.keys(_nativeStereoPannerNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeStereoPannerNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeStereoPannerNodeFactoryFactory[key];
    }
  });
});

var _nativeStereoPannerNodeFakerFactory = require("./native-stereo-panner-node-faker-factory");

Object.keys(_nativeStereoPannerNodeFakerFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeStereoPannerNodeFakerFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeStereoPannerNodeFakerFactory[key];
    }
  });
});

var _nativeStereoPannerNodeFakerFactoryFactory = require("./native-stereo-panner-node-faker-factory-factory");

Object.keys(_nativeStereoPannerNodeFakerFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeStereoPannerNodeFakerFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeStereoPannerNodeFakerFactoryFactory[key];
    }
  });
});

var _nativeWaveShaperNode = require("./native-wave-shaper-node");

Object.keys(_nativeWaveShaperNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeWaveShaperNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeWaveShaperNode[key];
    }
  });
});

var _nativeWaveShaperNodeFactory = require("./native-wave-shaper-node-factory");

Object.keys(_nativeWaveShaperNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeWaveShaperNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeWaveShaperNodeFactory[key];
    }
  });
});

var _nativeWaveShaperNodeFactoryFactory = require("./native-wave-shaper-node-factory-factory");

Object.keys(_nativeWaveShaperNodeFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeWaveShaperNodeFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeWaveShaperNodeFactoryFactory[key];
    }
  });
});

var _nativeWaveShaperNodeFakerFactory = require("./native-wave-shaper-node-faker-factory");

Object.keys(_nativeWaveShaperNodeFakerFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeWaveShaperNodeFakerFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeWaveShaperNodeFakerFactory[key];
    }
  });
});

var _nativeWaveShaperNodeFakerFactoryFactory = require("./native-wave-shaper-node-faker-factory-factory");

Object.keys(_nativeWaveShaperNodeFakerFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nativeWaveShaperNodeFakerFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nativeWaveShaperNodeFakerFactoryFactory[key];
    }
  });
});

var _notSupportedErrorFactory = require("./not-supported-error-factory");

Object.keys(_notSupportedErrorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _notSupportedErrorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _notSupportedErrorFactory[key];
    }
  });
});

var _offlineAudioContextConstructorFactory = require("./offline-audio-context-constructor-factory");

Object.keys(_offlineAudioContextConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _offlineAudioContextConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _offlineAudioContextConstructorFactory[key];
    }
  });
});

var _oscillatorNodeConstructor = require("./oscillator-node-constructor");

Object.keys(_oscillatorNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _oscillatorNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _oscillatorNodeConstructor[key];
    }
  });
});

var _oscillatorNodeConstructorFactory = require("./oscillator-node-constructor-factory");

Object.keys(_oscillatorNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _oscillatorNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _oscillatorNodeConstructorFactory[key];
    }
  });
});

var _oscillatorNodeRenderer = require("./oscillator-node-renderer");

Object.keys(_oscillatorNodeRenderer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _oscillatorNodeRenderer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _oscillatorNodeRenderer[key];
    }
  });
});

var _oscillatorNodeRendererFactory = require("./oscillator-node-renderer-factory");

Object.keys(_oscillatorNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _oscillatorNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _oscillatorNodeRendererFactory[key];
    }
  });
});

var _oscillatorNodeRendererFactoryFactory = require("./oscillator-node-renderer-factory-factory");

Object.keys(_oscillatorNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _oscillatorNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _oscillatorNodeRendererFactoryFactory[key];
    }
  });
});

var _oscillatorType = require("./oscillator-type");

Object.keys(_oscillatorType).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _oscillatorType[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _oscillatorType[key];
    }
  });
});

var _outputConnection = require("./output-connection");

Object.keys(_outputConnection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _outputConnection[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _outputConnection[key];
    }
  });
});

var _overSampleType = require("./over-sample-type");

Object.keys(_overSampleType).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _overSampleType[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _overSampleType[key];
    }
  });
});

var _overwriteAccessorsFunction = require("./overwrite-accessors-function");

Object.keys(_overwriteAccessorsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _overwriteAccessorsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _overwriteAccessorsFunction[key];
    }
  });
});

var _pannerNodeConstructor = require("./panner-node-constructor");

Object.keys(_pannerNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _pannerNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pannerNodeConstructor[key];
    }
  });
});

var _pannerNodeConstructorFactory = require("./panner-node-constructor-factory");

Object.keys(_pannerNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _pannerNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pannerNodeConstructorFactory[key];
    }
  });
});

var _pannerNodeRendererFactory = require("./panner-node-renderer-factory");

Object.keys(_pannerNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _pannerNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pannerNodeRendererFactory[key];
    }
  });
});

var _pannerNodeRendererFactoryFactory = require("./panner-node-renderer-factory-factory");

Object.keys(_pannerNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _pannerNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pannerNodeRendererFactoryFactory[key];
    }
  });
});

var _panningModelType = require("./panning-model-type");

Object.keys(_panningModelType).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _panningModelType[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _panningModelType[key];
    }
  });
});

var _passiveAudioNodeInputConnection = require("./passive-audio-node-input-connection");

Object.keys(_passiveAudioNodeInputConnection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _passiveAudioNodeInputConnection[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _passiveAudioNodeInputConnection[key];
    }
  });
});

var _passiveAudioParamInputConnection = require("./passive-audio-param-input-connection");

Object.keys(_passiveAudioParamInputConnection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _passiveAudioParamInputConnection[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _passiveAudioParamInputConnection[key];
    }
  });
});

var _periodicWaveConstructor = require("./periodic-wave-constructor");

Object.keys(_periodicWaveConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _periodicWaveConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _periodicWaveConstructor[key];
    }
  });
});

var _periodicWaveConstructorFactory = require("./periodic-wave-constructor-factory");

Object.keys(_periodicWaveConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _periodicWaveConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _periodicWaveConstructorFactory[key];
    }
  });
});

var _pickElementFromSetFunction = require("./pick-element-from-set-function");

Object.keys(_pickElementFromSetFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _pickElementFromSetFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pickElementFromSetFunction[key];
    }
  });
});

var _renderAutomationFactory = require("./render-automation-factory");

Object.keys(_renderAutomationFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _renderAutomationFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _renderAutomationFactory[key];
    }
  });
});

var _renderAutomationFunction = require("./render-automation-function");

Object.keys(_renderAutomationFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _renderAutomationFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _renderAutomationFunction[key];
    }
  });
});

var _renderInputsOfAudioNodeFactory = require("./render-inputs-of-audio-node-factory");

Object.keys(_renderInputsOfAudioNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _renderInputsOfAudioNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _renderInputsOfAudioNodeFactory[key];
    }
  });
});

var _renderInputsOfAudioNodeFunction = require("./render-inputs-of-audio-node-function");

Object.keys(_renderInputsOfAudioNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _renderInputsOfAudioNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _renderInputsOfAudioNodeFunction[key];
    }
  });
});

var _renderInputsOfAudioParamFactory = require("./render-inputs-of-audio-param-factory");

Object.keys(_renderInputsOfAudioParamFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _renderInputsOfAudioParamFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _renderInputsOfAudioParamFactory[key];
    }
  });
});

var _renderInputsOfAudioParamFunction = require("./render-inputs-of-audio-param-function");

Object.keys(_renderInputsOfAudioParamFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _renderInputsOfAudioParamFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _renderInputsOfAudioParamFunction[key];
    }
  });
});

var _renderNativeOfflineAudioContextFactory = require("./render-native-offline-audio-context-factory");

Object.keys(_renderNativeOfflineAudioContextFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _renderNativeOfflineAudioContextFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _renderNativeOfflineAudioContextFactory[key];
    }
  });
});

var _renderNativeOfflineAudioContextFunction = require("./render-native-offline-audio-context-function");

Object.keys(_renderNativeOfflineAudioContextFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _renderNativeOfflineAudioContextFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _renderNativeOfflineAudioContextFunction[key];
    }
  });
});

var _sanitizeAudioWorkletNodeOptionsFunction = require("./sanitize-audio-worklet-node-options-function");

Object.keys(_sanitizeAudioWorkletNodeOptionsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sanitizeAudioWorkletNodeOptionsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sanitizeAudioWorkletNodeOptionsFunction[key];
    }
  });
});

var _sanitizeChannelSplitterOptionsFunction = require("./sanitize-channel-splitter-options-function");

Object.keys(_sanitizeChannelSplitterOptionsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sanitizeChannelSplitterOptionsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sanitizeChannelSplitterOptionsFunction[key];
    }
  });
});

var _sanitizePeriodicWaveOptionsFunction = require("./sanitize-periodic-wave-options-function");

Object.keys(_sanitizePeriodicWaveOptionsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _sanitizePeriodicWaveOptionsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _sanitizePeriodicWaveOptionsFunction[key];
    }
  });
});

var _setActiveAudioWorkletNodeInputsFactory = require("./set-active-audio-worklet-node-inputs-factory");

Object.keys(_setActiveAudioWorkletNodeInputsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _setActiveAudioWorkletNodeInputsFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _setActiveAudioWorkletNodeInputsFactory[key];
    }
  });
});

var _setActiveAudioWorkletNodeInputsFunction = require("./set-active-audio-worklet-node-inputs-function");

Object.keys(_setActiveAudioWorkletNodeInputsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _setActiveAudioWorkletNodeInputsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _setActiveAudioWorkletNodeInputsFunction[key];
    }
  });
});

var _setAudioNodeTailTimeFactory = require("./set-audio-node-tail-time-factory");

Object.keys(_setAudioNodeTailTimeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _setAudioNodeTailTimeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _setAudioNodeTailTimeFactory[key];
    }
  });
});

var _setAudioNodeTailTimeFunction = require("./set-audio-node-tail-time-function");

Object.keys(_setAudioNodeTailTimeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _setAudioNodeTailTimeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _setAudioNodeTailTimeFunction[key];
    }
  });
});

var _setValueAtTimeUntilPossibleFunction = require("./set-value-at-time-until-possible-function");

Object.keys(_setValueAtTimeUntilPossibleFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _setValueAtTimeUntilPossibleFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _setValueAtTimeUntilPossibleFunction[key];
    }
  });
});

var _startRenderingFactory = require("./start-rendering-factory");

Object.keys(_startRenderingFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _startRenderingFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _startRenderingFactory[key];
    }
  });
});

var _startRenderingFunction = require("./start-rendering-function");

Object.keys(_startRenderingFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _startRenderingFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _startRenderingFunction[key];
    }
  });
});

var _stereoPannerNodeConstructor = require("./stereo-panner-node-constructor");

Object.keys(_stereoPannerNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _stereoPannerNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stereoPannerNodeConstructor[key];
    }
  });
});

var _stereoPannerNodeConstructorFactory = require("./stereo-panner-node-constructor-factory");

Object.keys(_stereoPannerNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _stereoPannerNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stereoPannerNodeConstructorFactory[key];
    }
  });
});

var _stereoPannerNodeRendererFactoryFactory = require("./stereo-panner-node-renderer-factory-factory");

Object.keys(_stereoPannerNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _stereoPannerNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stereoPannerNodeRendererFactoryFactory[key];
    }
  });
});

var _stereoPannerNodeRendererFactory = require("./stereo-panner-node-renderer-factory");

Object.keys(_stereoPannerNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _stereoPannerNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stereoPannerNodeRendererFactory[key];
    }
  });
});

var _testAudioBufferCopyChannelMethodsSubarraySupportFactory = require("./test-audio-buffer-copy-channel-methods-subarray-support-factory");

Object.keys(_testAudioBufferCopyChannelMethodsSubarraySupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testAudioBufferCopyChannelMethodsSubarraySupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testAudioBufferCopyChannelMethodsSubarraySupportFactory[key];
    }
  });
});

var _testAudioBufferConstructorSupportFactory = require("./test-audio-buffer-constructor-support-factory");

Object.keys(_testAudioBufferConstructorSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testAudioBufferConstructorSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testAudioBufferConstructorSupportFactory[key];
    }
  });
});

var _testAudioContextCloseMethodSupportFactory = require("./test-audio-context-close-method-support-factory");

Object.keys(_testAudioContextCloseMethodSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testAudioContextCloseMethodSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testAudioContextCloseMethodSupportFactory[key];
    }
  });
});

var _testAudioContextDecodeAudioDataMethodTypeErrorSupportFactory = require("./test-audio-context-decode-audio-data-method-type-error-support-factory");

Object.keys(_testAudioContextDecodeAudioDataMethodTypeErrorSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testAudioContextDecodeAudioDataMethodTypeErrorSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testAudioContextDecodeAudioDataMethodTypeErrorSupportFactory[key];
    }
  });
});

var _testAudioContextOptionsSupportFactory = require("./test-audio-context-options-support-factory");

Object.keys(_testAudioContextOptionsSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testAudioContextOptionsSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testAudioContextOptionsSupportFactory[key];
    }
  });
});

var _testAudioNodeConnectMethodSupportFactory = require("./test-audio-node-connect-method-support-factory");

Object.keys(_testAudioNodeConnectMethodSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testAudioNodeConnectMethodSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testAudioNodeConnectMethodSupportFactory[key];
    }
  });
});

var _testAudioWorkletNodeOptionsClonabilityFunction = require("./test-audio-worklet-node-options-clonability-function");

Object.keys(_testAudioWorkletNodeOptionsClonabilityFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testAudioWorkletNodeOptionsClonabilityFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testAudioWorkletNodeOptionsClonabilityFunction[key];
    }
  });
});

var _testAudioWorkletProcessorNoOutputsSupportFactory = require("./test-audio-worklet-processor-no-outputs-support-factory");

Object.keys(_testAudioWorkletProcessorNoOutputsSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testAudioWorkletProcessorNoOutputsSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testAudioWorkletProcessorNoOutputsSupportFactory[key];
    }
  });
});

var _testAudioWorkletProcessorPostMessageSupportFactory = require("./test-audio-worklet-processor-post-message-support-factory");

Object.keys(_testAudioWorkletProcessorPostMessageSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testAudioWorkletProcessorPostMessageSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testAudioWorkletProcessorPostMessageSupportFactory[key];
    }
  });
});

var _testChannelMergerNodeChannelCountSupportFactory = require("./test-channel-merger-node-channel-count-support-factory");

Object.keys(_testChannelMergerNodeChannelCountSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testChannelMergerNodeChannelCountSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testChannelMergerNodeChannelCountSupportFactory[key];
    }
  });
});

var _testConstantSourceNodeAccurateSchedulingSupportFactory = require("./test-constant-source-node-accurate-scheduling-support-factory");

Object.keys(_testConstantSourceNodeAccurateSchedulingSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testConstantSourceNodeAccurateSchedulingSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testConstantSourceNodeAccurateSchedulingSupportFactory[key];
    }
  });
});

var _testConvolverNodeBufferReassignabilitySupportFactory = require("./test-convolver-node-buffer-reassignability-support-factory");

Object.keys(_testConvolverNodeBufferReassignabilitySupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testConvolverNodeBufferReassignabilitySupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testConvolverNodeBufferReassignabilitySupportFactory[key];
    }
  });
});

var _testConvolverNodeChannelCountSupportFactory = require("./test-convolver-node-channel-count-support-factory");

Object.keys(_testConvolverNodeChannelCountSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testConvolverNodeChannelCountSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testConvolverNodeChannelCountSupportFactory[key];
    }
  });
});

var _testIsSecureContextSupportFactory = require("./test-is-secure-context-support-factory");

Object.keys(_testIsSecureContextSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testIsSecureContextSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testIsSecureContextSupportFactory[key];
    }
  });
});

var _testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport = require("./test-media-stream-audio-source-node-media-stream-without-audio-track-support");

Object.keys(_testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport[key];
    }
  });
});

var _testOfflineAudioContextCurrentTimeSupportFactory = require("./test-offline-audio-context-current-time-support-factory");

Object.keys(_testOfflineAudioContextCurrentTimeSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testOfflineAudioContextCurrentTimeSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testOfflineAudioContextCurrentTimeSupportFactory[key];
    }
  });
});

var _testStereoPannerNodeDefaultValueSupportFactory = require("./test-stereo-panner-node-default-value-support-factory");

Object.keys(_testStereoPannerNodeDefaultValueSupportFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testStereoPannerNodeDefaultValueSupportFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testStereoPannerNodeDefaultValueSupportFactory[key];
    }
  });
});

var _unknownErrorFactory = require("./unknown-error-factory");

Object.keys(_unknownErrorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _unknownErrorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _unknownErrorFactory[key];
    }
  });
});

var _unrenderedAudioWorkletNodeStore = require("./unrendered-audio-worklet-node-store");

Object.keys(_unrenderedAudioWorkletNodeStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _unrenderedAudioWorkletNodeStore[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _unrenderedAudioWorkletNodeStore[key];
    }
  });
});

var _unrenderedAudioWorkletNodes = require("./unrendered-audio-worklet-nodes");

Object.keys(_unrenderedAudioWorkletNodes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _unrenderedAudioWorkletNodes[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _unrenderedAudioWorkletNodes[key];
    }
  });
});

var _waveShaperNodeConstructor = require("./wave-shaper-node-constructor");

Object.keys(_waveShaperNodeConstructor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _waveShaperNodeConstructor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _waveShaperNodeConstructor[key];
    }
  });
});

var _waveShaperNodeConstructorFactory = require("./wave-shaper-node-constructor-factory");

Object.keys(_waveShaperNodeConstructorFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _waveShaperNodeConstructorFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _waveShaperNodeConstructorFactory[key];
    }
  });
});

var _waveShaperNodeRendererFactoryFactory = require("./wave-shaper-node-renderer-factory-factory");

Object.keys(_waveShaperNodeRendererFactoryFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _waveShaperNodeRendererFactoryFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _waveShaperNodeRendererFactoryFactory[key];
    }
  });
});

var _waveShaperNodeRendererFactory = require("./wave-shaper-node-renderer-factory");

Object.keys(_waveShaperNodeRendererFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _waveShaperNodeRendererFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _waveShaperNodeRendererFactory[key];
    }
  });
});

var _window = require("./window");

Object.keys(_window).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _window[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _window[key];
    }
  });
});

var _windowFactory = require("./window-factory");

Object.keys(_windowFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _windowFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _windowFactory[key];
    }
  });
});

var _wrapAudioBufferCopyChannelMethodsFactory = require("./wrap-audio-buffer-copy-channel-methods-factory");

Object.keys(_wrapAudioBufferCopyChannelMethodsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _wrapAudioBufferCopyChannelMethodsFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _wrapAudioBufferCopyChannelMethodsFactory[key];
    }
  });
});

var _wrapAudioBufferCopyChannelMethodsFunction = require("./wrap-audio-buffer-copy-channel-methods-function");

Object.keys(_wrapAudioBufferCopyChannelMethodsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _wrapAudioBufferCopyChannelMethodsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _wrapAudioBufferCopyChannelMethodsFunction[key];
    }
  });
});

var _wrapAudioBufferCopyChannelMethodsOutOfBoundsFactory = require("./wrap-audio-buffer-copy-channel-methods-out-of-bounds-factory");

Object.keys(_wrapAudioBufferCopyChannelMethodsOutOfBoundsFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _wrapAudioBufferCopyChannelMethodsOutOfBoundsFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _wrapAudioBufferCopyChannelMethodsOutOfBoundsFactory[key];
    }
  });
});

var _wrapAudioBufferCopyChannelMethodsOutOfBoundsFunction = require("./wrap-audio-buffer-copy-channel-methods-out-of-bounds-function");

Object.keys(_wrapAudioBufferCopyChannelMethodsOutOfBoundsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _wrapAudioBufferCopyChannelMethodsOutOfBoundsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _wrapAudioBufferCopyChannelMethodsOutOfBoundsFunction[key];
    }
  });
});

var _wrapAudioBufferSourceNodeStartMethodOffsetClampingFunction = require("./wrap-audio-buffer-source-node-start-method-offset-clamping-function");

Object.keys(_wrapAudioBufferSourceNodeStartMethodOffsetClampingFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _wrapAudioBufferSourceNodeStartMethodOffsetClampingFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _wrapAudioBufferSourceNodeStartMethodOffsetClampingFunction[key];
    }
  });
});

var _wrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory = require("./wrap-audio-buffer-source-node-stop-method-nullified-buffer-factory");

Object.keys(_wrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _wrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _wrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory[key];
    }
  });
});

var _wrapAudioBufferSourceNodeStopMethodNullifiedBufferFunction = require("./wrap-audio-buffer-source-node-stop-method-nullified-buffer-function");

Object.keys(_wrapAudioBufferSourceNodeStopMethodNullifiedBufferFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _wrapAudioBufferSourceNodeStopMethodNullifiedBufferFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _wrapAudioBufferSourceNodeStopMethodNullifiedBufferFunction[key];
    }
  });
});

var _wrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction = require("./wrap-audio-scheduled-source-node-stop-method-consecutive-calls-function");

Object.keys(_wrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _wrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _wrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction[key];
    }
  });
});

var _wrapChannelMergerNodeFactory = require("./wrap-channel-merger-node-factory");

Object.keys(_wrapChannelMergerNodeFactory).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _wrapChannelMergerNodeFactory[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _wrapChannelMergerNodeFactory[key];
    }
  });
});

var _wrapChannelMergerNodeFunction = require("./wrap-channel-merger-node-function");

Object.keys(_wrapChannelMergerNodeFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _wrapChannelMergerNodeFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _wrapChannelMergerNodeFunction[key];
    }
  });
});

var _wrapEventListenerFunction = require("./wrap-event-listener-function");

Object.keys(_wrapEventListenerFunction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _wrapEventListenerFunction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _wrapEventListenerFunction[key];
    }
  });
});
},{"./abort-error-factory":"../node_modules/standardized-audio-context/build/es2019/types/abort-error-factory.js","./active-audio-worklet-node-inputs-store":"../node_modules/standardized-audio-context/build/es2019/types/active-audio-worklet-node-inputs-store.js","./active-input-connection":"../node_modules/standardized-audio-context/build/es2019/types/active-input-connection.js","./add-active-input-connection-to-audio-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/add-active-input-connection-to-audio-node-factory.js","./add-active-input-connection-to-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/add-active-input-connection-to-audio-node-function.js","./add-audio-node-connections-factory":"../node_modules/standardized-audio-context/build/es2019/types/add-audio-node-connections-factory.js","./add-audio-node-connections-function":"../node_modules/standardized-audio-context/build/es2019/types/add-audio-node-connections-function.js","./add-audio-param-connections-factory":"../node_modules/standardized-audio-context/build/es2019/types/add-audio-param-connections-factory.js","./add-audio-param-connections-function":"../node_modules/standardized-audio-context/build/es2019/types/add-audio-param-connections-function.js","./add-audio-worklet-module-factory":"../node_modules/standardized-audio-context/build/es2019/types/add-audio-worklet-module-factory.js","./add-audio-worklet-module-function":"../node_modules/standardized-audio-context/build/es2019/types/add-audio-worklet-module-function.js","./add-connection-to-audio-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/add-connection-to-audio-node-factory.js","./add-connection-to-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/add-connection-to-audio-node-function.js","./add-passive-input-connection-to-audio-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/add-passive-input-connection-to-audio-node-factory.js","./add-passive-input-connection-to-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/add-passive-input-connection-to-audio-node-function.js","./add-silent-connection-factory":"../node_modules/standardized-audio-context/build/es2019/types/add-silent-connection-factory.js","./add-silent-connection-function":"../node_modules/standardized-audio-context/build/es2019/types/add-silent-connection-function.js","./add-unrendered-audio-worklet-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/add-unrendered-audio-worklet-node-factory.js","./add-unrendered-audio-worklet-node-function":"../node_modules/standardized-audio-context/build/es2019/types/add-unrendered-audio-worklet-node-function.js","./analyser-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/analyser-node-constructor.js","./analyser-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/analyser-node-constructor-factory.js","./analyser-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/analyser-node-renderer-factory.js","./analyser-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/analyser-node-renderer-factory-factory.js","./any-audio-buffer":"../node_modules/standardized-audio-context/build/es2019/types/any-audio-buffer.js","./any-context":"../node_modules/standardized-audio-context/build/es2019/types/any-context.js","./audio-buffer-constructor":"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-constructor.js","./audio-buffer-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-constructor-factory.js","./audio-buffer-source-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-constructor.js","./audio-buffer-source-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-constructor-factory.js","./audio-buffer-source-node-renderer":"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer.js","./audio-buffer-source-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer-factory.js","./audio-buffer-source-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer-factory-factory.js","./audio-buffer-store":"../node_modules/standardized-audio-context/build/es2019/types/audio-buffer-store.js","./audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/types/audio-context-constructor.js","./audio-context-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-context-constructor-factory.js","./audio-context-latency-category":"../node_modules/standardized-audio-context/build/es2019/types/audio-context-latency-category.js","./audio-context-state":"../node_modules/standardized-audio-context/build/es2019/types/audio-context-state.js","./audio-destination-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-constructor.js","./audio-destination-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-constructor-factory.js","./audio-destination-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-renderer-factory.js","./audio-listener-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-listener-factory.js","./audio-listener-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-listener-factory-factory.js","./audio-node-connections":"../node_modules/standardized-audio-context/build/es2019/types/audio-node-connections.js","./audio-node-connections-store":"../node_modules/standardized-audio-context/build/es2019/types/audio-node-connections-store.js","./audio-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/audio-node-constructor.js","./audio-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-node-constructor-factory.js","./audio-node-output-connection":"../node_modules/standardized-audio-context/build/es2019/types/audio-node-output-connection.js","./audio-node-renderer":"../node_modules/standardized-audio-context/build/es2019/types/audio-node-renderer.js","./audio-node-store":"../node_modules/standardized-audio-context/build/es2019/types/audio-node-store.js","./audio-node-tail-time-store":"../node_modules/standardized-audio-context/build/es2019/types/audio-node-tail-time-store.js","./audio-param-audio-node-store":"../node_modules/standardized-audio-context/build/es2019/types/audio-param-audio-node-store.js","./audio-param-connections":"../node_modules/standardized-audio-context/build/es2019/types/audio-param-connections.js","./audio-param-connections-store":"../node_modules/standardized-audio-context/build/es2019/types/audio-param-connections-store.js","./audio-param-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-param-factory.js","./audio-param-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-param-factory-factory.js","./audio-param-map":"../node_modules/standardized-audio-context/build/es2019/types/audio-param-map.js","./audio-param-output-connection":"../node_modules/standardized-audio-context/build/es2019/types/audio-param-output-connection.js","./audio-param-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-param-renderer-factory.js","./audio-param-store":"../node_modules/standardized-audio-context/build/es2019/types/audio-param-store.js","./audio-worklet-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-constructor.js","./audio-worklet-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-constructor-factory.js","./audio-worklet-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-renderer-factory.js","./audio-worklet-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-renderer-factory-factory.js","./backup-offline-audio-context-store":"../node_modules/standardized-audio-context/build/es2019/types/backup-offline-audio-context-store.js","./base-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/types/base-audio-context-constructor.js","./base-audio-context-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/base-audio-context-constructor-factory.js","./biquad-filter-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-constructor.js","./biquad-filter-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-constructor-factory.js","./biquad-filter-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-renderer-factory.js","./biquad-filter-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-renderer-factory-factory.js","./biquad-filter-type":"../node_modules/standardized-audio-context/build/es2019/types/biquad-filter-type.js","./channel-count-mode":"../node_modules/standardized-audio-context/build/es2019/types/channel-count-mode.js","./channel-interpretation":"../node_modules/standardized-audio-context/build/es2019/types/channel-interpretation.js","./channel-merger-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-constructor.js","./channel-merger-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-constructor-factory.js","./channel-merger-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-renderer-factory.js","./channel-merger-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-renderer-factory-factory.js","./channel-splitter-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-constructor.js","./channel-splitter-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-constructor-factory.js","./channel-splitter-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-renderer-factory.js","./channel-splitter-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-renderer-factory-factory.js","./cache-test-result-factory":"../node_modules/standardized-audio-context/build/es2019/types/cache-test-result-factory.js","./cache-test-result-function":"../node_modules/standardized-audio-context/build/es2019/types/cache-test-result-function.js","./connect-audio-param-factory":"../node_modules/standardized-audio-context/build/es2019/types/connect-audio-param-factory.js","./connect-audio-param-function":"../node_modules/standardized-audio-context/build/es2019/types/connect-audio-param-function.js","./connect-multiple-outputs-factory":"../node_modules/standardized-audio-context/build/es2019/types/connect-multiple-outputs-factory.js","./connect-multiple-outputs-function":"../node_modules/standardized-audio-context/build/es2019/types/connect-multiple-outputs-function.js","./connect-native-audio-node-to-native-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/connect-native-audio-node-to-native-audio-node-function.js","./connected-native-audio-buffer-source-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/connected-native-audio-buffer-source-node-factory.js","./connected-native-audio-buffer-source-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/connected-native-audio-buffer-source-node-factory-factory.js","./constant-source-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/constant-source-node-constructor.js","./constant-source-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/constant-source-node-constructor-factory.js","./constant-source-node-renderer":"../node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer.js","./constant-source-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer-factory.js","./constant-source-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer-factory-factory.js","./constructor":"../node_modules/standardized-audio-context/build/es2019/types/constructor.js","./context":"../node_modules/standardized-audio-context/build/es2019/types/context.js","./context-store":"../node_modules/standardized-audio-context/build/es2019/types/context-store.js","./convert-number-to-unsigned-long-factory":"../node_modules/standardized-audio-context/build/es2019/types/convert-number-to-unsigned-long-factory.js","./convert-number-to-unsigned-long-function":"../node_modules/standardized-audio-context/build/es2019/types/convert-number-to-unsigned-long-function.js","./convolver-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/convolver-node-constructor.js","./convolver-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/convolver-node-constructor-factory.js","./convolver-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/convolver-node-renderer-factory.js","./convolver-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/convolver-node-renderer-factory-factory.js","./create-native-offline-audio-context-factory":"../node_modules/standardized-audio-context/build/es2019/types/create-native-offline-audio-context-factory.js","./create-native-offline-audio-context-function":"../node_modules/standardized-audio-context/build/es2019/types/create-native-offline-audio-context-function.js","./cycle-counters":"../node_modules/standardized-audio-context/build/es2019/types/cycle-counters.js","./data-clone-error-factory":"../node_modules/standardized-audio-context/build/es2019/types/data-clone-error-factory.js","./decode-audio-data-factory":"../node_modules/standardized-audio-context/build/es2019/types/decode-audio-data-factory.js","./decode-audio-data-function":"../node_modules/standardized-audio-context/build/es2019/types/decode-audio-data-function.js","./decode-error-callback":"../node_modules/standardized-audio-context/build/es2019/types/decode-error-callback.js","./decode-success-callback":"../node_modules/standardized-audio-context/build/es2019/types/decode-success-callback.js","./decrement-cycle-counter-factory":"../node_modules/standardized-audio-context/build/es2019/types/decrement-cycle-counter-factory.js","./decrement-cycle-counter-function":"../node_modules/standardized-audio-context/build/es2019/types/decrement-cycle-counter-function.js","./delay-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/delay-node-constructor.js","./delay-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/delay-node-constructor-factory.js","./delay-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/delay-node-renderer-factory.js","./delay-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/delay-node-renderer-factory-factory.js","./delete-active-input-connection-to-audio-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/delete-active-input-connection-to-audio-node-factory.js","./delete-active-input-connection-to-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/delete-active-input-connection-to-audio-node-function.js","./delete-unrendered-audio-worklet-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/delete-unrendered-audio-worklet-node-factory.js","./delete-unrendered-audio-worklet-node-function":"../node_modules/standardized-audio-context/build/es2019/types/delete-unrendered-audio-worklet-node-function.js","./detect-cycles-factory":"../node_modules/standardized-audio-context/build/es2019/types/detect-cycles-factory.js","./detect-cycles-function":"../node_modules/standardized-audio-context/build/es2019/types/detect-cycles-function.js","./disconnect-multiple-outputs-factory":"../node_modules/standardized-audio-context/build/es2019/types/disconnect-multiple-outputs-factory.js","./disconnect-multiple-outputs-function":"../node_modules/standardized-audio-context/build/es2019/types/disconnect-multiple-outputs-function.js","./disconnect-native-audio-node-from-native-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/disconnect-native-audio-node-from-native-audio-node-function.js","./distance-model-type":"../node_modules/standardized-audio-context/build/es2019/types/distance-model-type.js","./dynamics-compressor-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-constructor.js","./dynamics-compressor-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-constructor-factory.js","./dynamics-compressor-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-renderer-factory.js","./dynamics-compressor-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-renderer-factory-factory.js","./encoding-error-factory":"../node_modules/standardized-audio-context/build/es2019/types/encoding-error-factory.js","./error-event-handler":"../node_modules/standardized-audio-context/build/es2019/types/error-event-handler.js","./evaluate-audio-worklet-global-scope-function":"../node_modules/standardized-audio-context/build/es2019/types/evaluate-audio-worklet-global-scope-function.js","./evaluate-source-factory":"../node_modules/standardized-audio-context/build/es2019/types/evaluate-source-factory.js","./evaluate-source-function":"../node_modules/standardized-audio-context/build/es2019/types/evaluate-source-function.js","./event-handler":"../node_modules/standardized-audio-context/build/es2019/types/event-handler.js","./event-target-constructor":"../node_modules/standardized-audio-context/build/es2019/types/event-target-constructor.js","./event-target-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/event-target-constructor-factory.js","./expose-current-frame-and-current-time-factory":"../node_modules/standardized-audio-context/build/es2019/types/expose-current-frame-and-current-time-factory.js","./expose-current-frame-and-current-time-function":"../node_modules/standardized-audio-context/build/es2019/types/expose-current-frame-and-current-time-function.js","./fetch-source-factory":"../node_modules/standardized-audio-context/build/es2019/types/fetch-source-factory.js","./fetch-source-function":"../node_modules/standardized-audio-context/build/es2019/types/fetch-source-function.js","./gain-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/gain-node-constructor.js","./gain-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/gain-node-constructor-factory.js","./gain-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/gain-node-renderer-factory.js","./gain-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/gain-node-renderer-factory-factory.js","./get-active-audio-worklet-node-inputs-factory":"../node_modules/standardized-audio-context/build/es2019/types/get-active-audio-worklet-node-inputs-factory.js","./get-active-audio-worklet-node-inputs-function":"../node_modules/standardized-audio-context/build/es2019/types/get-active-audio-worklet-node-inputs-function.js","./get-audio-node-connections-function":"../node_modules/standardized-audio-context/build/es2019/types/get-audio-node-connections-function.js","./get-audio-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/get-audio-node-renderer-factory.js","./get-audio-node-renderer-function":"../node_modules/standardized-audio-context/build/es2019/types/get-audio-node-renderer-function.js","./get-audio-node-tail-time-factory":"../node_modules/standardized-audio-context/build/es2019/types/get-audio-node-tail-time-factory.js","./get-audio-node-tail-time-function":"../node_modules/standardized-audio-context/build/es2019/types/get-audio-node-tail-time-function.js","./get-audio-param-connections-function":"../node_modules/standardized-audio-context/build/es2019/types/get-audio-param-connections-function.js","./get-audio-param-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/get-audio-param-renderer-factory.js","./get-audio-param-renderer-function":"../node_modules/standardized-audio-context/build/es2019/types/get-audio-param-renderer-function.js","./get-backup-offline-audio-context-factory":"../node_modules/standardized-audio-context/build/es2019/types/get-backup-offline-audio-context-factory.js","./get-backup-offline-audio-context-function":"../node_modules/standardized-audio-context/build/es2019/types/get-backup-offline-audio-context-function.js","./get-event-listeners-of-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/get-event-listeners-of-audio-node-function.js","./get-first-sample-function":"../node_modules/standardized-audio-context/build/es2019/types/get-first-sample-function.js","./get-native-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/get-native-audio-node-function.js","./get-native-audio-param-function":"../node_modules/standardized-audio-context/build/es2019/types/get-native-audio-param-function.js","./get-native-context-factory":"../node_modules/standardized-audio-context/build/es2019/types/get-native-context-factory.js","./get-native-context-function":"../node_modules/standardized-audio-context/build/es2019/types/get-native-context-function.js","./get-or-create-backup-offline-audio-context-factory":"../node_modules/standardized-audio-context/build/es2019/types/get-or-create-backup-offline-audio-context-factory.js","./get-or-create-backup-offline-audio-context-function":"../node_modules/standardized-audio-context/build/es2019/types/get-or-create-backup-offline-audio-context-function.js","./get-unrendered-audio-worklet-nodes-factory":"../node_modules/standardized-audio-context/build/es2019/types/get-unrendered-audio-worklet-nodes-factory.js","./get-unrendered-audio-worklet-nodes-function":"../node_modules/standardized-audio-context/build/es2019/types/get-unrendered-audio-worklet-nodes-function.js","./get-value-for-key-function":"../node_modules/standardized-audio-context/build/es2019/types/get-value-for-key-function.js","./iir-filter-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-constructor.js","./iir-filter-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-constructor-factory.js","./iir-filter-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-renderer-factory.js","./iir-filter-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-renderer-factory-factory.js","./increment-cycle-counter-factory":"../node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-factory.js","./increment-cycle-counter-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-factory-factory.js","./increment-cycle-counter-function":"../node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-function.js","./index-size-error-factory":"../node_modules/standardized-audio-context/build/es2019/types/index-size-error-factory.js","./insert-element-in-set-function":"../node_modules/standardized-audio-context/build/es2019/types/insert-element-in-set-function.js","./internal-state-event-listener":"../node_modules/standardized-audio-context/build/es2019/types/internal-state-event-listener.js","./invalid-access-error-factory":"../node_modules/standardized-audio-context/build/es2019/types/invalid-access-error-factory.js","./invalid-state-error-factory":"../node_modules/standardized-audio-context/build/es2019/types/invalid-state-error-factory.js","./is-active-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/is-active-audio-node-function.js","./is-any-audio-context-factory":"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-context-factory.js","./is-any-audio-context-function":"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-context-function.js","./is-any-audio-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-node-factory.js","./is-any-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-node-function.js","./is-any-audio-param-factory":"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-param-factory.js","./is-any-audio-param-function":"../node_modules/standardized-audio-context/build/es2019/types/is-any-audio-param-function.js","./is-any-offline-audio-context-factory":"../node_modules/standardized-audio-context/build/es2019/types/is-any-offline-audio-context-factory.js","./is-any-offline-audio-context-function":"../node_modules/standardized-audio-context/build/es2019/types/is-any-offline-audio-context-function.js","./is-dc-curve-function":"../node_modules/standardized-audio-context/build/es2019/types/is-dc-curve-function.js","./is-native-audio-context-factory":"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-context-factory.js","./is-native-audio-context-function":"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-context-function.js","./is-native-audio-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-node-factory.js","./is-native-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-node-function.js","./is-native-audio-param-factory":"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-param-factory.js","./is-native-audio-param-function":"../node_modules/standardized-audio-context/build/es2019/types/is-native-audio-param-function.js","./is-native-context-factory":"../node_modules/standardized-audio-context/build/es2019/types/is-native-context-factory.js","./is-native-context-function":"../node_modules/standardized-audio-context/build/es2019/types/is-native-context-function.js","./is-native-offline-audio-context-factory":"../node_modules/standardized-audio-context/build/es2019/types/is-native-offline-audio-context-factory.js","./is-native-offline-audio-context-function":"../node_modules/standardized-audio-context/build/es2019/types/is-native-offline-audio-context-function.js","./is-part-of-a-cycle-function":"../node_modules/standardized-audio-context/build/es2019/types/is-part-of-a-cycle-function.js","./is-passive-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/is-passive-audio-node-function.js","./is-secure-context-factory":"../node_modules/standardized-audio-context/build/es2019/types/is-secure-context-factory.js","./is-supported-promise-factory":"../node_modules/standardized-audio-context/build/es2019/types/is-supported-promise-factory.js","./media-element-audio-source-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/media-element-audio-source-node-constructor.js","./media-element-audio-source-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/media-element-audio-source-node-constructor-factory.js","./media-stream-audio-destination-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-destination-node-constructor.js","./media-stream-audio-destination-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-destination-node-constructor-factory.js","./media-stream-audio-source-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-source-node-constructor.js","./media-stream-audio-source-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-source-node-constructor-factory.js","./media-stream-track-audio-source-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/media-stream-track-audio-source-node-constructor.js","./media-stream-track-audio-source-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/media-stream-track-audio-source-node-constructor-factory.js","./minimal-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/types/minimal-audio-context-constructor.js","./minimal-audio-context-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/minimal-audio-context-constructor-factory.js","./minimal-base-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/types/minimal-base-audio-context-constructor.js","./minimal-base-audio-context-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/minimal-base-audio-context-constructor-factory.js","./minimal-offline-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/types/minimal-offline-audio-context-constructor.js","./minimal-offline-audio-context-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/minimal-offline-audio-context-constructor-factory.js","./monitor-connections-factory":"../node_modules/standardized-audio-context/build/es2019/types/monitor-connections-factory.js","./monitor-connections-function":"../node_modules/standardized-audio-context/build/es2019/types/monitor-connections-function.js","./native-analyser-node":"../node_modules/standardized-audio-context/build/es2019/types/native-analyser-node.js","./native-analyser-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-analyser-node-factory.js","./native-analyser-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-analyser-node-factory-factory.js","./native-audio-buffer":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer.js","./native-audio-buffer-constructor":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-constructor.js","./native-audio-buffer-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-constructor-factory.js","./native-audio-buffer-source-node":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node.js","./native-audio-buffer-source-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node-factory.js","./native-audio-buffer-source-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node-factory-factory.js","./native-audio-context":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-context.js","./native-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-context-constructor.js","./native-audio-context-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-context-constructor-factory.js","./native-audio-destination-node":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node.js","./native-audio-destination-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node-factory.js","./native-audio-destination-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node-factory-factory.js","./native-audio-listener":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-listener.js","./native-audio-node":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-node.js","./native-audio-param":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-param.js","./native-audio-param-map":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-param-map.js","./native-audio-worklet":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet.js","./native-audio-worklet-node":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node.js","./native-audio-worklet-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-constructor.js","./native-audio-worklet-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-constructor-factory.js","./native-audio-worklet-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-factory.js","./native-audio-worklet-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-factory-factory.js","./native-audio-worklet-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-faker-factory.js","./native-audio-worklet-node-faker-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-faker-factory-factory.js","./native-audio-worklet-node-options":"../node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-options.js","./native-biquad-filter-node":"../node_modules/standardized-audio-context/build/es2019/types/native-biquad-filter-node.js","./native-biquad-filter-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-biquad-filter-node-factory.js","./native-channel-merger-node":"../node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node.js","./native-channel-merger-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node-factory.js","./native-channel-merger-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node-factory-factory.js","./native-channel-splitter-node":"../node_modules/standardized-audio-context/build/es2019/types/native-channel-splitter-node.js","./native-channel-splitter-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-channel-splitter-node-factory.js","./native-constant-source-node":"../node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node.js","./native-constant-source-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-factory.js","./native-constant-source-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-factory-factory.js","./native-constant-source-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-faker-factory.js","./native-constant-source-node-faker-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-faker-factory-factory.js","./native-context":"../node_modules/standardized-audio-context/build/es2019/types/native-context.js","./native-convolver-node":"../node_modules/standardized-audio-context/build/es2019/types/native-convolver-node.js","./native-convolver-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-convolver-node-factory.js","./native-convolver-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-convolver-node-factory-factory.js","./native-delay-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-delay-node-factory.js","./native-delay-node":"../node_modules/standardized-audio-context/build/es2019/types/native-delay-node.js","./native-dynamics-compressor-node":"../node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node.js","./native-dynamics-compressor-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node-factory.js","./native-dynamics-compressor-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node-factory-factory.js","./native-event-target":"../node_modules/standardized-audio-context/build/es2019/types/native-event-target.js","./native-gain-node":"../node_modules/standardized-audio-context/build/es2019/types/native-gain-node.js","./native-gain-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-gain-node-factory.js","./native-iir-filter-node":"../node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node.js","./native-iir-filter-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-factory.js","./native-iir-filter-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-factory-factory.js","./native-iir-filter-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-faker-factory.js","./native-iir-filter-node-faker-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-faker-factory-factory.js","./native-media-element-audio-source-node":"../node_modules/standardized-audio-context/build/es2019/types/native-media-element-audio-source-node.js","./native-media-element-audio-source-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-media-element-audio-source-node-factory.js","./native-media-stream-audio-destination-node":"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-destination-node.js","./native-media-stream-audio-destination-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-destination-node-factory.js","./native-media-stream-audio-source-node":"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-source-node.js","./native-media-stream-audio-source-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-source-node-factory.js","./native-media-stream-track-audio-source-node":"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node.js","./native-media-stream-track-audio-source-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node-factory.js","./native-media-stream-track-audio-source-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node-factory-factory.js","./native-offline-audio-context":"../node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context.js","./native-offline-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context-constructor.js","./native-offline-audio-context-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context-constructor-factory.js","./native-oscillator-node":"../node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node.js","./native-oscillator-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node-factory.js","./native-oscillator-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node-factory-factory.js","./native-panner-node":"../node_modules/standardized-audio-context/build/es2019/types/native-panner-node.js","./native-panner-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-panner-node-factory.js","./native-panner-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-panner-node-factory-factory.js","./native-panner-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-panner-node-faker-factory.js","./native-panner-node-faker-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-panner-node-faker-factory-factory.js","./native-periodic-wave":"../node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave.js","./native-periodic-wave-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave-factory.js","./native-periodic-wave-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave-factory-factory.js","./native-script-processor-node":"../node_modules/standardized-audio-context/build/es2019/types/native-script-processor-node.js","./native-script-processor-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-script-processor-node-factory.js","./native-stereo-panner-node":"../node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node.js","./native-stereo-panner-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-factory.js","./native-stereo-panner-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-factory-factory.js","./native-stereo-panner-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-faker-factory.js","./native-stereo-panner-node-faker-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-faker-factory-factory.js","./native-wave-shaper-node":"../node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node.js","./native-wave-shaper-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-factory.js","./native-wave-shaper-node-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-factory-factory.js","./native-wave-shaper-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-faker-factory.js","./native-wave-shaper-node-faker-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-faker-factory-factory.js","./not-supported-error-factory":"../node_modules/standardized-audio-context/build/es2019/types/not-supported-error-factory.js","./offline-audio-context-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/offline-audio-context-constructor-factory.js","./oscillator-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/oscillator-node-constructor.js","./oscillator-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/oscillator-node-constructor-factory.js","./oscillator-node-renderer":"../node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer.js","./oscillator-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer-factory.js","./oscillator-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer-factory-factory.js","./oscillator-type":"../node_modules/standardized-audio-context/build/es2019/types/oscillator-type.js","./output-connection":"../node_modules/standardized-audio-context/build/es2019/types/output-connection.js","./over-sample-type":"../node_modules/standardized-audio-context/build/es2019/types/over-sample-type.js","./overwrite-accessors-function":"../node_modules/standardized-audio-context/build/es2019/types/overwrite-accessors-function.js","./panner-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/panner-node-constructor.js","./panner-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/panner-node-constructor-factory.js","./panner-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/panner-node-renderer-factory.js","./panner-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/panner-node-renderer-factory-factory.js","./panning-model-type":"../node_modules/standardized-audio-context/build/es2019/types/panning-model-type.js","./passive-audio-node-input-connection":"../node_modules/standardized-audio-context/build/es2019/types/passive-audio-node-input-connection.js","./passive-audio-param-input-connection":"../node_modules/standardized-audio-context/build/es2019/types/passive-audio-param-input-connection.js","./periodic-wave-constructor":"../node_modules/standardized-audio-context/build/es2019/types/periodic-wave-constructor.js","./periodic-wave-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/periodic-wave-constructor-factory.js","./pick-element-from-set-function":"../node_modules/standardized-audio-context/build/es2019/types/pick-element-from-set-function.js","./render-automation-factory":"../node_modules/standardized-audio-context/build/es2019/types/render-automation-factory.js","./render-automation-function":"../node_modules/standardized-audio-context/build/es2019/types/render-automation-function.js","./render-inputs-of-audio-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-node-factory.js","./render-inputs-of-audio-node-function":"../node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-node-function.js","./render-inputs-of-audio-param-factory":"../node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-param-factory.js","./render-inputs-of-audio-param-function":"../node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-param-function.js","./render-native-offline-audio-context-factory":"../node_modules/standardized-audio-context/build/es2019/types/render-native-offline-audio-context-factory.js","./render-native-offline-audio-context-function":"../node_modules/standardized-audio-context/build/es2019/types/render-native-offline-audio-context-function.js","./sanitize-audio-worklet-node-options-function":"../node_modules/standardized-audio-context/build/es2019/types/sanitize-audio-worklet-node-options-function.js","./sanitize-channel-splitter-options-function":"../node_modules/standardized-audio-context/build/es2019/types/sanitize-channel-splitter-options-function.js","./sanitize-periodic-wave-options-function":"../node_modules/standardized-audio-context/build/es2019/types/sanitize-periodic-wave-options-function.js","./set-active-audio-worklet-node-inputs-factory":"../node_modules/standardized-audio-context/build/es2019/types/set-active-audio-worklet-node-inputs-factory.js","./set-active-audio-worklet-node-inputs-function":"../node_modules/standardized-audio-context/build/es2019/types/set-active-audio-worklet-node-inputs-function.js","./set-audio-node-tail-time-factory":"../node_modules/standardized-audio-context/build/es2019/types/set-audio-node-tail-time-factory.js","./set-audio-node-tail-time-function":"../node_modules/standardized-audio-context/build/es2019/types/set-audio-node-tail-time-function.js","./set-value-at-time-until-possible-function":"../node_modules/standardized-audio-context/build/es2019/types/set-value-at-time-until-possible-function.js","./start-rendering-factory":"../node_modules/standardized-audio-context/build/es2019/types/start-rendering-factory.js","./start-rendering-function":"../node_modules/standardized-audio-context/build/es2019/types/start-rendering-function.js","./stereo-panner-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-constructor.js","./stereo-panner-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-constructor-factory.js","./stereo-panner-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-renderer-factory-factory.js","./stereo-panner-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-renderer-factory.js","./test-audio-buffer-copy-channel-methods-subarray-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-audio-buffer-copy-channel-methods-subarray-support-factory.js","./test-audio-buffer-constructor-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-audio-buffer-constructor-support-factory.js","./test-audio-context-close-method-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-audio-context-close-method-support-factory.js","./test-audio-context-decode-audio-data-method-type-error-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-audio-context-decode-audio-data-method-type-error-support-factory.js","./test-audio-context-options-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-audio-context-options-support-factory.js","./test-audio-node-connect-method-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-audio-node-connect-method-support-factory.js","./test-audio-worklet-node-options-clonability-function":"../node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-node-options-clonability-function.js","./test-audio-worklet-processor-no-outputs-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-processor-no-outputs-support-factory.js","./test-audio-worklet-processor-post-message-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-processor-post-message-support-factory.js","./test-channel-merger-node-channel-count-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-channel-merger-node-channel-count-support-factory.js","./test-constant-source-node-accurate-scheduling-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-constant-source-node-accurate-scheduling-support-factory.js","./test-convolver-node-buffer-reassignability-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-convolver-node-buffer-reassignability-support-factory.js","./test-convolver-node-channel-count-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-convolver-node-channel-count-support-factory.js","./test-is-secure-context-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-is-secure-context-support-factory.js","./test-media-stream-audio-source-node-media-stream-without-audio-track-support":"../node_modules/standardized-audio-context/build/es2019/types/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js","./test-offline-audio-context-current-time-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-offline-audio-context-current-time-support-factory.js","./test-stereo-panner-node-default-value-support-factory":"../node_modules/standardized-audio-context/build/es2019/types/test-stereo-panner-node-default-value-support-factory.js","./unknown-error-factory":"../node_modules/standardized-audio-context/build/es2019/types/unknown-error-factory.js","./unrendered-audio-worklet-node-store":"../node_modules/standardized-audio-context/build/es2019/types/unrendered-audio-worklet-node-store.js","./unrendered-audio-worklet-nodes":"../node_modules/standardized-audio-context/build/es2019/types/unrendered-audio-worklet-nodes.js","./wave-shaper-node-constructor":"../node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-constructor.js","./wave-shaper-node-constructor-factory":"../node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-constructor-factory.js","./wave-shaper-node-renderer-factory-factory":"../node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-renderer-factory-factory.js","./wave-shaper-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-renderer-factory.js","./window":"../node_modules/standardized-audio-context/build/es2019/types/window.js","./window-factory":"../node_modules/standardized-audio-context/build/es2019/types/window-factory.js","./wrap-audio-buffer-copy-channel-methods-factory":"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-factory.js","./wrap-audio-buffer-copy-channel-methods-function":"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-function.js","./wrap-audio-buffer-copy-channel-methods-out-of-bounds-factory":"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-out-of-bounds-factory.js","./wrap-audio-buffer-copy-channel-methods-out-of-bounds-function":"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-out-of-bounds-function.js","./wrap-audio-buffer-source-node-start-method-offset-clamping-function":"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-start-method-offset-clamping-function.js","./wrap-audio-buffer-source-node-stop-method-nullified-buffer-factory":"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-stop-method-nullified-buffer-factory.js","./wrap-audio-buffer-source-node-stop-method-nullified-buffer-function":"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-stop-method-nullified-buffer-function.js","./wrap-audio-scheduled-source-node-stop-method-consecutive-calls-function":"../node_modules/standardized-audio-context/build/es2019/types/wrap-audio-scheduled-source-node-stop-method-consecutive-calls-function.js","./wrap-channel-merger-node-factory":"../node_modules/standardized-audio-context/build/es2019/types/wrap-channel-merger-node-factory.js","./wrap-channel-merger-node-function":"../node_modules/standardized-audio-context/build/es2019/types/wrap-channel-merger-node-function.js","./wrap-event-listener-function":"../node_modules/standardized-audio-context/build/es2019/types/wrap-event-listener-function.js"}],"../node_modules/standardized-audio-context/build/es2019/module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  AnalyserNode: true,
  AudioBuffer: true,
  AudioBufferSourceNode: true,
  addAudioWorkletModule: true,
  decodeAudioData: true,
  AudioContext: true,
  AudioWorkletNode: true,
  BiquadFilterNode: true,
  ChannelMergerNode: true,
  ChannelSplitterNode: true,
  ConvolverNode: true,
  ConstantSourceNode: true,
  DelayNode: true,
  DynamicsCompressorNode: true,
  GainNode: true,
  IIRFilterNode: true,
  MediaElementAudioSourceNode: true,
  MediaStreamAudioDestinationNode: true,
  MediaStreamAudioSourceNode: true,
  MediaStreamTrackAudioSourceNode: true,
  MinimalAudioContext: true,
  MinimalOfflineAudioContext: true,
  OfflineAudioContext: true,
  OscillatorNode: true,
  PannerNode: true,
  PeriodicWave: true,
  StereoPannerNode: true,
  WaveShaperNode: true,
  isAnyAudioContext: true,
  isAnyAudioNode: true,
  isAnyAudioParam: true,
  isAnyOfflineAudioContext: true,
  isSupported: true
};
exports.isSupported = exports.isAnyOfflineAudioContext = exports.isAnyAudioParam = exports.isAnyAudioNode = exports.isAnyAudioContext = exports.decodeAudioData = exports.addAudioWorkletModule = exports.WaveShaperNode = exports.StereoPannerNode = exports.PeriodicWave = exports.PannerNode = exports.OscillatorNode = exports.OfflineAudioContext = exports.MinimalOfflineAudioContext = exports.MinimalAudioContext = exports.MediaStreamTrackAudioSourceNode = exports.MediaStreamAudioSourceNode = exports.MediaStreamAudioDestinationNode = exports.MediaElementAudioSourceNode = exports.IIRFilterNode = exports.GainNode = exports.DynamicsCompressorNode = exports.DelayNode = exports.ConvolverNode = exports.ConstantSourceNode = exports.ChannelSplitterNode = exports.ChannelMergerNode = exports.BiquadFilterNode = exports.AudioWorkletNode = exports.AudioContext = exports.AudioBufferSourceNode = exports.AudioBuffer = exports.AnalyserNode = void 0;

var _automationEvents = require("automation-events");

var _abortError = require("./factories/abort-error");

var _addActiveInputConnectionToAudioNode = require("./factories/add-active-input-connection-to-audio-node");

var _addAudioNodeConnections = require("./factories/add-audio-node-connections");

var _addAudioParamConnections = require("./factories/add-audio-param-connections");

var _addAudioWorkletModule = require("./factories/add-audio-worklet-module");

var _addConnectionToAudioNode = require("./factories/add-connection-to-audio-node");

var _addPassiveInputConnectionToAudioNode = require("./factories/add-passive-input-connection-to-audio-node");

var _addSilentConnection = require("./factories/add-silent-connection");

var _addUnrenderedAudioWorkletNode = require("./factories/add-unrendered-audio-worklet-node");

var _analyserNodeConstructor = require("./factories/analyser-node-constructor");

var _analyserNodeRendererFactory = require("./factories/analyser-node-renderer-factory");

var _audioBufferConstructor = require("./factories/audio-buffer-constructor");

var _audioBufferSourceNodeConstructor = require("./factories/audio-buffer-source-node-constructor");

var _audioBufferSourceNodeRendererFactory = require("./factories/audio-buffer-source-node-renderer-factory");

var _audioContextConstructor = require("./factories/audio-context-constructor");

var _audioDestinationNodeConstructor = require("./factories/audio-destination-node-constructor");

var _audioDestinationNodeRendererFactory = require("./factories/audio-destination-node-renderer-factory");

var _audioListenerFactory = require("./factories/audio-listener-factory");

var _audioNodeConstructor = require("./factories/audio-node-constructor");

var _audioParamFactory = require("./factories/audio-param-factory");

var _audioParamRenderer = require("./factories/audio-param-renderer");

var _audioWorkletNodeConstructor = require("./factories/audio-worklet-node-constructor");

var _audioWorkletNodeRendererFactory = require("./factories/audio-worklet-node-renderer-factory");

var _baseAudioContextConstructor = require("./factories/base-audio-context-constructor");

var _biquadFilterNodeConstructor = require("./factories/biquad-filter-node-constructor");

var _biquadFilterNodeRendererFactory = require("./factories/biquad-filter-node-renderer-factory");

var _cacheTestResult = require("./factories/cache-test-result");

var _channelMergerNodeConstructor = require("./factories/channel-merger-node-constructor");

var _channelMergerNodeRendererFactory = require("./factories/channel-merger-node-renderer-factory");

var _channelSplitterNodeConstructor = require("./factories/channel-splitter-node-constructor");

var _channelSplitterNodeRendererFactory = require("./factories/channel-splitter-node-renderer-factory");

var _connectAudioParam = require("./factories/connect-audio-param");

var _connectMultipleOutputs = require("./factories/connect-multiple-outputs");

var _connectedNativeAudioBufferSourceNodeFactory = require("./factories/connected-native-audio-buffer-source-node-factory");

var _constantSourceNodeConstructor = require("./factories/constant-source-node-constructor");

var _constantSourceNodeRendererFactory = require("./factories/constant-source-node-renderer-factory");

var _convertNumberToUnsignedLong = require("./factories/convert-number-to-unsigned-long");

var _convolverNodeConstructor = require("./factories/convolver-node-constructor");

var _convolverNodeRendererFactory = require("./factories/convolver-node-renderer-factory");

var _createNativeOfflineAudioContext = require("./factories/create-native-offline-audio-context");

var _dataCloneError = require("./factories/data-clone-error");

var _decodeAudioData = require("./factories/decode-audio-data");

var _decrementCycleCounter = require("./factories/decrement-cycle-counter");

var _delayNodeConstructor = require("./factories/delay-node-constructor");

var _delayNodeRendererFactory = require("./factories/delay-node-renderer-factory");

var _deleteActiveInputConnectionToAudioNode = require("./factories/delete-active-input-connection-to-audio-node");

var _deleteUnrenderedAudioWorkletNode = require("./factories/delete-unrendered-audio-worklet-node");

var _detectCycles = require("./factories/detect-cycles");

var _disconnectMultipleOutputs = require("./factories/disconnect-multiple-outputs");

var _dynamicsCompressorNodeConstructor = require("./factories/dynamics-compressor-node-constructor");

var _dynamicsCompressorNodeRendererFactory = require("./factories/dynamics-compressor-node-renderer-factory");

var _encodingError = require("./factories/encoding-error");

var _evaluateSource = require("./factories/evaluate-source");

var _eventTargetConstructor = require("./factories/event-target-constructor");

var _exposeCurrentFrameAndCurrentTime = require("./factories/expose-current-frame-and-current-time");

var _fetchSource = require("./factories/fetch-source");

var _gainNodeConstructor = require("./factories/gain-node-constructor");

var _gainNodeRendererFactory = require("./factories/gain-node-renderer-factory");

var _getActiveAudioWorkletNodeInputs = require("./factories/get-active-audio-worklet-node-inputs");

var _getAudioNodeRenderer = require("./factories/get-audio-node-renderer");

var _getAudioNodeTailTime = require("./factories/get-audio-node-tail-time");

var _getAudioParamRenderer = require("./factories/get-audio-param-renderer");

var _getBackupOfflineAudioContext = require("./factories/get-backup-offline-audio-context");

var _getNativeContext = require("./factories/get-native-context");

var _getOrCreateBackupOfflineAudioContext = require("./factories/get-or-create-backup-offline-audio-context");

var _getUnrenderedAudioWorkletNodes = require("./factories/get-unrendered-audio-worklet-nodes");

var _iirFilterNodeConstructor = require("./factories/iir-filter-node-constructor");

var _iirFilterNodeRendererFactory = require("./factories/iir-filter-node-renderer-factory");

var _incrementCycleCounterFactory = require("./factories/increment-cycle-counter-factory");

var _indexSizeError = require("./factories/index-size-error");

var _invalidAccessError = require("./factories/invalid-access-error");

var _invalidStateError = require("./factories/invalid-state-error");

var _isAnyAudioContext = require("./factories/is-any-audio-context");

var _isAnyAudioNode = require("./factories/is-any-audio-node");

var _isAnyAudioParam = require("./factories/is-any-audio-param");

var _isAnyOfflineAudioContext = require("./factories/is-any-offline-audio-context");

var _isNativeAudioContext = require("./factories/is-native-audio-context");

var _isNativeAudioNode = require("./factories/is-native-audio-node");

var _isNativeAudioParam = require("./factories/is-native-audio-param");

var _isNativeContext = require("./factories/is-native-context");

var _isNativeOfflineAudioContext = require("./factories/is-native-offline-audio-context");

var _isSecureContext = require("./factories/is-secure-context");

var _isSupportedPromise = require("./factories/is-supported-promise");

var _mediaElementAudioSourceNodeConstructor = require("./factories/media-element-audio-source-node-constructor");

var _mediaStreamAudioDestinationNodeConstructor = require("./factories/media-stream-audio-destination-node-constructor");

var _mediaStreamAudioSourceNodeConstructor = require("./factories/media-stream-audio-source-node-constructor");

var _mediaStreamTrackAudioSourceNodeConstructor = require("./factories/media-stream-track-audio-source-node-constructor");

var _minimalAudioContextConstructor = require("./factories/minimal-audio-context-constructor");

var _minimalBaseAudioContextConstructor = require("./factories/minimal-base-audio-context-constructor");

var _minimalOfflineAudioContextConstructor = require("./factories/minimal-offline-audio-context-constructor");

var _monitorConnections = require("./factories/monitor-connections");

var _nativeAnalyserNodeFactory = require("./factories/native-analyser-node-factory");

var _nativeAudioBufferConstructor = require("./factories/native-audio-buffer-constructor");

var _nativeAudioBufferSourceNodeFactory = require("./factories/native-audio-buffer-source-node-factory");

var _nativeAudioContextConstructor = require("./factories/native-audio-context-constructor");

var _nativeAudioDestinationNode = require("./factories/native-audio-destination-node");

var _nativeAudioWorkletNodeConstructor = require("./factories/native-audio-worklet-node-constructor");

var _nativeAudioWorkletNodeFactory = require("./factories/native-audio-worklet-node-factory");

var _nativeAudioWorkletNodeFakerFactory = require("./factories/native-audio-worklet-node-faker-factory");

var _nativeBiquadFilterNode = require("./factories/native-biquad-filter-node");

var _nativeChannelMergerNodeFactory = require("./factories/native-channel-merger-node-factory");

var _nativeChannelSplitterNode = require("./factories/native-channel-splitter-node");

var _nativeConstantSourceNodeFactory = require("./factories/native-constant-source-node-factory");

var _nativeConstantSourceNodeFakerFactory = require("./factories/native-constant-source-node-faker-factory");

var _nativeConvolverNodeFactory = require("./factories/native-convolver-node-factory");

var _nativeDelayNode = require("./factories/native-delay-node");

var _nativeDynamicsCompressorNodeFactory = require("./factories/native-dynamics-compressor-node-factory");

var _nativeGainNode = require("./factories/native-gain-node");

var _nativeIirFilterNodeFactory = require("./factories/native-iir-filter-node-factory");

var _nativeIirFilterNodeFakerFactory = require("./factories/native-iir-filter-node-faker-factory");

var _nativeMediaElementAudioSourceNode = require("./factories/native-media-element-audio-source-node");

var _nativeMediaStreamAudioDestinationNode = require("./factories/native-media-stream-audio-destination-node");

var _nativeMediaStreamAudioSourceNode = require("./factories/native-media-stream-audio-source-node");

var _nativeMediaStreamTrackAudioSourceNodeFactory = require("./factories/native-media-stream-track-audio-source-node-factory");

var _nativeOfflineAudioContextConstructor = require("./factories/native-offline-audio-context-constructor");

var _nativeOscillatorNodeFactory = require("./factories/native-oscillator-node-factory");

var _nativePannerNodeFactory = require("./factories/native-panner-node-factory");

var _nativePannerNodeFakerFactory = require("./factories/native-panner-node-faker-factory");

var _nativePeriodicWaveFactory = require("./factories/native-periodic-wave-factory");

var _nativeScriptProcessorNode = require("./factories/native-script-processor-node");

var _nativeStereoPannerNodeFactory = require("./factories/native-stereo-panner-node-factory");

var _nativeStereoPannerNodeFakerFactory = require("./factories/native-stereo-panner-node-faker-factory");

var _nativeWaveShaperNodeFactory = require("./factories/native-wave-shaper-node-factory");

var _nativeWaveShaperNodeFakerFactory = require("./factories/native-wave-shaper-node-faker-factory");

var _notSupportedError = require("./factories/not-supported-error");

var _offlineAudioContextConstructor = require("./factories/offline-audio-context-constructor");

var _oscillatorNodeConstructor = require("./factories/oscillator-node-constructor");

var _oscillatorNodeRendererFactory = require("./factories/oscillator-node-renderer-factory");

var _pannerNodeConstructor = require("./factories/panner-node-constructor");

var _pannerNodeRendererFactory = require("./factories/panner-node-renderer-factory");

var _periodicWaveConstructor = require("./factories/periodic-wave-constructor");

var _renderAutomation = require("./factories/render-automation");

var _renderInputsOfAudioNode = require("./factories/render-inputs-of-audio-node");

var _renderInputsOfAudioParam = require("./factories/render-inputs-of-audio-param");

var _renderNativeOfflineAudioContext = require("./factories/render-native-offline-audio-context");

var _setActiveAudioWorkletNodeInputs = require("./factories/set-active-audio-worklet-node-inputs");

var _setAudioNodeTailTime = require("./factories/set-audio-node-tail-time");

var _startRendering = require("./factories/start-rendering");

var _stereoPannerNodeConstructor = require("./factories/stereo-panner-node-constructor");

var _stereoPannerNodeRendererFactory = require("./factories/stereo-panner-node-renderer-factory");

var _testAudioBufferConstructorSupport = require("./factories/test-audio-buffer-constructor-support");

var _testAudioBufferCopyChannelMethodsSubarraySupport = require("./factories/test-audio-buffer-copy-channel-methods-subarray-support");

var _testAudioContextCloseMethodSupport = require("./factories/test-audio-context-close-method-support");

var _testAudioContextDecodeAudioDataMethodTypeErrorSupport = require("./factories/test-audio-context-decode-audio-data-method-type-error-support");

var _testAudioContextOptionsSupport = require("./factories/test-audio-context-options-support");

var _testAudioNodeConnectMethodSupport = require("./factories/test-audio-node-connect-method-support");

var _testAudioWorkletProcessorNoOutputsSupport = require("./factories/test-audio-worklet-processor-no-outputs-support");

var _testAudioWorkletProcessorPostMessageSupport = require("./factories/test-audio-worklet-processor-post-message-support");

var _testChannelMergerNodeChannelCountSupport = require("./factories/test-channel-merger-node-channel-count-support");

var _testConstantSourceNodeAccurateSchedulingSupport = require("./factories/test-constant-source-node-accurate-scheduling-support");

var _testConvolverNodeBufferReassignabilitySupport = require("./factories/test-convolver-node-buffer-reassignability-support");

var _testConvolverNodeChannelCountSupport = require("./factories/test-convolver-node-channel-count-support");

var _testIsSecureContextSupport = require("./factories/test-is-secure-context-support");

var _testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport = require("./factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support");

var _testOfflineAudioContextCurrentTimeSupport = require("./factories/test-offline-audio-context-current-time-support");

var _testStereoPannerNodeDefaultValueSupport = require("./factories/test-stereo-panner-node-default-value-support");

var _unknownError = require("./factories/unknown-error");

var _waveShaperNodeConstructor = require("./factories/wave-shaper-node-constructor");

var _waveShaperNodeRendererFactory = require("./factories/wave-shaper-node-renderer-factory");

var _window = require("./factories/window");

var _wrapAudioBufferCopyChannelMethods = require("./factories/wrap-audio-buffer-copy-channel-methods");

var _wrapAudioBufferCopyChannelMethodsOutOfBounds = require("./factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds");

var _wrapAudioBufferSourceNodeStopMethodNullifiedBuffer = require("./factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer");

var _wrapChannelMergerNode = require("./factories/wrap-channel-merger-node");

var _globals = require("./globals");

var _connectNativeAudioNodeToNativeAudioNode = require("./helpers/connect-native-audio-node-to-native-audio-node");

var _disconnectNativeAudioNodeFromNativeAudioNode = require("./helpers/disconnect-native-audio-node-from-native-audio-node");

var _getAudioNodeConnections = require("./helpers/get-audio-node-connections");

var _getAudioParamConnections = require("./helpers/get-audio-param-connections");

var _getEventListenersOfAudioNode = require("./helpers/get-event-listeners-of-audio-node");

var _getFirstSample = require("./helpers/get-first-sample");

var _getNativeAudioNode = require("./helpers/get-native-audio-node");

var _getNativeAudioParam = require("./helpers/get-native-audio-param");

var _getValueForKey = require("./helpers/get-value-for-key");

var _insertElementInSet = require("./helpers/insert-element-in-set");

var _isActiveAudioNode = require("./helpers/is-active-audio-node");

var _isDcCurve = require("./helpers/is-dc-curve");

var _isPartOfACycle = require("./helpers/is-part-of-a-cycle");

var _isPassiveAudioNode = require("./helpers/is-passive-audio-node");

var _overwriteAccessors = require("./helpers/overwrite-accessors");

var _pickElementFromSet = require("./helpers/pick-element-from-set");

var _sanitizeAudioWorkletNodeOptions = require("./helpers/sanitize-audio-worklet-node-options");

var _sanitizeChannelSplitterOptions = require("./helpers/sanitize-channel-splitter-options");

var _sanitizePeriodicWaveOptions = require("./helpers/sanitize-periodic-wave-options");

var _setValueAtTimeUntilPossible = require("./helpers/set-value-at-time-until-possible");

var _testAudioBufferCopyChannelMethodsOutOfBoundsSupport = require("./helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support");

var _testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = require("./helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support");

var _testAudioBufferSourceNodeStartMethodOffsetClampingSupport = require("./helpers/test-audio-buffer-source-node-start-method-offset-clamping-support");

var _testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = require("./helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support");

var _testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = require("./helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support");

var _testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = require("./helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support");

var _testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = require("./helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support");

var _testAudioWorkletNodeOptionsClonability = require("./helpers/test-audio-worklet-node-options-clonability");

var _testDomExceptionConstructorSupport = require("./helpers/test-dom-exception-constructor-support");

var _testPromiseSupport = require("./helpers/test-promise-support");

var _testTransferablesSupport = require("./helpers/test-transferables-support");

var _wrapAudioBufferSourceNodeStartMethodOffsetClamping = require("./helpers/wrap-audio-buffer-source-node-start-method-offset-clamping");

var _wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = require("./helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls");

var _wrapEventListener = require("./helpers/wrap-event-listener");

var _index = require("./interfaces/index");

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});

var _index2 = require("./types/index");

Object.keys(_index2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index2[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index2[key];
    }
  });
});

/*
 * @todo Explicitly referencing the barrel file seems to be necessary when enabling the
 * isolatedModules compiler option.
 */
const addActiveInputConnectionToAudioNode = (0, _addActiveInputConnectionToAudioNode.createAddActiveInputConnectionToAudioNode)(_insertElementInSet.insertElementInSet);
const addPassiveInputConnectionToAudioNode = (0, _addPassiveInputConnectionToAudioNode.createAddPassiveInputConnectionToAudioNode)(_insertElementInSet.insertElementInSet);
const deleteActiveInputConnectionToAudioNode = (0, _deleteActiveInputConnectionToAudioNode.createDeleteActiveInputConnectionToAudioNode)(_pickElementFromSet.pickElementFromSet);
const audioNodeTailTimeStore = new WeakMap();
const getAudioNodeTailTime = (0, _getAudioNodeTailTime.createGetAudioNodeTailTime)(audioNodeTailTimeStore);
const cacheTestResult = (0, _cacheTestResult.createCacheTestResult)(new Map(), new WeakMap());
const window = (0, _window.createWindow)();
const createNativeAnalyserNode = (0, _nativeAnalyserNodeFactory.createNativeAnalyserNodeFactory)(cacheTestResult, _indexSizeError.createIndexSizeError);
const getAudioNodeRenderer = (0, _getAudioNodeRenderer.createGetAudioNodeRenderer)(_getAudioNodeConnections.getAudioNodeConnections);
const renderInputsOfAudioNode = (0, _renderInputsOfAudioNode.createRenderInputsOfAudioNode)(_getAudioNodeConnections.getAudioNodeConnections, getAudioNodeRenderer, _isPartOfACycle.isPartOfACycle);
const createAnalyserNodeRenderer = (0, _analyserNodeRendererFactory.createAnalyserNodeRendererFactory)(createNativeAnalyserNode, _getNativeAudioNode.getNativeAudioNode, renderInputsOfAudioNode);
const getNativeContext = (0, _getNativeContext.createGetNativeContext)(_globals.CONTEXT_STORE);
const nativeOfflineAudioContextConstructor = (0, _nativeOfflineAudioContextConstructor.createNativeOfflineAudioContextConstructor)(window);
const isNativeOfflineAudioContext = (0, _isNativeOfflineAudioContext.createIsNativeOfflineAudioContext)(nativeOfflineAudioContextConstructor);
const audioParamAudioNodeStore = new WeakMap();
const eventTargetConstructor = (0, _eventTargetConstructor.createEventTargetConstructor)(_wrapEventListener.wrapEventListener);
const nativeAudioContextConstructor = (0, _nativeAudioContextConstructor.createNativeAudioContextConstructor)(window);
const isNativeAudioContext = (0, _isNativeAudioContext.createIsNativeAudioContext)(nativeAudioContextConstructor);
const isNativeAudioNode = (0, _isNativeAudioNode.createIsNativeAudioNode)(window);
const isNativeAudioParam = (0, _isNativeAudioParam.createIsNativeAudioParam)(window);
const nativeAudioWorkletNodeConstructor = (0, _nativeAudioWorkletNodeConstructor.createNativeAudioWorkletNodeConstructor)(window);
const audioNodeConstructor = (0, _audioNodeConstructor.createAudioNodeConstructor)((0, _addAudioNodeConnections.createAddAudioNodeConnections)(_globals.AUDIO_NODE_CONNECTIONS_STORE), (0, _addConnectionToAudioNode.createAddConnectionToAudioNode)(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, _connectNativeAudioNodeToNativeAudioNode.connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, _disconnectNativeAudioNodeFromNativeAudioNode.disconnectNativeAudioNodeFromNativeAudioNode, _getAudioNodeConnections.getAudioNodeConnections, getAudioNodeTailTime, _getEventListenersOfAudioNode.getEventListenersOfAudioNode, _getNativeAudioNode.getNativeAudioNode, _insertElementInSet.insertElementInSet, _isActiveAudioNode.isActiveAudioNode, _isPartOfACycle.isPartOfACycle, _isPassiveAudioNode.isPassiveAudioNode), cacheTestResult, (0, _incrementCycleCounterFactory.createIncrementCycleCounterFactory)(_globals.CYCLE_COUNTERS, _disconnectNativeAudioNodeFromNativeAudioNode.disconnectNativeAudioNodeFromNativeAudioNode, _getAudioNodeConnections.getAudioNodeConnections, _getNativeAudioNode.getNativeAudioNode, _getNativeAudioParam.getNativeAudioParam, _isActiveAudioNode.isActiveAudioNode), _indexSizeError.createIndexSizeError, _invalidAccessError.createInvalidAccessError, _notSupportedError.createNotSupportedError, (0, _decrementCycleCounter.createDecrementCycleCounter)(_connectNativeAudioNodeToNativeAudioNode.connectNativeAudioNodeToNativeAudioNode, _globals.CYCLE_COUNTERS, _getAudioNodeConnections.getAudioNodeConnections, _getNativeAudioNode.getNativeAudioNode, _getNativeAudioParam.getNativeAudioParam, getNativeContext, _isActiveAudioNode.isActiveAudioNode, isNativeOfflineAudioContext), (0, _detectCycles.createDetectCycles)(audioParamAudioNodeStore, _getAudioNodeConnections.getAudioNodeConnections, _getValueForKey.getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);
const analyserNodeConstructor = (0, _analyserNodeConstructor.createAnalyserNodeConstructor)(audioNodeConstructor, createAnalyserNodeRenderer, _indexSizeError.createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);
exports.AnalyserNode = analyserNodeConstructor;
const audioBufferStore = new WeakSet();
const nativeAudioBufferConstructor = (0, _nativeAudioBufferConstructor.createNativeAudioBufferConstructor)(window);
const convertNumberToUnsignedLong = (0, _convertNumberToUnsignedLong.createConvertNumberToUnsignedLong)(new Uint32Array(1));
const wrapAudioBufferCopyChannelMethods = (0, _wrapAudioBufferCopyChannelMethods.createWrapAudioBufferCopyChannelMethods)(convertNumberToUnsignedLong, _indexSizeError.createIndexSizeError);
const wrapAudioBufferCopyChannelMethodsOutOfBounds = (0, _wrapAudioBufferCopyChannelMethodsOutOfBounds.createWrapAudioBufferCopyChannelMethodsOutOfBounds)(convertNumberToUnsignedLong);
const audioBufferConstructor = (0, _audioBufferConstructor.createAudioBufferConstructor)(audioBufferStore, cacheTestResult, _notSupportedError.createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, (0, _testAudioBufferConstructorSupport.createTestAudioBufferConstructorSupport)(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
exports.AudioBuffer = audioBufferConstructor;
const addSilentConnection = (0, _addSilentConnection.createAddSilentConnection)(_nativeGainNode.createNativeGainNode);
const renderInputsOfAudioParam = (0, _renderInputsOfAudioParam.createRenderInputsOfAudioParam)(getAudioNodeRenderer, _getAudioParamConnections.getAudioParamConnections, _isPartOfACycle.isPartOfACycle);
const connectAudioParam = (0, _connectAudioParam.createConnectAudioParam)(renderInputsOfAudioParam);
const createNativeAudioBufferSourceNode = (0, _nativeAudioBufferSourceNodeFactory.createNativeAudioBufferSourceNodeFactory)(addSilentConnection, cacheTestResult, _testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport.testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, _testAudioBufferSourceNodeStartMethodOffsetClampingSupport.testAudioBufferSourceNodeStartMethodOffsetClampingSupport, _testAudioBufferSourceNodeStopMethodNullifiedBufferSupport.testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, _testAudioScheduledSourceNodeStartMethodNegativeParametersSupport.testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, _testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport.testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, _testAudioScheduledSourceNodeStopMethodNegativeParametersSupport.testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, _wrapAudioBufferSourceNodeStartMethodOffsetClamping.wrapAudioBufferSourceNodeStartMethodOffsetClamping, (0, _wrapAudioBufferSourceNodeStopMethodNullifiedBuffer.createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer)(_overwriteAccessors.overwriteAccessors), _wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls.wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
const renderAutomation = (0, _renderAutomation.createRenderAutomation)((0, _getAudioParamRenderer.createGetAudioParamRenderer)(_getAudioParamConnections.getAudioParamConnections), renderInputsOfAudioParam);
const createAudioBufferSourceNodeRenderer = (0, _audioBufferSourceNodeRendererFactory.createAudioBufferSourceNodeRendererFactory)(connectAudioParam, createNativeAudioBufferSourceNode, _getNativeAudioNode.getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const createAudioParam = (0, _audioParamFactory.createAudioParamFactory)((0, _addAudioParamConnections.createAddAudioParamConnections)(_globals.AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, _globals.AUDIO_PARAM_STORE, _audioParamRenderer.createAudioParamRenderer, _automationEvents.createCancelAndHoldAutomationEvent, _automationEvents.createCancelScheduledValuesAutomationEvent, _automationEvents.createExponentialRampToValueAutomationEvent, _automationEvents.createLinearRampToValueAutomationEvent, _automationEvents.createSetTargetAutomationEvent, _automationEvents.createSetValueAutomationEvent, _automationEvents.createSetValueCurveAutomationEvent, nativeAudioContextConstructor, _setValueAtTimeUntilPossible.setValueAtTimeUntilPossible);
const audioBufferSourceNodeConstructor = (0, _audioBufferSourceNodeConstructor.createAudioBufferSourceNodeConstructor)(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, _invalidStateError.createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, _wrapEventListener.wrapEventListener);
exports.AudioBufferSourceNode = audioBufferSourceNodeConstructor;
const audioDestinationNodeConstructor = (0, _audioDestinationNodeConstructor.createAudioDestinationNodeConstructor)(audioNodeConstructor, _audioDestinationNodeRendererFactory.createAudioDestinationNodeRenderer, _indexSizeError.createIndexSizeError, _invalidStateError.createInvalidStateError, (0, _nativeAudioDestinationNode.createNativeAudioDestinationNodeFactory)(_nativeGainNode.createNativeGainNode, _overwriteAccessors.overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);
const createBiquadFilterNodeRenderer = (0, _biquadFilterNodeRendererFactory.createBiquadFilterNodeRendererFactory)(connectAudioParam, _nativeBiquadFilterNode.createNativeBiquadFilterNode, _getNativeAudioNode.getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const setAudioNodeTailTime = (0, _setAudioNodeTailTime.createSetAudioNodeTailTime)(audioNodeTailTimeStore);
const biquadFilterNodeConstructor = (0, _biquadFilterNodeConstructor.createBiquadFilterNodeConstructor)(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, _invalidAccessError.createInvalidAccessError, _nativeBiquadFilterNode.createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
exports.BiquadFilterNode = biquadFilterNodeConstructor;
const monitorConnections = (0, _monitorConnections.createMonitorConnections)(_insertElementInSet.insertElementInSet, isNativeAudioNode);
const wrapChannelMergerNode = (0, _wrapChannelMergerNode.createWrapChannelMergerNode)(_invalidStateError.createInvalidStateError, monitorConnections);
const createNativeChannelMergerNode = (0, _nativeChannelMergerNodeFactory.createNativeChannelMergerNodeFactory)(nativeAudioContextConstructor, wrapChannelMergerNode);
const createChannelMergerNodeRenderer = (0, _channelMergerNodeRendererFactory.createChannelMergerNodeRendererFactory)(createNativeChannelMergerNode, _getNativeAudioNode.getNativeAudioNode, renderInputsOfAudioNode);
const channelMergerNodeConstructor = (0, _channelMergerNodeConstructor.createChannelMergerNodeConstructor)(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);
exports.ChannelMergerNode = channelMergerNodeConstructor;
const createChannelSplitterNodeRenderer = (0, _channelSplitterNodeRendererFactory.createChannelSplitterNodeRendererFactory)(_nativeChannelSplitterNode.createNativeChannelSplitterNode, _getNativeAudioNode.getNativeAudioNode, renderInputsOfAudioNode);
const channelSplitterNodeConstructor = (0, _channelSplitterNodeConstructor.createChannelSplitterNodeConstructor)(audioNodeConstructor, createChannelSplitterNodeRenderer, _nativeChannelSplitterNode.createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, _sanitizeChannelSplitterOptions.sanitizeChannelSplitterOptions);
exports.ChannelSplitterNode = channelSplitterNodeConstructor;
const createNativeConstantSourceNodeFaker = (0, _nativeConstantSourceNodeFakerFactory.createNativeConstantSourceNodeFakerFactory)(addSilentConnection, createNativeAudioBufferSourceNode, _nativeGainNode.createNativeGainNode, monitorConnections);
const createNativeConstantSourceNode = (0, _nativeConstantSourceNodeFactory.createNativeConstantSourceNodeFactory)(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, _testAudioScheduledSourceNodeStartMethodNegativeParametersSupport.testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, _testAudioScheduledSourceNodeStopMethodNegativeParametersSupport.testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);
const createConstantSourceNodeRenderer = (0, _constantSourceNodeRendererFactory.createConstantSourceNodeRendererFactory)(connectAudioParam, createNativeConstantSourceNode, _getNativeAudioNode.getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const constantSourceNodeConstructor = (0, _constantSourceNodeConstructor.createConstantSourceNodeConstructor)(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, _wrapEventListener.wrapEventListener);
exports.ConstantSourceNode = constantSourceNodeConstructor;
const createNativeConvolverNode = (0, _nativeConvolverNodeFactory.createNativeConvolverNodeFactory)(_notSupportedError.createNotSupportedError, _overwriteAccessors.overwriteAccessors);
const createConvolverNodeRenderer = (0, _convolverNodeRendererFactory.createConvolverNodeRendererFactory)(createNativeConvolverNode, _getNativeAudioNode.getNativeAudioNode, renderInputsOfAudioNode);
const convolverNodeConstructor = (0, _convolverNodeConstructor.createConvolverNodeConstructor)(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
exports.ConvolverNode = convolverNodeConstructor;
const createDelayNodeRenderer = (0, _delayNodeRendererFactory.createDelayNodeRendererFactory)(connectAudioParam, _nativeDelayNode.createNativeDelayNode, _getNativeAudioNode.getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const delayNodeConstructor = (0, _delayNodeConstructor.createDelayNodeConstructor)(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, _nativeDelayNode.createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
exports.DelayNode = delayNodeConstructor;
const createNativeDynamicsCompressorNode = (0, _nativeDynamicsCompressorNodeFactory.createNativeDynamicsCompressorNodeFactory)(_notSupportedError.createNotSupportedError);
const createDynamicsCompressorNodeRenderer = (0, _dynamicsCompressorNodeRendererFactory.createDynamicsCompressorNodeRendererFactory)(connectAudioParam, createNativeDynamicsCompressorNode, _getNativeAudioNode.getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const dynamicsCompressorNodeConstructor = (0, _dynamicsCompressorNodeConstructor.createDynamicsCompressorNodeConstructor)(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, _notSupportedError.createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
exports.DynamicsCompressorNode = dynamicsCompressorNodeConstructor;
const createGainNodeRenderer = (0, _gainNodeRendererFactory.createGainNodeRendererFactory)(connectAudioParam, _nativeGainNode.createNativeGainNode, _getNativeAudioNode.getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const gainNodeConstructor = (0, _gainNodeConstructor.createGainNodeConstructor)(audioNodeConstructor, createAudioParam, createGainNodeRenderer, _nativeGainNode.createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);
exports.GainNode = gainNodeConstructor;
const createNativeIIRFilterNodeFaker = (0, _nativeIirFilterNodeFakerFactory.createNativeIIRFilterNodeFakerFactory)(_invalidAccessError.createInvalidAccessError, _invalidStateError.createInvalidStateError, _nativeScriptProcessorNode.createNativeScriptProcessorNode, _notSupportedError.createNotSupportedError);
const renderNativeOfflineAudioContext = (0, _renderNativeOfflineAudioContext.createRenderNativeOfflineAudioContext)(cacheTestResult, _nativeGainNode.createNativeGainNode, _nativeScriptProcessorNode.createNativeScriptProcessorNode, (0, _testOfflineAudioContextCurrentTimeSupport.createTestOfflineAudioContextCurrentTimeSupport)(_nativeGainNode.createNativeGainNode, nativeOfflineAudioContextConstructor));
const createIIRFilterNodeRenderer = (0, _iirFilterNodeRendererFactory.createIIRFilterNodeRendererFactory)(createNativeAudioBufferSourceNode, _getNativeAudioNode.getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
const createNativeIIRFilterNode = (0, _nativeIirFilterNodeFactory.createNativeIIRFilterNodeFactory)(createNativeIIRFilterNodeFaker);
const iIRFilterNodeConstructor = (0, _iirFilterNodeConstructor.createIIRFilterNodeConstructor)(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
exports.IIRFilterNode = iIRFilterNodeConstructor;
const createAudioListener = (0, _audioListenerFactory.createAudioListenerFactory)(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, _nativeScriptProcessorNode.createNativeScriptProcessorNode, _notSupportedError.createNotSupportedError, _getFirstSample.getFirstSample, isNativeOfflineAudioContext, _overwriteAccessors.overwriteAccessors);
const unrenderedAudioWorkletNodeStore = new WeakMap();
const minimalBaseAudioContextConstructor = (0, _minimalBaseAudioContextConstructor.createMinimalBaseAudioContextConstructor)(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, _wrapEventListener.wrapEventListener);
const createNativeOscillatorNode = (0, _nativeOscillatorNodeFactory.createNativeOscillatorNodeFactory)(addSilentConnection, cacheTestResult, _testAudioScheduledSourceNodeStartMethodNegativeParametersSupport.testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, _testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport.testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, _testAudioScheduledSourceNodeStopMethodNegativeParametersSupport.testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, _wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls.wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
const createOscillatorNodeRenderer = (0, _oscillatorNodeRendererFactory.createOscillatorNodeRendererFactory)(connectAudioParam, createNativeOscillatorNode, _getNativeAudioNode.getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const oscillatorNodeConstructor = (0, _oscillatorNodeConstructor.createOscillatorNodeConstructor)(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, _wrapEventListener.wrapEventListener);
exports.OscillatorNode = oscillatorNodeConstructor;
const createConnectedNativeAudioBufferSourceNode = (0, _connectedNativeAudioBufferSourceNodeFactory.createConnectedNativeAudioBufferSourceNodeFactory)(createNativeAudioBufferSourceNode);
const createNativeWaveShaperNodeFaker = (0, _nativeWaveShaperNodeFakerFactory.createNativeWaveShaperNodeFakerFactory)(createConnectedNativeAudioBufferSourceNode, _invalidStateError.createInvalidStateError, _nativeGainNode.createNativeGainNode, _isDcCurve.isDCCurve, monitorConnections);
const createNativeWaveShaperNode = (0, _nativeWaveShaperNodeFactory.createNativeWaveShaperNodeFactory)(createConnectedNativeAudioBufferSourceNode, _invalidStateError.createInvalidStateError, createNativeWaveShaperNodeFaker, _isDcCurve.isDCCurve, monitorConnections, nativeAudioContextConstructor, _overwriteAccessors.overwriteAccessors);
const createNativePannerNodeFaker = (0, _nativePannerNodeFakerFactory.createNativePannerNodeFakerFactory)(_connectNativeAudioNodeToNativeAudioNode.connectNativeAudioNodeToNativeAudioNode, _invalidStateError.createInvalidStateError, createNativeChannelMergerNode, _nativeGainNode.createNativeGainNode, _nativeScriptProcessorNode.createNativeScriptProcessorNode, createNativeWaveShaperNode, _notSupportedError.createNotSupportedError, _disconnectNativeAudioNodeFromNativeAudioNode.disconnectNativeAudioNodeFromNativeAudioNode, _getFirstSample.getFirstSample, monitorConnections);
const createNativePannerNode = (0, _nativePannerNodeFactory.createNativePannerNodeFactory)(createNativePannerNodeFaker);
const createPannerNodeRenderer = (0, _pannerNodeRendererFactory.createPannerNodeRendererFactory)(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, _nativeGainNode.createNativeGainNode, createNativePannerNode, _getNativeAudioNode.getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
const pannerNodeConstructor = (0, _pannerNodeConstructor.createPannerNodeConstructor)(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
exports.PannerNode = pannerNodeConstructor;
const createNativePeriodicWave = (0, _nativePeriodicWaveFactory.createNativePeriodicWaveFactory)(_indexSizeError.createIndexSizeError);
const periodicWaveConstructor = (0, _periodicWaveConstructor.createPeriodicWaveConstructor)(createNativePeriodicWave, getNativeContext, new WeakSet(), _sanitizePeriodicWaveOptions.sanitizePeriodicWaveOptions);
exports.PeriodicWave = periodicWaveConstructor;
const nativeStereoPannerNodeFakerFactory = (0, _nativeStereoPannerNodeFakerFactory.createNativeStereoPannerNodeFakerFactory)(createNativeChannelMergerNode, _nativeChannelSplitterNode.createNativeChannelSplitterNode, _nativeGainNode.createNativeGainNode, createNativeWaveShaperNode, _notSupportedError.createNotSupportedError, monitorConnections);
const createNativeStereoPannerNode = (0, _nativeStereoPannerNodeFactory.createNativeStereoPannerNodeFactory)(nativeStereoPannerNodeFakerFactory, _notSupportedError.createNotSupportedError);
const createStereoPannerNodeRenderer = (0, _stereoPannerNodeRendererFactory.createStereoPannerNodeRendererFactory)(connectAudioParam, createNativeStereoPannerNode, _getNativeAudioNode.getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
const stereoPannerNodeConstructor = (0, _stereoPannerNodeConstructor.createStereoPannerNodeConstructor)(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);
exports.StereoPannerNode = stereoPannerNodeConstructor;
const createWaveShaperNodeRenderer = (0, _waveShaperNodeRendererFactory.createWaveShaperNodeRendererFactory)(createNativeWaveShaperNode, _getNativeAudioNode.getNativeAudioNode, renderInputsOfAudioNode);
const waveShaperNodeConstructor = (0, _waveShaperNodeConstructor.createWaveShaperNodeConstructor)(audioNodeConstructor, _invalidStateError.createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
exports.WaveShaperNode = waveShaperNodeConstructor;
const isSecureContext = (0, _isSecureContext.createIsSecureContext)(window);
const exposeCurrentFrameAndCurrentTime = (0, _exposeCurrentFrameAndCurrentTime.createExposeCurrentFrameAndCurrentTime)(window);
const backupOfflineAudioContextStore = new WeakMap();
const getOrCreateBackupOfflineAudioContext = (0, _getOrCreateBackupOfflineAudioContext.createGetOrCreateBackupOfflineAudioContext)(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor); // The addAudioWorkletModule() function is only available in a SecureContext.

const addAudioWorkletModule = isSecureContext ? (0, _addAudioWorkletModule.createAddAudioWorkletModule)(cacheTestResult, _notSupportedError.createNotSupportedError, (0, _evaluateSource.createEvaluateSource)(window), exposeCurrentFrameAndCurrentTime, (0, _fetchSource.createFetchSource)(_abortError.createAbortError), getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, new WeakMap(), new WeakMap(), (0, _testAudioWorkletProcessorPostMessageSupport.createTestAudioWorkletProcessorPostMessageSupport)(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), // @todo window is guaranteed to be defined because isSecureContext checks that as well.
window) : undefined;
exports.addAudioWorkletModule = addAudioWorkletModule;
const isNativeContext = (0, _isNativeContext.createIsNativeContext)(isNativeAudioContext, isNativeOfflineAudioContext);
const decodeAudioData = (0, _decodeAudioData.createDecodeAudioData)(audioBufferStore, cacheTestResult, _dataCloneError.createDataCloneError, _encodingError.createEncodingError, new WeakSet(), getNativeContext, isNativeContext, _testAudioBufferCopyChannelMethodsOutOfBoundsSupport.testAudioBufferCopyChannelMethodsOutOfBoundsSupport, _testPromiseSupport.testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
exports.decodeAudioData = decodeAudioData;
const baseAudioContextConstructor = (0, _baseAudioContextConstructor.createBaseAudioContextConstructor)(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);
const mediaElementAudioSourceNodeConstructor = (0, _mediaElementAudioSourceNodeConstructor.createMediaElementAudioSourceNodeConstructor)(audioNodeConstructor, _nativeMediaElementAudioSourceNode.createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
exports.MediaElementAudioSourceNode = mediaElementAudioSourceNodeConstructor;
const mediaStreamAudioDestinationNodeConstructor = (0, _mediaStreamAudioDestinationNodeConstructor.createMediaStreamAudioDestinationNodeConstructor)(audioNodeConstructor, _nativeMediaStreamAudioDestinationNode.createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);
exports.MediaStreamAudioDestinationNode = mediaStreamAudioDestinationNodeConstructor;
const mediaStreamAudioSourceNodeConstructor = (0, _mediaStreamAudioSourceNodeConstructor.createMediaStreamAudioSourceNodeConstructor)(audioNodeConstructor, _nativeMediaStreamAudioSourceNode.createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
exports.MediaStreamAudioSourceNode = mediaStreamAudioSourceNodeConstructor;
const createNativeMediaStreamTrackAudioSourceNode = (0, _nativeMediaStreamTrackAudioSourceNodeFactory.createNativeMediaStreamTrackAudioSourceNodeFactory)(_invalidStateError.createInvalidStateError, isNativeOfflineAudioContext);
const mediaStreamTrackAudioSourceNodeConstructor = (0, _mediaStreamTrackAudioSourceNodeConstructor.createMediaStreamTrackAudioSourceNodeConstructor)(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);
exports.MediaStreamTrackAudioSourceNode = mediaStreamTrackAudioSourceNodeConstructor;
const audioContextConstructor = (0, _audioContextConstructor.createAudioContextConstructor)(baseAudioContextConstructor, _invalidStateError.createInvalidStateError, _notSupportedError.createNotSupportedError, _unknownError.createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);
exports.AudioContext = audioContextConstructor;
const getUnrenderedAudioWorkletNodes = (0, _getUnrenderedAudioWorkletNodes.createGetUnrenderedAudioWorkletNodes)(unrenderedAudioWorkletNodeStore);
const addUnrenderedAudioWorkletNode = (0, _addUnrenderedAudioWorkletNode.createAddUnrenderedAudioWorkletNode)(getUnrenderedAudioWorkletNodes);
const connectMultipleOutputs = (0, _connectMultipleOutputs.createConnectMultipleOutputs)(_indexSizeError.createIndexSizeError);
const deleteUnrenderedAudioWorkletNode = (0, _deleteUnrenderedAudioWorkletNode.createDeleteUnrenderedAudioWorkletNode)(getUnrenderedAudioWorkletNodes);
const disconnectMultipleOutputs = (0, _disconnectMultipleOutputs.createDisconnectMultipleOutputs)(_indexSizeError.createIndexSizeError);
const activeAudioWorkletNodeInputsStore = new WeakMap();
const getActiveAudioWorkletNodeInputs = (0, _getActiveAudioWorkletNodeInputs.createGetActiveAudioWorkletNodeInputs)(activeAudioWorkletNodeInputsStore, _getValueForKey.getValueForKey);
const createNativeAudioWorkletNodeFaker = (0, _nativeAudioWorkletNodeFakerFactory.createNativeAudioWorkletNodeFakerFactory)(connectMultipleOutputs, _indexSizeError.createIndexSizeError, _invalidStateError.createInvalidStateError, createNativeChannelMergerNode, _nativeChannelSplitterNode.createNativeChannelSplitterNode, createNativeConstantSourceNode, _nativeGainNode.createNativeGainNode, _nativeScriptProcessorNode.createNativeScriptProcessorNode, _notSupportedError.createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);
const createNativeAudioWorkletNode = (0, _nativeAudioWorkletNodeFactory.createNativeAudioWorkletNodeFactory)(_invalidStateError.createInvalidStateError, createNativeAudioWorkletNodeFaker, _nativeGainNode.createNativeGainNode, _notSupportedError.createNotSupportedError, monitorConnections);
const createAudioWorkletNodeRenderer = (0, _audioWorkletNodeRendererFactory.createAudioWorkletNodeRendererFactory)(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, _nativeChannelSplitterNode.createNativeChannelSplitterNode, createNativeConstantSourceNode, _nativeGainNode.createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, _getNativeAudioNode.getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
const getBackupOfflineAudioContext = (0, _getBackupOfflineAudioContext.createGetBackupOfflineAudioContext)(backupOfflineAudioContextStore);
const setActiveAudioWorkletNodeInputs = (0, _setActiveAudioWorkletNodeInputs.createSetActiveAudioWorkletNodeInputs)(activeAudioWorkletNodeInputsStore); // The AudioWorkletNode constructor is only available in a SecureContext.

const audioWorkletNodeConstructor = isSecureContext ? (0, _audioWorkletNodeConstructor.createAudioWorkletNodeConstructor)(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, _getAudioNodeConnections.getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, _sanitizeAudioWorkletNodeOptions.sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, _testAudioWorkletNodeOptionsClonability.testAudioWorkletNodeOptionsClonability, _wrapEventListener.wrapEventListener) : undefined;
exports.AudioWorkletNode = audioWorkletNodeConstructor;
const minimalAudioContextConstructor = (0, _minimalAudioContextConstructor.createMinimalAudioContextConstructor)(_invalidStateError.createInvalidStateError, _notSupportedError.createNotSupportedError, _unknownError.createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);
exports.MinimalAudioContext = minimalAudioContextConstructor;
const createNativeOfflineAudioContext = (0, _createNativeOfflineAudioContext.createCreateNativeOfflineAudioContext)(_notSupportedError.createNotSupportedError, nativeOfflineAudioContextConstructor);
const startRendering = (0, _startRendering.createStartRendering)(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, _testAudioBufferCopyChannelMethodsOutOfBoundsSupport.testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
const minimalOfflineAudioContextConstructor = (0, _minimalOfflineAudioContextConstructor.createMinimalOfflineAudioContextConstructor)(cacheTestResult, _invalidStateError.createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);
exports.MinimalOfflineAudioContext = minimalOfflineAudioContextConstructor;
const offlineAudioContextConstructor = (0, _offlineAudioContextConstructor.createOfflineAudioContextConstructor)(baseAudioContextConstructor, cacheTestResult, _invalidStateError.createInvalidStateError, createNativeOfflineAudioContext, startRendering);
exports.OfflineAudioContext = offlineAudioContextConstructor;
const isAnyAudioContext = (0, _isAnyAudioContext.createIsAnyAudioContext)(_globals.CONTEXT_STORE, isNativeAudioContext);
exports.isAnyAudioContext = isAnyAudioContext;
const isAnyAudioNode = (0, _isAnyAudioNode.createIsAnyAudioNode)(_globals.AUDIO_NODE_STORE, isNativeAudioNode);
exports.isAnyAudioNode = isAnyAudioNode;
const isAnyAudioParam = (0, _isAnyAudioParam.createIsAnyAudioParam)(_globals.AUDIO_PARAM_STORE, isNativeAudioParam);
exports.isAnyAudioParam = isAnyAudioParam;
const isAnyOfflineAudioContext = (0, _isAnyOfflineAudioContext.createIsAnyOfflineAudioContext)(_globals.CONTEXT_STORE, isNativeOfflineAudioContext);
exports.isAnyOfflineAudioContext = isAnyOfflineAudioContext;

const isSupported = () => (0, _isSupportedPromise.createIsSupportedPromise)(cacheTestResult, (0, _testAudioBufferCopyChannelMethodsSubarraySupport.createTestAudioBufferCopyChannelMethodsSubarraySupport)(nativeOfflineAudioContextConstructor), (0, _testAudioContextCloseMethodSupport.createTestAudioContextCloseMethodSupport)(nativeAudioContextConstructor), (0, _testAudioContextDecodeAudioDataMethodTypeErrorSupport.createTestAudioContextDecodeAudioDataMethodTypeErrorSupport)(nativeOfflineAudioContextConstructor), (0, _testAudioContextOptionsSupport.createTestAudioContextOptionsSupport)(nativeAudioContextConstructor), (0, _testAudioNodeConnectMethodSupport.createTestAudioNodeConnectMethodSupport)(nativeOfflineAudioContextConstructor), (0, _testAudioWorkletProcessorNoOutputsSupport.createTestAudioWorkletProcessorNoOutputsSupport)(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), (0, _testChannelMergerNodeChannelCountSupport.createTestChannelMergerNodeChannelCountSupport)(nativeOfflineAudioContextConstructor), (0, _testConstantSourceNodeAccurateSchedulingSupport.createTestConstantSourceNodeAccurateSchedulingSupport)(nativeOfflineAudioContextConstructor), (0, _testConvolverNodeBufferReassignabilitySupport.createTestConvolverNodeBufferReassignabilitySupport)(nativeOfflineAudioContextConstructor), (0, _testConvolverNodeChannelCountSupport.createTestConvolverNodeChannelCountSupport)(nativeOfflineAudioContextConstructor), _testDomExceptionConstructorSupport.testDomExceptionConstructorSupport, (0, _testIsSecureContextSupport.createTestIsSecureContextSupport)(window), (0, _testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport.createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport)(nativeAudioContextConstructor), (0, _testStereoPannerNodeDefaultValueSupport.createTestStereoPannerNodeDefaultValueSupport)(nativeOfflineAudioContextConstructor), _testTransferablesSupport.testTransferablesSupport);

exports.isSupported = isSupported;
},{"automation-events":"../node_modules/automation-events/build/es5/bundle.js","./factories/abort-error":"../node_modules/standardized-audio-context/build/es2019/factories/abort-error.js","./factories/add-active-input-connection-to-audio-node":"../node_modules/standardized-audio-context/build/es2019/factories/add-active-input-connection-to-audio-node.js","./factories/add-audio-node-connections":"../node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js","./factories/add-audio-param-connections":"../node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js","./factories/add-audio-worklet-module":"../node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js","./factories/add-connection-to-audio-node":"../node_modules/standardized-audio-context/build/es2019/factories/add-connection-to-audio-node.js","./factories/add-passive-input-connection-to-audio-node":"../node_modules/standardized-audio-context/build/es2019/factories/add-passive-input-connection-to-audio-node.js","./factories/add-silent-connection":"../node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js","./factories/add-unrendered-audio-worklet-node":"../node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js","./factories/analyser-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/analyser-node-constructor.js","./factories/analyser-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/analyser-node-renderer-factory.js","./factories/audio-buffer-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js","./factories/audio-buffer-source-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js","./factories/audio-buffer-source-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js","./factories/audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/audio-context-constructor.js","./factories/audio-destination-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js","./factories/audio-destination-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js","./factories/audio-listener-factory":"../node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js","./factories/audio-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js","./factories/audio-param-factory":"../node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js","./factories/audio-param-renderer":"../node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js","./factories/audio-worklet-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js","./factories/audio-worklet-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js","./factories/base-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/base-audio-context-constructor.js","./factories/biquad-filter-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-constructor.js","./factories/biquad-filter-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-renderer-factory.js","./factories/cache-test-result":"../node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js","./factories/channel-merger-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-constructor.js","./factories/channel-merger-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-renderer-factory.js","./factories/channel-splitter-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-constructor.js","./factories/channel-splitter-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-renderer-factory.js","./factories/connect-audio-param":"../node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js","./factories/connect-multiple-outputs":"../node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js","./factories/connected-native-audio-buffer-source-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js","./factories/constant-source-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-constructor.js","./factories/constant-source-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-renderer-factory.js","./factories/convert-number-to-unsigned-long":"../node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js","./factories/convolver-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/convolver-node-constructor.js","./factories/convolver-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/convolver-node-renderer-factory.js","./factories/create-native-offline-audio-context":"../node_modules/standardized-audio-context/build/es2019/factories/create-native-offline-audio-context.js","./factories/data-clone-error":"../node_modules/standardized-audio-context/build/es2019/factories/data-clone-error.js","./factories/decode-audio-data":"../node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js","./factories/decrement-cycle-counter":"../node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js","./factories/delay-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/delay-node-constructor.js","./factories/delay-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/delay-node-renderer-factory.js","./factories/delete-active-input-connection-to-audio-node":"../node_modules/standardized-audio-context/build/es2019/factories/delete-active-input-connection-to-audio-node.js","./factories/delete-unrendered-audio-worklet-node":"../node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js","./factories/detect-cycles":"../node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js","./factories/disconnect-multiple-outputs":"../node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js","./factories/dynamics-compressor-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-constructor.js","./factories/dynamics-compressor-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-renderer-factory.js","./factories/encoding-error":"../node_modules/standardized-audio-context/build/es2019/factories/encoding-error.js","./factories/evaluate-source":"../node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js","./factories/event-target-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js","./factories/expose-current-frame-and-current-time":"../node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js","./factories/fetch-source":"../node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js","./factories/gain-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/gain-node-constructor.js","./factories/gain-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/gain-node-renderer-factory.js","./factories/get-active-audio-worklet-node-inputs":"../node_modules/standardized-audio-context/build/es2019/factories/get-active-audio-worklet-node-inputs.js","./factories/get-audio-node-renderer":"../node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js","./factories/get-audio-node-tail-time":"../node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-tail-time.js","./factories/get-audio-param-renderer":"../node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js","./factories/get-backup-offline-audio-context":"../node_modules/standardized-audio-context/build/es2019/factories/get-backup-offline-audio-context.js","./factories/get-native-context":"../node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js","./factories/get-or-create-backup-offline-audio-context":"../node_modules/standardized-audio-context/build/es2019/factories/get-or-create-backup-offline-audio-context.js","./factories/get-unrendered-audio-worklet-nodes":"../node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js","./factories/iir-filter-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-constructor.js","./factories/iir-filter-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-renderer-factory.js","./factories/increment-cycle-counter-factory":"../node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js","./factories/index-size-error":"../node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js","./factories/invalid-access-error":"../node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js","./factories/invalid-state-error":"../node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js","./factories/is-any-audio-context":"../node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-context.js","./factories/is-any-audio-node":"../node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-node.js","./factories/is-any-audio-param":"../node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-param.js","./factories/is-any-offline-audio-context":"../node_modules/standardized-audio-context/build/es2019/factories/is-any-offline-audio-context.js","./factories/is-native-audio-context":"../node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js","./factories/is-native-audio-node":"../node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js","./factories/is-native-audio-param":"../node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js","./factories/is-native-context":"../node_modules/standardized-audio-context/build/es2019/factories/is-native-context.js","./factories/is-native-offline-audio-context":"../node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js","./factories/is-secure-context":"../node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js","./factories/is-supported-promise":"../node_modules/standardized-audio-context/build/es2019/factories/is-supported-promise.js","./factories/media-element-audio-source-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/media-element-audio-source-node-constructor.js","./factories/media-stream-audio-destination-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-destination-node-constructor.js","./factories/media-stream-audio-source-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js","./factories/media-stream-track-audio-source-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/media-stream-track-audio-source-node-constructor.js","./factories/minimal-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/minimal-audio-context-constructor.js","./factories/minimal-base-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js","./factories/minimal-offline-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/minimal-offline-audio-context-constructor.js","./factories/monitor-connections":"../node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js","./factories/native-analyser-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-analyser-node-factory.js","./factories/native-audio-buffer-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js","./factories/native-audio-buffer-source-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js","./factories/native-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js","./factories/native-audio-destination-node":"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js","./factories/native-audio-worklet-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js","./factories/native-audio-worklet-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js","./factories/native-audio-worklet-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js","./factories/native-biquad-filter-node":"../node_modules/standardized-audio-context/build/es2019/factories/native-biquad-filter-node.js","./factories/native-channel-merger-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js","./factories/native-channel-splitter-node":"../node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node.js","./factories/native-constant-source-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js","./factories/native-constant-source-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js","./factories/native-convolver-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-factory.js","./factories/native-delay-node":"../node_modules/standardized-audio-context/build/es2019/factories/native-delay-node.js","./factories/native-dynamics-compressor-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-dynamics-compressor-node-factory.js","./factories/native-gain-node":"../node_modules/standardized-audio-context/build/es2019/factories/native-gain-node.js","./factories/native-iir-filter-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-factory.js","./factories/native-iir-filter-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-faker-factory.js","./factories/native-media-element-audio-source-node":"../node_modules/standardized-audio-context/build/es2019/factories/native-media-element-audio-source-node.js","./factories/native-media-stream-audio-destination-node":"../node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-destination-node.js","./factories/native-media-stream-audio-source-node":"../node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node.js","./factories/native-media-stream-track-audio-source-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js","./factories/native-offline-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js","./factories/native-oscillator-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-oscillator-node-factory.js","./factories/native-panner-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-factory.js","./factories/native-panner-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-faker-factory.js","./factories/native-periodic-wave-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-periodic-wave-factory.js","./factories/native-script-processor-node":"../node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node.js","./factories/native-stereo-panner-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-factory.js","./factories/native-stereo-panner-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-faker-factory.js","./factories/native-wave-shaper-node-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js","./factories/native-wave-shaper-node-faker-factory":"../node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-faker-factory.js","./factories/not-supported-error":"../node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js","./factories/offline-audio-context-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/offline-audio-context-constructor.js","./factories/oscillator-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-constructor.js","./factories/oscillator-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-renderer-factory.js","./factories/panner-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/panner-node-constructor.js","./factories/panner-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/panner-node-renderer-factory.js","./factories/periodic-wave-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/periodic-wave-constructor.js","./factories/render-automation":"../node_modules/standardized-audio-context/build/es2019/factories/render-automation.js","./factories/render-inputs-of-audio-node":"../node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js","./factories/render-inputs-of-audio-param":"../node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js","./factories/render-native-offline-audio-context":"../node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js","./factories/set-active-audio-worklet-node-inputs":"../node_modules/standardized-audio-context/build/es2019/factories/set-active-audio-worklet-node-inputs.js","./factories/set-audio-node-tail-time":"../node_modules/standardized-audio-context/build/es2019/factories/set-audio-node-tail-time.js","./factories/start-rendering":"../node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js","./factories/stereo-panner-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-constructor.js","./factories/stereo-panner-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-renderer-factory.js","./factories/test-audio-buffer-constructor-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js","./factories/test-audio-buffer-copy-channel-methods-subarray-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-copy-channel-methods-subarray-support.js","./factories/test-audio-context-close-method-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-close-method-support.js","./factories/test-audio-context-decode-audio-data-method-type-error-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-decode-audio-data-method-type-error-support.js","./factories/test-audio-context-options-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-options-support.js","./factories/test-audio-node-connect-method-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-node-connect-method-support.js","./factories/test-audio-worklet-processor-no-outputs-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-no-outputs-support.js","./factories/test-audio-worklet-processor-post-message-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-post-message-support.js","./factories/test-channel-merger-node-channel-count-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-channel-merger-node-channel-count-support.js","./factories/test-constant-source-node-accurate-scheduling-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-constant-source-node-accurate-scheduling-support.js","./factories/test-convolver-node-buffer-reassignability-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-buffer-reassignability-support.js","./factories/test-convolver-node-channel-count-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-channel-count-support.js","./factories/test-is-secure-context-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-is-secure-context-support.js","./factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js","./factories/test-offline-audio-context-current-time-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js","./factories/test-stereo-panner-node-default-value-support":"../node_modules/standardized-audio-context/build/es2019/factories/test-stereo-panner-node-default-value-support.js","./factories/unknown-error":"../node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js","./factories/wave-shaper-node-constructor":"../node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-constructor.js","./factories/wave-shaper-node-renderer-factory":"../node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-renderer-factory.js","./factories/window":"../node_modules/standardized-audio-context/build/es2019/factories/window.js","./factories/wrap-audio-buffer-copy-channel-methods":"../node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js","./factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds":"../node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js","./factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer":"../node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js","./factories/wrap-channel-merger-node":"../node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js","./globals":"../node_modules/standardized-audio-context/build/es2019/globals.js","./helpers/connect-native-audio-node-to-native-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js","./helpers/disconnect-native-audio-node-from-native-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js","./helpers/get-audio-node-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js","./helpers/get-audio-param-connections":"../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js","./helpers/get-event-listeners-of-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js","./helpers/get-first-sample":"../node_modules/standardized-audio-context/build/es2019/helpers/get-first-sample.js","./helpers/get-native-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js","./helpers/get-native-audio-param":"../node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js","./helpers/get-value-for-key":"../node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js","./helpers/insert-element-in-set":"../node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js","./helpers/is-active-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","./helpers/is-dc-curve":"../node_modules/standardized-audio-context/build/es2019/helpers/is-dc-curve.js","./helpers/is-part-of-a-cycle":"../node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js","./helpers/is-passive-audio-node":"../node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js","./helpers/overwrite-accessors":"../node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js","./helpers/pick-element-from-set":"../node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js","./helpers/sanitize-audio-worklet-node-options":"../node_modules/standardized-audio-context/build/es2019/helpers/sanitize-audio-worklet-node-options.js","./helpers/sanitize-channel-splitter-options":"../node_modules/standardized-audio-context/build/es2019/helpers/sanitize-channel-splitter-options.js","./helpers/sanitize-periodic-wave-options":"../node_modules/standardized-audio-context/build/es2019/helpers/sanitize-periodic-wave-options.js","./helpers/set-value-at-time-until-possible":"../node_modules/standardized-audio-context/build/es2019/helpers/set-value-at-time-until-possible.js","./helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js","./helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.js","./helpers/test-audio-buffer-source-node-start-method-offset-clamping-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.js","./helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js","./helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.js","./helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js","./helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js","./helpers/test-audio-worklet-node-options-clonability":"../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-worklet-node-options-clonability.js","./helpers/test-dom-exception-constructor-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-dom-exception-constructor-support.js","./helpers/test-promise-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js","./helpers/test-transferables-support":"../node_modules/standardized-audio-context/build/es2019/helpers/test-transferables-support.js","./helpers/wrap-audio-buffer-source-node-start-method-offset-clamping":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js","./helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js","./helpers/wrap-event-listener":"../node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js","./interfaces/index":"../node_modules/standardized-audio-context/build/es2019/interfaces/index.js","./types/index":"../node_modules/standardized-audio-context/build/es2019/types/index.js"}],"../node_modules/tone/build/esm/core/util/Debug.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;
exports.assertContextRunning = assertContextRunning;
exports.assertRange = assertRange;
exports.log = log;
exports.setLogger = setLogger;
exports.warn = warn;

/**
 * Assert that the statement is true, otherwise invoke the error.
 * @param statement
 * @param error The message which is passed into an Error
 */
function assert(statement, error) {
  if (!statement) {
    throw new Error(error);
  }
}
/**
 * Make sure that the given value is within the range
 */


function assertRange(value, gte, lte = Infinity) {
  if (!(gte <= value && value <= lte)) {
    throw new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);
  }
}
/**
 * Make sure that the given value is within the range
 */


function assertContextRunning(context) {
  // add a warning if the context is not started
  if (!context.isOffline && context.state !== "running") {
    warn("The AudioContext is \"suspended\". Invoke Tone.start() from a user action to start the audio.");
  }
}
/**
 * The default logger is the console
 */


let defaultLogger = console;
/**
 * Set the logging interface
 */

function setLogger(logger) {
  defaultLogger = logger;
}
/**
 * Log anything
 */


function log(...args) {
  defaultLogger.log(...args);
}
/**
 * Warn anything
 */


function warn(...args) {
  defaultLogger.warn(...args);
}
},{}],"../node_modules/tone/build/esm/core/util/TypeCheck.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArray = isArray;
exports.isBoolean = isBoolean;
exports.isDefined = isDefined;
exports.isFunction = isFunction;
exports.isNote = isNote;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isString = isString;
exports.isUndef = isUndef;

/**
 * Test if the arg is undefined
 */
function isUndef(arg) {
  return typeof arg === "undefined";
}
/**
 * Test if the arg is not undefined
 */


function isDefined(arg) {
  return !isUndef(arg);
}
/**
 * Test if the arg is a function
 */


function isFunction(arg) {
  return typeof arg === "function";
}
/**
 * Test if the argument is a number.
 */


function isNumber(arg) {
  return typeof arg === "number";
}
/**
 * Test if the given argument is an object literal (i.e. `{}`);
 */


function isObject(arg) {
  return Object.prototype.toString.call(arg) === "[object Object]" && arg.constructor === Object;
}
/**
 * Test if the argument is a boolean.
 */


function isBoolean(arg) {
  return typeof arg === "boolean";
}
/**
 * Test if the argument is an Array
 */


function isArray(arg) {
  return Array.isArray(arg);
}
/**
 * Test if the argument is a string.
 */


function isString(arg) {
  return typeof arg === "string";
}
/**
 * Test if the argument is in the form of a note in scientific pitch notation.
 * e.g. "C4"
 */


function isNote(arg) {
  return isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);
}
},{}],"../node_modules/tone/build/esm/core/context/AudioContext.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAudioContext = createAudioContext;
exports.createAudioWorkletNode = createAudioWorkletNode;
exports.createOfflineAudioContext = createOfflineAudioContext;
exports.hasAudioContext = void 0;
Object.defineProperty(exports, "supported", {
  enumerable: true,
  get: function () {
    return _standardizedAudioContext.isSupported;
  }
});
exports.theWindow = void 0;

var _standardizedAudioContext = require("standardized-audio-context");

var _Debug = require("../util/Debug");

var _TypeCheck = require("../util/TypeCheck");

/**
 * Create a new AudioContext
 */
function createAudioContext(options) {
  return new _standardizedAudioContext.AudioContext(options);
}
/**
 * Create a new OfflineAudioContext
 */


function createOfflineAudioContext(channels, length, sampleRate) {
  return new _standardizedAudioContext.OfflineAudioContext(channels, length, sampleRate);
}
/**
 * A reference to the window object
 * @hidden
 */


const theWindow = typeof self === "object" ? self : null;
/**
 * If the browser has a window object which has an AudioContext
 * @hidden
 */

exports.theWindow = theWindow;
const hasAudioContext = theWindow && (theWindow.hasOwnProperty("AudioContext") || theWindow.hasOwnProperty("webkitAudioContext"));
exports.hasAudioContext = hasAudioContext;

function createAudioWorkletNode(context, name, options) {
  (0, _Debug.assert)((0, _TypeCheck.isDefined)(_standardizedAudioContext.AudioWorkletNode), "This node only works in a secure context (https or localhost)"); // @ts-ignore

  return new _standardizedAudioContext.AudioWorkletNode(context, name, options);
}
/**
 * This promise resolves to a boolean which indicates if the
 * functionality is supported within the currently used browse.
 * Taken from [standardized-audio-context](https://github.com/chrisguttandin/standardized-audio-context#issupported)
 */
},{"standardized-audio-context":"../node_modules/standardized-audio-context/build/es2019/module.js","../util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","../util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js"}],"../node_modules/tslib/tslib.es6.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__assign = void 0;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncValues = __asyncValues;
exports.__await = __await;
exports.__awaiter = __awaiter;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldIn = __classPrivateFieldIn;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__createBinding = void 0;
exports.__decorate = __decorate;
exports.__exportStar = __exportStar;
exports.__extends = __extends;
exports.__generator = __generator;
exports.__importDefault = __importDefault;
exports.__importStar = __importStar;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__metadata = __metadata;
exports.__param = __param;
exports.__read = __read;
exports.__rest = __rest;
exports.__spread = __spread;
exports.__spreadArray = __spreadArray;
exports.__spreadArrays = __spreadArrays;
exports.__values = __values;

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  exports.__assign = __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

exports.__assign = __assign;

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

var __createBinding = Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
};

exports.__createBinding = __createBinding;

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}
/** @deprecated */


function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}
/** @deprecated */


function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}

;

var __setModuleDefault = Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
}

function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
},{}],"../node_modules/tone/build/esm/core/clock/Ticker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Ticker = void 0;

/**
 * A class which provides a reliable callback using either
 * a Web Worker, or if that isn't supported, falls back to setTimeout.
 */
class Ticker {
  constructor(callback, type, updateInterval) {
    this._callback = callback;
    this._type = type;
    this._updateInterval = updateInterval; // create the clock source for the first time

    this._createClock();
  }
  /**
   * Generate a web worker
   */


  _createWorker() {
    const blob = new Blob([
    /* javascript */
    `
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`], {
      type: "text/javascript"
    });
    const blobUrl = URL.createObjectURL(blob);
    const worker = new Worker(blobUrl);
    worker.onmessage = this._callback.bind(this);
    this._worker = worker;
  }
  /**
   * Create a timeout loop
   */


  _createTimeout() {
    this._timeout = setTimeout(() => {
      this._createTimeout();

      this._callback();
    }, this._updateInterval * 1000);
  }
  /**
   * Create the clock source.
   */


  _createClock() {
    if (this._type === "worker") {
      try {
        this._createWorker();
      } catch (e) {
        // workers not supported, fallback to timeout
        this._type = "timeout";

        this._createClock();
      }
    } else if (this._type === "timeout") {
      this._createTimeout();
    }
  }
  /**
   * Clean up the current clock source
   */


  _disposeClock() {
    if (this._timeout) {
      clearTimeout(this._timeout);
      this._timeout = 0;
    }

    if (this._worker) {
      this._worker.terminate();

      this._worker.onmessage = null;
    }
  }
  /**
   * The rate in seconds the ticker will update
   */


  get updateInterval() {
    return this._updateInterval;
  }

  set updateInterval(interval) {
    this._updateInterval = Math.max(interval, 128 / 44100);

    if (this._type === "worker") {
      this._worker.postMessage(Math.max(interval * 1000, 1));
    }
  }
  /**
   * The type of the ticker, either a worker or a timeout
   */


  get type() {
    return this._type;
  }

  set type(type) {
    this._disposeClock();

    this._type = type;

    this._createClock();
  }
  /**
   * Clean up
   */


  dispose() {
    this._disposeClock();
  }

}

exports.Ticker = Ticker;
},{}],"../node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAudioBuffer = isAudioBuffer;
exports.isAudioContext = isAudioContext;
exports.isAudioNode = isAudioNode;
exports.isAudioParam = isAudioParam;
exports.isOfflineAudioContext = isOfflineAudioContext;

var _standardizedAudioContext = require("standardized-audio-context");

/**
 * Test if the given value is an instanceof AudioParam
 */
function isAudioParam(arg) {
  return (0, _standardizedAudioContext.isAnyAudioParam)(arg);
}
/**
 * Test if the given value is an instanceof AudioNode
 */


function isAudioNode(arg) {
  return (0, _standardizedAudioContext.isAnyAudioNode)(arg);
}
/**
 * Test if the arg is instanceof an OfflineAudioContext
 */


function isOfflineAudioContext(arg) {
  return (0, _standardizedAudioContext.isAnyOfflineAudioContext)(arg);
}
/**
 * Test if the arg is an instanceof AudioContext
 */


function isAudioContext(arg) {
  return (0, _standardizedAudioContext.isAnyAudioContext)(arg);
}
/**
 * Test if the arg is instanceof an AudioBuffer
 */


function isAudioBuffer(arg) {
  return arg instanceof AudioBuffer;
}
},{"standardized-audio-context":"../node_modules/standardized-audio-context/build/es2019/module.js"}],"../node_modules/tone/build/esm/core/util/Defaults.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepEquals = deepEquals;
exports.deepMerge = deepMerge;
exports.defaultArg = defaultArg;
exports.getDefaultsFromInstance = getDefaultsFromInstance;
exports.omitFromObject = omitFromObject;
exports.optionsFromArguments = optionsFromArguments;

var _AdvancedTypeCheck = require("./AdvancedTypeCheck");

var _TypeCheck = require("./TypeCheck");

/**
 * Some objects should not be merged
 */
function noCopy(key, arg) {
  return key === "value" || (0, _AdvancedTypeCheck.isAudioParam)(arg) || (0, _AdvancedTypeCheck.isAudioNode)(arg) || (0, _AdvancedTypeCheck.isAudioBuffer)(arg);
}

function deepMerge(target, ...sources) {
  if (!sources.length) {
    return target;
  }

  const source = sources.shift();

  if ((0, _TypeCheck.isObject)(target) && (0, _TypeCheck.isObject)(source)) {
    for (const key in source) {
      if (noCopy(key, source[key])) {
        target[key] = source[key];
      } else if ((0, _TypeCheck.isObject)(source[key])) {
        if (!target[key]) {
          Object.assign(target, {
            [key]: {}
          });
        }

        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, {
          [key]: source[key]
        });
      }
    }
  } // @ts-ignore


  return deepMerge(target, ...sources);
}
/**
 * Returns true if the two arrays have the same value for each of the elements
 */


function deepEquals(arrayA, arrayB) {
  return arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);
}
/**
 * Convert an args array into an object.
 */


function optionsFromArguments(defaults, argsArray, keys = [], objKey) {
  const opts = {};
  const args = Array.from(argsArray); // if the first argument is an object and has an object key

  if ((0, _TypeCheck.isObject)(args[0]) && objKey && !Reflect.has(args[0], objKey)) {
    // if it's not part of the defaults
    const partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));

    if (!partOfDefaults) {
      // merge that key
      deepMerge(opts, {
        [objKey]: args[0]
      }); // remove the obj key from the keys

      keys.splice(keys.indexOf(objKey), 1); // shift the first argument off

      args.shift();
    }
  }

  if (args.length === 1 && (0, _TypeCheck.isObject)(args[0])) {
    deepMerge(opts, args[0]);
  } else {
    for (let i = 0; i < keys.length; i++) {
      if ((0, _TypeCheck.isDefined)(args[i])) {
        opts[keys[i]] = args[i];
      }
    }
  }

  return deepMerge(defaults, opts);
}
/**
 * Return this instances default values by calling Constructor.getDefaults()
 */


function getDefaultsFromInstance(instance) {
  return instance.constructor.getDefaults();
}
/**
 * Returns the fallback if the given object is undefined.
 * Take an array of arguments and return a formatted options object.
 */


function defaultArg(given, fallback) {
  if ((0, _TypeCheck.isUndef)(given)) {
    return fallback;
  } else {
    return given;
  }
}
/**
 * Remove all of the properties belonging to omit from obj.
 */


function omitFromObject(obj, omit) {
  omit.forEach(prop => {
    if (Reflect.has(obj, prop)) {
      delete obj[prop];
    }
  });
  return obj;
}
},{"./AdvancedTypeCheck":"../node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js","./TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js"}],"../node_modules/tone/build/esm/core/Tone.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tone = void 0;

var _version = require("../version");

var _AudioContext = require("./context/AudioContext");

var _Debug = require("./util/Debug");

/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */

/**
 * @class  Tone is the base class of all other classes.
 * @category Core
 * @constructor
 */
class Tone {
  constructor() {
    //-------------------------------------
    // 	DEBUGGING
    //-------------------------------------

    /**
     * Set this debug flag to log all events that happen in this class.
     */
    this.debug = false; //-------------------------------------
    // 	DISPOSING
    //-------------------------------------

    /**
     * Indicates if the instance was disposed
     */

    this._wasDisposed = false;
  }
  /**
   * Returns all of the default options belonging to the class.
   */


  static getDefaults() {
    return {};
  }
  /**
   * Prints the outputs to the console log for debugging purposes.
   * Prints the contents only if either the object has a property
   * called `debug` set to true, or a variable called TONE_DEBUG_CLASS
   * is set to the name of the class.
   * @example
   * const osc = new Tone.Oscillator();
   * // prints all logs originating from this oscillator
   * osc.debug = true;
   * // calls to start/stop will print in the console
   * osc.start();
   */


  log(...args) {
    // if the object is either set to debug = true
    // or if there is a string on the Tone.global.with the class name
    if (this.debug || _AudioContext.theWindow && this.toString() === _AudioContext.theWindow.TONE_DEBUG_CLASS) {
      (0, _Debug.log)(this, ...args);
    }
  }
  /**
   * disconnect and dispose.
   */


  dispose() {
    this._wasDisposed = true;
    return this;
  }
  /**
   * Indicates if the instance was disposed. 'Disposing' an
   * instance means that all of the Web Audio nodes that were
   * created for the instance are disconnected and freed for garbage collection.
   */


  get disposed() {
    return this._wasDisposed;
  }
  /**
   * Convert the class to a string
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.toString());
   */


  toString() {
    return this.name;
  }

}
/**
 * The version number semver
 */


exports.Tone = Tone;
Tone.version = _version.version;
},{"../version":"../node_modules/tone/build/esm/version.js","./context/AudioContext":"../node_modules/tone/build/esm/core/context/AudioContext.js","./util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/core/util/Math.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EQ = EQ;
exports.GT = GT;
exports.GTE = GTE;
exports.LT = LT;
exports.clamp = clamp;

/**
 * The threshold for correctness for operators. Less than one sample even
 * at very high sampling rates (e.g. `1e-6 < 1 / 192000`).
 */
const EPSILON = 1e-6;
/**
 * Test if A is greater than B
 */

function GT(a, b) {
  return a > b + EPSILON;
}
/**
 * Test if A is greater than or equal to B
 */


function GTE(a, b) {
  return GT(a, b) || EQ(a, b);
}
/**
 * Test if A is less than B
 */


function LT(a, b) {
  return a + EPSILON < b;
}
/**
 * Test if A is less than B
 */


function EQ(a, b) {
  return Math.abs(a - b) < EPSILON;
}
/**
 * Clamp the value within the given range
 */


function clamp(value, min, max) {
  return Math.max(Math.min(value, max), min);
}
},{}],"../node_modules/tone/build/esm/core/util/Timeline.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Timeline = void 0;

var _Tone = require("../Tone");

var _Defaults = require("./Defaults");

var _Debug = require("./Debug");

var _Math = require("./Math");

/**
 * A Timeline class for scheduling and maintaining state
 * along a timeline. All events must have a "time" property.
 * Internally, events are stored in time order for fast
 * retrieval.
 */
class Timeline extends _Tone.Tone {
  constructor() {
    super();
    this.name = "Timeline";
    /**
     * The array of scheduled timeline events
     */

    this._timeline = [];
    const options = (0, _Defaults.optionsFromArguments)(Timeline.getDefaults(), arguments, ["memory"]);
    this.memory = options.memory;
    this.increasing = options.increasing;
  }

  static getDefaults() {
    return {
      memory: Infinity,
      increasing: false
    };
  }
  /**
   * The number of items in the timeline.
   */


  get length() {
    return this._timeline.length;
  }
  /**
   * Insert an event object onto the timeline. Events must have a "time" attribute.
   * @param event  The event object to insert into the timeline.
   */


  add(event) {
    // the event needs to have a time attribute
    (0, _Debug.assert)(Reflect.has(event, "time"), "Timeline: events must have a time attribute");
    event.time = event.time.valueOf();

    if (this.increasing && this.length) {
      const lastValue = this._timeline[this.length - 1];
      (0, _Debug.assert)((0, _Math.GTE)(event.time, lastValue.time), "The time must be greater than or equal to the last scheduled time");

      this._timeline.push(event);
    } else {
      const index = this._search(event.time);

      this._timeline.splice(index + 1, 0, event);
    } // if the length is more than the memory, remove the previous ones


    if (this.length > this.memory) {
      const diff = this.length - this.memory;

      this._timeline.splice(0, diff);
    }

    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  {Object}  event  The event object to remove from the list.
   * @returns {Timeline} this
   */


  remove(event) {
    const index = this._timeline.indexOf(event);

    if (index !== -1) {
      this._timeline.splice(index, 1);
    }

    return this;
  }
  /**
   * Get the nearest event whose time is less than or equal to the given time.
   * @param  time  The time to query.
   */


  get(time, param = "time") {
    const index = this._search(time, param);

    if (index !== -1) {
      return this._timeline[index];
    } else {
      return null;
    }
  }
  /**
   * Return the first event in the timeline without removing it
   * @returns {Object} The first event object
   */


  peek() {
    return this._timeline[0];
  }
  /**
   * Return the first event in the timeline and remove it
   */


  shift() {
    return this._timeline.shift();
  }
  /**
   * Get the event which is scheduled after the given time.
   * @param  time  The time to query.
   */


  getAfter(time, param = "time") {
    const index = this._search(time, param);

    if (index + 1 < this._timeline.length) {
      return this._timeline[index + 1];
    } else {
      return null;
    }
  }
  /**
   * Get the event before the event at the given time.
   * @param  time  The time to query.
   */


  getBefore(time) {
    const len = this._timeline.length; // if it's after the last item, return the last item

    if (len > 0 && this._timeline[len - 1].time < time) {
      return this._timeline[len - 1];
    }

    const index = this._search(time);

    if (index - 1 >= 0) {
      return this._timeline[index - 1];
    } else {
      return null;
    }
  }
  /**
   * Cancel events at and after the given time
   * @param  after  The time to query.
   */


  cancel(after) {
    if (this._timeline.length > 1) {
      let index = this._search(after);

      if (index >= 0) {
        if ((0, _Math.EQ)(this._timeline[index].time, after)) {
          // get the first item with that time
          for (let i = index; i >= 0; i--) {
            if ((0, _Math.EQ)(this._timeline[i].time, after)) {
              index = i;
            } else {
              break;
            }
          }

          this._timeline = this._timeline.slice(0, index);
        } else {
          this._timeline = this._timeline.slice(0, index + 1);
        }
      } else {
        this._timeline = [];
      }
    } else if (this._timeline.length === 1) {
      // the first item's time
      if ((0, _Math.GTE)(this._timeline[0].time, after)) {
        this._timeline = [];
      }
    }

    return this;
  }
  /**
   * Cancel events before or equal to the given time.
   * @param  time  The time to cancel before.
   */


  cancelBefore(time) {
    const index = this._search(time);

    if (index >= 0) {
      this._timeline = this._timeline.slice(index + 1);
    }

    return this;
  }
  /**
   * Returns the previous event if there is one. null otherwise
   * @param  event The event to find the previous one of
   * @return The event right before the given event
   */


  previousEvent(event) {
    const index = this._timeline.indexOf(event);

    if (index > 0) {
      return this._timeline[index - 1];
    } else {
      return null;
    }
  }
  /**
   * Does a binary search on the timeline array and returns the
   * nearest event index whose time is after or equal to the given time.
   * If a time is searched before the first index in the timeline, -1 is returned.
   * If the time is after the end, the index of the last item is returned.
   */


  _search(time, param = "time") {
    if (this._timeline.length === 0) {
      return -1;
    }

    let beginning = 0;
    const len = this._timeline.length;
    let end = len;

    if (len > 0 && this._timeline[len - 1][param] <= time) {
      return len - 1;
    }

    while (beginning < end) {
      // calculate the midpoint for roughly equal partition
      let midPoint = Math.floor(beginning + (end - beginning) / 2);
      const event = this._timeline[midPoint];
      const nextEvent = this._timeline[midPoint + 1];

      if ((0, _Math.EQ)(event[param], time)) {
        // choose the last one that has the same time
        for (let i = midPoint; i < this._timeline.length; i++) {
          const testEvent = this._timeline[i];

          if ((0, _Math.EQ)(testEvent[param], time)) {
            midPoint = i;
          } else {
            break;
          }
        }

        return midPoint;
      } else if ((0, _Math.LT)(event[param], time) && (0, _Math.GT)(nextEvent[param], time)) {
        return midPoint;
      } else if ((0, _Math.GT)(event[param], time)) {
        // search lower
        end = midPoint;
      } else {
        // search upper
        beginning = midPoint + 1;
      }
    }

    return -1;
  }
  /**
   * Internal iterator. Applies extra safety checks for
   * removing items from the array.
   */


  _iterate(callback, lowerBound = 0, upperBound = this._timeline.length - 1) {
    this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);
  }
  /**
   * Iterate over everything in the array
   * @param  callback The callback to invoke with every item
   */


  forEach(callback) {
    this._iterate(callback);

    return this;
  }
  /**
   * Iterate over everything in the array at or before the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */


  forEachBefore(time, callback) {
    // iterate over the items in reverse so that removing an item doesn't break things
    const upperBound = this._search(time);

    if (upperBound !== -1) {
      this._iterate(callback, 0, upperBound);
    }

    return this;
  }
  /**
   * Iterate over everything in the array after the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */


  forEachAfter(time, callback) {
    // iterate over the items in reverse so that removing an item doesn't break things
    const lowerBound = this._search(time);

    this._iterate(callback, lowerBound + 1);

    return this;
  }
  /**
   * Iterate over everything in the array between the startTime and endTime.
   * The timerange is inclusive of the startTime, but exclusive of the endTime.
   * range = [startTime, endTime).
   * @param  startTime The time to check if items are before
   * @param  endTime The end of the test interval.
   * @param  callback The callback to invoke with every item
   */


  forEachBetween(startTime, endTime, callback) {
    let lowerBound = this._search(startTime);

    let upperBound = this._search(endTime);

    if (lowerBound !== -1 && upperBound !== -1) {
      if (this._timeline[lowerBound].time !== startTime) {
        lowerBound += 1;
      } // exclusive of the end time


      if (this._timeline[upperBound].time === endTime) {
        upperBound -= 1;
      }

      this._iterate(callback, lowerBound, upperBound);
    } else if (lowerBound === -1) {
      this._iterate(callback, 0, upperBound);
    }

    return this;
  }
  /**
   * Iterate over everything in the array at or after the given time. Similar to
   * forEachAfter, but includes the item(s) at the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */


  forEachFrom(time, callback) {
    // iterate over the items in reverse so that removing an item doesn't break things
    let lowerBound = this._search(time); // work backwards until the event time is less than time


    while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {
      lowerBound--;
    }

    this._iterate(callback, lowerBound + 1);

    return this;
  }
  /**
   * Iterate over everything in the array at the given time
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */


  forEachAtTime(time, callback) {
    // iterate over the items in reverse so that removing an item doesn't break things
    const upperBound = this._search(time);

    if (upperBound !== -1 && (0, _Math.EQ)(this._timeline[upperBound].time, time)) {
      let lowerBound = upperBound;

      for (let i = upperBound; i >= 0; i--) {
        if ((0, _Math.EQ)(this._timeline[i].time, time)) {
          lowerBound = i;
        } else {
          break;
        }
      }

      this._iterate(event => {
        callback(event);
      }, lowerBound, upperBound);
    }

    return this;
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();
    this._timeline = [];
    return this;
  }

}

exports.Timeline = Timeline;
},{"../Tone":"../node_modules/tone/build/esm/core/Tone.js","./Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Debug":"../node_modules/tone/build/esm/core/util/Debug.js","./Math":"../node_modules/tone/build/esm/core/util/Math.js"}],"../node_modules/tone/build/esm/core/context/ContextInitialization.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.closeContext = closeContext;
exports.initializeContext = initializeContext;
exports.onContextClose = onContextClose;
exports.onContextInit = onContextInit;
//-------------------------------------
// INITIALIZING NEW CONTEXT
//-------------------------------------

/**
 * Array of callbacks to invoke when a new context is created
 */
const notifyNewContext = [];
/**
 * Used internally to setup a new Context
 */

function onContextInit(cb) {
  notifyNewContext.push(cb);
}
/**
 * Invoke any classes which need to also be initialized when a new context is created.
 */


function initializeContext(ctx) {
  // add any additional modules
  notifyNewContext.forEach(cb => cb(ctx));
}
/**
 * Array of callbacks to invoke when a new context is created
 */


const notifyCloseContext = [];
/**
 * Used internally to tear down a Context
 */

function onContextClose(cb) {
  notifyCloseContext.push(cb);
}

function closeContext(ctx) {
  // add any additional modules
  notifyCloseContext.forEach(cb => cb(ctx));
}
},{}],"../node_modules/tone/build/esm/core/util/Emitter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Emitter = void 0;

var _Tone = require("../Tone");

var _TypeCheck = require("./TypeCheck");

/**
 * Emitter gives classes which extend it
 * the ability to listen for and emit events.
 * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).
 * MIT (c) 2011 Jerome Etienne.
 * @category Core
 */
class Emitter extends _Tone.Tone {
  constructor() {
    super(...arguments);
    this.name = "Emitter";
  }
  /**
   * Bind a callback to a specific event.
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */


  on(event, callback) {
    // split the event
    const events = event.split(/\W+/);
    events.forEach(eventName => {
      if ((0, _TypeCheck.isUndef)(this._events)) {
        this._events = {};
      }

      if (!this._events.hasOwnProperty(eventName)) {
        this._events[eventName] = [];
      }

      this._events[eventName].push(callback);
    });
    return this;
  }
  /**
   * Bind a callback which is only invoked once
   * @param  event     The name of the event to listen for.
   * @param  callback  The callback to invoke when the event is emitted
   */


  once(event, callback) {
    const boundCallback = (...args) => {
      // invoke the callback
      callback(...args); // remove the event

      this.off(event, boundCallback);
    };

    this.on(event, boundCallback);
    return this;
  }
  /**
   * Remove the event listener.
   * @param  event     The event to stop listening to.
   * @param  callback  The callback which was bound to the event with Emitter.on.
   *                   If no callback is given, all callbacks events are removed.
   */


  off(event, callback) {
    const events = event.split(/\W+/);
    events.forEach(eventName => {
      if ((0, _TypeCheck.isUndef)(this._events)) {
        this._events = {};
      }

      if (this._events.hasOwnProperty(event)) {
        if ((0, _TypeCheck.isUndef)(callback)) {
          this._events[event] = [];
        } else {
          const eventList = this._events[event];

          for (let i = eventList.length - 1; i >= 0; i--) {
            if (eventList[i] === callback) {
              eventList.splice(i, 1);
            }
          }
        }
      }
    });
    return this;
  }
  /**
   * Invoke all of the callbacks bound to the event
   * with any arguments passed in.
   * @param  event  The name of the event.
   * @param args The arguments to pass to the functions listening.
   */


  emit(event, ...args) {
    if (this._events) {
      if (this._events.hasOwnProperty(event)) {
        const eventList = this._events[event].slice(0);

        for (let i = 0, len = eventList.length; i < len; i++) {
          eventList[i].apply(this, args);
        }
      }
    }

    return this;
  }
  /**
   * Add Emitter functions (on/off/emit) to the object
   */


  static mixin(constr) {
    // instance._events = {};
    ["on", "once", "off", "emit"].forEach(name => {
      const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);
      Object.defineProperty(constr.prototype, name, property);
    });
  }
  /**
   * Clean up
   */


  dispose() {
    super.dispose();
    this._events = undefined;
    return this;
  }

}

exports.Emitter = Emitter;
},{"../Tone":"../node_modules/tone/build/esm/core/Tone.js","./TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js"}],"../node_modules/tone/build/esm/core/context/BaseContext.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseContext = void 0;

var _Emitter = require("../util/Emitter");

class BaseContext extends _Emitter.Emitter {
  constructor() {
    super(...arguments);
    this.isOffline = false;
  }
  /*
   * This is a placeholder so that JSON.stringify does not throw an error
   * This matches what JSON.stringify(audioContext) returns on a native
   * audioContext instance.
   */


  toJSON() {
    return {};
  }

}

exports.BaseContext = BaseContext;
},{"../util/Emitter":"../node_modules/tone/build/esm/core/util/Emitter.js"}],"../node_modules/tone/build/esm/core/context/Context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Context = void 0;

var _tslib = require("tslib");

var _Ticker = require("../clock/Ticker");

var _AdvancedTypeCheck = require("../util/AdvancedTypeCheck");

var _Defaults = require("../util/Defaults");

var _Timeline = require("../util/Timeline");

var _TypeCheck = require("../util/TypeCheck");

var _AudioContext = require("./AudioContext");

var _ContextInitialization = require("./ContextInitialization");

var _BaseContext = require("./BaseContext");

var _Debug = require("../util/Debug");

/**
 * Wrapper around the native AudioContext.
 * @category Core
 */
class Context extends _BaseContext.BaseContext {
  constructor() {
    super();
    this.name = "Context";
    /**
     * An object containing all of the constants AudioBufferSourceNodes
     */

    this._constants = new Map();
    /**
     * All of the setTimeout events.
     */

    this._timeouts = new _Timeline.Timeline();
    /**
     * The timeout id counter
     */

    this._timeoutIds = 0;
    /**
     * Private indicator if the context has been initialized
     */

    this._initialized = false;
    /**
     * Indicates if the context is an OfflineAudioContext or an AudioContext
     */

    this.isOffline = false; //--------------------------------------------
    // AUDIO WORKLET
    //--------------------------------------------

    /**
     * Maps a module name to promise of the addModule method
     */

    this._workletModules = new Map();
    const options = (0, _Defaults.optionsFromArguments)(Context.getDefaults(), arguments, ["context"]);

    if (options.context) {
      this._context = options.context;
    } else {
      this._context = (0, _AudioContext.createAudioContext)({
        latencyHint: options.latencyHint
      });
    }

    this._ticker = new _Ticker.Ticker(this.emit.bind(this, "tick"), options.clockSource, options.updateInterval);
    this.on("tick", this._timeoutLoop.bind(this)); // fwd events from the context

    this._context.onstatechange = () => {
      this.emit("statechange", this.state);
    };

    this._setLatencyHint(options.latencyHint);

    this.lookAhead = options.lookAhead;
  }

  static getDefaults() {
    return {
      clockSource: "worker",
      latencyHint: "interactive",
      lookAhead: 0.1,
      updateInterval: 0.05
    };
  }
  /**
   * Finish setting up the context. **You usually do not need to do this manually.**
   */


  initialize() {
    if (!this._initialized) {
      // add any additional modules
      (0, _ContextInitialization.initializeContext)(this);
      this._initialized = true;
    }

    return this;
  } //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------


  createAnalyser() {
    return this._context.createAnalyser();
  }

  createOscillator() {
    return this._context.createOscillator();
  }

  createBufferSource() {
    return this._context.createBufferSource();
  }

  createBiquadFilter() {
    return this._context.createBiquadFilter();
  }

  createBuffer(numberOfChannels, length, sampleRate) {
    return this._context.createBuffer(numberOfChannels, length, sampleRate);
  }

  createChannelMerger(numberOfInputs) {
    return this._context.createChannelMerger(numberOfInputs);
  }

  createChannelSplitter(numberOfOutputs) {
    return this._context.createChannelSplitter(numberOfOutputs);
  }

  createConstantSource() {
    return this._context.createConstantSource();
  }

  createConvolver() {
    return this._context.createConvolver();
  }

  createDelay(maxDelayTime) {
    return this._context.createDelay(maxDelayTime);
  }

  createDynamicsCompressor() {
    return this._context.createDynamicsCompressor();
  }

  createGain() {
    return this._context.createGain();
  }

  createIIRFilter(feedForward, feedback) {
    // @ts-ignore
    return this._context.createIIRFilter(feedForward, feedback);
  }

  createPanner() {
    return this._context.createPanner();
  }

  createPeriodicWave(real, imag, constraints) {
    return this._context.createPeriodicWave(real, imag, constraints);
  }

  createStereoPanner() {
    return this._context.createStereoPanner();
  }

  createWaveShaper() {
    return this._context.createWaveShaper();
  }

  createMediaStreamSource(stream) {
    (0, _Debug.assert)((0, _AdvancedTypeCheck.isAudioContext)(this._context), "Not available if OfflineAudioContext");
    const context = this._context;
    return context.createMediaStreamSource(stream);
  }

  createMediaElementSource(element) {
    (0, _Debug.assert)((0, _AdvancedTypeCheck.isAudioContext)(this._context), "Not available if OfflineAudioContext");
    const context = this._context;
    return context.createMediaElementSource(element);
  }

  createMediaStreamDestination() {
    (0, _Debug.assert)((0, _AdvancedTypeCheck.isAudioContext)(this._context), "Not available if OfflineAudioContext");
    const context = this._context;
    return context.createMediaStreamDestination();
  }

  decodeAudioData(audioData) {
    return this._context.decodeAudioData(audioData);
  }
  /**
   * The current time in seconds of the AudioContext.
   */


  get currentTime() {
    return this._context.currentTime;
  }
  /**
   * The current time in seconds of the AudioContext.
   */


  get state() {
    return this._context.state;
  }
  /**
   * The current time in seconds of the AudioContext.
   */


  get sampleRate() {
    return this._context.sampleRate;
  }
  /**
   * The listener
   */


  get listener() {
    this.initialize();
    return this._listener;
  }

  set listener(l) {
    (0, _Debug.assert)(!this._initialized, "The listener cannot be set after initialization.");
    this._listener = l;
  }
  /**
   * There is only one Transport per Context. It is created on initialization.
   */


  get transport() {
    this.initialize();
    return this._transport;
  }

  set transport(t) {
    (0, _Debug.assert)(!this._initialized, "The transport cannot be set after initialization.");
    this._transport = t;
  }
  /**
   * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.
   */


  get draw() {
    this.initialize();
    return this._draw;
  }

  set draw(d) {
    (0, _Debug.assert)(!this._initialized, "Draw cannot be set after initialization.");
    this._draw = d;
  }
  /**
   * A reference to the Context's destination node.
   */


  get destination() {
    this.initialize();
    return this._destination;
  }

  set destination(d) {
    (0, _Debug.assert)(!this._initialized, "The destination cannot be set after initialization.");
    this._destination = d;
  }
  /**
   * Create an audio worklet node from a name and options. The module
   * must first be loaded using [[addAudioWorkletModule]].
   */


  createAudioWorkletNode(name, options) {
    return (0, _AudioContext.createAudioWorkletNode)(this.rawContext, name, options);
  }
  /**
   * Add an AudioWorkletProcessor module
   * @param url The url of the module
   * @param name The name of the module
   */


  addAudioWorkletModule(url, name) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _Debug.assert)((0, _TypeCheck.isDefined)(this.rawContext.audioWorklet), "AudioWorkletNode is only available in a secure context (https or localhost)");

      if (!this._workletModules.has(name)) {
        this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));
      }

      yield this._workletModules.get(name);
    });
  }
  /**
   * Returns a promise which resolves when all of the worklets have been loaded on this context
   */


  workletsAreReady() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const promises = [];

      this._workletModules.forEach(promise => promises.push(promise));

      yield Promise.all(promises);
    });
  } //---------------------------
  // TICKER
  //---------------------------

  /**
   * How often the interval callback is invoked.
   * This number corresponds to how responsive the scheduling
   * can be. context.updateInterval + context.lookAhead gives you the
   * total latency between scheduling an event and hearing it.
   */


  get updateInterval() {
    return this._ticker.updateInterval;
  }

  set updateInterval(interval) {
    this._ticker.updateInterval = interval;
  }
  /**
   * What the source of the clock is, either "worker" (default),
   * "timeout", or "offline" (none).
   */


  get clockSource() {
    return this._ticker.type;
  }

  set clockSource(type) {
    this._ticker.type = type;
  }
  /**
   * The type of playback, which affects tradeoffs between audio
   * output latency and responsiveness.
   * In addition to setting the value in seconds, the latencyHint also
   * accepts the strings "interactive" (prioritizes low latency),
   * "playback" (prioritizes sustained playback), "balanced" (balances
   * latency and performance).
   * @example
   * // prioritize sustained playback
   * const context = new Tone.Context({ latencyHint: "playback" });
   * // set this context as the global Context
   * Tone.setContext(context);
   * // the global context is gettable with Tone.getContext()
   * console.log(Tone.getContext().latencyHint);
   */


  get latencyHint() {
    return this._latencyHint;
  }
  /**
   * Update the lookAhead and updateInterval based on the latencyHint
   */


  _setLatencyHint(hint) {
    let lookAheadValue = 0;
    this._latencyHint = hint;

    if ((0, _TypeCheck.isString)(hint)) {
      switch (hint) {
        case "interactive":
          lookAheadValue = 0.1;
          break;

        case "playback":
          lookAheadValue = 0.5;
          break;

        case "balanced":
          lookAheadValue = 0.25;
          break;
      }
    }

    this.lookAhead = lookAheadValue;
    this.updateInterval = lookAheadValue / 2;
  }
  /**
   * The unwrapped AudioContext or OfflineAudioContext
   */


  get rawContext() {
    return this._context;
  }
  /**
   * The current audio context time plus a short [[lookAhead]].
   */


  now() {
    return this._context.currentTime + this.lookAhead;
  }
  /**
   * The current audio context time without the [[lookAhead]].
   * In most cases it is better to use [[now]] instead of [[immediate]] since
   * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,
   * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]
   * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.
   */


  immediate() {
    return this._context.currentTime;
  }
  /**
   * Starts the audio context from a suspended state. This is required
   * to initially start the AudioContext. See [[Tone.start]]
   */


  resume() {
    if ((0, _AdvancedTypeCheck.isAudioContext)(this._context)) {
      return this._context.resume();
    } else {
      return Promise.resolve();
    }
  }
  /**
   * Close the context. Once closed, the context can no longer be used and
   * any AudioNodes created from the context will be silent.
   */


  close() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      if ((0, _AdvancedTypeCheck.isAudioContext)(this._context)) {
        yield this._context.close();
      }

      if (this._initialized) {
        (0, _ContextInitialization.closeContext)(this);
      }
    });
  }
  /**
   * **Internal** Generate a looped buffer at some constant value.
   */


  getConstant(val) {
    if (this._constants.has(val)) {
      return this._constants.get(val);
    } else {
      const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);

      const arr = buffer.getChannelData(0);

      for (let i = 0; i < arr.length; i++) {
        arr[i] = val;
      }

      const constant = this._context.createBufferSource();

      constant.channelCount = 1;
      constant.channelCountMode = "explicit";
      constant.buffer = buffer;
      constant.loop = true;
      constant.start(0);

      this._constants.set(val, constant);

      return constant;
    }
  }
  /**
   * Clean up. Also closes the audio context.
   */


  dispose() {
    super.dispose();

    this._ticker.dispose();

    this._timeouts.dispose();

    Object.keys(this._constants).map(val => this._constants[val].disconnect());
    return this;
  } //---------------------------
  // TIMEOUTS
  //---------------------------

  /**
   * The private loop which keeps track of the context scheduled timeouts
   * Is invoked from the clock source
   */


  _timeoutLoop() {
    const now = this.now();

    let firstEvent = this._timeouts.peek();

    while (this._timeouts.length && firstEvent && firstEvent.time <= now) {
      // invoke the callback
      firstEvent.callback(); // shift the first event off

      this._timeouts.shift(); // get the next one


      firstEvent = this._timeouts.peek();
    }
  }
  /**
   * A setTimeout which is guaranteed by the clock source.
   * Also runs in the offline context.
   * @param  fn       The callback to invoke
   * @param  timeout  The timeout in seconds
   * @returns ID to use when invoking Context.clearTimeout
   */


  setTimeout(fn, timeout) {
    this._timeoutIds++;
    const now = this.now();

    this._timeouts.add({
      callback: fn,
      id: this._timeoutIds,
      time: now + timeout
    });

    return this._timeoutIds;
  }
  /**
   * Clears a previously scheduled timeout with Tone.context.setTimeout
   * @param  id  The ID returned from setTimeout
   */


  clearTimeout(id) {
    this._timeouts.forEach(event => {
      if (event.id === id) {
        this._timeouts.remove(event);
      }
    });

    return this;
  }
  /**
   * Clear the function scheduled by [[setInterval]]
   */


  clearInterval(id) {
    return this.clearTimeout(id);
  }
  /**
   * Adds a repeating event to the context's callback clock
   */


  setInterval(fn, interval) {
    const id = ++this._timeoutIds;

    const intervalFn = () => {
      const now = this.now();

      this._timeouts.add({
        callback: () => {
          // invoke the callback
          fn(); // invoke the event to repeat it

          intervalFn();
        },
        id,
        time: now + interval
      });
    }; // kick it off


    intervalFn();
    return id;
  }

}

exports.Context = Context;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../clock/Ticker":"../node_modules/tone/build/esm/core/clock/Ticker.js","../util/AdvancedTypeCheck":"../node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../util/Timeline":"../node_modules/tone/build/esm/core/util/Timeline.js","../util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","./AudioContext":"../node_modules/tone/build/esm/core/context/AudioContext.js","./ContextInitialization":"../node_modules/tone/build/esm/core/context/ContextInitialization.js","./BaseContext":"../node_modules/tone/build/esm/core/context/BaseContext.js","../util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/core/context/DummyContext.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DummyContext = void 0;

var _tslib = require("tslib");

var _BaseContext = require("./BaseContext");

class DummyContext extends _BaseContext.BaseContext {
  constructor() {
    super(...arguments);
    this.lookAhead = 0;
    this.latencyHint = 0;
    this.isOffline = false;
  } //---------------------------
  // BASE AUDIO CONTEXT METHODS
  //---------------------------


  createAnalyser() {
    return {};
  }

  createOscillator() {
    return {};
  }

  createBufferSource() {
    return {};
  }

  createBiquadFilter() {
    return {};
  }

  createBuffer(_numberOfChannels, _length, _sampleRate) {
    return {};
  }

  createChannelMerger(_numberOfInputs) {
    return {};
  }

  createChannelSplitter(_numberOfOutputs) {
    return {};
  }

  createConstantSource() {
    return {};
  }

  createConvolver() {
    return {};
  }

  createDelay(_maxDelayTime) {
    return {};
  }

  createDynamicsCompressor() {
    return {};
  }

  createGain() {
    return {};
  }

  createIIRFilter(_feedForward, _feedback) {
    return {};
  }

  createPanner() {
    return {};
  }

  createPeriodicWave(_real, _imag, _constraints) {
    return {};
  }

  createStereoPanner() {
    return {};
  }

  createWaveShaper() {
    return {};
  }

  createMediaStreamSource(_stream) {
    return {};
  }

  createMediaElementSource(_element) {
    return {};
  }

  createMediaStreamDestination() {
    return {};
  }

  decodeAudioData(_audioData) {
    return Promise.resolve({});
  } //---------------------------
  // TONE AUDIO CONTEXT METHODS
  //---------------------------


  createAudioWorkletNode(_name, _options) {
    return {};
  }

  get rawContext() {
    return {};
  }

  addAudioWorkletModule(_url, _name) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }

  resume() {
    return Promise.resolve();
  }

  setTimeout(_fn, _timeout) {
    return 0;
  }

  clearTimeout(_id) {
    return this;
  }

  setInterval(_fn, _interval) {
    return 0;
  }

  clearInterval(_id) {
    return this;
  }

  getConstant(_val) {
    return {};
  }

  get currentTime() {
    return 0;
  }

  get state() {
    return {};
  }

  get sampleRate() {
    return 0;
  }

  get listener() {
    return {};
  }

  get transport() {
    return {};
  }

  get draw() {
    return {};
  }

  set draw(_d) {}

  get destination() {
    return {};
  }

  set destination(_d) {}

  now() {
    return 0;
  }

  immediate() {
    return 0;
  }

}

exports.DummyContext = DummyContext;
},{"tslib":"../node_modules/tslib/tslib.es6.js","./BaseContext":"../node_modules/tone/build/esm/core/context/BaseContext.js"}],"../node_modules/tone/build/esm/core/util/Interface.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noOp = void 0;
exports.readOnly = readOnly;
exports.writable = writable;

var _TypeCheck = require("./TypeCheck");

/**
 * Make the property not writable using `defineProperty`. Internal use only.
 */
function readOnly(target, property) {
  if ((0, _TypeCheck.isArray)(property)) {
    property.forEach(str => readOnly(target, str));
  } else {
    Object.defineProperty(target, property, {
      enumerable: true,
      writable: false
    });
  }
}
/**
 * Make an attribute writeable. Internal use only.
 */


function writable(target, property) {
  if ((0, _TypeCheck.isArray)(property)) {
    property.forEach(str => writable(target, str));
  } else {
    Object.defineProperty(target, property, {
      writable: true
    });
  }
}

const noOp = () => {// no operation here!
};

exports.noOp = noOp;
},{"./TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js"}],"../node_modules/tone/build/esm/core/context/ToneAudioBuffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToneAudioBuffer = void 0;

var _tslib = require("tslib");

var _Global = require("../Global");

var _Tone = require("../Tone");

var _AdvancedTypeCheck = require("../util/AdvancedTypeCheck");

var _Defaults = require("../util/Defaults");

var _Interface = require("../util/Interface");

var _TypeCheck = require("../util/TypeCheck");

var _Debug = require("../util/Debug");

/**
 * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all
 * classes that make requests for audio files such as Tone.Player,
 * Tone.Sampler and Tone.Convolver.
 * @example
 * const buffer = new Tone.ToneAudioBuffer("https://tonejs.github.io/audio/casio/A1.mp3", () => {
 * 	console.log("loaded");
 * });
 * @category Core
 */
class ToneAudioBuffer extends _Tone.Tone {
  constructor() {
    super();
    this.name = "ToneAudioBuffer";
    /**
     * Callback when the buffer is loaded.
     */

    this.onload = _Interface.noOp;
    const options = (0, _Defaults.optionsFromArguments)(ToneAudioBuffer.getDefaults(), arguments, ["url", "onload", "onerror"]);
    this.reverse = options.reverse;
    this.onload = options.onload;

    if (options.url && (0, _AdvancedTypeCheck.isAudioBuffer)(options.url) || options.url instanceof ToneAudioBuffer) {
      this.set(options.url);
    } else if ((0, _TypeCheck.isString)(options.url)) {
      // initiate the download
      this.load(options.url).catch(options.onerror);
    }
  }

  static getDefaults() {
    return {
      onerror: _Interface.noOp,
      onload: _Interface.noOp,
      reverse: false
    };
  }
  /**
   * The sample rate of the AudioBuffer
   */


  get sampleRate() {
    if (this._buffer) {
      return this._buffer.sampleRate;
    } else {
      return (0, _Global.getContext)().sampleRate;
    }
  }
  /**
   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.
   */


  set(buffer) {
    if (buffer instanceof ToneAudioBuffer) {
      // if it's loaded, set it
      if (buffer.loaded) {
        this._buffer = buffer.get();
      } else {
        // otherwise when it's loaded, invoke it's callback
        buffer.onload = () => {
          this.set(buffer);
          this.onload(this);
        };
      }
    } else {
      this._buffer = buffer;
    } // reverse it initially


    if (this._reversed) {
      this._reverse();
    }

    return this;
  }
  /**
   * The audio buffer stored in the object.
   */


  get() {
    return this._buffer;
  }
  /**
   * Makes an fetch request for the selected url then decodes the file as an audio buffer.
   * Invokes the callback once the audio buffer loads.
   * @param url The url of the buffer to load. filetype support depends on the browser.
   * @returns A Promise which resolves with this ToneAudioBuffer
   */


  load(url) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const doneLoading = ToneAudioBuffer.load(url).then(audioBuffer => {
        this.set(audioBuffer); // invoke the onload method

        this.onload(this);
      });
      ToneAudioBuffer.downloads.push(doneLoading);

      try {
        yield doneLoading;
      } finally {
        // remove the downloaded file
        const index = ToneAudioBuffer.downloads.indexOf(doneLoading);
        ToneAudioBuffer.downloads.splice(index, 1);
      }

      return this;
    });
  }
  /**
   * clean up
   */


  dispose() {
    super.dispose();
    this._buffer = undefined;
    return this;
  }
  /**
   * Set the audio buffer from the array.
   * To create a multichannel AudioBuffer, pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   */


  fromArray(array) {
    const isMultidimensional = (0, _TypeCheck.isArray)(array) && array[0].length > 0;
    const channels = isMultidimensional ? array.length : 1;
    const len = isMultidimensional ? array[0].length : array.length;
    const context = (0, _Global.getContext)();
    const buffer = context.createBuffer(channels, len, context.sampleRate);
    const multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;

    for (let c = 0; c < channels; c++) {
      buffer.copyToChannel(multiChannelArray[c], c);
    }

    this._buffer = buffer;
    return this;
  }
  /**
   * Sums multiple channels into 1 channel
   * @param chanNum Optionally only copy a single channel from the array.
   */


  toMono(chanNum) {
    if ((0, _TypeCheck.isNumber)(chanNum)) {
      this.fromArray(this.toArray(chanNum));
    } else {
      let outputArray = new Float32Array(this.length);
      const numChannels = this.numberOfChannels;

      for (let channel = 0; channel < numChannels; channel++) {
        const channelArray = this.toArray(channel);

        for (let i = 0; i < channelArray.length; i++) {
          outputArray[i] += channelArray[i];
        }
      } // divide by the number of channels


      outputArray = outputArray.map(sample => sample / numChannels);
      this.fromArray(outputArray);
    }

    return this;
  }
  /**
   * Get the buffer as an array. Single channel buffers will return a 1-dimensional
   * Float32Array, and multichannel buffers will return multidimensional arrays.
   * @param channel Optionally only copy a single channel from the array.
   */


  toArray(channel) {
    if ((0, _TypeCheck.isNumber)(channel)) {
      return this.getChannelData(channel);
    } else if (this.numberOfChannels === 1) {
      return this.toArray(0);
    } else {
      const ret = [];

      for (let c = 0; c < this.numberOfChannels; c++) {
        ret[c] = this.getChannelData(c);
      }

      return ret;
    }
  }
  /**
   * Returns the Float32Array representing the PCM audio data for the specific channel.
   * @param  channel  The channel number to return
   * @return The audio as a TypedArray
   */


  getChannelData(channel) {
    if (this._buffer) {
      return this._buffer.getChannelData(channel);
    } else {
      return new Float32Array(0);
    }
  }
  /**
   * Cut a subsection of the array and return a buffer of the
   * subsection. Does not modify the original buffer
   * @param start The time to start the slice
   * @param end The end time to slice. If none is given will default to the end of the buffer
   */


  slice(start, end = this.duration) {
    const startSamples = Math.floor(start * this.sampleRate);
    const endSamples = Math.floor(end * this.sampleRate);
    (0, _Debug.assert)(startSamples < endSamples, "The start time must be less than the end time");
    const length = endSamples - startSamples;
    const retBuffer = (0, _Global.getContext)().createBuffer(this.numberOfChannels, length, this.sampleRate);

    for (let channel = 0; channel < this.numberOfChannels; channel++) {
      retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);
    }

    return new ToneAudioBuffer(retBuffer);
  }
  /**
   * Reverse the buffer.
   */


  _reverse() {
    if (this.loaded) {
      for (let i = 0; i < this.numberOfChannels; i++) {
        this.getChannelData(i).reverse();
      }
    }

    return this;
  }
  /**
   * If the buffer is loaded or not
   */


  get loaded() {
    return this.length > 0;
  }
  /**
   * The duration of the buffer in seconds.
   */


  get duration() {
    if (this._buffer) {
      return this._buffer.duration;
    } else {
      return 0;
    }
  }
  /**
   * The length of the buffer in samples
   */


  get length() {
    if (this._buffer) {
      return this._buffer.length;
    } else {
      return 0;
    }
  }
  /**
   * The number of discrete audio channels. Returns 0 if no buffer is loaded.
   */


  get numberOfChannels() {
    if (this._buffer) {
      return this._buffer.numberOfChannels;
    } else {
      return 0;
    }
  }
  /**
   * Reverse the buffer.
   */


  get reverse() {
    return this._reversed;
  }

  set reverse(rev) {
    if (this._reversed !== rev) {
      this._reversed = rev;

      this._reverse();
    }
  }
  /**
   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,
   * pass in a multidimensional array.
   * @param array The array to fill the audio buffer
   * @return A ToneAudioBuffer created from the array
   */


  static fromArray(array) {
    return new ToneAudioBuffer().fromArray(array);
  }
  /**
   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer
   * @param  url The url to load.
   * @return A promise which resolves to a ToneAudioBuffer
   */


  static fromUrl(url) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const buffer = new ToneAudioBuffer();
      return yield buffer.load(url);
    });
  }
  /**
   * Loads a url using fetch and returns the AudioBuffer.
   */


  static load(url) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      // test if the url contains multiple extensions
      const matches = url.match(/\[([^\]\[]+\|.+)\]$/);

      if (matches) {
        const extensions = matches[1].split("|");
        let extension = extensions[0];

        for (const ext of extensions) {
          if (ToneAudioBuffer.supportsType(ext)) {
            extension = ext;
            break;
          }
        }

        url = url.replace(matches[0], extension);
      } // make sure there is a slash between the baseUrl and the url


      const baseUrl = ToneAudioBuffer.baseUrl === "" || ToneAudioBuffer.baseUrl.endsWith("/") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + "/";
      const response = yield fetch(baseUrl + url);

      if (!response.ok) {
        throw new Error(`could not load url: ${url}`);
      }

      const arrayBuffer = yield response.arrayBuffer();
      const audioBuffer = yield (0, _Global.getContext)().decodeAudioData(arrayBuffer);
      return audioBuffer;
    });
  }
  /**
   * Checks a url's extension to see if the current browser can play that file type.
   * @param url The url/extension to test
   * @return If the file extension can be played
   * @static
   * @example
   * Tone.ToneAudioBuffer.supportsType("wav"); // returns true
   * Tone.ToneAudioBuffer.supportsType("path/to/file.wav"); // returns true
   */


  static supportsType(url) {
    const extensions = url.split(".");
    const extension = extensions[extensions.length - 1];
    const response = document.createElement("audio").canPlayType("audio/" + extension);
    return response !== "";
  }
  /**
   * Returns a Promise which resolves when all of the buffers have loaded
   */


  static loaded() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      // this makes sure that the function is always async
      yield Promise.resolve();

      while (ToneAudioBuffer.downloads.length) {
        yield ToneAudioBuffer.downloads[0];
      }
    });
  }

} //-------------------------------------
// STATIC METHODS
//-------------------------------------

/**
 * A path which is prefixed before every url.
 */


exports.ToneAudioBuffer = ToneAudioBuffer;
ToneAudioBuffer.baseUrl = "";
/**
 * All of the downloads
 */

ToneAudioBuffer.downloads = [];
},{"tslib":"../node_modules/tslib/tslib.es6.js","../Global":"../node_modules/tone/build/esm/core/Global.js","../Tone":"../node_modules/tone/build/esm/core/Tone.js","../util/AdvancedTypeCheck":"../node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","../util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/core/context/OfflineContext.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OfflineContext = void 0;

var _tslib = require("tslib");

var _AudioContext = require("../context/AudioContext");

var _Context = require("../context/Context");

var _AdvancedTypeCheck = require("../util/AdvancedTypeCheck");

var _ToneAudioBuffer = require("./ToneAudioBuffer");

/**
 * Wrapper around the OfflineAudioContext
 * @category Core
 * @example
 * // generate a single channel, 0.5 second buffer
 * const context = new Tone.OfflineContext(1, 0.5, 44100);
 * const osc = new Tone.Oscillator({ context });
 * context.render().then(buffer => {
 * 	console.log(buffer.numberOfChannels, buffer.duration);
 * });
 */
class OfflineContext extends _Context.Context {
  constructor() {
    super({
      clockSource: "offline",
      context: (0, _AdvancedTypeCheck.isOfflineAudioContext)(arguments[0]) ? arguments[0] : (0, _AudioContext.createOfflineAudioContext)(arguments[0], arguments[1] * arguments[2], arguments[2]),
      lookAhead: 0,
      updateInterval: (0, _AdvancedTypeCheck.isOfflineAudioContext)(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]
    });
    this.name = "OfflineContext";
    /**
     * An artificial clock source
     */

    this._currentTime = 0;
    this.isOffline = true;
    this._duration = (0, _AdvancedTypeCheck.isOfflineAudioContext)(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];
  }
  /**
   * Override the now method to point to the internal clock time
   */


  now() {
    return this._currentTime;
  }
  /**
   * Same as this.now()
   */


  get currentTime() {
    return this._currentTime;
  }
  /**
   * Render just the clock portion of the audio context.
   */


  _renderClock(asynchronous) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      let index = 0;

      while (this._duration - this._currentTime >= 0) {
        // invoke all the callbacks on that time
        this.emit("tick"); // increment the clock in block-sized chunks

        this._currentTime += 128 / this.sampleRate; // yield once a second of audio

        index++;
        const yieldEvery = Math.floor(this.sampleRate / 128);

        if (asynchronous && index % yieldEvery === 0) {
          yield new Promise(done => setTimeout(done, 1));
        }
      }
    });
  }
  /**
   * Render the output of the OfflineContext
   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.
   */


  render(asynchronous = true) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      yield this.workletsAreReady();
      yield this._renderClock(asynchronous);
      const buffer = yield this._context.startRendering();
      return new _ToneAudioBuffer.ToneAudioBuffer(buffer);
    });
  }
  /**
   * Close the context
   */


  close() {
    return Promise.resolve();
  }

}

exports.OfflineContext = OfflineContext;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../context/AudioContext":"../node_modules/tone/build/esm/core/context/AudioContext.js","../context/Context":"../node_modules/tone/build/esm/core/context/Context.js","../util/AdvancedTypeCheck":"../node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js","./ToneAudioBuffer":"../node_modules/tone/build/esm/core/context/ToneAudioBuffer.js"}],"../node_modules/tone/build/esm/core/Global.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContext = getContext;
exports.setContext = setContext;
exports.start = start;

var _version = require("../version");

var _AudioContext = require("./context/AudioContext");

var _Context = require("./context/Context");

var _DummyContext = require("./context/DummyContext");

var _OfflineContext = require("./context/OfflineContext");

var _AdvancedTypeCheck = require("./util/AdvancedTypeCheck");

/**
 * This dummy context is used to avoid throwing immediate errors when importing in Node.js
 */
const dummyContext = new _DummyContext.DummyContext();
/**
 * The global audio context which is getable and assignable through
 * getContext and setContext
 */

let globalContext = dummyContext;
/**
 * Returns the default system-wide [[Context]]
 * @category Core
 */

function getContext() {
  if (globalContext === dummyContext && _AudioContext.hasAudioContext) {
    setContext(new _Context.Context());
  }

  return globalContext;
}
/**
 * Set the default audio context
 * @category Core
 */


function setContext(context) {
  if ((0, _AdvancedTypeCheck.isAudioContext)(context)) {
    globalContext = new _Context.Context(context);
  } else if ((0, _AdvancedTypeCheck.isOfflineAudioContext)(context)) {
    globalContext = new _OfflineContext.OfflineContext(context);
  } else {
    globalContext = context;
  }
}
/**
 * Most browsers will not play _any_ audio until a user
 * clicks something (like a play button). Invoke this method
 * on a click or keypress event handler to start the audio context.
 * More about the Autoplay policy
 * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)
 * @example
 * document.querySelector("button").addEventListener("click", async () => {
 * 	await Tone.start();
 * 	console.log("context started");
 * });
 * @category Core
 */


function start() {
  return globalContext.resume();
}
/**
 * Log Tone.js + version in the console.
 */


if (_AudioContext.theWindow && !_AudioContext.theWindow.TONE_SILENCE_LOGGING) {
  let prefix = "v";

  if (_version.version === "dev") {
    prefix = "";
  }

  const printString = ` * Tone.js ${prefix}${_version.version} * `; // eslint-disable-next-line no-console

  console.log(`%c${printString}`, "background: #000; color: #fff");
}
},{"../version":"../node_modules/tone/build/esm/version.js","./context/AudioContext":"../node_modules/tone/build/esm/core/context/AudioContext.js","./context/Context":"../node_modules/tone/build/esm/core/context/Context.js","./context/DummyContext":"../node_modules/tone/build/esm/core/context/DummyContext.js","./context/OfflineContext":"../node_modules/tone/build/esm/core/context/OfflineContext.js","./util/AdvancedTypeCheck":"../node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js"}],"../node_modules/tone/build/esm/core/type/Conversions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dbToGain = dbToGain;
exports.equalPowerScale = equalPowerScale;
exports.ftom = ftom;
exports.ftomf = ftomf;
exports.gainToDb = gainToDb;
exports.getA4 = getA4;
exports.intervalToFrequencyRatio = intervalToFrequencyRatio;
exports.mtof = mtof;
exports.setA4 = setA4;

/**
 * Equal power gain scale. Good for cross-fading.
 * @param  percent (0-1)
 */
function equalPowerScale(percent) {
  const piFactor = 0.5 * Math.PI;
  return Math.sin(percent * piFactor);
}
/**
 * Convert decibels into gain.
 */


function dbToGain(db) {
  return Math.pow(10, db / 20);
}
/**
 * Convert gain to decibels.
 */


function gainToDb(gain) {
  return 20 * (Math.log(gain) / Math.LN10);
}
/**
 * Convert an interval (in semitones) to a frequency ratio.
 * @param interval the number of semitones above the base note
 * @example
 * Tone.intervalToFrequencyRatio(0); // 1
 * Tone.intervalToFrequencyRatio(12); // 2
 * Tone.intervalToFrequencyRatio(-12); // 0.5
 */


function intervalToFrequencyRatio(interval) {
  return Math.pow(2, interval / 12);
}
/**
 * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used
 * to generate all the other pitch values from notes. A4's values in Hertz.
 */


let A4 = 440;

function getA4() {
  return A4;
}

function setA4(freq) {
  A4 = freq;
}
/**
 * Convert a frequency value to a MIDI note.
 * @param frequency The value to frequency value to convert.
 * @example
 * Tone.ftom(440); // returns 69
 */


function ftom(frequency) {
  return Math.round(ftomf(frequency));
}
/**
 * Convert a frequency to a floating point midi value
 */


function ftomf(frequency) {
  return 69 + 12 * Math.log2(frequency / A4);
}
/**
 * Convert a MIDI note to frequency value.
 * @param  midi The midi number to convert.
 * @return The corresponding frequency value
 * @example
 * Tone.mtof(69); // 440
 */


function mtof(midi) {
  return A4 * Math.pow(2, (midi - 69) / 12);
}
},{}],"../node_modules/tone/build/esm/core/type/TimeBase.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimeBaseClass = void 0;

var _Tone = require("../Tone");

var _TypeCheck = require("../util/TypeCheck");

/**
 * TimeBase is a flexible encoding of time which can be evaluated to and from a string.
 */
class TimeBaseClass extends _Tone.Tone {
  /**
   * @param context The context associated with the time value. Used to compute
   * Transport and context-relative timing.
   * @param  value  The time value as a number, string or object
   * @param  units  Unit values
   */
  constructor(context, value, units) {
    super();
    /**
     * The default units
     */

    this.defaultUnits = "s";
    this._val = value;
    this._units = units;
    this.context = context;
    this._expressions = this._getExpressions();
  }
  /**
   * All of the time encoding expressions
   */


  _getExpressions() {
    return {
      hz: {
        method: value => {
          return this._frequencyToUnits(parseFloat(value));
        },
        regexp: /^(\d+(?:\.\d+)?)hz$/i
      },
      i: {
        method: value => {
          return this._ticksToUnits(parseInt(value, 10));
        },
        regexp: /^(\d+)i$/i
      },
      m: {
        method: value => {
          return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());
        },
        regexp: /^(\d+)m$/i
      },
      n: {
        method: (value, dot) => {
          const numericValue = parseInt(value, 10);
          const scalar = dot === "." ? 1.5 : 1;

          if (numericValue === 1) {
            return this._beatsToUnits(this._getTimeSignature()) * scalar;
          } else {
            return this._beatsToUnits(4 / numericValue) * scalar;
          }
        },
        regexp: /^(\d+)n(\.?)$/i
      },
      number: {
        method: value => {
          return this._expressions[this.defaultUnits].method.call(this, value);
        },
        regexp: /^(\d+(?:\.\d+)?)$/
      },
      s: {
        method: value => {
          return this._secondsToUnits(parseFloat(value));
        },
        regexp: /^(\d+(?:\.\d+)?)s$/
      },
      samples: {
        method: value => {
          return parseInt(value, 10) / this.context.sampleRate;
        },
        regexp: /^(\d+)samples$/
      },
      t: {
        method: value => {
          const numericValue = parseInt(value, 10);
          return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));
        },
        regexp: /^(\d+)t$/i
      },
      tr: {
        method: (m, q, s) => {
          let total = 0;

          if (m && m !== "0") {
            total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));
          }

          if (q && q !== "0") {
            total += this._beatsToUnits(parseFloat(q));
          }

          if (s && s !== "0") {
            total += this._beatsToUnits(parseFloat(s) / 4);
          }

          return total;
        },
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/
      }
    };
  } //-------------------------------------
  // 	VALUE OF
  //-------------------------------------

  /**
   * Evaluate the time value. Returns the time in seconds.
   */


  valueOf() {
    if (this._val instanceof TimeBaseClass) {
      this.fromType(this._val);
    }

    if ((0, _TypeCheck.isUndef)(this._val)) {
      return this._noArg();
    } else if ((0, _TypeCheck.isString)(this._val) && (0, _TypeCheck.isUndef)(this._units)) {
      for (const units in this._expressions) {
        if (this._expressions[units].regexp.test(this._val.trim())) {
          this._units = units;
          break;
        }
      }
    } else if ((0, _TypeCheck.isObject)(this._val)) {
      let total = 0;

      for (const typeName in this._val) {
        if ((0, _TypeCheck.isDefined)(this._val[typeName])) {
          const quantity = this._val[typeName]; // @ts-ignore

          const time = new this.constructor(this.context, typeName).valueOf() * quantity;
          total += time;
        }
      }

      return total;
    }

    if ((0, _TypeCheck.isDefined)(this._units)) {
      const expr = this._expressions[this._units];

      const matching = this._val.toString().trim().match(expr.regexp);

      if (matching) {
        return expr.method.apply(this, matching.slice(1));
      } else {
        return expr.method.call(this, this._val);
      }
    } else if ((0, _TypeCheck.isString)(this._val)) {
      return parseFloat(this._val);
    } else {
      return this._val;
    }
  } //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------

  /**
   * Returns the value of a frequency in the current units
   */


  _frequencyToUnits(freq) {
    return 1 / freq;
  }
  /**
   * Return the value of the beats in the current units
   */


  _beatsToUnits(beats) {
    return 60 / this._getBpm() * beats;
  }
  /**
   * Returns the value of a second in the current units
   */


  _secondsToUnits(seconds) {
    return seconds;
  }
  /**
   * Returns the value of a tick in the current time units
   */


  _ticksToUnits(ticks) {
    return ticks * this._beatsToUnits(1) / this._getPPQ();
  }
  /**
   * With no arguments, return 'now'
   */


  _noArg() {
    return this._now();
  } //-------------------------------------
  // 	TEMPO CONVERSIONS
  //-------------------------------------

  /**
   * Return the bpm
   */


  _getBpm() {
    return this.context.transport.bpm.value;
  }
  /**
   * Return the timeSignature
   */


  _getTimeSignature() {
    return this.context.transport.timeSignature;
  }
  /**
   * Return the PPQ or 192 if Transport is not available
   */


  _getPPQ() {
    return this.context.transport.PPQ;
  } //-------------------------------------
  // 	CONVERSION INTERFACE
  //-------------------------------------

  /**
   * Coerce a time type into this units type.
   * @param type Any time type units
   */


  fromType(type) {
    this._units = undefined;

    switch (this.defaultUnits) {
      case "s":
        this._val = type.toSeconds();
        break;

      case "i":
        this._val = type.toTicks();
        break;

      case "hz":
        this._val = type.toFrequency();
        break;

      case "midi":
        this._val = type.toMidi();
        break;
    }

    return this;
  }
  /**
   * Return the value in hertz
   */


  toFrequency() {
    return 1 / this.toSeconds();
  }
  /**
   * Return the time in samples
   */


  toSamples() {
    return this.toSeconds() * this.context.sampleRate;
  }
  /**
   * Return the time in milliseconds.
   */


  toMilliseconds() {
    return this.toSeconds() * 1000;
  }

}

exports.TimeBaseClass = TimeBaseClass;
},{"../Tone":"../node_modules/tone/build/esm/core/Tone.js","../util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js"}],"../node_modules/tone/build/esm/core/type/Time.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Time = Time;
exports.TimeClass = void 0;

var _Global = require("../Global");

var _Conversions = require("./Conversions");

var _TimeBase = require("./TimeBase");

/**
 * TimeClass is a primitive type for encoding and decoding Time values.
 * TimeClass can be passed into the parameter of any method which takes time as an argument.
 * @param  val    The time value.
 * @param  units  The units of the value.
 * @example
 * const time = Tone.Time("4n"); // a quarter note
 * @category Unit
 */
class TimeClass extends _TimeBase.TimeBaseClass {
  constructor() {
    super(...arguments);
    this.name = "TimeClass";
  }

  _getExpressions() {
    return Object.assign(super._getExpressions(), {
      now: {
        method: capture => {
          return this._now() + new this.constructor(this.context, capture).valueOf();
        },
        regexp: /^\+(.+)/
      },
      quantize: {
        method: capture => {
          const quantTo = new TimeClass(this.context, capture).valueOf();
          return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));
        },
        regexp: /^@(.+)/
      }
    });
  }
  /**
   * Quantize the time by the given subdivision. Optionally add a
   * percentage which will move the time value towards the ideal
   * quantized value by that percentage.
   * @param  subdiv    The subdivision to quantize to
   * @param  percent  Move the time value towards the quantized value by a percentage.
   * @example
   * Tone.Time(21).quantize(2); // returns 22
   * Tone.Time(0.6).quantize("4n", 0.5); // returns 0.55
   */


  quantize(subdiv, percent = 1) {
    const subdivision = new this.constructor(this.context, subdiv).valueOf();
    const value = this.valueOf();
    const multiple = Math.round(value / subdivision);
    const ideal = multiple * subdivision;
    const diff = ideal - value;
    return value + diff * percent;
  } //-------------------------------------
  // CONVERSIONS
  //-------------------------------------

  /**
   * Convert a Time to Notation. The notation values are will be the
   * closest representation between 1m to 128th note.
   * @return {Notation}
   * @example
   * // if the Transport is at 120bpm:
   * Tone.Time(2).toNotation(); // returns "1m"
   */


  toNotation() {
    const time = this.toSeconds();
    const testNotations = ["1m"];

    for (let power = 1; power < 9; power++) {
      const subdiv = Math.pow(2, power);
      testNotations.push(subdiv + "n.");
      testNotations.push(subdiv + "n");
      testNotations.push(subdiv + "t");
    }

    testNotations.push("0"); // find the closets notation representation

    let closest = testNotations[0];
    let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();
    testNotations.forEach(notation => {
      const notationSeconds = new TimeClass(this.context, notation).toSeconds();

      if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {
        closest = notation;
        closestSeconds = notationSeconds;
      }
    });
    return closest;
  }
  /**
   * Return the time encoded as Bars:Beats:Sixteenths.
   */


  toBarsBeatsSixteenths() {
    const quarterTime = this._beatsToUnits(1);

    let quarters = this.valueOf() / quarterTime;
    quarters = parseFloat(quarters.toFixed(4));
    const measures = Math.floor(quarters / this._getTimeSignature());
    let sixteenths = quarters % 1 * 4;
    quarters = Math.floor(quarters) % this._getTimeSignature();
    const sixteenthString = sixteenths.toString();

    if (sixteenthString.length > 3) {
      // the additional parseFloat removes insignificant trailing zeroes
      sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));
    }

    const progress = [measures, quarters, sixteenths];
    return progress.join(":");
  }
  /**
   * Return the time in ticks.
   */


  toTicks() {
    const quarterTime = this._beatsToUnits(1);

    const quarters = this.valueOf() / quarterTime;
    return Math.round(quarters * this._getPPQ());
  }
  /**
   * Return the time in seconds.
   */


  toSeconds() {
    return this.valueOf();
  }
  /**
   * Return the value as a midi note.
   */


  toMidi() {
    return (0, _Conversions.ftom)(this.toFrequency());
  }

  _now() {
    return this.context.now();
  }

}
/**
 * Create a TimeClass from a time string or number. The time is computed against the
 * global Tone.Context. To use a specific context, use [[TimeClass]]
 * @param value A value which represents time
 * @param units The value's units if they can't be inferred by the value.
 * @category Unit
 * @example
 * const time = Tone.Time("4n").toSeconds();
 * console.log(time);
 * @example
 * const note = Tone.Time(1).toNotation();
 * console.log(note);
 * @example
 * const freq = Tone.Time(0.5).toFrequency();
 * console.log(freq);
 */


exports.TimeClass = TimeClass;

function Time(value, units) {
  return new TimeClass((0, _Global.getContext)(), value, units);
}
},{"../Global":"../node_modules/tone/build/esm/core/Global.js","./Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js","./TimeBase":"../node_modules/tone/build/esm/core/type/TimeBase.js"}],"../node_modules/tone/build/esm/core/type/Frequency.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Frequency = Frequency;
exports.FrequencyClass = void 0;

var _Global = require("../Global");

var _Conversions = require("./Conversions");

var _Time = require("./Time");

/**
 * Frequency is a primitive type for encoding Frequency values.
 * Eventually all time values are evaluated to hertz using the `valueOf` method.
 * @example
 * Tone.Frequency("C3"); // 261
 * Tone.Frequency(38, "midi");
 * Tone.Frequency("C3").transpose(4);
 * @category Unit
 */
class FrequencyClass extends _Time.TimeClass {
  constructor() {
    super(...arguments);
    this.name = "Frequency";
    this.defaultUnits = "hz";
  }
  /**
   * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used
   * to generate all the other pitch values from notes. A4's values in Hertz.
   */


  static get A4() {
    return (0, _Conversions.getA4)();
  }

  static set A4(freq) {
    (0, _Conversions.setA4)(freq);
  } //-------------------------------------
  // 	AUGMENT BASE EXPRESSIONS
  //-------------------------------------


  _getExpressions() {
    return Object.assign({}, super._getExpressions(), {
      midi: {
        regexp: /^(\d+(?:\.\d+)?midi)/,

        method(value) {
          if (this.defaultUnits === "midi") {
            return value;
          } else {
            return FrequencyClass.mtof(value);
          }
        }

      },
      note: {
        regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,

        method(pitch, octave) {
          const index = noteToScaleIndex[pitch.toLowerCase()];
          const noteNumber = index + (parseInt(octave, 10) + 1) * 12;

          if (this.defaultUnits === "midi") {
            return noteNumber;
          } else {
            return FrequencyClass.mtof(noteNumber);
          }
        }

      },
      tr: {
        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,

        method(m, q, s) {
          let total = 1;

          if (m && m !== "0") {
            total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));
          }

          if (q && q !== "0") {
            total *= this._beatsToUnits(parseFloat(q));
          }

          if (s && s !== "0") {
            total *= this._beatsToUnits(parseFloat(s) / 4);
          }

          return total;
        }

      }
    });
  } //-------------------------------------
  // 	EXPRESSIONS
  //-------------------------------------

  /**
   * Transposes the frequency by the given number of semitones.
   * @return  A new transposed frequency
   * @example
   * Tone.Frequency("A4").transpose(3); // "C5"
   */


  transpose(interval) {
    return new FrequencyClass(this.context, this.valueOf() * (0, _Conversions.intervalToFrequencyRatio)(interval));
  }
  /**
   * Takes an array of semitone intervals and returns
   * an array of frequencies transposed by those intervals.
   * @return  Returns an array of Frequencies
   * @example
   * Tone.Frequency("A4").harmonize([0, 3, 7]); // ["A4", "C5", "E5"]
   */


  harmonize(intervals) {
    return intervals.map(interval => {
      return this.transpose(interval);
    });
  } //-------------------------------------
  // 	UNIT CONVERSIONS
  //-------------------------------------

  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Frequency("C4").toMidi(); // 60
   */


  toMidi() {
    return (0, _Conversions.ftom)(this.valueOf());
  }
  /**
   * Return the value of the frequency in Scientific Pitch Notation
   * @example
   * Tone.Frequency(69, "midi").toNote(); // "A4"
   */


  toNote() {
    const freq = this.toFrequency();
    const log = Math.log2(freq / FrequencyClass.A4);
    let noteNumber = Math.round(12 * log) + 57;
    const octave = Math.floor(noteNumber / 12);

    if (octave < 0) {
      noteNumber += -12 * octave;
    }

    const noteName = scaleIndexToNote[noteNumber % 12];
    return noteName + octave.toString();
  }
  /**
   * Return the duration of one cycle in seconds.
   */


  toSeconds() {
    return 1 / super.toSeconds();
  }
  /**
   * Return the duration of one cycle in ticks
   */


  toTicks() {
    const quarterTime = this._beatsToUnits(1);

    const quarters = this.valueOf() / quarterTime;
    return Math.floor(quarters * this._getPPQ());
  } //-------------------------------------
  // 	UNIT CONVERSIONS HELPERS
  //-------------------------------------

  /**
   * With no arguments, return 0
   */


  _noArg() {
    return 0;
  }
  /**
   * Returns the value of a frequency in the current units
   */


  _frequencyToUnits(freq) {
    return freq;
  }
  /**
   * Returns the value of a tick in the current time units
   */


  _ticksToUnits(ticks) {
    return 1 / (ticks * 60 / (this._getBpm() * this._getPPQ()));
  }
  /**
   * Return the value of the beats in the current units
   */


  _beatsToUnits(beats) {
    return 1 / super._beatsToUnits(beats);
  }
  /**
   * Returns the value of a second in the current units
   */


  _secondsToUnits(seconds) {
    return 1 / seconds;
  }
  /**
   * Convert a MIDI note to frequency value.
   * @param  midi The midi number to convert.
   * @return The corresponding frequency value
   */


  static mtof(midi) {
    return (0, _Conversions.mtof)(midi);
  }
  /**
   * Convert a frequency value to a MIDI note.
   * @param frequency The value to frequency value to convert.
   */


  static ftom(frequency) {
    return (0, _Conversions.ftom)(frequency);
  }

} //-------------------------------------
// 	FREQUENCY CONVERSIONS
//-------------------------------------

/**
 * Note to scale index.
 * @hidden
 */


exports.FrequencyClass = FrequencyClass;
const noteToScaleIndex = {
  cbb: -2,
  cb: -1,
  c: 0,
  "c#": 1,
  cx: 2,
  dbb: 0,
  db: 1,
  d: 2,
  "d#": 3,
  dx: 4,
  ebb: 2,
  eb: 3,
  e: 4,
  "e#": 5,
  ex: 6,
  fbb: 3,
  fb: 4,
  f: 5,
  "f#": 6,
  fx: 7,
  gbb: 5,
  gb: 6,
  g: 7,
  "g#": 8,
  gx: 9,
  abb: 7,
  ab: 8,
  a: 9,
  "a#": 10,
  ax: 11,
  bbb: 9,
  bb: 10,
  b: 11,
  "b#": 12,
  bx: 13
};
/**
 * scale index to note (sharps)
 * @hidden
 */

const scaleIndexToNote = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
/**
 * Convert a value into a FrequencyClass object.
 * @category Unit
 * @example
 * const midi = Tone.Frequency("C3").toMidi();
 * console.log(midi);
 * @example
 * const hertz = Tone.Frequency(38, "midi").toFrequency();
 * console.log(hertz);
 */

function Frequency(value, units) {
  return new FrequencyClass((0, _Global.getContext)(), value, units);
}
},{"../Global":"../node_modules/tone/build/esm/core/Global.js","./Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js","./Time":"../node_modules/tone/build/esm/core/type/Time.js"}],"../node_modules/tone/build/esm/core/type/TransportTime.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransportTime = TransportTime;
exports.TransportTimeClass = void 0;

var _Global = require("../Global");

var _Time = require("./Time");

/**
 * TransportTime is a the time along the Transport's
 * timeline. It is similar to Tone.Time, but instead of evaluating
 * against the AudioContext's clock, it is evaluated against
 * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).
 * @category Unit
 */
class TransportTimeClass extends _Time.TimeClass {
  constructor() {
    super(...arguments);
    this.name = "TransportTime";
  }
  /**
   * Return the current time in whichever context is relevant
   */


  _now() {
    return this.context.transport.seconds;
  }

}
/**
 * TransportTime is a the time along the Transport's
 * timeline. It is similar to [[Time]], but instead of evaluating
 * against the AudioContext's clock, it is evaluated against
 * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).
 * @category Unit
 */


exports.TransportTimeClass = TransportTimeClass;

function TransportTime(value, units) {
  return new TransportTimeClass((0, _Global.getContext)(), value, units);
}
},{"../Global":"../node_modules/tone/build/esm/core/Global.js","./Time":"../node_modules/tone/build/esm/core/type/Time.js"}],"../node_modules/tone/build/esm/core/context/ToneWithContext.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToneWithContext = void 0;

var _Global = require("../Global");

var _Tone = require("../Tone");

var _Frequency = require("../type/Frequency");

var _Time = require("../type/Time");

var _TransportTime = require("../type/TransportTime");

var _Defaults = require("../util/Defaults");

var _TypeCheck = require("../util/TypeCheck");

/**
 * The Base class for all nodes that have an AudioContext.
 */
class ToneWithContext extends _Tone.Tone {
  constructor() {
    super();
    const options = (0, _Defaults.optionsFromArguments)(ToneWithContext.getDefaults(), arguments, ["context"]);

    if (this.defaultContext) {
      this.context = this.defaultContext;
    } else {
      this.context = options.context;
    }
  }

  static getDefaults() {
    return {
      context: (0, _Global.getContext)()
    };
  }
  /**
   * Return the current time of the Context clock plus the lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.now());
   * }, 100);
   */


  now() {
    return this.context.currentTime + this.context.lookAhead;
  }
  /**
   * Return the current time of the Context clock without any lookAhead.
   * @example
   * setInterval(() => {
   * 	console.log(Tone.immediate());
   * }, 100);
   */


  immediate() {
    return this.context.currentTime;
  }
  /**
   * The duration in seconds of one sample.
   * @example
   * console.log(Tone.Transport.sampleTime);
   */


  get sampleTime() {
    return 1 / this.context.sampleRate;
  }
  /**
   * The number of seconds of 1 processing block (128 samples)
   * @example
   * console.log(Tone.Destination.blockTime);
   */


  get blockTime() {
    return 128 / this.context.sampleRate;
  }
  /**
   * Convert the incoming time to seconds.
   * This is calculated against the current [[Tone.Transport]] bpm
   * @example
   * const gain = new Tone.Gain();
   * setInterval(() => console.log(gain.toSeconds("4n")), 100);
   * // ramp the tempo to 60 bpm over 30 seconds
   * Tone.getTransport().bpm.rampTo(60, 30);
   */


  toSeconds(time) {
    return new _Time.TimeClass(this.context, time).toSeconds();
  }
  /**
   * Convert the input to a frequency number
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toFrequency("4n"));
   */


  toFrequency(freq) {
    return new _Frequency.FrequencyClass(this.context, freq).toFrequency();
  }
  /**
   * Convert the input time into ticks
   * @example
   * const gain = new Tone.Gain();
   * console.log(gain.toTicks("4n"));
   */


  toTicks(time) {
    return new _TransportTime.TransportTimeClass(this.context, time).toTicks();
  } //-------------------------------------
  // 	GET/SET
  //-------------------------------------

  /**
   * Get a subset of the properties which are in the partial props
   */


  _getPartialProperties(props) {
    const options = this.get(); // remove attributes from the prop that are not in the partial

    Object.keys(options).forEach(name => {
      if ((0, _TypeCheck.isUndef)(props[name])) {
        delete options[name];
      }
    });
    return options;
  }
  /**
   * Get the object's attributes.
   * @example
   * const osc = new Tone.Oscillator();
   * console.log(osc.get());
   */


  get() {
    const defaults = (0, _Defaults.getDefaultsFromInstance)(this);
    Object.keys(defaults).forEach(attribute => {
      if (Reflect.has(this, attribute)) {
        const member = this[attribute];

        if ((0, _TypeCheck.isDefined)(member) && (0, _TypeCheck.isDefined)(member.value) && (0, _TypeCheck.isDefined)(member.setValueAtTime)) {
          defaults[attribute] = member.value;
        } else if (member instanceof ToneWithContext) {
          defaults[attribute] = member._getPartialProperties(defaults[attribute]); // otherwise make sure it's a serializable type
        } else if ((0, _TypeCheck.isArray)(member) || (0, _TypeCheck.isNumber)(member) || (0, _TypeCheck.isString)(member) || (0, _TypeCheck.isBoolean)(member)) {
          defaults[attribute] = member;
        } else {
          // remove all undefined and unserializable attributes
          delete defaults[attribute];
        }
      }
    });
    return defaults;
  }
  /**
   * Set multiple properties at once with an object.
   * @example
   * const filter = new Tone.Filter().toDestination();
   * // set values using an object
   * filter.set({
   * 	frequency: "C6",
   * 	type: "highpass"
   * });
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/Analogsynth_octaves_highmid.mp3").connect(filter);
   * player.autostart = true;
   */


  set(props) {
    Object.keys(props).forEach(attribute => {
      if (Reflect.has(this, attribute) && (0, _TypeCheck.isDefined)(this[attribute])) {
        if (this[attribute] && (0, _TypeCheck.isDefined)(this[attribute].value) && (0, _TypeCheck.isDefined)(this[attribute].setValueAtTime)) {
          // small optimization
          if (this[attribute].value !== props[attribute]) {
            this[attribute].value = props[attribute];
          }
        } else if (this[attribute] instanceof ToneWithContext) {
          this[attribute].set(props[attribute]);
        } else {
          this[attribute] = props[attribute];
        }
      }
    });
    return this;
  }

}

exports.ToneWithContext = ToneWithContext;
},{"../Global":"../node_modules/tone/build/esm/core/Global.js","../Tone":"../node_modules/tone/build/esm/core/Tone.js","../type/Frequency":"../node_modules/tone/build/esm/core/type/Frequency.js","../type/Time":"../node_modules/tone/build/esm/core/type/Time.js","../type/TransportTime":"../node_modules/tone/build/esm/core/type/TransportTime.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js"}],"../node_modules/tone/build/esm/core/util/StateTimeline.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StateTimeline = void 0;

var _Timeline = require("./Timeline");

var _Debug = require("./Debug");

/**
 * A Timeline State. Provides the methods: `setStateAtTime("state", time)` and `getValueAtTime(time)`
 * @param initial The initial state of the StateTimeline.  Defaults to `undefined`
 */
class StateTimeline extends _Timeline.Timeline {
  constructor(initial = "stopped") {
    super();
    this.name = "StateTimeline";
    this._initial = initial;
    this.setStateAtTime(this._initial, 0);
  }
  /**
   * Returns the scheduled state scheduled before or at
   * the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   */


  getValueAtTime(time) {
    const event = this.get(time);

    if (event !== null) {
      return event.state;
    } else {
      return this._initial;
    }
  }
  /**
   * Add a state to the timeline.
   * @param  state The name of the state to set.
   * @param  time  The time to query.
   * @param options Any additional options that are needed in the timeline.
   */


  setStateAtTime(state, time, options) {
    (0, _Debug.assertRange)(time, 0);
    this.add(Object.assign({}, options, {
      state,
      time
    }));
    return this;
  }
  /**
   * Return the event before the time with the given state
   * @param  state The state to look for
   * @param  time  When to check before
   * @return  The event with the given state before the time
   */


  getLastState(state, time) {
    // time = this.toSeconds(time);
    const index = this._search(time);

    for (let i = index; i >= 0; i--) {
      const event = this._timeline[i];

      if (event.state === state) {
        return event;
      }
    }
  }
  /**
   * Return the event after the time with the given state
   * @param  state The state to look for
   * @param  time  When to check from
   * @return  The event with the given state after the time
   */


  getNextState(state, time) {
    // time = this.toSeconds(time);
    const index = this._search(time);

    if (index !== -1) {
      for (let i = index; i < this._timeline.length; i++) {
        const event = this._timeline[i];

        if (event.state === state) {
          return event;
        }
      }
    }
  }

}

exports.StateTimeline = StateTimeline;
},{"./Timeline":"../node_modules/tone/build/esm/core/util/Timeline.js","./Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/core/context/Param.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Param = void 0;

var _Conversions = require("../type/Conversions");

var _AdvancedTypeCheck = require("../util/AdvancedTypeCheck");

var _Defaults = require("../util/Defaults");

var _Timeline = require("../util/Timeline");

var _TypeCheck = require("../util/TypeCheck");

var _ToneWithContext = require("./ToneWithContext");

var _Math = require("../util/Math");

var _Debug = require("../util/Debug");

/**
 * Param wraps the native Web Audio's AudioParam to provide
 * additional unit conversion functionality. It also
 * serves as a base-class for classes which have a single,
 * automatable parameter.
 * @category Core
 */
class Param extends _ToneWithContext.ToneWithContext {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Param.getDefaults(), arguments, ["param", "units", "convert"]));
    this.name = "Param";
    this.overridden = false;
    /**
     * The minimum output value
     */

    this._minOutput = 1e-7;
    const options = (0, _Defaults.optionsFromArguments)(Param.getDefaults(), arguments, ["param", "units", "convert"]);
    (0, _Debug.assert)((0, _TypeCheck.isDefined)(options.param) && ((0, _AdvancedTypeCheck.isAudioParam)(options.param) || options.param instanceof Param), "param must be an AudioParam");

    while (!(0, _AdvancedTypeCheck.isAudioParam)(options.param)) {
      options.param = options.param._param;
    }

    this._swappable = (0, _TypeCheck.isDefined)(options.swappable) ? options.swappable : false;

    if (this._swappable) {
      this.input = this.context.createGain(); // initialize

      this._param = options.param;
      this.input.connect(this._param);
    } else {
      this._param = this.input = options.param;
    }

    this._events = new _Timeline.Timeline(1000);
    this._initialValue = this._param.defaultValue;
    this.units = options.units;
    this.convert = options.convert;
    this._minValue = options.minValue;
    this._maxValue = options.maxValue; // if the value is defined, set it immediately

    if ((0, _TypeCheck.isDefined)(options.value) && options.value !== this._toType(this._initialValue)) {
      this.setValueAtTime(options.value, 0);
    }
  }

  static getDefaults() {
    return Object.assign(_ToneWithContext.ToneWithContext.getDefaults(), {
      convert: true,
      units: "number"
    });
  }

  get value() {
    const now = this.now();
    return this.getValueAtTime(now);
  }

  set value(value) {
    this.cancelScheduledValues(this.now());
    this.setValueAtTime(value, this.now());
  }

  get minValue() {
    // if it's not the default minValue, return it
    if ((0, _TypeCheck.isDefined)(this._minValue)) {
      return this._minValue;
    } else if (this.units === "time" || this.units === "frequency" || this.units === "normalRange" || this.units === "positive" || this.units === "transportTime" || this.units === "ticks" || this.units === "bpm" || this.units === "hertz" || this.units === "samples") {
      return 0;
    } else if (this.units === "audioRange") {
      return -1;
    } else if (this.units === "decibels") {
      return -Infinity;
    } else {
      return this._param.minValue;
    }
  }

  get maxValue() {
    if ((0, _TypeCheck.isDefined)(this._maxValue)) {
      return this._maxValue;
    } else if (this.units === "normalRange" || this.units === "audioRange") {
      return 1;
    } else {
      return this._param.maxValue;
    }
  }
  /**
   * Type guard based on the unit name
   */


  _is(arg, type) {
    return this.units === type;
  }
  /**
   * Make sure the value is always in the defined range
   */


  _assertRange(value) {
    if ((0, _TypeCheck.isDefined)(this.maxValue) && (0, _TypeCheck.isDefined)(this.minValue)) {
      (0, _Debug.assertRange)(value, this._fromType(this.minValue), this._fromType(this.maxValue));
    }

    return value;
  }
  /**
   * Convert the given value from the type specified by Param.units
   * into the destination value (such as Gain or Frequency).
   */


  _fromType(val) {
    if (this.convert && !this.overridden) {
      if (this._is(val, "time")) {
        return this.toSeconds(val);
      } else if (this._is(val, "decibels")) {
        return (0, _Conversions.dbToGain)(val);
      } else if (this._is(val, "frequency")) {
        return this.toFrequency(val);
      } else {
        return val;
      }
    } else if (this.overridden) {
      // if it's overridden, should only schedule 0s
      return 0;
    } else {
      return val;
    }
  }
  /**
   * Convert the parameters value into the units specified by Param.units.
   */


  _toType(val) {
    if (this.convert && this.units === "decibels") {
      return (0, _Conversions.gainToDb)(val);
    } else {
      return val;
    }
  } //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // all docs are generated from ParamInterface.ts
  //-------------------------------------


  setValueAtTime(value, time) {
    const computedTime = this.toSeconds(time);

    const numericValue = this._fromType(value);

    (0, _Debug.assert)(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);

    this._assertRange(numericValue);

    this.log(this.units, "setValueAtTime", value, computedTime);

    this._events.add({
      time: computedTime,
      type: "setValueAtTime",
      value: numericValue
    });

    this._param.setValueAtTime(numericValue, computedTime);

    return this;
  }

  getValueAtTime(time) {
    const computedTime = Math.max(this.toSeconds(time), 0);

    const after = this._events.getAfter(computedTime);

    const before = this._events.get(computedTime);

    let value = this._initialValue; // if it was set by

    if (before === null) {
      value = this._initialValue;
    } else if (before.type === "setTargetAtTime" && (after === null || after.type === "setValueAtTime")) {
      const previous = this._events.getBefore(before.time);

      let previousVal;

      if (previous === null) {
        previousVal = this._initialValue;
      } else {
        previousVal = previous.value;
      }

      if (before.type === "setTargetAtTime") {
        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);
      }
    } else if (after === null) {
      value = before.value;
    } else if (after.type === "linearRampToValueAtTime" || after.type === "exponentialRampToValueAtTime") {
      let beforeValue = before.value;

      if (before.type === "setTargetAtTime") {
        const previous = this._events.getBefore(before.time);

        if (previous === null) {
          beforeValue = this._initialValue;
        } else {
          beforeValue = previous.value;
        }
      }

      if (after.type === "linearRampToValueAtTime") {
        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
      } else {
        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);
      }
    } else {
      value = before.value;
    }

    return this._toType(value);
  }

  setRampPoint(time) {
    time = this.toSeconds(time);
    let currentVal = this.getValueAtTime(time);
    this.cancelAndHoldAtTime(time);

    if (this._fromType(currentVal) === 0) {
      currentVal = this._toType(this._minOutput);
    }

    this.setValueAtTime(currentVal, time);
    return this;
  }

  linearRampToValueAtTime(value, endTime) {
    const numericValue = this._fromType(value);

    const computedTime = this.toSeconds(endTime);
    (0, _Debug.assert)(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);

    this._assertRange(numericValue);

    this._events.add({
      time: computedTime,
      type: "linearRampToValueAtTime",
      value: numericValue
    });

    this.log(this.units, "linearRampToValueAtTime", value, computedTime);

    this._param.linearRampToValueAtTime(numericValue, computedTime);

    return this;
  }

  exponentialRampToValueAtTime(value, endTime) {
    let numericValue = this._fromType(value); // the value can't be 0


    numericValue = (0, _Math.EQ)(numericValue, 0) ? this._minOutput : numericValue;

    this._assertRange(numericValue);

    const computedTime = this.toSeconds(endTime);
    (0, _Debug.assert)(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`); // store the event

    this._events.add({
      time: computedTime,
      type: "exponentialRampToValueAtTime",
      value: numericValue
    });

    this.log(this.units, "exponentialRampToValueAtTime", value, computedTime);

    this._param.exponentialRampToValueAtTime(numericValue, computedTime);

    return this;
  }

  exponentialRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
    return this;
  }

  linearRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
    return this;
  }

  targetRampTo(value, rampTime, startTime) {
    startTime = this.toSeconds(startTime);
    this.setRampPoint(startTime);
    this.exponentialApproachValueAtTime(value, startTime, rampTime);
    return this;
  }

  exponentialApproachValueAtTime(value, time, rampTime) {
    time = this.toSeconds(time);
    rampTime = this.toSeconds(rampTime);
    const timeConstant = Math.log(rampTime + 1) / Math.log(200);
    this.setTargetAtTime(value, time, timeConstant); // at 90% start a linear ramp to the final value

    this.cancelAndHoldAtTime(time + rampTime * 0.9);
    this.linearRampToValueAtTime(value, time + rampTime);
    return this;
  }

  setTargetAtTime(value, startTime, timeConstant) {
    const numericValue = this._fromType(value); // The value will never be able to approach without timeConstant > 0.


    (0, _Debug.assert)(isFinite(timeConstant) && timeConstant > 0, "timeConstant must be a number greater than 0");
    const computedTime = this.toSeconds(startTime);

    this._assertRange(numericValue);

    (0, _Debug.assert)(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);

    this._events.add({
      constant: timeConstant,
      time: computedTime,
      type: "setTargetAtTime",
      value: numericValue
    });

    this.log(this.units, "setTargetAtTime", value, computedTime, timeConstant);

    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);

    return this;
  }

  setValueCurveAtTime(values, startTime, duration, scaling = 1) {
    duration = this.toSeconds(duration);
    startTime = this.toSeconds(startTime);
    const startingValue = this._fromType(values[0]) * scaling;
    this.setValueAtTime(this._toType(startingValue), startTime);
    const segTime = duration / (values.length - 1);

    for (let i = 1; i < values.length; i++) {
      const numericValue = this._fromType(values[i]) * scaling;
      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);
    }

    return this;
  }

  cancelScheduledValues(time) {
    const computedTime = this.toSeconds(time);
    (0, _Debug.assert)(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);

    this._events.cancel(computedTime);

    this._param.cancelScheduledValues(computedTime);

    this.log(this.units, "cancelScheduledValues", computedTime);
    return this;
  }

  cancelAndHoldAtTime(time) {
    const computedTime = this.toSeconds(time);

    const valueAtTime = this._fromType(this.getValueAtTime(computedTime)); // remove the schedule events


    (0, _Debug.assert)(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);
    this.log(this.units, "cancelAndHoldAtTime", computedTime, "value=" + valueAtTime); // if there is an event at the given computedTime
    // and that even is not a "set"

    const before = this._events.get(computedTime);

    const after = this._events.getAfter(computedTime);

    if (before && (0, _Math.EQ)(before.time, computedTime)) {
      // remove everything after
      if (after) {
        this._param.cancelScheduledValues(after.time);

        this._events.cancel(after.time);
      } else {
        this._param.cancelAndHoldAtTime(computedTime);

        this._events.cancel(computedTime + this.sampleTime);
      }
    } else if (after) {
      this._param.cancelScheduledValues(after.time); // cancel the next event(s)


      this._events.cancel(after.time);

      if (after.type === "linearRampToValueAtTime") {
        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);
      } else if (after.type === "exponentialRampToValueAtTime") {
        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);
      }
    } // set the value at the given time


    this._events.add({
      time: computedTime,
      type: "setValueAtTime",
      value: valueAtTime
    });

    this._param.setValueAtTime(valueAtTime, computedTime);

    return this;
  }

  rampTo(value, rampTime = 0.1, startTime) {
    if (this.units === "frequency" || this.units === "bpm" || this.units === "decibels") {
      this.exponentialRampTo(value, rampTime, startTime);
    } else {
      this.linearRampTo(value, rampTime, startTime);
    }

    return this;
  }
  /**
   * Apply all of the previously scheduled events to the passed in Param or AudioParam.
   * The applied values will start at the context's current time and schedule
   * all of the events which are scheduled on this Param onto the passed in param.
   */


  apply(param) {
    const now = this.context.currentTime; // set the param's value at the current time and schedule everything else

    param.setValueAtTime(this.getValueAtTime(now), now); // if the previous event was a curve, then set the rest of it

    const previousEvent = this._events.get(now);

    if (previousEvent && previousEvent.type === "setTargetAtTime") {
      // approx it until the next event with linear ramps
      const nextEvent = this._events.getAfter(previousEvent.time); // or for 2 seconds if there is no event


      const endTime = nextEvent ? nextEvent.time : now + 2;
      const subdivisions = (endTime - now) / 10;

      for (let i = now; i < endTime; i += subdivisions) {
        param.linearRampToValueAtTime(this.getValueAtTime(i), i);
      }
    }

    this._events.forEachAfter(this.context.currentTime, event => {
      if (event.type === "cancelScheduledValues") {
        param.cancelScheduledValues(event.time);
      } else if (event.type === "setTargetAtTime") {
        param.setTargetAtTime(event.value, event.time, event.constant);
      } else {
        param[event.type](event.value, event.time);
      }
    });

    return this;
  }
  /**
   * Replace the Param's internal AudioParam. Will apply scheduled curves
   * onto the parameter and replace the connections.
   */


  setParam(param) {
    (0, _Debug.assert)(this._swappable, "The Param must be assigned as 'swappable' in the constructor");
    const input = this.input;
    input.disconnect(this._param);
    this.apply(param);
    this._param = param;
    input.connect(this._param);
    return this;
  }

  dispose() {
    super.dispose();

    this._events.dispose();

    return this;
  }

  get defaultValue() {
    return this._toType(this._param.defaultValue);
  } //-------------------------------------
  // 	AUTOMATION CURVE CALCULATIONS
  // 	MIT License, copyright (c) 2014 Jordan Santell
  //-------------------------------------
  // Calculates the the value along the curve produced by setTargetAtTime


  _exponentialApproach(t0, v0, v1, timeConstant, t) {
    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);
  } // Calculates the the value along the curve produced by linearRampToValueAtTime


  _linearInterpolate(t0, v0, t1, v1, t) {
    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));
  } // Calculates the the value along the curve produced by exponentialRampToValueAtTime


  _exponentialInterpolate(t0, v0, t1, v1, t) {
    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));
  }

}

exports.Param = Param;
},{"../type/Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js","../util/AdvancedTypeCheck":"../node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../util/Timeline":"../node_modules/tone/build/esm/core/util/Timeline.js","../util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","./ToneWithContext":"../node_modules/tone/build/esm/core/context/ToneWithContext.js","../util/Math":"../node_modules/tone/build/esm/core/util/Math.js","../util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/core/context/ToneAudioNode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToneAudioNode = void 0;
exports.connect = connect;
exports.connectSeries = connectSeries;
exports.disconnect = disconnect;

var _AdvancedTypeCheck = require("../util/AdvancedTypeCheck");

var _TypeCheck = require("../util/TypeCheck");

var _Param = require("./Param");

var _ToneWithContext = require("./ToneWithContext");

var _Debug = require("../util/Debug");

/**
 * ToneAudioNode is the base class for classes which process audio.
 */
class ToneAudioNode extends _ToneWithContext.ToneWithContext {
  constructor() {
    super(...arguments);
    /**
     * The name of the class
     */

    this.name = "ToneAudioNode";
    /**
     * List all of the node that must be set to match the ChannelProperties
     */

    this._internalChannels = [];
  }
  /**
   * The number of inputs feeding into the AudioNode.
   * For source nodes, this will be 0.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfInputs);
   */


  get numberOfInputs() {
    if ((0, _TypeCheck.isDefined)(this.input)) {
      if ((0, _AdvancedTypeCheck.isAudioParam)(this.input) || this.input instanceof _Param.Param) {
        return 1;
      } else {
        return this.input.numberOfInputs;
      }
    } else {
      return 0;
    }
  }
  /**
   * The number of outputs of the AudioNode.
   * @example
   * const node = new Tone.Gain();
   * console.log(node.numberOfOutputs);
   */


  get numberOfOutputs() {
    if ((0, _TypeCheck.isDefined)(this.output)) {
      return this.output.numberOfOutputs;
    } else {
      return 0;
    }
  } //-------------------------------------
  // AUDIO PROPERTIES
  //-------------------------------------

  /**
   * Used to decide which nodes to get/set properties on
   */


  _isAudioNode(node) {
    return (0, _TypeCheck.isDefined)(node) && (node instanceof ToneAudioNode || (0, _AdvancedTypeCheck.isAudioNode)(node));
  }
  /**
   * Get all of the audio nodes (either internal or input/output) which together
   * make up how the class node responds to channel input/output
   */


  _getInternalNodes() {
    const nodeList = this._internalChannels.slice(0);

    if (this._isAudioNode(this.input)) {
      nodeList.push(this.input);
    }

    if (this._isAudioNode(this.output)) {
      if (this.input !== this.output) {
        nodeList.push(this.output);
      }
    }

    return nodeList;
  }
  /**
   * Set the audio options for this node such as channelInterpretation
   * channelCount, etc.
   * @param options
   */


  _setChannelProperties(options) {
    const nodeList = this._getInternalNodes();

    nodeList.forEach(node => {
      node.channelCount = options.channelCount;
      node.channelCountMode = options.channelCountMode;
      node.channelInterpretation = options.channelInterpretation;
    });
  }
  /**
   * Get the current audio options for this node such as channelInterpretation
   * channelCount, etc.
   */


  _getChannelProperties() {
    const nodeList = this._getInternalNodes();

    (0, _Debug.assert)(nodeList.length > 0, "ToneAudioNode does not have any internal nodes"); // use the first node to get properties
    // they should all be the same

    const node = nodeList[0];
    return {
      channelCount: node.channelCount,
      channelCountMode: node.channelCountMode,
      channelInterpretation: node.channelInterpretation
    };
  }
  /**
   * channelCount is the number of channels used when up-mixing and down-mixing
   * connections to any inputs to the node. The default value is 2 except for
   * specific nodes where its value is specially determined.
   */


  get channelCount() {
    return this._getChannelProperties().channelCount;
  }

  set channelCount(channelCount) {
    const props = this._getChannelProperties(); // merge it with the other properties


    this._setChannelProperties(Object.assign(props, {
      channelCount
    }));
  }
  /**
   * channelCountMode determines how channels will be counted when up-mixing and
   * down-mixing connections to any inputs to the node.
   * The default value is "max". This attribute has no effect for nodes with no inputs.
   * * "max" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.
   * * "clamped-max" - computedNumberOfChannels is determined as for "max" and then clamped to a maximum value of the given channelCount.
   * * "explicit" - computedNumberOfChannels is the exact value as specified by the channelCount.
   */


  get channelCountMode() {
    return this._getChannelProperties().channelCountMode;
  }

  set channelCountMode(channelCountMode) {
    const props = this._getChannelProperties(); // merge it with the other properties


    this._setChannelProperties(Object.assign(props, {
      channelCountMode
    }));
  }
  /**
   * channelInterpretation determines how individual channels will be treated
   * when up-mixing and down-mixing connections to any inputs to the node.
   * The default value is "speakers".
   */


  get channelInterpretation() {
    return this._getChannelProperties().channelInterpretation;
  }

  set channelInterpretation(channelInterpretation) {
    const props = this._getChannelProperties(); // merge it with the other properties


    this._setChannelProperties(Object.assign(props, {
      channelInterpretation
    }));
  } //-------------------------------------
  // CONNECTIONS
  //-------------------------------------

  /**
   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode
   * @param destination The output to connect to
   * @param outputNum The output to connect from
   * @param inputNum The input to connect to
   */


  connect(destination, outputNum = 0, inputNum = 0) {
    connect(this, destination, outputNum, inputNum);
    return this;
  }
  /**
   * Connect the output to the context's destination node.
   * @example
   * const osc = new Tone.Oscillator("C2").start();
   * osc.toDestination();
   */


  toDestination() {
    this.connect(this.context.destination);
    return this;
  }
  /**
   * Connect the output to the context's destination node.
   * See [[toDestination]]
   * @deprecated
   */


  toMaster() {
    (0, _Debug.warn)("toMaster() has been renamed toDestination()");
    return this.toDestination();
  }
  /**
   * disconnect the output
   */


  disconnect(destination, outputNum = 0, inputNum = 0) {
    disconnect(this, destination, outputNum, inputNum);
    return this;
  }
  /**
   * Connect the output of this node to the rest of the nodes in series.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3");
   * player.autostart = true;
   * const filter = new Tone.AutoFilter(4).start();
   * const distortion = new Tone.Distortion(0.5);
   * // connect the player to the filter, distortion and then to the master output
   * player.chain(filter, distortion, Tone.Destination);
   */


  chain(...nodes) {
    connectSeries(this, ...nodes);
    return this;
  }
  /**
   * connect the output of this node to the rest of the nodes in parallel.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3");
   * player.autostart = true;
   * const pitchShift = new Tone.PitchShift(4).toDestination();
   * const filter = new Tone.Filter("G5").toDestination();
   * // connect a node to the pitch shift and filter in parallel
   * player.fan(pitchShift, filter);
   */


  fan(...nodes) {
    nodes.forEach(node => this.connect(node));
    return this;
  }
  /**
   * Dispose and disconnect
   */


  dispose() {
    super.dispose();

    if ((0, _TypeCheck.isDefined)(this.input)) {
      if (this.input instanceof ToneAudioNode) {
        this.input.dispose();
      } else if ((0, _AdvancedTypeCheck.isAudioNode)(this.input)) {
        this.input.disconnect();
      }
    }

    if ((0, _TypeCheck.isDefined)(this.output)) {
      if (this.output instanceof ToneAudioNode) {
        this.output.dispose();
      } else if ((0, _AdvancedTypeCheck.isAudioNode)(this.output)) {
        this.output.disconnect();
      }
    }

    this._internalChannels = [];
    return this;
  }

} //-------------------------------------
// CONNECTIONS
//-------------------------------------

/**
 * connect together all of the arguments in series
 * @param nodes
 */


exports.ToneAudioNode = ToneAudioNode;

function connectSeries(...nodes) {
  const first = nodes.shift();
  nodes.reduce((prev, current) => {
    if (prev instanceof ToneAudioNode) {
      prev.connect(current);
    } else if ((0, _AdvancedTypeCheck.isAudioNode)(prev)) {
      connect(prev, current);
    }

    return current;
  }, first);
}
/**
 * Connect two nodes together so that signal flows from the
 * first node to the second. Optionally specify the input and output channels.
 * @param srcNode The source node
 * @param dstNode The destination node
 * @param outputNumber The output channel of the srcNode
 * @param inputNumber The input channel of the dstNode
 */


function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
  (0, _Debug.assert)((0, _TypeCheck.isDefined)(srcNode), "Cannot connect from undefined node");
  (0, _Debug.assert)((0, _TypeCheck.isDefined)(dstNode), "Cannot connect to undefined node");

  if (dstNode instanceof ToneAudioNode || (0, _AdvancedTypeCheck.isAudioNode)(dstNode)) {
    (0, _Debug.assert)(dstNode.numberOfInputs > 0, "Cannot connect to node with no inputs");
  }

  (0, _Debug.assert)(srcNode.numberOfOutputs > 0, "Cannot connect from node with no outputs"); // resolve the input of the dstNode

  while (dstNode instanceof ToneAudioNode || dstNode instanceof _Param.Param) {
    if ((0, _TypeCheck.isDefined)(dstNode.input)) {
      dstNode = dstNode.input;
    }
  }

  while (srcNode instanceof ToneAudioNode) {
    if ((0, _TypeCheck.isDefined)(srcNode.output)) {
      srcNode = srcNode.output;
    }
  } // make the connection


  if ((0, _AdvancedTypeCheck.isAudioParam)(dstNode)) {
    srcNode.connect(dstNode, outputNumber);
  } else {
    srcNode.connect(dstNode, outputNumber, inputNumber);
  }
}
/**
 * Disconnect a node from all nodes or optionally include a destination node and input/output channels.
 * @param srcNode The source node
 * @param dstNode The destination node
 * @param outputNumber The output channel of the srcNode
 * @param inputNumber The input channel of the dstNode
 */


function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {
  // resolve the destination node
  if ((0, _TypeCheck.isDefined)(dstNode)) {
    while (dstNode instanceof ToneAudioNode) {
      dstNode = dstNode.input;
    }
  } // resolve the src node


  while (!(0, _AdvancedTypeCheck.isAudioNode)(srcNode)) {
    if ((0, _TypeCheck.isDefined)(srcNode.output)) {
      srcNode = srcNode.output;
    }
  }

  if ((0, _AdvancedTypeCheck.isAudioParam)(dstNode)) {
    srcNode.disconnect(dstNode, outputNumber);
  } else if ((0, _AdvancedTypeCheck.isAudioNode)(dstNode)) {
    srcNode.disconnect(dstNode, outputNumber, inputNumber);
  } else {
    srcNode.disconnect();
  }
}
},{"../util/AdvancedTypeCheck":"../node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js","../util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","./Param":"../node_modules/tone/build/esm/core/context/Param.js","./ToneWithContext":"../node_modules/tone/build/esm/core/context/ToneWithContext.js","../util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/core/context/Gain.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Gain = void 0;

var _Param = require("../context/Param");

var _Defaults = require("../util/Defaults");

var _Interface = require("../util/Interface");

var _ToneAudioNode = require("./ToneAudioNode");

/**
 * A thin wrapper around the Native Web Audio GainNode.
 * The GainNode is a basic building block of the Web Audio
 * API and is useful for routing audio and adjusting gains.
 * @category Core
 * @example
 * return Tone.Offline(() => {
 * 	const gainNode = new Tone.Gain(0).toDestination();
 * 	const osc = new Tone.Oscillator(30).connect(gainNode).start();
 * 	gainNode.gain.rampTo(1, 0.1);
 * 	gainNode.gain.rampTo(0, 0.4, 0.2);
 * }, 0.7, 1);
 */
class Gain extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Gain.getDefaults(), arguments, ["gain", "units"]));
    this.name = "Gain";
    /**
     * The wrapped GainNode.
     */

    this._gainNode = this.context.createGain(); // input = output

    this.input = this._gainNode;
    this.output = this._gainNode;
    const options = (0, _Defaults.optionsFromArguments)(Gain.getDefaults(), arguments, ["gain", "units"]);
    this.gain = new _Param.Param({
      context: this.context,
      convert: options.convert,
      param: this._gainNode.gain,
      units: options.units,
      value: options.gain,
      minValue: options.minValue,
      maxValue: options.maxValue
    });
    (0, _Interface.readOnly)(this, "gain");
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      convert: true,
      gain: 1,
      units: "gain"
    });
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();

    this._gainNode.disconnect();

    this.gain.dispose();
    return this;
  }

}

exports.Gain = Gain;
},{"../context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","./ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js"}],"../node_modules/tone/build/esm/source/OneShotSource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OneShotSource = void 0;

var _Gain = require("../core/context/Gain");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Interface = require("../core/util/Interface");

var _Debug = require("../core/util/Debug");

/**
 * Base class for fire-and-forget nodes
 */
class OneShotSource extends _ToneAudioNode.ToneAudioNode {
  constructor(options) {
    super(options);
    /**
     * The callback to invoke after the
     * source is done playing.
     */

    this.onended = _Interface.noOp;
    /**
     * The start time
     */

    this._startTime = -1;
    /**
     * The stop time
     */

    this._stopTime = -1;
    /**
     * The id of the timeout
     */

    this._timeout = -1;
    /**
     * The public output node
     */

    this.output = new _Gain.Gain({
      context: this.context,
      gain: 0
    });
    /**
     * The output gain node.
     */

    this._gainNode = this.output;
    /**
     * Get the playback state at the given time
     */

    this.getStateAtTime = function (time) {
      const computedTime = this.toSeconds(time);

      if (this._startTime !== -1 && computedTime >= this._startTime && (this._stopTime === -1 || computedTime <= this._stopTime)) {
        return "started";
      } else {
        return "stopped";
      }
    };

    this._fadeIn = options.fadeIn;
    this._fadeOut = options.fadeOut;
    this._curve = options.curve;
    this.onended = options.onended;
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      curve: "linear",
      fadeIn: 0,
      fadeOut: 0,
      onended: _Interface.noOp
    });
  }
  /**
   * Start the source at the given time
   * @param  time When to start the source
   */


  _startGain(time, gain = 1) {
    (0, _Debug.assert)(this._startTime === -1, "Source cannot be started more than once"); // apply a fade in envelope

    const fadeInTime = this.toSeconds(this._fadeIn); // record the start time

    this._startTime = time + fadeInTime;
    this._startTime = Math.max(this._startTime, this.context.currentTime); // schedule the envelope

    if (fadeInTime > 0) {
      this._gainNode.gain.setValueAtTime(0, time);

      if (this._curve === "linear") {
        this._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);
      } else {
        this._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);
      }
    } else {
      this._gainNode.gain.setValueAtTime(gain, time);
    }

    return this;
  }
  /**
   * Stop the source node at the given time.
   * @param time When to stop the source
   */


  stop(time) {
    this.log("stop", time);

    this._stopGain(this.toSeconds(time));

    return this;
  }
  /**
   * Stop the source at the given time
   * @param  time When to stop the source
   */


  _stopGain(time) {
    (0, _Debug.assert)(this._startTime !== -1, "'start' must be called before 'stop'"); // cancel the previous stop

    this.cancelStop(); // the fadeOut time

    const fadeOutTime = this.toSeconds(this._fadeOut); // schedule the stop callback

    this._stopTime = this.toSeconds(time) + fadeOutTime;
    this._stopTime = Math.max(this._stopTime, this.context.currentTime);

    if (fadeOutTime > 0) {
      // start the fade out curve at the given time
      if (this._curve === "linear") {
        this._gainNode.gain.linearRampTo(0, fadeOutTime, time);
      } else {
        this._gainNode.gain.targetRampTo(0, fadeOutTime, time);
      }
    } else {
      // stop any ongoing ramps, and set the value to 0
      this._gainNode.gain.cancelAndHoldAtTime(time);

      this._gainNode.gain.setValueAtTime(0, time);
    }

    this.context.clearTimeout(this._timeout);
    this._timeout = this.context.setTimeout(() => {
      // allow additional time for the exponential curve to fully decay
      const additionalTail = this._curve === "exponential" ? fadeOutTime * 2 : 0;

      this._stopSource(this.now() + additionalTail);

      this._onended();
    }, this._stopTime - this.context.currentTime);
    return this;
  }
  /**
   * Invoke the onended callback
   */


  _onended() {
    if (this.onended !== _Interface.noOp) {
      this.onended(this); // overwrite onended to make sure it only is called once

      this.onended = _Interface.noOp; // dispose when it's ended to free up for garbage collection only in the online context

      if (!this.context.isOffline) {
        const disposeCallback = () => this.dispose(); // @ts-ignore


        if (typeof window.requestIdleCallback !== "undefined") {
          // @ts-ignore
          window.requestIdleCallback(disposeCallback);
        } else {
          setTimeout(disposeCallback, 1000);
        }
      }
    }
  }
  /**
   * Get the playback state at the current time
   */


  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Cancel a scheduled stop event
   */


  cancelStop() {
    this.log("cancelStop");
    (0, _Debug.assert)(this._startTime !== -1, "Source is not started"); // cancel the stop envelope

    this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);

    this.context.clearTimeout(this._timeout);
    this._stopTime = -1;
    return this;
  }

  dispose() {
    super.dispose();

    this._gainNode.disconnect();

    return this;
  }

}

exports.OneShotSource = OneShotSource;
},{"../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/signal/ToneConstantSource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToneConstantSource = void 0;

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Param = require("../core/context/Param");

var _Defaults = require("../core/util/Defaults");

var _OneShotSource = require("../source/OneShotSource");

/**
 * Wrapper around the native fire-and-forget ConstantSource.
 * Adds the ability to reschedule the stop method.
 * @category Signal
 */
class ToneConstantSource extends _OneShotSource.OneShotSource {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(ToneConstantSource.getDefaults(), arguments, ["offset"]));
    this.name = "ToneConstantSource";
    /**
     * The signal generator
     */

    this._source = this.context.createConstantSource();
    const options = (0, _Defaults.optionsFromArguments)(ToneConstantSource.getDefaults(), arguments, ["offset"]);
    (0, _ToneAudioNode.connect)(this._source, this._gainNode);
    this.offset = new _Param.Param({
      context: this.context,
      convert: options.convert,
      param: this._source.offset,
      units: options.units,
      value: options.offset,
      minValue: options.minValue,
      maxValue: options.maxValue
    });
  }

  static getDefaults() {
    return Object.assign(_OneShotSource.OneShotSource.getDefaults(), {
      convert: true,
      offset: 1,
      units: "number"
    });
  }
  /**
   * Start the source node at the given time
   * @param  time When to start the source
   */


  start(time) {
    const computedTime = this.toSeconds(time);
    this.log("start", computedTime);

    this._startGain(computedTime);

    this._source.start(computedTime);

    return this;
  }

  _stopSource(time) {
    this._source.stop(time);
  }

  dispose() {
    super.dispose();

    if (this.state === "started") {
      this.stop();
    }

    this._source.disconnect();

    this.offset.dispose();
    return this;
  }

}

exports.ToneConstantSource = ToneConstantSource;
},{"../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../source/OneShotSource":"../node_modules/tone/build/esm/source/OneShotSource.js"}],"../node_modules/tone/build/esm/signal/Signal.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Signal = void 0;
exports.connectSignal = connectSignal;

var _Param = require("../core/context/Param");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _AdvancedTypeCheck = require("../core/util/AdvancedTypeCheck");

var _Defaults = require("../core/util/Defaults");

var _ToneConstantSource = require("./ToneConstantSource");

/**
 * A signal is an audio-rate value. Tone.Signal is a core component of the library.
 * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal
 * has all of the methods available to native Web Audio
 * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)
 * as well as additional conveniences. Read more about working with signals
 * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).
 *
 * @example
 * const osc = new Tone.Oscillator().toDestination().start();
 * // a scheduleable signal which can be connected to control an AudioParam or another Signal
 * const signal = new Tone.Signal({
 * 	value: "C4",
 * 	units: "frequency"
 * }).connect(osc.frequency);
 * // the scheduled ramp controls the connected signal
 * signal.rampTo("C2", 4, "+0.5");
 * @category Signal
 */
class Signal extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Signal.getDefaults(), arguments, ["value", "units"]));
    this.name = "Signal";
    /**
     * Indicates if the value should be overridden on connection.
     */

    this.override = true;
    const options = (0, _Defaults.optionsFromArguments)(Signal.getDefaults(), arguments, ["value", "units"]);
    this.output = this._constantSource = new _ToneConstantSource.ToneConstantSource({
      context: this.context,
      convert: options.convert,
      offset: options.value,
      units: options.units,
      minValue: options.minValue,
      maxValue: options.maxValue
    });

    this._constantSource.start(0);

    this.input = this._param = this._constantSource.offset;
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      convert: true,
      units: "number",
      value: 0
    });
  }

  connect(destination, outputNum = 0, inputNum = 0) {
    // start it only when connected to something
    connectSignal(this, destination, outputNum, inputNum);
    return this;
  }

  dispose() {
    super.dispose();

    this._param.dispose();

    this._constantSource.dispose();

    return this;
  } //-------------------------------------
  // ABSTRACT PARAM INTERFACE
  // just a proxy for the ConstantSourceNode's offset AudioParam
  // all docs are generated from AbstractParam.ts
  //-------------------------------------


  setValueAtTime(value, time) {
    this._param.setValueAtTime(value, time);

    return this;
  }

  getValueAtTime(time) {
    return this._param.getValueAtTime(time);
  }

  setRampPoint(time) {
    this._param.setRampPoint(time);

    return this;
  }

  linearRampToValueAtTime(value, time) {
    this._param.linearRampToValueAtTime(value, time);

    return this;
  }

  exponentialRampToValueAtTime(value, time) {
    this._param.exponentialRampToValueAtTime(value, time);

    return this;
  }

  exponentialRampTo(value, rampTime, startTime) {
    this._param.exponentialRampTo(value, rampTime, startTime);

    return this;
  }

  linearRampTo(value, rampTime, startTime) {
    this._param.linearRampTo(value, rampTime, startTime);

    return this;
  }

  targetRampTo(value, rampTime, startTime) {
    this._param.targetRampTo(value, rampTime, startTime);

    return this;
  }

  exponentialApproachValueAtTime(value, time, rampTime) {
    this._param.exponentialApproachValueAtTime(value, time, rampTime);

    return this;
  }

  setTargetAtTime(value, startTime, timeConstant) {
    this._param.setTargetAtTime(value, startTime, timeConstant);

    return this;
  }

  setValueCurveAtTime(values, startTime, duration, scaling) {
    this._param.setValueCurveAtTime(values, startTime, duration, scaling);

    return this;
  }

  cancelScheduledValues(time) {
    this._param.cancelScheduledValues(time);

    return this;
  }

  cancelAndHoldAtTime(time) {
    this._param.cancelAndHoldAtTime(time);

    return this;
  }

  rampTo(value, rampTime, startTime) {
    this._param.rampTo(value, rampTime, startTime);

    return this;
  }

  get value() {
    return this._param.value;
  }

  set value(value) {
    this._param.value = value;
  }

  get convert() {
    return this._param.convert;
  }

  set convert(convert) {
    this._param.convert = convert;
  }

  get units() {
    return this._param.units;
  }

  get overridden() {
    return this._param.overridden;
  }

  set overridden(overridden) {
    this._param.overridden = overridden;
  }

  get maxValue() {
    return this._param.maxValue;
  }

  get minValue() {
    return this._param.minValue;
  }
  /**
   * See [[Param.apply]].
   */


  apply(param) {
    this._param.apply(param);

    return this;
  }

}
/**
 * When connecting from a signal, it's necessary to zero out the node destination
 * node if that node is also a signal. If the destination is not 0, then the values
 * will be summed. This method insures that the output of the destination signal will
 * be the same as the source signal, making the destination signal a pass through node.
 * @param signal The output signal to connect from
 * @param destination the destination to connect to
 * @param outputNum the optional output number
 * @param inputNum the input number
 */


exports.Signal = Signal;

function connectSignal(signal, destination, outputNum, inputNum) {
  if (destination instanceof _Param.Param || (0, _AdvancedTypeCheck.isAudioParam)(destination) || destination instanceof Signal && destination.override) {
    // cancel changes
    destination.cancelScheduledValues(0); // reset the value

    destination.setValueAtTime(0, 0); // mark the value as overridden

    if (destination instanceof Signal) {
      destination.overridden = true;
    }
  }

  (0, _ToneAudioNode.connect)(signal, destination, outputNum, inputNum);
}
},{"../core/context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/util/AdvancedTypeCheck":"../node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./ToneConstantSource":"../node_modules/tone/build/esm/signal/ToneConstantSource.js"}],"../node_modules/tone/build/esm/core/clock/TickParam.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TickParam = void 0;

var _Param = require("../context/Param");

var _Defaults = require("../util/Defaults");

var _Timeline = require("../util/Timeline");

var _TypeCheck = require("../util/TypeCheck");

/**
 * A Param class just for computing ticks. Similar to the [[Param]] class,
 * but offers conversion to BPM values as well as ability to compute tick
 * duration and elapsed ticks
 */
class TickParam extends _Param.Param {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(TickParam.getDefaults(), arguments, ["value"]));
    this.name = "TickParam";
    /**
     * The timeline which tracks all of the automations.
     */

    this._events = new _Timeline.Timeline(Infinity);
    /**
     * The internal holder for the multiplier value
     */

    this._multiplier = 1;
    const options = (0, _Defaults.optionsFromArguments)(TickParam.getDefaults(), arguments, ["value"]); // set the multiplier

    this._multiplier = options.multiplier; // clear the ticks from the beginning

    this._events.cancel(0); // set an initial event


    this._events.add({
      ticks: 0,
      time: 0,
      type: "setValueAtTime",
      value: this._fromType(options.value)
    });

    this.setValueAtTime(options.value, 0);
  }

  static getDefaults() {
    return Object.assign(_Param.Param.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }

  setTargetAtTime(value, time, constant) {
    // approximate it with multiple linear ramps
    time = this.toSeconds(time);
    this.setRampPoint(time);

    const computedValue = this._fromType(value); // start from previously scheduled value


    const prevEvent = this._events.get(time);

    const segments = Math.round(Math.max(1 / constant, 1));

    for (let i = 0; i <= segments; i++) {
      const segTime = constant * i + time;

      const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);

      this.linearRampToValueAtTime(this._toType(rampVal), segTime);
    }

    return this;
  }

  setValueAtTime(value, time) {
    const computedTime = this.toSeconds(time);
    super.setValueAtTime(value, time);

    const event = this._events.get(computedTime);

    const previousEvent = this._events.previousEvent(event);

    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);

    event.ticks = Math.max(ticksUntilTime, 0);
    return this;
  }

  linearRampToValueAtTime(value, time) {
    const computedTime = this.toSeconds(time);
    super.linearRampToValueAtTime(value, time);

    const event = this._events.get(computedTime);

    const previousEvent = this._events.previousEvent(event);

    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);

    event.ticks = Math.max(ticksUntilTime, 0);
    return this;
  }

  exponentialRampToValueAtTime(value, time) {
    // aproximate it with multiple linear ramps
    time = this.toSeconds(time);

    const computedVal = this._fromType(value); // start from previously scheduled value


    const prevEvent = this._events.get(time); // approx 10 segments per second


    const segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));
    const segmentDur = (time - prevEvent.time) / segments;

    for (let i = 0; i <= segments; i++) {
      const segTime = segmentDur * i + prevEvent.time;

      const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);

      this.linearRampToValueAtTime(this._toType(rampVal), segTime);
    }

    return this;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  event The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */


  _getTicksUntilEvent(event, time) {
    if (event === null) {
      event = {
        ticks: 0,
        time: 0,
        type: "setValueAtTime",
        value: 0
      };
    } else if ((0, _TypeCheck.isUndef)(event.ticks)) {
      const previousEvent = this._events.previousEvent(event);

      event.ticks = this._getTicksUntilEvent(previousEvent, event.time);
    }

    const val0 = this._fromType(this.getValueAtTime(event.time));

    let val1 = this._fromType(this.getValueAtTime(time)); // if it's right on the line, take the previous value


    const onTheLineEvent = this._events.get(time);

    if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === "setValueAtTime") {
      val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));
    }

    return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;
  }
  /**
   * Returns the tick value at the time. Takes into account
   * any automation curves scheduled on the signal.
   * @param  time The time to get the tick count at
   * @return The number of ticks which have elapsed at the time given any automations.
   */


  getTicksAtTime(time) {
    const computedTime = this.toSeconds(time);

    const event = this._events.get(computedTime);

    return Math.max(this._getTicksUntilEvent(event, computedTime), 0);
  }
  /**
   * Return the elapsed time of the number of ticks from the given time
   * @param ticks The number of ticks to calculate
   * @param  time The time to get the next tick from
   * @return The duration of the number of ticks from the given time in seconds
   */


  getDurationOfTicks(ticks, time) {
    const computedTime = this.toSeconds(time);
    const currentTick = this.getTicksAtTime(time);
    return this.getTimeOfTick(currentTick + ticks) - computedTime;
  }
  /**
   * Given a tick, returns the time that tick occurs at.
   * @return The time that the tick occurs.
   */


  getTimeOfTick(tick) {
    const before = this._events.get(tick, "ticks");

    const after = this._events.getAfter(tick, "ticks");

    if (before && before.ticks === tick) {
      return before.time;
    } else if (before && after && after.type === "linearRampToValueAtTime" && before.value !== after.value) {
      const val0 = this._fromType(this.getValueAtTime(before.time));

      const val1 = this._fromType(this.getValueAtTime(after.time));

      const delta = (val1 - val0) / (after.time - before.time);
      const k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));
      const sol1 = (-val0 + k) / delta;
      const sol2 = (-val0 - k) / delta;
      return (sol1 > 0 ? sol1 : sol2) + before.time;
    } else if (before) {
      if (before.value === 0) {
        return Infinity;
      } else {
        return before.time + (tick - before.ticks) / before.value;
      }
    } else {
      return tick / this._initialValue;
    }
  }
  /**
   * Convert some number of ticks their the duration in seconds accounting
   * for any automation curves starting at the given time.
   * @param  ticks The number of ticks to convert to seconds.
   * @param  when  When along the automation timeline to convert the ticks.
   * @return The duration in seconds of the ticks.
   */


  ticksToTime(ticks, when) {
    return this.getDurationOfTicks(ticks, when);
  }
  /**
   * The inverse of [[ticksToTime]]. Convert a duration in
   * seconds to the corresponding number of ticks accounting for any
   * automation curves starting at the given time.
   * @param  duration The time interval to convert to ticks.
   * @param  when When along the automation timeline to convert the ticks.
   * @return The duration in ticks.
   */


  timeToTicks(duration, when) {
    const computedTime = this.toSeconds(when);
    const computedDuration = this.toSeconds(duration);
    const startTicks = this.getTicksAtTime(computedTime);
    const endTicks = this.getTicksAtTime(computedTime + computedDuration);
    return endTicks - startTicks;
  }
  /**
   * Convert from the type when the unit value is BPM
   */


  _fromType(val) {
    if (this.units === "bpm" && this.multiplier) {
      return 1 / (60 / val / this.multiplier);
    } else {
      return super._fromType(val);
    }
  }
  /**
   * Special case of type conversion where the units === "bpm"
   */


  _toType(val) {
    if (this.units === "bpm" && this.multiplier) {
      return val / this.multiplier * 60;
    } else {
      return super._toType(val);
    }
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */


  get multiplier() {
    return this._multiplier;
  }

  set multiplier(m) {
    // get and reset the current value with the new multiplier
    // might be necessary to clear all the previous values
    const currentVal = this.value;
    this._multiplier = m;
    this.cancelScheduledValues(0);
    this.setValueAtTime(currentVal, 0);
  }

}

exports.TickParam = TickParam;
},{"../context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../util/Timeline":"../node_modules/tone/build/esm/core/util/Timeline.js","../util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js"}],"../node_modules/tone/build/esm/core/clock/TickSignal.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TickSignal = void 0;

var _Signal = require("../../signal/Signal");

var _Defaults = require("../util/Defaults");

var _TickParam = require("./TickParam");

/**
 * TickSignal extends Tone.Signal, but adds the capability
 * to calculate the number of elapsed ticks. exponential and target curves
 * are approximated with multiple linear ramps.
 *
 * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,
 * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)
 * describing integrating timing functions for tempo calculations.
 */
class TickSignal extends _Signal.Signal {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(TickSignal.getDefaults(), arguments, ["value"]));
    this.name = "TickSignal";
    const options = (0, _Defaults.optionsFromArguments)(TickSignal.getDefaults(), arguments, ["value"]);
    this.input = this._param = new _TickParam.TickParam({
      context: this.context,
      convert: options.convert,
      multiplier: options.multiplier,
      param: this._constantSource.offset,
      units: options.units,
      value: options.value
    });
  }

  static getDefaults() {
    return Object.assign(_Signal.Signal.getDefaults(), {
      multiplier: 1,
      units: "hertz",
      value: 1
    });
  }

  ticksToTime(ticks, when) {
    return this._param.ticksToTime(ticks, when);
  }

  timeToTicks(duration, when) {
    return this._param.timeToTicks(duration, when);
  }

  getTimeOfTick(tick) {
    return this._param.getTimeOfTick(tick);
  }

  getDurationOfTicks(ticks, time) {
    return this._param.getDurationOfTicks(ticks, time);
  }

  getTicksAtTime(time) {
    return this._param.getTicksAtTime(time);
  }
  /**
   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
   */


  get multiplier() {
    return this._param.multiplier;
  }

  set multiplier(m) {
    this._param.multiplier = m;
  }

  dispose() {
    super.dispose();

    this._param.dispose();

    return this;
  }

}

exports.TickSignal = TickSignal;
},{"../../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./TickParam":"../node_modules/tone/build/esm/core/clock/TickParam.js"}],"../node_modules/tone/build/esm/core/clock/TickSource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TickSource = void 0;

var _ToneWithContext = require("../context/ToneWithContext");

var _Defaults = require("../util/Defaults");

var _Interface = require("../util/Interface");

var _StateTimeline = require("../util/StateTimeline");

var _Timeline = require("../util/Timeline");

var _TypeCheck = require("../util/TypeCheck");

var _TickSignal = require("./TickSignal");

var _Math = require("../util/Math");

/**
 * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.
 */
class TickSource extends _ToneWithContext.ToneWithContext {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(TickSource.getDefaults(), arguments, ["frequency"]));
    this.name = "TickSource";
    /**
     * The state timeline
     */

    this._state = new _StateTimeline.StateTimeline();
    /**
     * The offset values of the ticks
     */

    this._tickOffset = new _Timeline.Timeline();
    const options = (0, _Defaults.optionsFromArguments)(TickSource.getDefaults(), arguments, ["frequency"]);
    this.frequency = new _TickSignal.TickSignal({
      context: this.context,
      units: options.units,
      value: options.frequency
    });
    (0, _Interface.readOnly)(this, "frequency"); // set the initial state

    this._state.setStateAtTime("stopped", 0); // add the first event


    this.setTicksAtTime(0, 0);
  }

  static getDefaults() {
    return Object.assign({
      frequency: 1,
      units: "hertz"
    }, _ToneWithContext.ToneWithContext.getDefaults());
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */


  get state() {
    return this.getStateAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset The number of ticks to start the source at
   */


  start(time, offset) {
    const computedTime = this.toSeconds(time);

    if (this._state.getValueAtTime(computedTime) !== "started") {
      this._state.setStateAtTime("started", computedTime);

      if ((0, _TypeCheck.isDefined)(offset)) {
        this.setTicksAtTime(offset, computedTime);
      }
    }

    return this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   */


  stop(time) {
    const computedTime = this.toSeconds(time); // cancel the previous stop

    if (this._state.getValueAtTime(computedTime) === "stopped") {
      const event = this._state.get(computedTime);

      if (event && event.time > 0) {
        this._tickOffset.cancel(event.time);

        this._state.cancel(event.time);
      }
    }

    this._state.cancel(computedTime);

    this._state.setStateAtTime("stopped", computedTime);

    this.setTicksAtTime(0, computedTime);
    return this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */


  pause(time) {
    const computedTime = this.toSeconds(time);

    if (this._state.getValueAtTime(computedTime) === "started") {
      this._state.setStateAtTime("paused", computedTime);
    }

    return this;
  }
  /**
   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.
   * @param time When to clear the events after
   */


  cancel(time) {
    time = this.toSeconds(time);

    this._state.cancel(time);

    this._tickOffset.cancel(time);

    return this;
  }
  /**
   * Get the elapsed ticks at the given time
   * @param  time  When to get the tick value
   * @return The number of ticks
   */


  getTicksAtTime(time) {
    const computedTime = this.toSeconds(time);

    const stopEvent = this._state.getLastState("stopped", computedTime); // this event allows forEachBetween to iterate until the current time


    const tmpEvent = {
      state: "paused",
      time: computedTime
    };

    this._state.add(tmpEvent); // keep track of the previous offset event


    let lastState = stopEvent;
    let elapsedTicks = 0; // iterate through all the events since the last stop

    this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {
      let periodStartTime = lastState.time; // if there is an offset event in this period use that

      const offsetEvent = this._tickOffset.get(e.time);

      if (offsetEvent && offsetEvent.time >= lastState.time) {
        elapsedTicks = offsetEvent.ticks;
        periodStartTime = offsetEvent.time;
      }

      if (lastState.state === "started" && e.state !== "started") {
        elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);
      }

      lastState = e;
    }); // remove the temporary event


    this._state.remove(tmpEvent); // return the ticks


    return elapsedTicks;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked. Returns -1 when stopped.
   */


  get ticks() {
    return this.getTicksAtTime(this.now());
  }

  set ticks(t) {
    this.setTicksAtTime(t, this.now());
  }
  /**
   * The time since ticks=0 that the TickSource has been running. Accounts
   * for tempo curves
   */


  get seconds() {
    return this.getSecondsAtTime(this.now());
  }

  set seconds(s) {
    const now = this.now();
    const ticks = this.frequency.timeToTicks(s, now);
    this.setTicksAtTime(ticks, now);
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */


  getSecondsAtTime(time) {
    time = this.toSeconds(time);

    const stopEvent = this._state.getLastState("stopped", time); // this event allows forEachBetween to iterate until the current time


    const tmpEvent = {
      state: "paused",
      time
    };

    this._state.add(tmpEvent); // keep track of the previous offset event


    let lastState = stopEvent;
    let elapsedSeconds = 0; // iterate through all the events since the last stop

    this._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {
      let periodStartTime = lastState.time; // if there is an offset event in this period use that

      const offsetEvent = this._tickOffset.get(e.time);

      if (offsetEvent && offsetEvent.time >= lastState.time) {
        elapsedSeconds = offsetEvent.seconds;
        periodStartTime = offsetEvent.time;
      }

      if (lastState.state === "started" && e.state !== "started") {
        elapsedSeconds += e.time - periodStartTime;
      }

      lastState = e;
    }); // remove the temporary event


    this._state.remove(tmpEvent); // return the ticks


    return elapsedSeconds;
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */


  setTicksAtTime(ticks, time) {
    time = this.toSeconds(time);

    this._tickOffset.cancel(time);

    this._tickOffset.add({
      seconds: this.frequency.getDurationOfTicks(ticks, time),
      ticks,
      time
    });

    return this;
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   */


  getStateAtTime(time) {
    time = this.toSeconds(time);
    return this._state.getValueAtTime(time);
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */


  getTimeOfTick(tick, before = this.now()) {
    const offset = this._tickOffset.get(before);

    const event = this._state.get(before);

    const startTime = Math.max(offset.time, event.time);
    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;
    return this.frequency.getTimeOfTick(absoluteTicks);
  }
  /**
   * Invoke the callback event at all scheduled ticks between the
   * start time and the end time
   * @param  startTime  The beginning of the search range
   * @param  endTime    The end of the search range
   * @param  callback   The callback to invoke with each tick
   */


  forEachTickBetween(startTime, endTime, callback) {
    // only iterate through the sections where it is "started"
    let lastStateEvent = this._state.get(startTime);

    this._state.forEachBetween(startTime, endTime, event => {
      if (lastStateEvent && lastStateEvent.state === "started" && event.state !== "started") {
        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);
      }

      lastStateEvent = event;
    });

    let error = null;

    if (lastStateEvent && lastStateEvent.state === "started") {
      const maxStartTime = Math.max(lastStateEvent.time, startTime); // figure out the difference between the frequency ticks and the

      const startTicks = this.frequency.getTicksAtTime(maxStartTime);
      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);
      const diff = startTicks - ticksAtStart;
      let offset = Math.ceil(diff) - diff; // guard against floating point issues

      offset = (0, _Math.EQ)(offset, 1) ? 0 : offset;
      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);

      while (nextTickTime < endTime) {
        try {
          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));
        } catch (e) {
          error = e;
          break;
        }

        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);
      }
    }

    if (error) {
      throw error;
    }

    return this;
  }
  /**
   * Clean up
   */


  dispose() {
    super.dispose();

    this._state.dispose();

    this._tickOffset.dispose();

    this.frequency.dispose();
    return this;
  }

}

exports.TickSource = TickSource;
},{"../context/ToneWithContext":"../node_modules/tone/build/esm/core/context/ToneWithContext.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../util/StateTimeline":"../node_modules/tone/build/esm/core/util/StateTimeline.js","../util/Timeline":"../node_modules/tone/build/esm/core/util/Timeline.js","../util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","./TickSignal":"../node_modules/tone/build/esm/core/clock/TickSignal.js","../util/Math":"../node_modules/tone/build/esm/core/util/Math.js"}],"../node_modules/tone/build/esm/core/clock/Clock.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Clock = void 0;

var _ToneWithContext = require("../context/ToneWithContext");

var _Defaults = require("../util/Defaults");

var _Emitter = require("../util/Emitter");

var _Interface = require("../util/Interface");

var _StateTimeline = require("../util/StateTimeline");

var _TickSource = require("./TickSource");

var _Debug = require("../util/Debug");

/**
 * A sample accurate clock which provides a callback at the given rate.
 * While the callback is not sample-accurate (it is still susceptible to
 * loose JS timing), the time passed in as the argument to the callback
 * is precise. For most applications, it is better to use Tone.Transport
 * instead of the Clock by itself since you can synchronize multiple callbacks.
 * @example
 * // the callback will be invoked approximately once a second
 * // and will print the time exactly once a second apart.
 * const clock = new Tone.Clock(time => {
 * 	console.log(time);
 * }, 1);
 * clock.start();
 * @category Core
 */
class Clock extends _ToneWithContext.ToneWithContext {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Clock.getDefaults(), arguments, ["callback", "frequency"]));
    this.name = "Clock";
    /**
     * The callback function to invoke at the scheduled tick.
     */

    this.callback = _Interface.noOp;
    /**
     * The last time the loop callback was invoked
     */

    this._lastUpdate = 0;
    /**
     * Keep track of the playback state
     */

    this._state = new _StateTimeline.StateTimeline("stopped");
    /**
     * Context bound reference to the _loop method
     * This is necessary to remove the event in the end.
     */

    this._boundLoop = this._loop.bind(this);
    const options = (0, _Defaults.optionsFromArguments)(Clock.getDefaults(), arguments, ["callback", "frequency"]);
    this.callback = options.callback;
    this._tickSource = new _TickSource.TickSource({
      context: this.context,
      frequency: options.frequency,
      units: options.units
    });
    this._lastUpdate = 0;
    this.frequency = this._tickSource.frequency;
    (0, _Interface.readOnly)(this, "frequency"); // add an initial state

    this._state.setStateAtTime("stopped", 0); // bind a callback to the worker thread


    this.context.on("tick", this._boundLoop);
  }

  static getDefaults() {
    return Object.assign(_ToneWithContext.ToneWithContext.getDefaults(), {
      callback: _Interface.noOp,
      frequency: 1,
      units: "hertz"
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped" or "paused".
   */


  get state() {
    return this._state.getValueAtTime(this.now());
  }
  /**
   * Start the clock at the given time. Optionally pass in an offset
   * of where to start the tick counter from.
   * @param  time    The time the clock should start
   * @param offset  Where the tick counter starts counting from.
   */


  start(time, offset) {
    // make sure the context is running
    (0, _Debug.assertContextRunning)(this.context); // start the loop

    const computedTime = this.toSeconds(time);
    this.log("start", computedTime);

    if (this._state.getValueAtTime(computedTime) !== "started") {
      this._state.setStateAtTime("started", computedTime);

      this._tickSource.start(computedTime, offset);

      if (computedTime < this._lastUpdate) {
        this.emit("start", computedTime, offset);
      }
    }

    return this;
  }
  /**
   * Stop the clock. Stopping the clock resets the tick counter to 0.
   * @param time The time when the clock should stop.
   * @example
   * const clock = new Tone.Clock(time => {
   * 	console.log(time);
   * }, 1);
   * clock.start();
   * // stop the clock after 10 seconds
   * clock.stop("+10");
   */


  stop(time) {
    const computedTime = this.toSeconds(time);
    this.log("stop", computedTime);

    this._state.cancel(computedTime);

    this._state.setStateAtTime("stopped", computedTime);

    this._tickSource.stop(computedTime);

    if (computedTime < this._lastUpdate) {
      this.emit("stop", computedTime);
    }

    return this;
  }
  /**
   * Pause the clock. Pausing does not reset the tick counter.
   * @param time The time when the clock should stop.
   */


  pause(time) {
    const computedTime = this.toSeconds(time);

    if (this._state.getValueAtTime(computedTime) === "started") {
      this._state.setStateAtTime("paused", computedTime);

      this._tickSource.pause(computedTime);

      if (computedTime < this._lastUpdate) {
        this.emit("pause", computedTime);
      }
    }

    return this;
  }
  /**
   * The number of times the callback was invoked. Starts counting at 0
   * and increments after the callback was invoked.
   */


  get ticks() {
    return Math.ceil(this.getTicksAtTime(this.now()));
  }

  set ticks(t) {
    this._tickSource.ticks = t;
  }
  /**
   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves
   */


  get seconds() {
    return this._tickSource.seconds;
  }

  set seconds(s) {
    this._tickSource.seconds = s;
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */


  getSecondsAtTime(time) {
    return this._tickSource.getSecondsAtTime(time);
  }
  /**
   * Set the clock's ticks at the given time.
   * @param  ticks The tick value to set
   * @param  time  When to set the tick value
   */


  setTicksAtTime(ticks, time) {
    this._tickSource.setTicksAtTime(ticks, time);

    return this;
  }
  /**
   * Get the time of the given tick. The second argument
   * is when to test before. Since ticks can be set (with setTicksAtTime)
   * there may be multiple times for a given tick value.
   * @param  tick The tick number.
   * @param  before When to measure the tick value from.
   * @return The time of the tick
   */


  getTimeOfTick(tick, before = this.now()) {
    return this._tickSource.getTimeOfTick(tick, before);
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */


  getTicksAtTime(time) {
    return this._tickSource.getTicksAtTime(time);
  }
  /**
   * Get the time of the next tick
   * @param  offset The tick number.
   */


  nextTickTime(offset, when) {
    const computedTime = this.toSeconds(when);
    const currentTick = this.getTicksAtTime(computedTime);
    return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);
  }
  /**
   * The scheduling loop.
   */


  _loop() {
    const startTime = this._lastUpdate;
    const endTime = this.now();
    this._lastUpdate = endTime;
    this.log("loop", startTime, endTime);

    if (startTime !== endTime) {
      // the state change events
      this._state.forEachBetween(startTime, endTime, e => {
        switch (e.state) {
          case "started":
            const offset = this._tickSource.getTicksAtTime(e.time);

            this.emit("start", e.time, offset);
            break;

          case "stopped":
            if (e.time !== 0) {
              this.emit("stop", e.time);
            }

            break;

          case "paused":
            this.emit("pause", e.time);
            break;
        }
      }); // the tick callbacks


      this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {
        this.callback(time, ticks);
      });
    }
  }
  /**
   * Returns the scheduled state at the given time.
   * @param  time  The time to query.
   * @return  The name of the state input in setStateAtTime.
   * @example
   * const clock = new Tone.Clock();
   * clock.start("+0.1");
   * clock.getStateAtTime("+0.1"); // returns "started"
   */


  getStateAtTime(time) {
    const computedTime = this.toSeconds(time);
    return this._state.getValueAtTime(computedTime);
  }
  /**
   * Clean up
   */


  dispose() {
    super.dispose();
    this.context.off("tick", this._boundLoop);

    this._tickSource.dispose();

    this._state.dispose();

    return this;
  }

}

exports.Clock = Clock;

_Emitter.Emitter.mixin(Clock);
},{"../context/ToneWithContext":"../node_modules/tone/build/esm/core/context/ToneWithContext.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../util/Emitter":"../node_modules/tone/build/esm/core/util/Emitter.js","../util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../util/StateTimeline":"../node_modules/tone/build/esm/core/util/StateTimeline.js","./TickSource":"../node_modules/tone/build/esm/core/clock/TickSource.js","../util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/core/context/Delay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Delay = void 0;

var _Param = require("../context/Param");

var _Defaults = require("../util/Defaults");

var _Interface = require("../util/Interface");

var _ToneAudioNode = require("./ToneAudioNode");

/**
 * Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).
 * @category Core
 * @example
 * return Tone.Offline(() => {
 * 	const delay = new Tone.Delay(0.1).toDestination();
 * 	// connect the signal to both the delay and the destination
 * 	const pulse = new Tone.PulseOscillator().connect(delay).toDestination();
 * 	// start and stop the pulse
 * 	pulse.start(0).stop(0.01);
 * }, 0.5, 1);
 */
class Delay extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Delay.getDefaults(), arguments, ["delayTime", "maxDelay"]));
    this.name = "Delay";
    const options = (0, _Defaults.optionsFromArguments)(Delay.getDefaults(), arguments, ["delayTime", "maxDelay"]);
    const maxDelayInSeconds = this.toSeconds(options.maxDelay);
    this._maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options.delayTime));
    this._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);
    this.delayTime = new _Param.Param({
      context: this.context,
      param: this._delayNode.delayTime,
      units: "time",
      value: options.delayTime,
      minValue: 0,
      maxValue: this.maxDelay
    });
    (0, _Interface.readOnly)(this, "delayTime");
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      delayTime: 0,
      maxDelay: 1
    });
  }
  /**
   * The maximum delay time. This cannot be changed after
   * the value is passed into the constructor.
   */


  get maxDelay() {
    return this._maxDelay;
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();

    this._delayNode.disconnect();

    this.delayTime.dispose();
    return this;
  }

}

exports.Delay = Delay;
},{"../context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","./ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js"}],"../node_modules/tone/build/esm/core/context/Offline.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Offline = Offline;

var _tslib = require("tslib");

var _Global = require("../Global");

var _OfflineContext = require("./OfflineContext");

var _ToneAudioBuffer = require("./ToneAudioBuffer");

/**
 * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.
 * The OfflineAudioContext is capable of rendering much faster than real time in many cases.
 * The callback function also passes in an offline instance of [[Context]] which can be used
 * to schedule events along the Transport.
 * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.
 * @param  duration     the amount of time to record for.
 * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.
 * @example
 * // render 2 seconds of the oscillator
 * Tone.Offline(() => {
 * 	// only nodes created in this callback will be recorded
 * 	const oscillator = new Tone.Oscillator().toDestination().start(0);
 * }, 2).then((buffer) => {
 * 	// do something with the output buffer
 * 	console.log(buffer);
 * });
 * @example
 * // can also schedule events along the Transport
 * // using the passed in Offline Transport
 * Tone.Offline(({ transport }) => {
 * 	const osc = new Tone.Oscillator().toDestination();
 * 	transport.schedule(time => {
 * 		osc.start(time).stop(time + 0.1);
 * 	}, 1);
 * 	// make sure to start the transport
 * 	transport.start(0.2);
 * }, 4).then((buffer) => {
 * 	// do something with the output buffer
 * 	console.log(buffer);
 * });
 * @category Core
 */
function Offline(callback, duration, channels = 2, sampleRate = (0, _Global.getContext)().sampleRate) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
    // set the OfflineAudioContext based on the current context
    const originalContext = (0, _Global.getContext)();
    const context = new _OfflineContext.OfflineContext(channels, duration, sampleRate);
    (0, _Global.setContext)(context); // invoke the callback/scheduling

    yield callback(context); // then render the audio

    const bufferPromise = context.render(); // return the original AudioContext

    (0, _Global.setContext)(originalContext); // await the rendering

    const buffer = yield bufferPromise; // return the audio

    return new _ToneAudioBuffer.ToneAudioBuffer(buffer);
  });
}
},{"tslib":"../node_modules/tslib/tslib.es6.js","../Global":"../node_modules/tone/build/esm/core/Global.js","./OfflineContext":"../node_modules/tone/build/esm/core/context/OfflineContext.js","./ToneAudioBuffer":"../node_modules/tone/build/esm/core/context/ToneAudioBuffer.js"}],"../node_modules/tone/build/esm/core/context/ToneAudioBuffers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToneAudioBuffers = void 0;

var _Tone = require("../Tone");

var _Defaults = require("../util/Defaults");

var _Interface = require("../util/Interface");

var _TypeCheck = require("../util/TypeCheck");

var _ToneAudioBuffer = require("./ToneAudioBuffer");

var _Debug = require("../util/Debug");

/**
 * A data structure for holding multiple buffers in a Map-like datastructure.
 *
 * @example
 * const pianoSamples = new Tone.ToneAudioBuffers({
 * 	A1: "https://tonejs.github.io/audio/casio/A1.mp3",
 * 	A2: "https://tonejs.github.io/audio/casio/A2.mp3",
 * }, () => {
 * 	const player = new Tone.Player().toDestination();
 * 	// play one of the samples when they all load
 * 	player.buffer = pianoSamples.get("A2");
 * 	player.start();
 * });
 * @example
 * // To pass in additional parameters in the second parameter
 * const buffers = new Tone.ToneAudioBuffers({
 * 	 urls: {
 * 		 A1: "A1.mp3",
 * 		 A2: "A2.mp3",
 * 	 },
 * 	 onload: () => console.log("loaded"),
 * 	 baseUrl: "https://tonejs.github.io/audio/casio/"
 * });
 * @category Core
 */
class ToneAudioBuffers extends _Tone.Tone {
  constructor() {
    super();
    this.name = "ToneAudioBuffers";
    /**
     * All of the buffers
     */

    this._buffers = new Map();
    /**
     * Keep track of the number of loaded buffers
     */

    this._loadingCount = 0;
    const options = (0, _Defaults.optionsFromArguments)(ToneAudioBuffers.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    this.baseUrl = options.baseUrl; // add each one

    Object.keys(options.urls).forEach(name => {
      this._loadingCount++;
      const url = options.urls[name];
      this.add(name, url, this._bufferLoaded.bind(this, options.onload), options.onerror);
    });
  }

  static getDefaults() {
    return {
      baseUrl: "",
      onerror: _Interface.noOp,
      onload: _Interface.noOp,
      urls: {}
    };
  }
  /**
   * True if the buffers object has a buffer by that name.
   * @param  name  The key or index of the buffer.
   */


  has(name) {
    return this._buffers.has(name.toString());
  }
  /**
   * Get a buffer by name. If an array was loaded,
   * then use the array index.
   * @param  name  The key or index of the buffer.
   */


  get(name) {
    (0, _Debug.assert)(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);
    return this._buffers.get(name.toString());
  }
  /**
   * A buffer was loaded. decrement the counter.
   */


  _bufferLoaded(callback) {
    this._loadingCount--;

    if (this._loadingCount === 0 && callback) {
      callback();
    }
  }
  /**
   * If the buffers are loaded or not
   */


  get loaded() {
    return Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);
  }
  /**
   * Add a buffer by name and url to the Buffers
   * @param  name      A unique name to give the buffer
   * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   * @param  onerror  Invoked if the buffer can't be loaded
   */


  add(name, url, callback = _Interface.noOp, onerror = _Interface.noOp) {
    if ((0, _TypeCheck.isString)(url)) {
      this._buffers.set(name.toString(), new _ToneAudioBuffer.ToneAudioBuffer(this.baseUrl + url, callback, onerror));
    } else {
      this._buffers.set(name.toString(), new _ToneAudioBuffer.ToneAudioBuffer(url, callback, onerror));
    }

    return this;
  }

  dispose() {
    super.dispose();

    this._buffers.forEach(buffer => buffer.dispose());

    this._buffers.clear();

    return this;
  }

}

exports.ToneAudioBuffers = ToneAudioBuffers;
},{"../Tone":"../node_modules/tone/build/esm/core/Tone.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","./ToneAudioBuffer":"../node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","../util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/core/type/Midi.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Midi = Midi;
exports.MidiClass = void 0;

var _Global = require("../Global");

var _Conversions = require("./Conversions");

var _Frequency = require("./Frequency");

/**
 * Midi is a primitive type for encoding Time values.
 * Midi can be constructed with or without the `new` keyword. Midi can be passed
 * into the parameter of any method which takes time as an argument.
 * @category Unit
 */
class MidiClass extends _Frequency.FrequencyClass {
  constructor() {
    super(...arguments);
    this.name = "MidiClass";
    this.defaultUnits = "midi";
  }
  /**
   * Returns the value of a frequency in the current units
   */


  _frequencyToUnits(freq) {
    return (0, _Conversions.ftom)(super._frequencyToUnits(freq));
  }
  /**
   * Returns the value of a tick in the current time units
   */


  _ticksToUnits(ticks) {
    return (0, _Conversions.ftom)(super._ticksToUnits(ticks));
  }
  /**
   * Return the value of the beats in the current units
   */


  _beatsToUnits(beats) {
    return (0, _Conversions.ftom)(super._beatsToUnits(beats));
  }
  /**
   * Returns the value of a second in the current units
   */


  _secondsToUnits(seconds) {
    return (0, _Conversions.ftom)(super._secondsToUnits(seconds));
  }
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Midi(60).toMidi(); // 60
   */


  toMidi() {
    return this.valueOf();
  }
  /**
   * Return the value of the frequency as a MIDI note
   * @example
   * Tone.Midi(60).toFrequency(); // 261.6255653005986
   */


  toFrequency() {
    return (0, _Conversions.mtof)(this.toMidi());
  }
  /**
   * Transposes the frequency by the given number of semitones.
   * @return A new transposed MidiClass
   * @example
   * Tone.Midi("A4").transpose(3); // "C5"
   */


  transpose(interval) {
    return new MidiClass(this.context, this.toMidi() + interval);
  }

}
/**
 * Convert a value into a FrequencyClass object.
 * @category Unit
 */


exports.MidiClass = MidiClass;

function Midi(value, units) {
  return new MidiClass((0, _Global.getContext)(), value, units);
}
},{"../Global":"../node_modules/tone/build/esm/core/Global.js","./Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js","./Frequency":"../node_modules/tone/build/esm/core/type/Frequency.js"}],"../node_modules/tone/build/esm/core/type/Ticks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Ticks = Ticks;
exports.TicksClass = void 0;

var _Global = require("../Global");

var _TransportTime = require("./TransportTime");

/**
 * Ticks is a primitive type for encoding Time values.
 * Ticks can be constructed with or without the `new` keyword. Ticks can be passed
 * into the parameter of any method which takes time as an argument.
 * @example
 * const t = Tone.Ticks("4n"); // a quarter note as ticks
 * @category Unit
 */
class TicksClass extends _TransportTime.TransportTimeClass {
  constructor() {
    super(...arguments);
    this.name = "Ticks";
    this.defaultUnits = "i";
  }
  /**
   * Get the current time in the given units
   */


  _now() {
    return this.context.transport.ticks;
  }
  /**
   * Return the value of the beats in the current units
   */


  _beatsToUnits(beats) {
    return this._getPPQ() * beats;
  }
  /**
   * Returns the value of a second in the current units
   */


  _secondsToUnits(seconds) {
    return Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());
  }
  /**
   * Returns the value of a tick in the current time units
   */


  _ticksToUnits(ticks) {
    return ticks;
  }
  /**
   * Return the time in ticks
   */


  toTicks() {
    return this.valueOf();
  }
  /**
   * Return the time in seconds
   */


  toSeconds() {
    return this.valueOf() / this._getPPQ() * (60 / this._getBpm());
  }

}
/**
 * Convert a time representation to ticks
 * @category Unit
 */


exports.TicksClass = TicksClass;

function Ticks(value, units) {
  return new TicksClass((0, _Global.getContext)(), value, units);
}
},{"../Global":"../node_modules/tone/build/esm/core/Global.js","./TransportTime":"../node_modules/tone/build/esm/core/type/TransportTime.js"}],"../node_modules/tone/build/esm/core/util/Draw.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Draw = void 0;

var _ToneWithContext = require("../context/ToneWithContext");

var _Timeline = require("./Timeline");

var _ContextInitialization = require("../context/ContextInitialization");

/**
 * Draw is useful for synchronizing visuals and audio events.
 * Callbacks from Tone.Transport or any of the Tone.Event classes
 * always happen _before_ the scheduled time and are not synchronized
 * to the animation frame so they are not good for triggering tightly
 * synchronized visuals and sound. Draw makes it easy to schedule
 * callbacks using the AudioContext time and uses requestAnimationFrame.
 * @example
 * Tone.Transport.schedule((time) => {
 * 	// use the time argument to schedule a callback with Draw
 * 	Tone.Draw.schedule(() => {
 * 		// do drawing or DOM manipulation here
 * 		console.log(time);
 * 	}, time);
 * }, "+0.5");
 * Tone.Transport.start();
 * @category Core
 */
class Draw extends _ToneWithContext.ToneWithContext {
  constructor() {
    super(...arguments);
    this.name = "Draw";
    /**
     * The duration after which events are not invoked.
     */

    this.expiration = 0.25;
    /**
     * The amount of time before the scheduled time
     * that the callback can be invoked. Default is
     * half the time of an animation frame (0.008 seconds).
     */

    this.anticipation = 0.008;
    /**
     * All of the events.
     */

    this._events = new _Timeline.Timeline();
    /**
     * The draw loop
     */

    this._boundDrawLoop = this._drawLoop.bind(this);
    /**
     * The animation frame id
     */

    this._animationFrame = -1;
  }
  /**
   * Schedule a function at the given time to be invoked
   * on the nearest animation frame.
   * @param  callback  Callback is invoked at the given time.
   * @param  time      The time relative to the AudioContext time to invoke the callback.
   * @example
   * Tone.Transport.scheduleRepeat(time => {
   * 	Tone.Draw.schedule(() => console.log(time), time);
   * }, 1);
   * Tone.Transport.start();
   */


  schedule(callback, time) {
    this._events.add({
      callback,
      time: this.toSeconds(time)
    }); // start the draw loop on the first event


    if (this._events.length === 1) {
      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
    }

    return this;
  }
  /**
   * Cancel events scheduled after the given time
   * @param  after  Time after which scheduled events will be removed from the scheduling timeline.
   */


  cancel(after) {
    this._events.cancel(this.toSeconds(after));

    return this;
  }
  /**
   * The draw loop
   */


  _drawLoop() {
    const now = this.context.currentTime;

    while (this._events.length && this._events.peek().time - this.anticipation <= now) {
      const event = this._events.shift();

      if (event && now - event.time <= this.expiration) {
        event.callback();
      }
    }

    if (this._events.length > 0) {
      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);
    }
  }

  dispose() {
    super.dispose();

    this._events.dispose();

    cancelAnimationFrame(this._animationFrame);
    return this;
  }

} //-------------------------------------
// 	INITIALIZATION
//-------------------------------------


exports.Draw = Draw;
(0, _ContextInitialization.onContextInit)(context => {
  context.draw = new Draw({
    context
  });
});
(0, _ContextInitialization.onContextClose)(context => {
  context.draw.dispose();
});
},{"../context/ToneWithContext":"../node_modules/tone/build/esm/core/context/ToneWithContext.js","./Timeline":"../node_modules/tone/build/esm/core/util/Timeline.js","../context/ContextInitialization":"../node_modules/tone/build/esm/core/context/ContextInitialization.js"}],"../node_modules/tone/build/esm/core/util/IntervalTimeline.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IntervalTimeline = void 0;

var _Tone = require("../Tone");

var _TypeCheck = require("./TypeCheck");

var _Debug = require("./Debug");

/**
 * Similar to Tone.Timeline, but all events represent
 * intervals with both "time" and "duration" times. The
 * events are placed in a tree structure optimized
 * for querying an intersection point with the timeline
 * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)
 * to represent the data.
 */
class IntervalTimeline extends _Tone.Tone {
  constructor() {
    super(...arguments);
    this.name = "IntervalTimeline";
    /**
     * The root node of the inteval tree
     */

    this._root = null;
    /**
     * Keep track of the length of the timeline.
     */

    this._length = 0;
  }
  /**
   * The event to add to the timeline. All events must
   * have a time and duration value
   * @param  event  The event to add to the timeline
   */


  add(event) {
    (0, _Debug.assert)((0, _TypeCheck.isDefined)(event.time), "Events must have a time property");
    (0, _Debug.assert)((0, _TypeCheck.isDefined)(event.duration), "Events must have a duration parameter");
    event.time = event.time.valueOf();
    let node = new IntervalNode(event.time, event.time + event.duration, event);

    if (this._root === null) {
      this._root = node;
    } else {
      this._root.insert(node);
    }

    this._length++; // Restructure tree to be balanced

    while (node !== null) {
      node.updateHeight();
      node.updateMax();

      this._rebalance(node);

      node = node.parent;
    }

    return this;
  }
  /**
   * Remove an event from the timeline.
   * @param  event  The event to remove from the timeline
   */


  remove(event) {
    if (this._root !== null) {
      const results = [];

      this._root.search(event.time, results);

      for (const node of results) {
        if (node.event === event) {
          this._removeNode(node);

          this._length--;
          break;
        }
      }
    }

    return this;
  }
  /**
   * The number of items in the timeline.
   * @readOnly
   */


  get length() {
    return this._length;
  }
  /**
   * Remove events whose time time is after the given time
   * @param  after  The time to query.
   */


  cancel(after) {
    this.forEachFrom(after, event => this.remove(event));
    return this;
  }
  /**
   * Set the root node as the given node
   */


  _setRoot(node) {
    this._root = node;

    if (this._root !== null) {
      this._root.parent = null;
    }
  }
  /**
   * Replace the references to the node in the node's parent
   * with the replacement node.
   */


  _replaceNodeInParent(node, replacement) {
    if (node.parent !== null) {
      if (node.isLeftChild()) {
        node.parent.left = replacement;
      } else {
        node.parent.right = replacement;
      }

      this._rebalance(node.parent);
    } else {
      this._setRoot(replacement);
    }
  }
  /**
   * Remove the node from the tree and replace it with
   * a successor which follows the schema.
   */


  _removeNode(node) {
    if (node.left === null && node.right === null) {
      this._replaceNodeInParent(node, null);
    } else if (node.right === null) {
      this._replaceNodeInParent(node, node.left);
    } else if (node.left === null) {
      this._replaceNodeInParent(node, node.right);
    } else {
      const balance = node.getBalance();
      let replacement;
      let temp = null;

      if (balance > 0) {
        if (node.left.right === null) {
          replacement = node.left;
          replacement.right = node.right;
          temp = replacement;
        } else {
          replacement = node.left.right;

          while (replacement.right !== null) {
            replacement = replacement.right;
          }

          if (replacement.parent) {
            replacement.parent.right = replacement.left;
            temp = replacement.parent;
            replacement.left = node.left;
            replacement.right = node.right;
          }
        }
      } else if (node.right.left === null) {
        replacement = node.right;
        replacement.left = node.left;
        temp = replacement;
      } else {
        replacement = node.right.left;

        while (replacement.left !== null) {
          replacement = replacement.left;
        }

        if (replacement.parent) {
          replacement.parent.left = replacement.right;
          temp = replacement.parent;
          replacement.left = node.left;
          replacement.right = node.right;
        }
      }

      if (node.parent !== null) {
        if (node.isLeftChild()) {
          node.parent.left = replacement;
        } else {
          node.parent.right = replacement;
        }
      } else {
        this._setRoot(replacement);
      }

      if (temp) {
        this._rebalance(temp);
      }
    }

    node.dispose();
  }
  /**
   * Rotate the tree to the left
   */


  _rotateLeft(node) {
    const parent = node.parent;
    const isLeftChild = node.isLeftChild(); // Make node.right the new root of this sub tree (instead of node)

    const pivotNode = node.right;

    if (pivotNode) {
      node.right = pivotNode.left;
      pivotNode.left = node;
    }

    if (parent !== null) {
      if (isLeftChild) {
        parent.left = pivotNode;
      } else {
        parent.right = pivotNode;
      }
    } else {
      this._setRoot(pivotNode);
    }
  }
  /**
   * Rotate the tree to the right
   */


  _rotateRight(node) {
    const parent = node.parent;
    const isLeftChild = node.isLeftChild(); // Make node.left the new root of this sub tree (instead of node)

    const pivotNode = node.left;

    if (pivotNode) {
      node.left = pivotNode.right;
      pivotNode.right = node;
    }

    if (parent !== null) {
      if (isLeftChild) {
        parent.left = pivotNode;
      } else {
        parent.right = pivotNode;
      }
    } else {
      this._setRoot(pivotNode);
    }
  }
  /**
   * Balance the BST
   */


  _rebalance(node) {
    const balance = node.getBalance();

    if (balance > 1 && node.left) {
      if (node.left.getBalance() < 0) {
        this._rotateLeft(node.left);
      } else {
        this._rotateRight(node);
      }
    } else if (balance < -1 && node.right) {
      if (node.right.getBalance() > 0) {
        this._rotateRight(node.right);
      } else {
        this._rotateLeft(node);
      }
    }
  }
  /**
   * Get an event whose time and duration span the give time. Will
   * return the match whose "time" value is closest to the given time.
   * @return  The event which spans the desired time
   */


  get(time) {
    if (this._root !== null) {
      const results = [];

      this._root.search(time, results);

      if (results.length > 0) {
        let max = results[0];

        for (let i = 1; i < results.length; i++) {
          if (results[i].low > max.low) {
            max = results[i];
          }
        }

        return max.event;
      }
    }

    return null;
  }
  /**
   * Iterate over everything in the timeline.
   * @param  callback The callback to invoke with every item
   */


  forEach(callback) {
    if (this._root !== null) {
      const allNodes = [];

      this._root.traverse(node => allNodes.push(node));

      allNodes.forEach(node => {
        if (node.event) {
          callback(node.event);
        }
      });
    }

    return this;
  }
  /**
   * Iterate over everything in the array in which the given time
   * overlaps with the time and duration time of the event.
   * @param  time The time to check if items are overlapping
   * @param  callback The callback to invoke with every item
   */


  forEachAtTime(time, callback) {
    if (this._root !== null) {
      const results = [];

      this._root.search(time, results);

      results.forEach(node => {
        if (node.event) {
          callback(node.event);
        }
      });
    }

    return this;
  }
  /**
   * Iterate over everything in the array in which the time is greater
   * than or equal to the given time.
   * @param  time The time to check if items are before
   * @param  callback The callback to invoke with every item
   */


  forEachFrom(time, callback) {
    if (this._root !== null) {
      const results = [];

      this._root.searchAfter(time, results);

      results.forEach(node => {
        if (node.event) {
          callback(node.event);
        }
      });
    }

    return this;
  }
  /**
   * Clean up
   */


  dispose() {
    super.dispose();

    if (this._root !== null) {
      this._root.traverse(node => node.dispose());
    }

    this._root = null;
    return this;
  }

} //-------------------------------------
// 	INTERVAL NODE HELPER
//-------------------------------------

/**
 * Represents a node in the binary search tree, with the addition
 * of a "high" value which keeps track of the highest value of
 * its children.
 * References:
 * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/
 * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf
 * @param low
 * @param high
 */


exports.IntervalTimeline = IntervalTimeline;

class IntervalNode {
  constructor(low, high, event) {
    // the nodes to the left
    this._left = null; // the nodes to the right

    this._right = null; // the parent node

    this.parent = null; // the number of child nodes

    this.height = 0;
    this.event = event; // the low value

    this.low = low; // the high value

    this.high = high; // the high value for this and all child nodes

    this.max = this.high;
  }
  /**
   * Insert a node into the correct spot in the tree
   */


  insert(node) {
    if (node.low <= this.low) {
      if (this.left === null) {
        this.left = node;
      } else {
        this.left.insert(node);
      }
    } else if (this.right === null) {
      this.right = node;
    } else {
      this.right.insert(node);
    }
  }
  /**
   * Search the tree for nodes which overlap
   * with the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */


  search(point, results) {
    // If p is to the right of the rightmost point of any interval
    // in this node and all children, there won't be any matches.
    if (point > this.max) {
      return;
    } // Search left children


    if (this.left !== null) {
      this.left.search(point, results);
    } // Check this node


    if (this.low <= point && this.high > point) {
      results.push(this);
    } // If p is to the left of the time of this interval,
    // then it can't be in any child to the right.


    if (this.low > point) {
      return;
    } // Search right children


    if (this.right !== null) {
      this.right.search(point, results);
    }
  }
  /**
   * Search the tree for nodes which are less
   * than the given point
   * @param  point  The point to query
   * @param  results  The array to put the results
   */


  searchAfter(point, results) {
    // Check this node
    if (this.low >= point) {
      results.push(this);

      if (this.left !== null) {
        this.left.searchAfter(point, results);
      }
    } // search the right side


    if (this.right !== null) {
      this.right.searchAfter(point, results);
    }
  }
  /**
   * Invoke the callback on this element and both it's branches
   * @param  {Function}  callback
   */


  traverse(callback) {
    callback(this);

    if (this.left !== null) {
      this.left.traverse(callback);
    }

    if (this.right !== null) {
      this.right.traverse(callback);
    }
  }
  /**
   * Update the height of the node
   */


  updateHeight() {
    if (this.left !== null && this.right !== null) {
      this.height = Math.max(this.left.height, this.right.height) + 1;
    } else if (this.right !== null) {
      this.height = this.right.height + 1;
    } else if (this.left !== null) {
      this.height = this.left.height + 1;
    } else {
      this.height = 0;
    }
  }
  /**
   * Update the height of the node
   */


  updateMax() {
    this.max = this.high;

    if (this.left !== null) {
      this.max = Math.max(this.max, this.left.max);
    }

    if (this.right !== null) {
      this.max = Math.max(this.max, this.right.max);
    }
  }
  /**
   * The balance is how the leafs are distributed on the node
   * @return  Negative numbers are balanced to the right
   */


  getBalance() {
    let balance = 0;

    if (this.left !== null && this.right !== null) {
      balance = this.left.height - this.right.height;
    } else if (this.left !== null) {
      balance = this.left.height + 1;
    } else if (this.right !== null) {
      balance = -(this.right.height + 1);
    }

    return balance;
  }
  /**
   * @returns true if this node is the left child of its parent
   */


  isLeftChild() {
    return this.parent !== null && this.parent.left === this;
  }
  /**
   * get/set the left node
   */


  get left() {
    return this._left;
  }

  set left(node) {
    this._left = node;

    if (node !== null) {
      node.parent = this;
    }

    this.updateHeight();
    this.updateMax();
  }
  /**
   * get/set the right node
   */


  get right() {
    return this._right;
  }

  set right(node) {
    this._right = node;

    if (node !== null) {
      node.parent = this;
    }

    this.updateHeight();
    this.updateMax();
  }
  /**
   * null out references.
   */


  dispose() {
    this.parent = null;
    this._left = null;
    this._right = null;
    this.event = null;
  }

}
},{"../Tone":"../node_modules/tone/build/esm/core/Tone.js","./TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","./Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/core/type/NoteUnits.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"../node_modules/tone/build/esm/core/type/Units.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _NoteUnits = require("./NoteUnits");

Object.keys(_NoteUnits).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _NoteUnits[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _NoteUnits[key];
    }
  });
});
},{"./NoteUnits":"../node_modules/tone/build/esm/core/type/NoteUnits.js"}],"../node_modules/tone/build/esm/core/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  dbToGain: true,
  gainToDb: true,
  intervalToFrequencyRatio: true,
  ftom: true,
  mtof: true,
  optionsFromArguments: true,
  defaultArg: true,
  Unit: true,
  debug: true
};
exports.Unit = void 0;
Object.defineProperty(exports, "dbToGain", {
  enumerable: true,
  get: function () {
    return _Conversions.dbToGain;
  }
});
exports.debug = void 0;
Object.defineProperty(exports, "defaultArg", {
  enumerable: true,
  get: function () {
    return _Defaults.defaultArg;
  }
});
Object.defineProperty(exports, "ftom", {
  enumerable: true,
  get: function () {
    return _Conversions.ftom;
  }
});
Object.defineProperty(exports, "gainToDb", {
  enumerable: true,
  get: function () {
    return _Conversions.gainToDb;
  }
});
Object.defineProperty(exports, "intervalToFrequencyRatio", {
  enumerable: true,
  get: function () {
    return _Conversions.intervalToFrequencyRatio;
  }
});
Object.defineProperty(exports, "mtof", {
  enumerable: true,
  get: function () {
    return _Conversions.mtof;
  }
});
Object.defineProperty(exports, "optionsFromArguments", {
  enumerable: true,
  get: function () {
    return _Defaults.optionsFromArguments;
  }
});

var _Clock = require("./clock/Clock");

Object.keys(_Clock).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Clock[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Clock[key];
    }
  });
});

var _Context = require("./context/Context");

Object.keys(_Context).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Context[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Context[key];
    }
  });
});

var _BaseContext = require("./context/BaseContext");

Object.keys(_BaseContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _BaseContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _BaseContext[key];
    }
  });
});

var _Delay = require("./context/Delay");

Object.keys(_Delay).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Delay[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Delay[key];
    }
  });
});

var _Gain = require("./context/Gain");

Object.keys(_Gain).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Gain[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Gain[key];
    }
  });
});

var _Offline = require("./context/Offline");

Object.keys(_Offline).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Offline[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Offline[key];
    }
  });
});

var _OfflineContext = require("./context/OfflineContext");

Object.keys(_OfflineContext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _OfflineContext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _OfflineContext[key];
    }
  });
});

var _Param = require("./context/Param");

Object.keys(_Param).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Param[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Param[key];
    }
  });
});

var _ToneAudioBuffer = require("./context/ToneAudioBuffer");

Object.keys(_ToneAudioBuffer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _ToneAudioBuffer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ToneAudioBuffer[key];
    }
  });
});

var _ToneAudioBuffers = require("./context/ToneAudioBuffers");

Object.keys(_ToneAudioBuffers).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _ToneAudioBuffers[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ToneAudioBuffers[key];
    }
  });
});

var _ToneAudioNode = require("./context/ToneAudioNode");

Object.keys(_ToneAudioNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _ToneAudioNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ToneAudioNode[key];
    }
  });
});

var _Frequency = require("./type/Frequency");

Object.keys(_Frequency).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Frequency[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Frequency[key];
    }
  });
});

var _Midi = require("./type/Midi");

Object.keys(_Midi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Midi[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Midi[key];
    }
  });
});

var _Time = require("./type/Time");

Object.keys(_Time).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Time[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Time[key];
    }
  });
});

var _Ticks = require("./type/Ticks");

Object.keys(_Ticks).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Ticks[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Ticks[key];
    }
  });
});

var _TransportTime = require("./type/TransportTime");

Object.keys(_TransportTime).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _TransportTime[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TransportTime[key];
    }
  });
});

require("./util/Draw");

var _Emitter = require("./util/Emitter");

Object.keys(_Emitter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Emitter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Emitter[key];
    }
  });
});

var _IntervalTimeline = require("./util/IntervalTimeline");

Object.keys(_IntervalTimeline).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _IntervalTimeline[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _IntervalTimeline[key];
    }
  });
});

var _StateTimeline = require("./util/StateTimeline");

Object.keys(_StateTimeline).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _StateTimeline[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _StateTimeline[key];
    }
  });
});

var _Timeline = require("./util/Timeline");

Object.keys(_Timeline).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _Timeline[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Timeline[key];
    }
  });
});

var _TypeCheck = require("./util/TypeCheck");

Object.keys(_TypeCheck).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _TypeCheck[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TypeCheck[key];
    }
  });
});

var _Conversions = require("./type/Conversions");

var _Defaults = require("./util/Defaults");

var Unit = _interopRequireWildcard(require("./type/Units"));

exports.Unit = Unit;

var debug = _interopRequireWildcard(require("./util/Debug"));

exports.debug = debug;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./clock/Clock":"../node_modules/tone/build/esm/core/clock/Clock.js","./context/Context":"../node_modules/tone/build/esm/core/context/Context.js","./context/BaseContext":"../node_modules/tone/build/esm/core/context/BaseContext.js","./context/Delay":"../node_modules/tone/build/esm/core/context/Delay.js","./context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","./context/Offline":"../node_modules/tone/build/esm/core/context/Offline.js","./context/OfflineContext":"../node_modules/tone/build/esm/core/context/OfflineContext.js","./context/Param":"../node_modules/tone/build/esm/core/context/Param.js","./context/ToneAudioBuffer":"../node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","./context/ToneAudioBuffers":"../node_modules/tone/build/esm/core/context/ToneAudioBuffers.js","./context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","./type/Frequency":"../node_modules/tone/build/esm/core/type/Frequency.js","./type/Midi":"../node_modules/tone/build/esm/core/type/Midi.js","./type/Time":"../node_modules/tone/build/esm/core/type/Time.js","./type/Ticks":"../node_modules/tone/build/esm/core/type/Ticks.js","./type/TransportTime":"../node_modules/tone/build/esm/core/type/TransportTime.js","./util/Draw":"../node_modules/tone/build/esm/core/util/Draw.js","./util/Emitter":"../node_modules/tone/build/esm/core/util/Emitter.js","./util/IntervalTimeline":"../node_modules/tone/build/esm/core/util/IntervalTimeline.js","./util/StateTimeline":"../node_modules/tone/build/esm/core/util/StateTimeline.js","./util/Timeline":"../node_modules/tone/build/esm/core/util/Timeline.js","./util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","./type/Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js","./util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./type/Units":"../node_modules/tone/build/esm/core/type/Units.js","./util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/component/channel/Volume.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Volume = void 0;

var _Gain = require("../../core/context/Gain");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

/**
 * Volume is a simple volume node, useful for creating a volume fader.
 *
 * @example
 * const vol = new Tone.Volume(-12).toDestination();
 * const osc = new Tone.Oscillator().connect(vol).start();
 * @category Component
 */
class Volume extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Volume.getDefaults(), arguments, ["volume"]));
    this.name = "Volume";
    const options = (0, _Defaults.optionsFromArguments)(Volume.getDefaults(), arguments, ["volume"]);
    this.input = this.output = new _Gain.Gain({
      context: this.context,
      gain: options.volume,
      units: "decibels"
    });
    this.volume = this.output.gain;
    (0, _Interface.readOnly)(this, "volume");
    this._unmutedVolume = options.volume; // set the mute initially

    this.mute = options.mute;
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      mute: false,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const vol = new Tone.Volume(-12).toDestination();
   * const osc = new Tone.Oscillator().connect(vol).start();
   * // mute the output
   * vol.mute = true;
   */


  get mute() {
    return this.volume.value === -Infinity;
  }

  set mute(mute) {
    if (!this.mute && mute) {
      this._unmutedVolume = this.volume.value; // maybe it should ramp here?

      this.volume.value = -Infinity;
    } else if (this.mute && !mute) {
      this.volume.value = this._unmutedVolume;
    }
  }
  /**
   * clean up
   */


  dispose() {
    super.dispose();
    this.input.dispose();
    this.volume.dispose();
    return this;
  }

}

exports.Volume = Volume;
},{"../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/core/context/Destination.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Destination = void 0;

var _Volume = require("../../component/channel/Volume");

var _Defaults = require("../util/Defaults");

var _ContextInitialization = require("./ContextInitialization");

var _Gain = require("./Gain");

var _ToneAudioNode = require("./ToneAudioNode");

/**
 * A single master output which is connected to the
 * AudioDestinationNode (aka your speakers).
 * It provides useful conveniences such as the ability
 * to set the volume and mute the entire application.
 * It also gives you the ability to apply master effects to your application.
 *
 * @example
 * const oscillator = new Tone.Oscillator().start();
 * // the audio will go from the oscillator to the speakers
 * oscillator.connect(Tone.getDestination());
 * // a convenience for connecting to the master output is also provided:
 * oscillator.toDestination();
 * @category Core
 */
class Destination extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Destination.getDefaults(), arguments));
    this.name = "Destination";
    this.input = new _Volume.Volume({
      context: this.context
    });
    this.output = new _Gain.Gain({
      context: this.context
    });
    /**
     * The volume of the master output in decibels. -Infinity is silent, and 0 is no change.
     * @example
     * const osc = new Tone.Oscillator().toDestination();
     * osc.start();
     * // ramp the volume down to silent over 10 seconds
     * Tone.getDestination().volume.rampTo(-Infinity, 10);
     */

    this.volume = this.input.volume;
    const options = (0, _Defaults.optionsFromArguments)(Destination.getDefaults(), arguments);
    (0, _ToneAudioNode.connectSeries)(this.input, this.output, this.context.rawContext.destination);
    this.mute = options.mute;
    this._internalChannels = [this.input, this.context.rawContext.destination, this.output];
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      mute: false,
      volume: 0
    });
  }
  /**
   * Mute the output.
   * @example
   * const oscillator = new Tone.Oscillator().start().toDestination();
   * setTimeout(() => {
   * 	// mute the output
   * 	Tone.Destination.mute = true;
   * }, 1000);
   */


  get mute() {
    return this.input.mute;
  }

  set mute(mute) {
    this.input.mute = mute;
  }
  /**
   * Add a master effects chain. NOTE: this will disconnect any nodes which were previously
   * chained in the master effects chain.
   * @param args All arguments will be connected in a row and the Master will be routed through it.
   * @example
   * // route all audio through a filter and compressor
   * const lowpass = new Tone.Filter(800, "lowpass");
   * const compressor = new Tone.Compressor(-18);
   * Tone.Destination.chain(lowpass, compressor);
   */


  chain(...args) {
    this.input.disconnect();
    args.unshift(this.input);
    args.push(this.output);
    (0, _ToneAudioNode.connectSeries)(...args);
    return this;
  }
  /**
   * The maximum number of channels the system can output
   * @example
   * console.log(Tone.Destination.maxChannelCount);
   */


  get maxChannelCount() {
    return this.context.rawContext.destination.maxChannelCount;
  }
  /**
   * Clean up
   */


  dispose() {
    super.dispose();
    this.volume.dispose();
    return this;
  }

} //-------------------------------------
// 	INITIALIZATION
//-------------------------------------


exports.Destination = Destination;
(0, _ContextInitialization.onContextInit)(context => {
  context.destination = new Destination({
    context
  });
});
(0, _ContextInitialization.onContextClose)(context => {
  context.destination.dispose();
});
},{"../../component/channel/Volume":"../node_modules/tone/build/esm/component/channel/Volume.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./ContextInitialization":"../node_modules/tone/build/esm/core/context/ContextInitialization.js","./Gain":"../node_modules/tone/build/esm/core/context/Gain.js","./ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js"}],"../node_modules/tone/build/esm/core/util/TimelineValue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TimelineValue = void 0;

var _Timeline = require("./Timeline");

var _Tone = require("../Tone");

/**
 * Represents a single value which is gettable and settable in a timed way
 */
class TimelineValue extends _Tone.Tone {
  /**
   * @param initialValue The value to return if there is no scheduled values
   */
  constructor(initialValue) {
    super();
    this.name = "TimelineValue";
    /**
     * The timeline which stores the values
     */

    this._timeline = new _Timeline.Timeline({
      memory: 10
    });
    this._initialValue = initialValue;
  }
  /**
   * Set the value at the given time
   */


  set(value, time) {
    this._timeline.add({
      value,
      time
    });

    return this;
  }
  /**
   * Get the value at the given time
   */


  get(time) {
    const event = this._timeline.get(time);

    if (event) {
      return event.value;
    } else {
      return this._initialValue;
    }
  }

}

exports.TimelineValue = TimelineValue;
},{"./Timeline":"../node_modules/tone/build/esm/core/util/Timeline.js","../Tone":"../node_modules/tone/build/esm/core/Tone.js"}],"../node_modules/tone/build/esm/core/clock/TransportEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransportEvent = void 0;

var _Interface = require("../util/Interface");

/**
 * TransportEvent is an internal class used by [[Transport]]
 * to schedule events. Do no invoke this class directly, it is
 * handled from within Tone.Transport.
 */
class TransportEvent {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(transport, opts) {
    /**
     * The unique id of the event
     */
    this.id = TransportEvent._eventId++;
    const options = Object.assign(TransportEvent.getDefaults(), opts);
    this.transport = transport;
    this.callback = options.callback;
    this._once = options.once;
    this.time = options.time;
  }

  static getDefaults() {
    return {
      callback: _Interface.noOp,
      once: false,
      time: 0
    };
  }
  /**
   * Invoke the event callback.
   * @param  time  The AudioContext time in seconds of the event
   */


  invoke(time) {
    if (this.callback) {
      this.callback(time);

      if (this._once) {
        this.transport.clear(this.id);
      }
    }
  }
  /**
   * Clean up
   */


  dispose() {
    this.callback = undefined;
    return this;
  }

}
/**
 * Current ID counter
 */


exports.TransportEvent = TransportEvent;
TransportEvent._eventId = 0;
},{"../util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/core/clock/TransportRepeatEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransportRepeatEvent = void 0;

var _Ticks = require("../type/Ticks");

var _TransportEvent = require("./TransportEvent");

/**
 * TransportRepeatEvent is an internal class used by Tone.Transport
 * to schedule repeat events. This class should not be instantiated directly.
 */
class TransportRepeatEvent extends _TransportEvent.TransportEvent {
  /**
   * @param transport The transport object which the event belongs to
   */
  constructor(transport, opts) {
    super(transport, opts);
    /**
     * The ID of the current timeline event
     */

    this._currentId = -1;
    /**
     * The ID of the next timeline event
     */

    this._nextId = -1;
    /**
     * The time of the next event
     */

    this._nextTick = this.time;
    /**
     * a reference to the bound start method
     */

    this._boundRestart = this._restart.bind(this);
    const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);
    this.duration = new _Ticks.TicksClass(transport.context, options.duration).valueOf();
    this._interval = new _Ticks.TicksClass(transport.context, options.interval).valueOf();
    this._nextTick = options.time;
    this.transport.on("start", this._boundRestart);
    this.transport.on("loopStart", this._boundRestart);
    this.context = this.transport.context;

    this._restart();
  }

  static getDefaults() {
    return Object.assign({}, _TransportEvent.TransportEvent.getDefaults(), {
      duration: Infinity,
      interval: 1,
      once: false
    });
  }
  /**
   * Invoke the callback. Returns the tick time which
   * the next event should be scheduled at.
   * @param  time  The AudioContext time in seconds of the event
   */


  invoke(time) {
    // create more events if necessary
    this._createEvents(time); // call the super class


    super.invoke(time);
  }
  /**
   * Push more events onto the timeline to keep up with the position of the timeline
   */


  _createEvents(time) {
    // schedule the next event
    const ticks = this.transport.getTicksAtTime(time);

    if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {
      this._nextTick += this._interval;
      this._currentId = this._nextId;
      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new _Ticks.TicksClass(this.context, this._nextTick).toSeconds());
    }
  }
  /**
   * Push more events onto the timeline to keep up with the position of the timeline
   */


  _restart(time) {
    this.transport.clear(this._currentId);
    this.transport.clear(this._nextId);
    this._nextTick = this.time;
    const ticks = this.transport.getTicksAtTime(time);

    if (ticks > this.time) {
      this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;
    }

    this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new _Ticks.TicksClass(this.context, this._nextTick).toSeconds());
    this._nextTick += this._interval;
    this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new _Ticks.TicksClass(this.context, this._nextTick).toSeconds());
  }
  /**
   * Clean up
   */


  dispose() {
    super.dispose();
    this.transport.clear(this._currentId);
    this.transport.clear(this._nextId);
    this.transport.off("start", this._boundRestart);
    this.transport.off("loopStart", this._boundRestart);
    return this;
  }

}

exports.TransportRepeatEvent = TransportRepeatEvent;
},{"../type/Ticks":"../node_modules/tone/build/esm/core/type/Ticks.js","./TransportEvent":"../node_modules/tone/build/esm/core/clock/TransportEvent.js"}],"../node_modules/tone/build/esm/core/clock/Transport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transport = void 0;

var _Time = require("../../core/type/Time");

var _TimelineValue = require("../../core/util/TimelineValue");

var _ContextInitialization = require("../context/ContextInitialization");

var _Gain = require("../context/Gain");

var _ToneWithContext = require("../context/ToneWithContext");

var _Ticks = require("../type/Ticks");

var _TransportTime = require("../type/TransportTime");

var _Defaults = require("../util/Defaults");

var _Emitter = require("../util/Emitter");

var _Interface = require("../util/Interface");

var _IntervalTimeline = require("../util/IntervalTimeline");

var _Timeline = require("../util/Timeline");

var _TypeCheck = require("../util/TypeCheck");

var _Clock = require("./Clock");

var _TransportEvent = require("./TransportEvent");

var _TransportRepeatEvent = require("./TransportRepeatEvent");

/**
 * Transport for timing musical events.
 * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)
 * Transport timing events pass in the exact time of the scheduled event
 * in the argument of the callback function. Pass that time value to the object
 * you're scheduling. <br><br>
 * A single transport is created for you when the library is initialized.
 * <br><br>
 * The transport emits the events: "start", "stop", "pause", and "loop" which are
 * called with the time of that event as the argument.
 *
 * @example
 * const osc = new Tone.Oscillator().toDestination();
 * // repeated event every 8th note
 * Tone.Transport.scheduleRepeat((time) => {
 * 	// use the callback time to schedule events
 * 	osc.start(time).stop(time + 0.1);
 * }, "8n");
 * // transport must be started before it starts invoking events
 * Tone.Transport.start();
 * @category Core
 */
class Transport extends _ToneWithContext.ToneWithContext {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Transport.getDefaults(), arguments));
    this.name = "Transport"; //-------------------------------------
    // 	LOOPING
    //-------------------------------------

    /**
     * If the transport loops or not.
     */

    this._loop = new _TimelineValue.TimelineValue(false);
    /**
     * The loop start position in ticks
     */

    this._loopStart = 0;
    /**
     * The loop end position in ticks
     */

    this._loopEnd = 0; //-------------------------------------
    // 	TIMELINE EVENTS
    //-------------------------------------

    /**
     * All the events in an object to keep track by ID
     */

    this._scheduledEvents = {};
    /**
     * The scheduled events.
     */

    this._timeline = new _Timeline.Timeline();
    /**
     * Repeated events
     */

    this._repeatedEvents = new _IntervalTimeline.IntervalTimeline();
    /**
     * All of the synced Signals
     */

    this._syncedSignals = [];
    /**
     * The swing amount
     */

    this._swingAmount = 0;
    const options = (0, _Defaults.optionsFromArguments)(Transport.getDefaults(), arguments); // CLOCK/TEMPO

    this._ppq = options.ppq;
    this._clock = new _Clock.Clock({
      callback: this._processTick.bind(this),
      context: this.context,
      frequency: 0,
      units: "bpm"
    });

    this._bindClockEvents();

    this.bpm = this._clock.frequency;
    this._clock.frequency.multiplier = options.ppq;
    this.bpm.setValueAtTime(options.bpm, 0);
    (0, _Interface.readOnly)(this, "bpm");
    this._timeSignature = options.timeSignature; // SWING

    this._swingTicks = options.ppq / 2; // 8n
  }

  static getDefaults() {
    return Object.assign(_ToneWithContext.ToneWithContext.getDefaults(), {
      bpm: 120,
      loopEnd: "4m",
      loopStart: 0,
      ppq: 192,
      swing: 0,
      swingSubdivision: "8n",
      timeSignature: 4
    });
  } //-------------------------------------
  // 	TICKS
  //-------------------------------------

  /**
   * called on every tick
   * @param  tickTime clock relative tick time
   */


  _processTick(tickTime, ticks) {
    // do the loop test
    if (this._loop.get(tickTime)) {
      if (ticks >= this._loopEnd) {
        this.emit("loopEnd", tickTime);

        this._clock.setTicksAtTime(this._loopStart, tickTime);

        ticks = this._loopStart;
        this.emit("loopStart", tickTime, this._clock.getSecondsAtTime(tickTime));
        this.emit("loop", tickTime);
      }
    } // handle swing


    if (this._swingAmount > 0 && ticks % this._ppq !== 0 && // not on a downbeat
    ticks % (this._swingTicks * 2) !== 0) {
      // add some swing
      const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);

      const amount = Math.sin(progress * Math.PI) * this._swingAmount;

      tickTime += new _Ticks.TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;
    } // invoke the timeline events scheduled on this tick


    this._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));
  } //-------------------------------------
  // 	SCHEDULABLE EVENTS
  //-------------------------------------

  /**
   * Schedule an event along the timeline.
   * @param callback The callback to be invoked at the time.
   * @param time The time to invoke the callback at.
   * @return The id of the event which can be used for canceling the event.
   * @example
   * // schedule an event on the 16th measure
   * Tone.Transport.schedule((time) => {
   * 	// invoked on measure 16
   * 	console.log("measure 16!");
   * }, "16:0:0");
   */


  schedule(callback, time) {
    const event = new _TransportEvent.TransportEvent(this, {
      callback,
      time: new _TransportTime.TransportTimeClass(this.context, time).toTicks()
    });
    return this._addEvent(event, this._timeline);
  }
  /**
   * Schedule a repeated event along the timeline. The event will fire
   * at the `interval` starting at the `startTime` and for the specified
   * `duration`.
   * @param  callback   The callback to invoke.
   * @param  interval   The duration between successive callbacks. Must be a positive number.
   * @param  startTime  When along the timeline the events should start being invoked.
   * @param  duration How long the event should repeat.
   * @return  The ID of the scheduled event. Use this to cancel the event.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // a callback invoked every eighth note after the first measure
   * Tone.Transport.scheduleRepeat((time) => {
   * 	osc.start(time).stop(time + 0.1);
   * }, "8n", "1m");
   */


  scheduleRepeat(callback, interval, startTime, duration = Infinity) {
    const event = new _TransportRepeatEvent.TransportRepeatEvent(this, {
      callback,
      duration: new _Time.TimeClass(this.context, duration).toTicks(),
      interval: new _Time.TimeClass(this.context, interval).toTicks(),
      time: new _TransportTime.TransportTimeClass(this.context, startTime).toTicks()
    }); // kick it off if the Transport is started
    // @ts-ignore

    return this._addEvent(event, this._repeatedEvents);
  }
  /**
   * Schedule an event that will be removed after it is invoked.
   * @param callback The callback to invoke once.
   * @param time The time the callback should be invoked.
   * @returns The ID of the scheduled event.
   */


  scheduleOnce(callback, time) {
    const event = new _TransportEvent.TransportEvent(this, {
      callback,
      once: true,
      time: new _TransportTime.TransportTimeClass(this.context, time).toTicks()
    });
    return this._addEvent(event, this._timeline);
  }
  /**
   * Clear the passed in event id from the timeline
   * @param eventId The id of the event.
   */


  clear(eventId) {
    if (this._scheduledEvents.hasOwnProperty(eventId)) {
      const item = this._scheduledEvents[eventId.toString()];

      item.timeline.remove(item.event);
      item.event.dispose();
      delete this._scheduledEvents[eventId.toString()];
    }

    return this;
  }
  /**
   * Add an event to the correct timeline. Keep track of the
   * timeline it was added to.
   * @returns the event id which was just added
   */


  _addEvent(event, timeline) {
    this._scheduledEvents[event.id.toString()] = {
      event,
      timeline
    };
    timeline.add(event);
    return event.id;
  }
  /**
   * Remove scheduled events from the timeline after
   * the given time. Repeated events will be removed
   * if their startTime is after the given time
   * @param after Clear all events after this time.
   */


  cancel(after = 0) {
    const computedAfter = this.toTicks(after);

    this._timeline.forEachFrom(computedAfter, event => this.clear(event.id));

    this._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));

    return this;
  } //-------------------------------------
  // 	START/STOP/PAUSE
  //-------------------------------------

  /**
   * Bind start/stop/pause events from the clock and emit them.
   */


  _bindClockEvents() {
    this._clock.on("start", (time, offset) => {
      offset = new _Ticks.TicksClass(this.context, offset).toSeconds();
      this.emit("start", time, offset);
    });

    this._clock.on("stop", time => {
      this.emit("stop", time);
    });

    this._clock.on("pause", time => {
      this.emit("pause", time);
    });
  }
  /**
   * Returns the playback state of the source, either "started", "stopped", or "paused"
   */


  get state() {
    return this._clock.getStateAtTime(this.now());
  }
  /**
   * Start the transport and all sources synced to the transport.
   * @param  time The time when the transport should start.
   * @param  offset The timeline offset to start the transport.
   * @example
   * // start the transport in one second starting at beginning of the 5th measure.
   * Tone.Transport.start("+1", "4:0:0");
   */


  start(time, offset) {
    let offsetTicks;

    if ((0, _TypeCheck.isDefined)(offset)) {
      offsetTicks = this.toTicks(offset);
    } // start the clock


    this._clock.start(time, offsetTicks);

    return this;
  }
  /**
   * Stop the transport and all sources synced to the transport.
   * @param time The time when the transport should stop.
   * @example
   * Tone.Transport.stop();
   */


  stop(time) {
    this._clock.stop(time);

    return this;
  }
  /**
   * Pause the transport and all sources synced to the transport.
   */


  pause(time) {
    this._clock.pause(time);

    return this;
  }
  /**
   * Toggle the current state of the transport. If it is
   * started, it will stop it, otherwise it will start the Transport.
   * @param  time The time of the event
   */


  toggle(time) {
    time = this.toSeconds(time);

    if (this._clock.getStateAtTime(time) !== "started") {
      this.start(time);
    } else {
      this.stop(time);
    }

    return this;
  } //-------------------------------------
  // 	SETTERS/GETTERS
  //-------------------------------------

  /**
   * The time signature as just the numerator over 4.
   * For example 4/4 would be just 4 and 6/8 would be 3.
   * @example
   * // common time
   * Tone.Transport.timeSignature = 4;
   * // 7/8
   * Tone.Transport.timeSignature = [7, 8];
   * // this will be reduced to a single number
   * Tone.Transport.timeSignature; // returns 3.5
   */


  get timeSignature() {
    return this._timeSignature;
  }

  set timeSignature(timeSig) {
    if ((0, _TypeCheck.isArray)(timeSig)) {
      timeSig = timeSig[0] / timeSig[1] * 4;
    }

    this._timeSignature = timeSig;
  }
  /**
   * When the Transport.loop = true, this is the starting position of the loop.
   */


  get loopStart() {
    return new _Time.TimeClass(this.context, this._loopStart, "i").toSeconds();
  }

  set loopStart(startPosition) {
    this._loopStart = this.toTicks(startPosition);
  }
  /**
   * When the Transport.loop = true, this is the ending position of the loop.
   */


  get loopEnd() {
    return new _Time.TimeClass(this.context, this._loopEnd, "i").toSeconds();
  }

  set loopEnd(endPosition) {
    this._loopEnd = this.toTicks(endPosition);
  }
  /**
   * If the transport loops or not.
   */


  get loop() {
    return this._loop.get(this.now());
  }

  set loop(loop) {
    this._loop.set(loop, this.now());
  }
  /**
   * Set the loop start and stop at the same time.
   * @example
   * // loop over the first measure
   * Tone.Transport.setLoopPoints(0, "1m");
   * Tone.Transport.loop = true;
   */


  setLoopPoints(startPosition, endPosition) {
    this.loopStart = startPosition;
    this.loopEnd = endPosition;
    return this;
  }
  /**
   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.
   */


  get swing() {
    return this._swingAmount;
  }

  set swing(amount) {
    // scale the values to a normal range
    this._swingAmount = amount;
  }
  /**
   * Set the subdivision which the swing will be applied to.
   * The default value is an 8th note. Value must be less
   * than a quarter note.
   */


  get swingSubdivision() {
    return new _Ticks.TicksClass(this.context, this._swingTicks).toNotation();
  }

  set swingSubdivision(subdivision) {
    this._swingTicks = this.toTicks(subdivision);
  }
  /**
   * The Transport's position in Bars:Beats:Sixteenths.
   * Setting the value will jump to that position right away.
   */


  get position() {
    const now = this.now();

    const ticks = this._clock.getTicksAtTime(now);

    return new _Ticks.TicksClass(this.context, ticks).toBarsBeatsSixteenths();
  }

  set position(progress) {
    const ticks = this.toTicks(progress);
    this.ticks = ticks;
  }
  /**
   * The Transport's position in seconds
   * Setting the value will jump to that position right away.
   */


  get seconds() {
    return this._clock.seconds;
  }

  set seconds(s) {
    const now = this.now();

    const ticks = this._clock.frequency.timeToTicks(s, now);

    this.ticks = ticks;
  }
  /**
   * The Transport's loop position as a normalized value. Always
   * returns 0 if the transport if loop is not true.
   */


  get progress() {
    if (this.loop) {
      const now = this.now();

      const ticks = this._clock.getTicksAtTime(now);

      return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);
    } else {
      return 0;
    }
  }
  /**
   * The transports current tick position.
   */


  get ticks() {
    return this._clock.ticks;
  }

  set ticks(t) {
    if (this._clock.ticks !== t) {
      const now = this.now(); // stop everything synced to the transport

      if (this.state === "started") {
        const ticks = this._clock.getTicksAtTime(now); // schedule to start on the next tick, #573


        const remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);

        const time = now + remainingTick;
        this.emit("stop", time);

        this._clock.setTicksAtTime(t, time); // restart it with the new time


        this.emit("start", time, this._clock.getSecondsAtTime(time));
      } else {
        this._clock.setTicksAtTime(t, now);
      }
    }
  }
  /**
   * Get the clock's ticks at the given time.
   * @param  time  When to get the tick value
   * @return The tick value at the given time.
   */


  getTicksAtTime(time) {
    return Math.round(this._clock.getTicksAtTime(time));
  }
  /**
   * Return the elapsed seconds at the given time.
   * @param  time  When to get the elapsed seconds
   * @return  The number of elapsed seconds
   */


  getSecondsAtTime(time) {
    return this._clock.getSecondsAtTime(time);
  }
  /**
   * Pulses Per Quarter note. This is the smallest resolution
   * the Transport timing supports. This should be set once
   * on initialization and not set again. Changing this value
   * after other objects have been created can cause problems.
   */


  get PPQ() {
    return this._clock.frequency.multiplier;
  }

  set PPQ(ppq) {
    this._clock.frequency.multiplier = ppq;
  } //-------------------------------------
  // 	SYNCING
  //-------------------------------------

  /**
   * Returns the time aligned to the next subdivision
   * of the Transport. If the Transport is not started,
   * it will return 0.
   * Note: this will not work precisely during tempo ramps.
   * @param  subdivision  The subdivision to quantize to
   * @return  The context time of the next subdivision.
   * @example
   * // the transport must be started, otherwise returns 0
   * Tone.Transport.start();
   * Tone.Transport.nextSubdivision("4n");
   */


  nextSubdivision(subdivision) {
    subdivision = this.toTicks(subdivision);

    if (this.state !== "started") {
      // if the transport's not started, return 0
      return 0;
    } else {
      const now = this.now(); // the remainder of the current ticks and the subdivision

      const transportPos = this.getTicksAtTime(now);
      const remainingTicks = subdivision - transportPos % subdivision;
      return this._clock.nextTickTime(remainingTicks, now);
    }
  }
  /**
   * Attaches the signal to the tempo control signal so that
   * any changes in the tempo will change the signal in the same
   * ratio.
   *
   * @param signal
   * @param ratio Optionally pass in the ratio between the two signals.
   * 			Otherwise it will be computed based on their current values.
   */


  syncSignal(signal, ratio) {
    if (!ratio) {
      // get the sync ratio
      const now = this.now();

      if (signal.getValueAtTime(now) !== 0) {
        const bpm = this.bpm.getValueAtTime(now);
        const computedFreq = 1 / (60 / bpm / this.PPQ);
        ratio = signal.getValueAtTime(now) / computedFreq;
      } else {
        ratio = 0;
      }
    }

    const ratioSignal = new _Gain.Gain(ratio); // @ts-ignore

    this.bpm.connect(ratioSignal); // @ts-ignore

    ratioSignal.connect(signal._param);

    this._syncedSignals.push({
      initial: signal.value,
      ratio: ratioSignal,
      signal
    });

    signal.value = 0;
    return this;
  }
  /**
   * Unsyncs a previously synced signal from the transport's control.
   * See Transport.syncSignal.
   */


  unsyncSignal(signal) {
    for (let i = this._syncedSignals.length - 1; i >= 0; i--) {
      const syncedSignal = this._syncedSignals[i];

      if (syncedSignal.signal === signal) {
        syncedSignal.ratio.dispose();
        syncedSignal.signal.value = syncedSignal.initial;

        this._syncedSignals.splice(i, 1);
      }
    }

    return this;
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();

    this._clock.dispose();

    (0, _Interface.writable)(this, "bpm");

    this._timeline.dispose();

    this._repeatedEvents.dispose();

    return this;
  }

}

exports.Transport = Transport;

_Emitter.Emitter.mixin(Transport); //-------------------------------------
// 	INITIALIZATION
//-------------------------------------


(0, _ContextInitialization.onContextInit)(context => {
  context.transport = new Transport({
    context
  });
});
(0, _ContextInitialization.onContextClose)(context => {
  context.transport.dispose();
});
},{"../../core/type/Time":"../node_modules/tone/build/esm/core/type/Time.js","../../core/util/TimelineValue":"../node_modules/tone/build/esm/core/util/TimelineValue.js","../context/ContextInitialization":"../node_modules/tone/build/esm/core/context/ContextInitialization.js","../context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../context/ToneWithContext":"../node_modules/tone/build/esm/core/context/ToneWithContext.js","../type/Ticks":"../node_modules/tone/build/esm/core/type/Ticks.js","../type/TransportTime":"../node_modules/tone/build/esm/core/type/TransportTime.js","../util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../util/Emitter":"../node_modules/tone/build/esm/core/util/Emitter.js","../util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../util/IntervalTimeline":"../node_modules/tone/build/esm/core/util/IntervalTimeline.js","../util/Timeline":"../node_modules/tone/build/esm/core/util/Timeline.js","../util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","./Clock":"../node_modules/tone/build/esm/core/clock/Clock.js","./TransportEvent":"../node_modules/tone/build/esm/core/clock/TransportEvent.js","./TransportRepeatEvent":"../node_modules/tone/build/esm/core/clock/TransportRepeatEvent.js"}],"../node_modules/tone/build/esm/source/Source.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Source = void 0;

var _Volume = require("../component/channel/Volume");

require("../core/context/Destination");

require("../core/clock/Transport");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

var _StateTimeline = require("../core/util/StateTimeline");

var _TypeCheck = require("../core/util/TypeCheck");

var _Debug = require("../core/util/Debug");

var _Math = require("../core/util/Math");

/**
 * Base class for sources.
 * start/stop of this.context.transport.
 *
 * ```
 * // Multiple state change events can be chained together,
 * // but must be set in the correct order and with ascending times
 * // OK
 * state.start().stop("+0.2");
 * // OK
 * state.start().stop("+0.2").start("+0.4").stop("+0.7")
 * // BAD
 * state.stop("+0.2").start();
 * // BAD
 * state.start("+0.3").stop("+0.2");
 * ```
 */
class Source extends _ToneAudioNode.ToneAudioNode {
  constructor(options) {
    super(options);
    /**
     * Sources have no inputs
     */

    this.input = undefined;
    /**
     * Keep track of the scheduled state.
     */

    this._state = new _StateTimeline.StateTimeline("stopped");
    /**
     * The synced `start` callback function from the transport
     */

    this._synced = false;
    /**
     * Keep track of all of the scheduled event ids
     */

    this._scheduled = [];
    /**
     * Placeholder functions for syncing/unsyncing to transport
     */

    this._syncedStart = _Interface.noOp;
    this._syncedStop = _Interface.noOp;
    this._state.memory = 100;
    this._state.increasing = true;
    this._volume = this.output = new _Volume.Volume({
      context: this.context,
      mute: options.mute,
      volume: options.volume
    });
    this.volume = this._volume.volume;
    (0, _Interface.readOnly)(this, "volume");
    this.onstop = options.onstop;
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      mute: false,
      onstop: _Interface.noOp,
      volume: 0
    });
  }
  /**
   * Returns the playback state of the source, either "started" or "stopped".
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/ahntone_c3.mp3", () => {
   * 	player.start();
   * 	console.log(player.state);
   * }).toDestination();
   */


  get state() {
    if (this._synced) {
      if (this.context.transport.state === "started") {
        return this._state.getValueAtTime(this.context.transport.seconds);
      } else {
        return "stopped";
      }
    } else {
      return this._state.getValueAtTime(this.now());
    }
  }
  /**
   * Mute the output.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * // mute the output
   * osc.mute = true;
   */


  get mute() {
    return this._volume.mute;
  }

  set mute(mute) {
    this._volume.mute = mute;
  }
  /**
   * Ensure that the scheduled time is not before the current time.
   * Should only be used when scheduled unsynced.
   */


  _clampToCurrentTime(time) {
    if (this._synced) {
      return time;
    } else {
      return Math.max(time, this.context.currentTime);
    }
  }
  /**
   * Start the source at the specified time. If no time is given,
   * start the source now.
   * @param  time When the source should be started.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start("+0.5"); // starts the source 0.5 seconds from now
   */


  start(time, offset, duration) {
    let computedTime = (0, _TypeCheck.isUndef)(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);
    computedTime = this._clampToCurrentTime(computedTime); // if it's started, stop it and restart it

    if (!this._synced && this._state.getValueAtTime(computedTime) === "started") {
      // time should be strictly greater than the previous start time
      (0, _Debug.assert)((0, _Math.GT)(computedTime, this._state.get(computedTime).time), "Start time must be strictly greater than previous start time");

      this._state.cancel(computedTime);

      this._state.setStateAtTime("started", computedTime);

      this.log("restart", computedTime);
      this.restart(computedTime, offset, duration);
    } else {
      this.log("start", computedTime);

      this._state.setStateAtTime("started", computedTime);

      if (this._synced) {
        // add the offset time to the event
        const event = this._state.get(computedTime);

        if (event) {
          event.offset = this.toSeconds((0, _Defaults.defaultArg)(offset, 0));
          event.duration = duration ? this.toSeconds(duration) : undefined;
        }

        const sched = this.context.transport.schedule(t => {
          this._start(t, offset, duration);
        }, computedTime);

        this._scheduled.push(sched); // if the transport is already started
        // and the time is greater than where the transport is


        if (this.context.transport.state === "started" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {
          this._syncedStart(this.now(), this.context.transport.seconds);
        }
      } else {
        (0, _Debug.assertContextRunning)(this.context);

        this._start(computedTime, offset, duration);
      }
    }

    return this;
  }
  /**
   * Stop the source at the specified time. If no time is given,
   * stop the source now.
   * @param  time When the source should be stopped.
   * @example
   * const source = new Tone.Oscillator().toDestination();
   * source.start();
   * source.stop("+0.5"); // stops the source 0.5 seconds from now
   */


  stop(time) {
    let computedTime = (0, _TypeCheck.isUndef)(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);
    computedTime = this._clampToCurrentTime(computedTime);

    if (this._state.getValueAtTime(computedTime) === "started" || (0, _TypeCheck.isDefined)(this._state.getNextState("started", computedTime))) {
      this.log("stop", computedTime);

      if (!this._synced) {
        this._stop(computedTime);
      } else {
        const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);

        this._scheduled.push(sched);
      }

      this._state.cancel(computedTime);

      this._state.setStateAtTime("stopped", computedTime);
    }

    return this;
  }
  /**
   * Restart the source.
   */


  restart(time, offset, duration) {
    time = this.toSeconds(time);

    if (this._state.getValueAtTime(time) === "started") {
      this._state.cancel(time);

      this._restart(time, offset, duration);
    }

    return this;
  }
  /**
   * Sync the source to the Transport so that all subsequent
   * calls to `start` and `stop` are synced to the TransportTime
   * instead of the AudioContext time.
   *
   * @example
   * const osc = new Tone.Oscillator().toDestination();
   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline
   * osc.sync().start(0).stop(0.3);
   * // start the transport.
   * Tone.Transport.start();
   * // set it to loop once a second
   * Tone.Transport.loop = true;
   * Tone.Transport.loopEnd = 1;
   */


  sync() {
    if (!this._synced) {
      this._synced = true;

      this._syncedStart = (time, offset) => {
        if (offset > 0) {
          // get the playback state at that time
          const stateEvent = this._state.get(offset); // listen for start events which may occur in the middle of the sync'ed time


          if (stateEvent && stateEvent.state === "started" && stateEvent.time !== offset) {
            // get the offset
            const startOffset = offset - this.toSeconds(stateEvent.time);
            let duration;

            if (stateEvent.duration) {
              duration = this.toSeconds(stateEvent.duration) - startOffset;
            }

            this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);
          }
        }
      };

      this._syncedStop = time => {
        const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));

        if (this._state.getValueAtTime(seconds) === "started") {
          this._stop(time);
        }
      };

      this.context.transport.on("start", this._syncedStart);
      this.context.transport.on("loopStart", this._syncedStart);
      this.context.transport.on("stop", this._syncedStop);
      this.context.transport.on("pause", this._syncedStop);
      this.context.transport.on("loopEnd", this._syncedStop);
    }

    return this;
  }
  /**
   * Unsync the source to the Transport. See Source.sync
   */


  unsync() {
    if (this._synced) {
      this.context.transport.off("stop", this._syncedStop);
      this.context.transport.off("pause", this._syncedStop);
      this.context.transport.off("loopEnd", this._syncedStop);
      this.context.transport.off("start", this._syncedStart);
      this.context.transport.off("loopStart", this._syncedStart);
    }

    this._synced = false; // clear all of the scheduled ids

    this._scheduled.forEach(id => this.context.transport.clear(id));

    this._scheduled = [];

    this._state.cancel(0); // stop it also


    this._stop(0);

    return this;
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();
    this.onstop = _Interface.noOp;
    this.unsync();

    this._volume.dispose();

    this._state.dispose();

    return this;
  }

}

exports.Source = Source;
},{"../component/channel/Volume":"../node_modules/tone/build/esm/component/channel/Volume.js","../core/context/Destination":"../node_modules/tone/build/esm/core/context/Destination.js","../core/clock/Transport":"../node_modules/tone/build/esm/core/clock/Transport.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../core/util/StateTimeline":"../node_modules/tone/build/esm/core/util/StateTimeline.js","../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","../core/util/Math":"../node_modules/tone/build/esm/core/util/Math.js"}],"../node_modules/tone/build/esm/source/buffer/ToneBufferSource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToneBufferSource = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Param = require("../../core/context/Param");

var _ToneAudioBuffer = require("../../core/context/ToneAudioBuffer");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _TypeCheck = require("../../core/util/TypeCheck");

var _Debug = require("../../core/util/Debug");

var _OneShotSource = require("../OneShotSource");

var _Math = require("../../core/util/Math");

/**
 * Wrapper around the native BufferSourceNode.
 * @category Source
 */
class ToneBufferSource extends _OneShotSource.OneShotSource {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(ToneBufferSource.getDefaults(), arguments, ["url", "onload"]));
    this.name = "ToneBufferSource";
    /**
     * The oscillator
     */

    this._source = this.context.createBufferSource();
    this._internalChannels = [this._source];
    /**
     * indicators if the source has started/stopped
     */

    this._sourceStarted = false;
    this._sourceStopped = false;
    const options = (0, _Defaults.optionsFromArguments)(ToneBufferSource.getDefaults(), arguments, ["url", "onload"]);
    (0, _ToneAudioNode.connect)(this._source, this._gainNode);

    this._source.onended = () => this._stopSource();
    /**
     * The playbackRate of the buffer
     */


    this.playbackRate = new _Param.Param({
      context: this.context,
      param: this._source.playbackRate,
      units: "positive",
      value: options.playbackRate
    }); // set some values initially

    this.loop = options.loop;
    this.loopStart = options.loopStart;
    this.loopEnd = options.loopEnd;
    this._buffer = new _ToneAudioBuffer.ToneAudioBuffer(options.url, options.onload, options.onerror);

    this._internalChannels.push(this._source);
  }

  static getDefaults() {
    return Object.assign(_OneShotSource.OneShotSource.getDefaults(), {
      url: new _ToneAudioBuffer.ToneAudioBuffer(),
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      onload: _Interface.noOp,
      onerror: _Interface.noOp,
      playbackRate: 1
    });
  }
  /**
   * The fadeIn time of the amplitude envelope.
   */


  get fadeIn() {
    return this._fadeIn;
  }

  set fadeIn(t) {
    this._fadeIn = t;
  }
  /**
   * The fadeOut time of the amplitude envelope.
   */


  get fadeOut() {
    return this._fadeOut;
  }

  set fadeOut(t) {
    this._fadeOut = t;
  }
  /**
   * The curve applied to the fades, either "linear" or "exponential"
   */


  get curve() {
    return this._curve;
  }

  set curve(t) {
    this._curve = t;
  }
  /**
   * Start the buffer
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   * @param  gain  The gain to play the buffer back at.
   */


  start(time, offset, duration, gain = 1) {
    (0, _Debug.assert)(this.buffer.loaded, "buffer is either not set or not loaded");
    const computedTime = this.toSeconds(time); // apply the gain envelope

    this._startGain(computedTime, gain); // if it's a loop the default offset is the loopstart point


    if (this.loop) {
      offset = (0, _Defaults.defaultArg)(offset, this.loopStart);
    } else {
      // otherwise the default offset is 0
      offset = (0, _Defaults.defaultArg)(offset, 0);
    } // make sure the offset is not less than 0


    let computedOffset = Math.max(this.toSeconds(offset), 0); // start the buffer source

    if (this.loop) {
      // modify the offset if it's greater than the loop time
      const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;
      const loopStart = this.toSeconds(this.loopStart);
      const loopDuration = loopEnd - loopStart; // move the offset back

      if ((0, _Math.GTE)(computedOffset, loopEnd)) {
        computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;
      } // when the offset is very close to the duration, set it to 0


      if ((0, _Math.EQ)(computedOffset, this.buffer.duration)) {
        computedOffset = 0;
      }
    } // this.buffer.loaded would have return false if the AudioBuffer was undefined


    this._source.buffer = this.buffer.get();
    this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;

    if ((0, _Math.LT)(computedOffset, this.buffer.duration)) {
      this._sourceStarted = true;

      this._source.start(computedTime, computedOffset);
    } // if a duration is given, schedule a stop


    if ((0, _TypeCheck.isDefined)(duration)) {
      let computedDur = this.toSeconds(duration); // make sure it's never negative

      computedDur = Math.max(computedDur, 0);
      this.stop(computedTime + computedDur);
    }

    return this;
  }

  _stopSource(time) {
    if (!this._sourceStopped && this._sourceStarted) {
      this._sourceStopped = true;

      this._source.stop(this.toSeconds(time));

      this._onended();
    }
  }
  /**
   * If loop is true, the loop will start at this position.
   */


  get loopStart() {
    return this._source.loopStart;
  }

  set loopStart(loopStart) {
    this._source.loopStart = this.toSeconds(loopStart);
  }
  /**
   * If loop is true, the loop will end at this position.
   */


  get loopEnd() {
    return this._source.loopEnd;
  }

  set loopEnd(loopEnd) {
    this._source.loopEnd = this.toSeconds(loopEnd);
  }
  /**
   * The audio buffer belonging to the player.
   */


  get buffer() {
    return this._buffer;
  }

  set buffer(buffer) {
    this._buffer.set(buffer);
  }
  /**
   * If the buffer should loop once it's over.
   */


  get loop() {
    return this._source.loop;
  }

  set loop(loop) {
    this._source.loop = loop;

    if (this._sourceStarted) {
      this.cancelStop();
    }
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();
    this._source.onended = null;

    this._source.disconnect();

    this._buffer.dispose();

    this.playbackRate.dispose();
    return this;
  }

}

exports.ToneBufferSource = ToneBufferSource;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../../core/context/ToneAudioBuffer":"../node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","../OneShotSource":"../node_modules/tone/build/esm/source/OneShotSource.js","../../core/util/Math":"../node_modules/tone/build/esm/core/util/Math.js"}],"../node_modules/tone/build/esm/source/Noise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Noise = void 0;

var _ToneAudioBuffer = require("../core/context/ToneAudioBuffer");

var _Defaults = require("../core/util/Defaults");

var _Debug = require("../core/util/Debug");

var _Source = require("../source/Source");

var _ToneBufferSource = require("./buffer/ToneBufferSource");

/**
 * Noise is a noise generator. It uses looped noise buffers to save on performance.
 * Noise supports the noise types: "pink", "white", and "brown". Read more about
 * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).
 *
 * @example
 * // initialize the noise and start
 * const noise = new Tone.Noise("pink").start();
 * // make an autofilter to shape the noise
 * const autoFilter = new Tone.AutoFilter({
 * 	frequency: "8n",
 * 	baseFrequency: 200,
 * 	octaves: 8
 * }).toDestination().start();
 * // connect the noise
 * noise.connect(autoFilter);
 * // start the autofilter LFO
 * autoFilter.start();
 * @category Source
 */
class Noise extends _Source.Source {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Noise.getDefaults(), arguments, ["type"]));
    this.name = "Noise";
    /**
     * Private reference to the source
     */

    this._source = null;
    const options = (0, _Defaults.optionsFromArguments)(Noise.getDefaults(), arguments, ["type"]);
    this._playbackRate = options.playbackRate;
    this.type = options.type;
    this._fadeIn = options.fadeIn;
    this._fadeOut = options.fadeOut;
  }

  static getDefaults() {
    return Object.assign(_Source.Source.getDefaults(), {
      fadeIn: 0,
      fadeOut: 0,
      playbackRate: 1,
      type: "white"
    });
  }
  /**
   * The type of the noise. Can be "white", "brown", or "pink".
   * @example
   * const noise = new Tone.Noise().toDestination().start();
   * noise.type = "brown";
   */


  get type() {
    return this._type;
  }

  set type(type) {
    (0, _Debug.assert)(type in _noiseBuffers, "Noise: invalid type: " + type);

    if (this._type !== type) {
      this._type = type; // if it's playing, stop and restart it

      if (this.state === "started") {
        const now = this.now();

        this._stop(now);

        this._start(now);
      }
    }
  }
  /**
   * The playback rate of the noise. Affects
   * the "frequency" of the noise.
   */


  get playbackRate() {
    return this._playbackRate;
  }

  set playbackRate(rate) {
    this._playbackRate = rate;

    if (this._source) {
      this._source.playbackRate.value = rate;
    }
  }
  /**
   * internal start method
   */


  _start(time) {
    const buffer = _noiseBuffers[this._type];
    this._source = new _ToneBufferSource.ToneBufferSource({
      url: buffer,
      context: this.context,
      fadeIn: this._fadeIn,
      fadeOut: this._fadeOut,
      loop: true,
      onended: () => this.onstop(this),
      playbackRate: this._playbackRate
    }).connect(this.output);

    this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));
  }
  /**
   * internal stop method
   */


  _stop(time) {
    if (this._source) {
      this._source.stop(this.toSeconds(time));

      this._source = null;
    }
  }
  /**
   * The fadeIn time of the amplitude envelope.
   */


  get fadeIn() {
    return this._fadeIn;
  }

  set fadeIn(time) {
    this._fadeIn = time;

    if (this._source) {
      this._source.fadeIn = this._fadeIn;
    }
  }
  /**
   * The fadeOut time of the amplitude envelope.
   */


  get fadeOut() {
    return this._fadeOut;
  }

  set fadeOut(time) {
    this._fadeOut = time;

    if (this._source) {
      this._source.fadeOut = this._fadeOut;
    }
  }

  _restart(time) {
    // TODO could be optimized by cancelling the buffer source 'stop'
    this._stop(time);

    this._start(time);
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();

    if (this._source) {
      this._source.disconnect();
    }

    return this;
  }

} //--------------------
// THE NOISE BUFFERS
//--------------------
// Noise buffer stats


exports.Noise = Noise;
const BUFFER_LENGTH = 44100 * 5;
const NUM_CHANNELS = 2;
/**
 * Cache the noise buffers
 */

const _noiseCache = {
  brown: null,
  pink: null,
  white: null
};
/**
 * The noise arrays. Generated on initialization.
 * borrowed heavily from https://github.com/zacharydenton/noise.js
 * (c) 2013 Zach Denton (MIT)
 */

const _noiseBuffers = {
  get brown() {
    if (!_noiseCache.brown) {
      const buffer = [];

      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer[channelNum] = channel;
        let lastOut = 0.0;

        for (let i = 0; i < BUFFER_LENGTH; i++) {
          const white = Math.random() * 2 - 1;
          channel[i] = (lastOut + 0.02 * white) / 1.02;
          lastOut = channel[i];
          channel[i] *= 3.5; // (roughly) compensate for gain
        }
      }

      _noiseCache.brown = new _ToneAudioBuffer.ToneAudioBuffer().fromArray(buffer);
    }

    return _noiseCache.brown;
  },

  get pink() {
    if (!_noiseCache.pink) {
      const buffer = [];

      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer[channelNum] = channel;
        let b0, b1, b2, b3, b4, b5, b6;
        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;

        for (let i = 0; i < BUFFER_LENGTH; i++) {
          const white = Math.random() * 2 - 1;
          b0 = 0.99886 * b0 + white * 0.0555179;
          b1 = 0.99332 * b1 + white * 0.0750759;
          b2 = 0.96900 * b2 + white * 0.1538520;
          b3 = 0.86650 * b3 + white * 0.3104856;
          b4 = 0.55000 * b4 + white * 0.5329522;
          b5 = -0.7616 * b5 - white * 0.0168980;
          channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
          channel[i] *= 0.11; // (roughly) compensate for gain

          b6 = white * 0.115926;
        }
      }

      _noiseCache.pink = new _ToneAudioBuffer.ToneAudioBuffer().fromArray(buffer);
    }

    return _noiseCache.pink;
  },

  get white() {
    if (!_noiseCache.white) {
      const buffer = [];

      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {
        const channel = new Float32Array(BUFFER_LENGTH);
        buffer[channelNum] = channel;

        for (let i = 0; i < BUFFER_LENGTH; i++) {
          channel[i] = Math.random() * 2 - 1;
        }
      }

      _noiseCache.white = new _ToneAudioBuffer.ToneAudioBuffer().fromArray(buffer);
    }

    return _noiseCache.white;
  }

};
},{"../core/context/ToneAudioBuffer":"../node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","../source/Source":"../node_modules/tone/build/esm/source/Source.js","./buffer/ToneBufferSource":"../node_modules/tone/build/esm/source/buffer/ToneBufferSource.js"}],"../node_modules/tone/build/esm/source/UserMedia.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserMedia = void 0;

var _tslib = require("tslib");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Volume = require("../component/channel/Volume");

var _Defaults = require("../core/util/Defaults");

var _Debug = require("../core/util/Debug");

var _Interface = require("../core/util/Interface");

var _TypeCheck = require("../core/util/TypeCheck");

/**
 * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.
 * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)
 * to see which browsers are supported. Access to an external input
 * is limited to secure (HTTPS) connections.
 * @example
 * const meter = new Tone.Meter();
 * const mic = new Tone.UserMedia().connect(meter);
 * mic.open().then(() => {
 * 	// promise resolves when input is available
 * 	console.log("mic open");
 * 	// print the incoming mic levels in decibels
 * 	setInterval(() => console.log(meter.getValue()), 100);
 * }).catch(e => {
 * 	// promise is rejected when the user doesn't have or allow mic access
 * 	console.log("mic not open");
 * });
 * @category Source
 */
class UserMedia extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(UserMedia.getDefaults(), arguments, ["volume"]));
    this.name = "UserMedia";
    const options = (0, _Defaults.optionsFromArguments)(UserMedia.getDefaults(), arguments, ["volume"]);
    this._volume = this.output = new _Volume.Volume({
      context: this.context,
      volume: options.volume
    });
    this.volume = this._volume.volume;
    (0, _Interface.readOnly)(this, "volume");
    this.mute = options.mute;
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      mute: false,
      volume: 0
    });
  }
  /**
   * Open the media stream. If a string is passed in, it is assumed
   * to be the label or id of the stream, if a number is passed in,
   * it is the input number of the stream.
   * @param  labelOrId The label or id of the audio input media device.
   *                   With no argument, the default stream is opened.
   * @return The promise is resolved when the stream is open.
   */


  open(labelOrId) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _Debug.assert)(UserMedia.supported, "UserMedia is not supported"); // close the previous stream

      if (this.state === "started") {
        this.close();
      }

      const devices = yield UserMedia.enumerateDevices();

      if ((0, _TypeCheck.isNumber)(labelOrId)) {
        this._device = devices[labelOrId];
      } else {
        this._device = devices.find(device => {
          return device.label === labelOrId || device.deviceId === labelOrId;
        }); // didn't find a matching device

        if (!this._device && devices.length > 0) {
          this._device = devices[0];
        }

        (0, _Debug.assert)((0, _TypeCheck.isDefined)(this._device), `No matching device ${labelOrId}`);
      } // do getUserMedia


      const constraints = {
        audio: {
          echoCancellation: false,
          sampleRate: this.context.sampleRate,
          noiseSuppression: false,
          mozNoiseSuppression: false
        }
      };

      if (this._device) {
        // @ts-ignore
        constraints.audio.deviceId = this._device.deviceId;
      }

      const stream = yield navigator.mediaDevices.getUserMedia(constraints); // start a new source only if the previous one is closed

      if (!this._stream) {
        this._stream = stream; // Wrap a MediaStreamSourceNode around the live input stream.

        const mediaStreamNode = this.context.createMediaStreamSource(stream); // Connect the MediaStreamSourceNode to a gate gain node

        (0, _ToneAudioNode.connect)(mediaStreamNode, this.output);
        this._mediaStream = mediaStreamNode;
      }

      return this;
    });
  }
  /**
   * Close the media stream
   */


  close() {
    if (this._stream && this._mediaStream) {
      this._stream.getAudioTracks().forEach(track => {
        track.stop();
      });

      this._stream = undefined; // remove the old media stream

      this._mediaStream.disconnect();

      this._mediaStream = undefined;
    }

    this._device = undefined;
    return this;
  }
  /**
   * Returns a promise which resolves with the list of audio input devices available.
   * @return The promise that is resolved with the devices
   * @example
   * Tone.UserMedia.enumerateDevices().then((devices) => {
   * 	// print the device labels
   * 	console.log(devices.map(device => device.label));
   * });
   */


  static enumerateDevices() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const allDevices = yield navigator.mediaDevices.enumerateDevices();
      return allDevices.filter(device => {
        return device.kind === "audioinput";
      });
    });
  }
  /**
   * Returns the playback state of the source, "started" when the microphone is open
   * and "stopped" when the mic is closed.
   */


  get state() {
    return this._stream && this._stream.active ? "started" : "stopped";
  }
  /**
   * Returns an identifier for the represented device that is
   * persisted across sessions. It is un-guessable by other applications and
   * unique to the origin of the calling application. It is reset when the
   * user clears cookies (for Private Browsing, a different identifier is
   * used that is not persisted across sessions). Returns undefined when the
   * device is not open.
   */


  get deviceId() {
    if (this._device) {
      return this._device.deviceId;
    } else {
      return undefined;
    }
  }
  /**
   * Returns a group identifier. Two devices have the
   * same group identifier if they belong to the same physical device.
   * Returns null  when the device is not open.
   */


  get groupId() {
    if (this._device) {
      return this._device.groupId;
    } else {
      return undefined;
    }
  }
  /**
   * Returns a label describing this device (for example "Built-in Microphone").
   * Returns undefined when the device is not open or label is not available
   * because of permissions.
   */


  get label() {
    if (this._device) {
      return this._device.label;
    } else {
      return undefined;
    }
  }
  /**
   * Mute the output.
   * @example
   * const mic = new Tone.UserMedia();
   * mic.open().then(() => {
   * 	// promise resolves when input is available
   * });
   * // mute the output
   * mic.mute = true;
   */


  get mute() {
    return this._volume.mute;
  }

  set mute(mute) {
    this._volume.mute = mute;
  }

  dispose() {
    super.dispose();
    this.close();

    this._volume.dispose();

    this.volume.dispose();
    return this;
  }
  /**
   * If getUserMedia is supported by the browser.
   */


  static get supported() {
    return (0, _TypeCheck.isDefined)(navigator.mediaDevices) && (0, _TypeCheck.isDefined)(navigator.mediaDevices.getUserMedia);
  }

}

exports.UserMedia = UserMedia;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../component/channel/Volume":"../node_modules/tone/build/esm/component/channel/Volume.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js"}],"../node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateWaveform = generateWaveform;

var _tslib = require("tslib");

var _OfflineContext = require("../../core/context/OfflineContext");

/**
 * Render a segment of the oscillator to an offline context and return the results as an array
 */
function generateWaveform(instance, length) {
  return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
    const duration = length / instance.context.sampleRate;
    const context = new _OfflineContext.OfflineContext(1, duration, instance.context.sampleRate);
    const clone = new instance.constructor(Object.assign(instance.get(), {
      // should do 2 iterations
      frequency: 2 / duration,
      // zero out the detune
      detune: 0,
      context
    })).toDestination();
    clone.start(0);
    const buffer = yield context.render();
    return buffer.getChannelData(0);
  });
}
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/context/OfflineContext":"../node_modules/tone/build/esm/core/context/OfflineContext.js"}],"../node_modules/tone/build/esm/source/oscillator/ToneOscillatorNode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToneOscillatorNode = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Param = require("../../core/context/Param");

var _Defaults = require("../../core/util/Defaults");

var _OneShotSource = require("../OneShotSource");

var _Interface = require("../../core/util/Interface");

/**
 * Wrapper around the native fire-and-forget OscillatorNode.
 * Adds the ability to reschedule the stop method.
 * ***[[Oscillator]] is better for most use-cases***
 * @category Source
 */
class ToneOscillatorNode extends _OneShotSource.OneShotSource {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(ToneOscillatorNode.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "ToneOscillatorNode";
    /**
     * The oscillator
     */

    this._oscillator = this.context.createOscillator();
    this._internalChannels = [this._oscillator];
    const options = (0, _Defaults.optionsFromArguments)(ToneOscillatorNode.getDefaults(), arguments, ["frequency", "type"]);
    (0, _ToneAudioNode.connect)(this._oscillator, this._gainNode);
    this.type = options.type;
    this.frequency = new _Param.Param({
      context: this.context,
      param: this._oscillator.frequency,
      units: "frequency",
      value: options.frequency
    });
    this.detune = new _Param.Param({
      context: this.context,
      param: this._oscillator.detune,
      units: "cents",
      value: options.detune
    });
    (0, _Interface.readOnly)(this, ["frequency", "detune"]);
  }

  static getDefaults() {
    return Object.assign(_OneShotSource.OneShotSource.getDefaults(), {
      detune: 0,
      frequency: 440,
      type: "sine"
    });
  }
  /**
   * Start the oscillator node at the given time
   * @param  time When to start the oscillator
   */


  start(time) {
    const computedTime = this.toSeconds(time);
    this.log("start", computedTime);

    this._startGain(computedTime);

    this._oscillator.start(computedTime);

    return this;
  }

  _stopSource(time) {
    this._oscillator.stop(time);
  }
  /**
   * Sets an arbitrary custom periodic waveform given a PeriodicWave.
   * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave
   */


  setPeriodicWave(periodicWave) {
    this._oscillator.setPeriodicWave(periodicWave);

    return this;
  }
  /**
   * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'
   */


  get type() {
    return this._oscillator.type;
  }

  set type(type) {
    this._oscillator.type = type;
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();

    if (this.state === "started") {
      this.stop();
    }

    this._oscillator.disconnect();

    this.frequency.dispose();
    this.detune.dispose();
    return this;
  }

}

exports.ToneOscillatorNode = ToneOscillatorNode;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../OneShotSource":"../node_modules/tone/build/esm/source/OneShotSource.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/source/oscillator/Oscillator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Oscillator = void 0;

var _tslib = require("tslib");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _TypeCheck = require("../../core/util/TypeCheck");

var _Signal = require("../../signal/Signal");

var _Source = require("../Source");

var _OscillatorInterface = require("./OscillatorInterface");

var _ToneOscillatorNode = require("./ToneOscillatorNode");

var _Debug = require("../../core/util/Debug");

var _Math = require("../../core/util/Math");

/**
 * Oscillator supports a number of features including
 * phase rotation, multiple oscillator types (see Oscillator.type),
 * and Transport syncing (see Oscillator.syncFrequency).
 *
 * @example
 * // make and start a 440hz sine tone
 * const osc = new Tone.Oscillator(440, "sine").toDestination().start();
 * @category Source
 */
class Oscillator extends _Source.Source {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Oscillator.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "Oscillator";
    /**
     * the main oscillator
     */

    this._oscillator = null;
    const options = (0, _Defaults.optionsFromArguments)(Oscillator.getDefaults(), arguments, ["frequency", "type"]);
    this.frequency = new _Signal.Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency
    });
    (0, _Interface.readOnly)(this, "frequency");
    this.detune = new _Signal.Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    });
    (0, _Interface.readOnly)(this, "detune");
    this._partials = options.partials;
    this._partialCount = options.partialCount;
    this._type = options.type;

    if (options.partialCount && options.type !== "custom") {
      this._type = this.baseType + options.partialCount.toString();
    }

    this.phase = options.phase;
  }

  static getDefaults() {
    return Object.assign(_Source.Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      partialCount: 0,
      partials: [],
      phase: 0,
      type: "sine"
    });
  }
  /**
   * start the oscillator
   */


  _start(time) {
    const computedTime = this.toSeconds(time); // new oscillator with previous values

    const oscillator = new _ToneOscillatorNode.ToneOscillatorNode({
      context: this.context,
      onended: () => this.onstop(this)
    });
    this._oscillator = oscillator;

    if (this._wave) {
      this._oscillator.setPeriodicWave(this._wave);
    } else {
      this._oscillator.type = this._type;
    } // connect the control signal to the oscillator frequency & detune


    this._oscillator.connect(this.output);

    this.frequency.connect(this._oscillator.frequency);
    this.detune.connect(this._oscillator.detune); // start the oscillator

    this._oscillator.start(computedTime);
  }
  /**
   * stop the oscillator
   */


  _stop(time) {
    const computedTime = this.toSeconds(time);

    if (this._oscillator) {
      this._oscillator.stop(computedTime);
    }
  }
  /**
   * Restart the oscillator. Does not stop the oscillator, but instead
   * just cancels any scheduled 'stop' from being invoked.
   */


  _restart(time) {
    const computedTime = this.toSeconds(time);
    this.log("restart", computedTime);

    if (this._oscillator) {
      this._oscillator.cancelStop();
    }

    this._state.cancel(computedTime);

    return this;
  }
  /**
   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,
   * will also affect the oscillators frequency.
   * @example
   * const osc = new Tone.Oscillator().toDestination().start();
   * osc.frequency.value = 440;
   * // the ratio between the bpm and the frequency will be maintained
   * osc.syncFrequency();
   * // double the tempo
   * Tone.Transport.bpm.value *= 2;
   * // the frequency of the oscillator is doubled to 880
   */


  syncFrequency() {
    this.context.transport.syncSignal(this.frequency);
    return this;
  }
  /**
   * Unsync the oscillator's frequency from the Transport.
   * See Oscillator.syncFrequency
   */


  unsyncFrequency() {
    this.context.transport.unsyncSignal(this.frequency);
    return this;
  }
  /**
   * Get a cached periodic wave. Avoids having to recompute
   * the oscillator values when they have already been computed
   * with the same values.
   */


  _getCachedPeriodicWave() {
    if (this._type === "custom") {
      const oscProps = Oscillator._periodicWaveCache.find(description => {
        return description.phase === this._phase && (0, _Defaults.deepEquals)(description.partials, this._partials);
      });

      return oscProps;
    } else {
      const oscProps = Oscillator._periodicWaveCache.find(description => {
        return description.type === this._type && description.phase === this._phase;
      });

      this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;
      return oscProps;
    }
  }

  get type() {
    return this._type;
  }

  set type(type) {
    this._type = type;
    const isBasicType = ["sine", "square", "sawtooth", "triangle"].indexOf(type) !== -1;

    if (this._phase === 0 && isBasicType) {
      this._wave = undefined;
      this._partialCount = 0; // just go with the basic approach

      if (this._oscillator !== null) {
        // already tested that it's a basic type
        this._oscillator.type = type;
      }
    } else {
      // first check if the value is cached
      const cache = this._getCachedPeriodicWave();

      if ((0, _TypeCheck.isDefined)(cache)) {
        const {
          partials,
          wave
        } = cache;
        this._wave = wave;
        this._partials = partials;

        if (this._oscillator !== null) {
          this._oscillator.setPeriodicWave(this._wave);
        }
      } else {
        const [real, imag] = this._getRealImaginary(type, this._phase);

        const periodicWave = this.context.createPeriodicWave(real, imag);
        this._wave = periodicWave;

        if (this._oscillator !== null) {
          this._oscillator.setPeriodicWave(this._wave);
        } // set the cache


        Oscillator._periodicWaveCache.push({
          imag,
          partialCount: this._partialCount,
          partials: this._partials,
          phase: this._phase,
          real,
          type: this._type,
          wave: this._wave
        });

        if (Oscillator._periodicWaveCache.length > 100) {
          Oscillator._periodicWaveCache.shift();
        }
      }
    }
  }

  get baseType() {
    return this._type.replace(this.partialCount.toString(), "");
  }

  set baseType(baseType) {
    if (this.partialCount && this._type !== "custom" && baseType !== "custom") {
      this.type = baseType + this.partialCount;
    } else {
      this.type = baseType;
    }
  }

  get partialCount() {
    return this._partialCount;
  }

  set partialCount(p) {
    (0, _Debug.assertRange)(p, 0);
    let type = this._type;
    const partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);

    if (partial) {
      type = partial[1];
    }

    if (this._type !== "custom") {
      if (p === 0) {
        this.type = type;
      } else {
        this.type = type + p.toString();
      }
    } else {
      // extend or shorten the partials array
      const fullPartials = new Float32Array(p); // copy over the partials array

      this._partials.forEach((v, i) => fullPartials[i] = v);

      this._partials = Array.from(fullPartials);
      this.type = this._type;
    }
  }
  /**
   * Returns the real and imaginary components based
   * on the oscillator type.
   * @returns [real: Float32Array, imaginary: Float32Array]
   */


  _getRealImaginary(type, phase) {
    const fftSize = 4096;
    let periodicWaveSize = fftSize / 2;
    const real = new Float32Array(periodicWaveSize);
    const imag = new Float32Array(periodicWaveSize);
    let partialCount = 1;

    if (type === "custom") {
      partialCount = this._partials.length + 1;
      this._partialCount = this._partials.length;
      periodicWaveSize = partialCount; // if the partial count is 0, don't bother doing any computation

      if (this._partials.length === 0) {
        return [real, imag];
      }
    } else {
      const partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(type);

      if (partial) {
        partialCount = parseInt(partial[2], 10) + 1;
        this._partialCount = parseInt(partial[2], 10);
        type = partial[1];
        partialCount = Math.max(partialCount, 2);
        periodicWaveSize = partialCount;
      } else {
        this._partialCount = 0;
      }

      this._partials = [];
    }

    for (let n = 1; n < periodicWaveSize; ++n) {
      const piFactor = 2 / (n * Math.PI);
      let b;

      switch (type) {
        case "sine":
          b = n <= partialCount ? 1 : 0;
          this._partials[n - 1] = b;
          break;

        case "square":
          b = n & 1 ? 2 * piFactor : 0;
          this._partials[n - 1] = b;
          break;

        case "sawtooth":
          b = piFactor * (n & 1 ? 1 : -1);
          this._partials[n - 1] = b;
          break;

        case "triangle":
          if (n & 1) {
            b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);
          } else {
            b = 0;
          }

          this._partials[n - 1] = b;
          break;

        case "custom":
          b = this._partials[n - 1];
          break;

        default:
          throw new TypeError("Oscillator: invalid type: " + type);
      }

      if (b !== 0) {
        real[n] = -b * Math.sin(phase * n);
        imag[n] = b * Math.cos(phase * n);
      } else {
        real[n] = 0;
        imag[n] = 0;
      }
    }

    return [real, imag];
  }
  /**
   * Compute the inverse FFT for a given phase.
   */


  _inverseFFT(real, imag, phase) {
    let sum = 0;
    const len = real.length;

    for (let i = 0; i < len; i++) {
      sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);
    }

    return sum;
  }
  /**
   * Returns the initial value of the oscillator when stopped.
   * E.g. a "sine" oscillator with phase = 90 would return an initial value of -1.
   */


  getInitialValue() {
    const [real, imag] = this._getRealImaginary(this._type, 0);

    let maxValue = 0;
    const twoPi = Math.PI * 2;
    const testPositions = 32; // check for peaks in 16 places

    for (let i = 0; i < testPositions; i++) {
      maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);
    }

    return (0, _Math.clamp)(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);
  }

  get partials() {
    return this._partials.slice(0, this.partialCount);
  }

  set partials(partials) {
    this._partials = partials;
    this._partialCount = this._partials.length;

    if (partials.length) {
      this.type = "custom";
    }
  }

  get phase() {
    return this._phase * (180 / Math.PI);
  }

  set phase(phase) {
    this._phase = phase * Math.PI / 180; // reset the type

    this.type = this._type;
  }

  asArray(length = 1024) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _OscillatorInterface.generateWaveform)(this, length);
    });
  }

  dispose() {
    super.dispose();

    if (this._oscillator !== null) {
      this._oscillator.dispose();
    }

    this._wave = undefined;
    this.frequency.dispose();
    this.detune.dispose();
    return this;
  }

}
/**
 * Cache the periodic waves to avoid having to redo computations
 */


exports.Oscillator = Oscillator;
Oscillator._periodicWaveCache = [];
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","../../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../Source":"../node_modules/tone/build/esm/source/Source.js","./OscillatorInterface":"../node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js","./ToneOscillatorNode":"../node_modules/tone/build/esm/source/oscillator/ToneOscillatorNode.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","../../core/util/Math":"../node_modules/tone/build/esm/core/util/Math.js"}],"../node_modules/tone/build/esm/signal/SignalOperator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignalOperator = void 0;

var _Defaults = require("../core/util/Defaults");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Signal = require("./Signal");

/**
 * A signal operator has an input and output and modifies the signal.
 */
class SignalOperator extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(SignalOperator.getDefaults(), arguments, ["context"])));
  }

  connect(destination, outputNum = 0, inputNum = 0) {
    (0, _Signal.connectSignal)(this, destination, outputNum, inputNum);
    return this;
  }

}

exports.SignalOperator = SignalOperator;
},{"../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","./Signal":"../node_modules/tone/build/esm/signal/Signal.js"}],"../node_modules/tone/build/esm/signal/WaveShaper.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaveShaper = void 0;

var _Defaults = require("../core/util/Defaults");

var _TypeCheck = require("../core/util/TypeCheck");

var _Debug = require("../core/util/Debug");

var _Signal = require("./Signal");

var _SignalOperator = require("./SignalOperator");

/**
 * Wraps the native Web Audio API
 * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).
 *
 * @example
 * const osc = new Tone.Oscillator().toDestination().start();
 * // multiply the output of the signal by 2 using the waveshaper's function
 * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);
 * const signal = new Tone.Signal(440).connect(timesTwo);
 * @category Signal
 */
class WaveShaper extends _SignalOperator.SignalOperator {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(WaveShaper.getDefaults(), arguments, ["mapping", "length"])));
    this.name = "WaveShaper";
    /**
     * the waveshaper node
     */

    this._shaper = this.context.createWaveShaper();
    /**
     * The input to the waveshaper node.
     */

    this.input = this._shaper;
    /**
     * The output from the waveshaper node
     */

    this.output = this._shaper;
    const options = (0, _Defaults.optionsFromArguments)(WaveShaper.getDefaults(), arguments, ["mapping", "length"]);

    if ((0, _TypeCheck.isArray)(options.mapping) || options.mapping instanceof Float32Array) {
      this.curve = Float32Array.from(options.mapping);
    } else if ((0, _TypeCheck.isFunction)(options.mapping)) {
      this.setMap(options.mapping, options.length);
    }
  }

  static getDefaults() {
    return Object.assign(_Signal.Signal.getDefaults(), {
      length: 1024
    });
  }
  /**
   * Uses a mapping function to set the value of the curve.
   * @param mapping The function used to define the values.
   *                The mapping function take two arguments:
   *                the first is the value at the current position
   *                which goes from -1 to 1 over the number of elements
   *                in the curve array. The second argument is the array position.
   * @example
   * const shaper = new Tone.WaveShaper();
   * // map the input signal from [-1, 1] to [0, 10]
   * shaper.setMap((val, index) => (val + 1) * 5);
   */


  setMap(mapping, length = 1024) {
    const array = new Float32Array(length);

    for (let i = 0, len = length; i < len; i++) {
      const normalized = i / (len - 1) * 2 - 1;
      array[i] = mapping(normalized, i);
    }

    this.curve = array;
    return this;
  }
  /**
   * The array to set as the waveshaper curve. For linear curves
   * array length does not make much difference, but for complex curves
   * longer arrays will provide smoother interpolation.
   */


  get curve() {
    return this._shaper.curve;
  }

  set curve(mapping) {
    this._shaper.curve = mapping;
  }
  /**
   * Specifies what type of oversampling (if any) should be used when
   * applying the shaping curve. Can either be "none", "2x" or "4x".
   */


  get oversample() {
    return this._shaper.oversample;
  }

  set oversample(oversampling) {
    const isOverSampleType = ["none", "2x", "4x"].some(str => str.includes(oversampling));
    (0, _Debug.assert)(isOverSampleType, "oversampling must be either 'none', '2x', or '4x'");
    this._shaper.oversample = oversampling;
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();

    this._shaper.disconnect();

    return this;
  }

}

exports.WaveShaper = WaveShaper;
},{"../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","./Signal":"../node_modules/tone/build/esm/signal/Signal.js","./SignalOperator":"../node_modules/tone/build/esm/signal/SignalOperator.js"}],"../node_modules/tone/build/esm/signal/AudioToGain.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AudioToGain = void 0;

var _SignalOperator = require("./SignalOperator");

var _WaveShaper = require("./WaveShaper");

/**
 * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].
 * See [[GainToAudio]].
 * @category Signal
 */
class AudioToGain extends _SignalOperator.SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "AudioToGain";
    /**
     * The node which converts the audio ranges
     */

    this._norm = new _WaveShaper.WaveShaper({
      context: this.context,
      mapping: x => (x + 1) / 2
    });
    /**
     * The AudioRange input [-1, 1]
     */

    this.input = this._norm;
    /**
     * The GainRange output [0, 1]
     */

    this.output = this._norm;
  }
  /**
   * clean up
   */


  dispose() {
    super.dispose();

    this._norm.dispose();

    return this;
  }

}

exports.AudioToGain = AudioToGain;
},{"./SignalOperator":"../node_modules/tone/build/esm/signal/SignalOperator.js","./WaveShaper":"../node_modules/tone/build/esm/signal/WaveShaper.js"}],"../node_modules/tone/build/esm/signal/Multiply.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Multiply = void 0;

var _Gain = require("../core/context/Gain");

var _Defaults = require("../core/util/Defaults");

var _Signal = require("./Signal");

/**
 * Multiply two incoming signals. Or, if a number is given in the constructor,
 * multiplies the incoming signal by that value.
 *
 * @example
 * // multiply two signals
 * const mult = new Tone.Multiply();
 * const sigA = new Tone.Signal(3);
 * const sigB = new Tone.Signal(4);
 * sigA.connect(mult);
 * sigB.connect(mult.factor);
 * // output of mult is 12.
 * @example
 * // multiply a signal and a number
 * const mult = new Tone.Multiply(10);
 * const sig = new Tone.Signal(2).connect(mult);
 * // the output of mult is 20.
 * @category Signal
 */
class Multiply extends _Signal.Signal {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(Multiply.getDefaults(), arguments, ["value"])));
    this.name = "Multiply";
    /**
     * Indicates if the value should be overridden on connection
     */

    this.override = false;
    const options = (0, _Defaults.optionsFromArguments)(Multiply.getDefaults(), arguments, ["value"]);
    this._mult = this.input = this.output = new _Gain.Gain({
      context: this.context,
      minValue: options.minValue,
      maxValue: options.maxValue
    });
    this.factor = this._param = this._mult.gain;
    this.factor.setValueAtTime(options.value, 0);
  }

  static getDefaults() {
    return Object.assign(_Signal.Signal.getDefaults(), {
      value: 0
    });
  }

  dispose() {
    super.dispose();

    this._mult.dispose();

    return this;
  }

}

exports.Multiply = Multiply;
},{"../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Signal":"../node_modules/tone/build/esm/signal/Signal.js"}],"../node_modules/tone/build/esm/source/oscillator/AMOscillator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AMOscillator = void 0;

var _tslib = require("tslib");

var _Gain = require("../../core/context/Gain");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _AudioToGain = require("../../signal/AudioToGain");

var _Multiply = require("../../signal/Multiply");

var _Source = require("../Source");

var _Oscillator = require("./Oscillator");

var _OscillatorInterface = require("./OscillatorInterface");

/**
 * An amplitude modulated oscillator node. It is implemented with
 * two oscillators, one which modulators the other's amplitude
 * through a gain node.
 * ```
 *    +-------------+       +----------+
 *    | Carrier Osc +>------> GainNode |
 *    +-------------+       |          +--->Output
 *                      +---> gain     |
 * +---------------+    |   +----------+
 * | Modulator Osc +>---+
 * +---------------+
 * ```
 * @example
 * return Tone.Offline(() => {
 * 	const amOsc = new Tone.AMOscillator(30, "sine", "square").toDestination().start();
 * }, 0.2, 1);
 * @category Source
 */
class AMOscillator extends _Source.Source {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(AMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]));
    this.name = "AMOscillator";
    /**
     * convert the -1,1 output to 0,1
     */

    this._modulationScale = new _AudioToGain.AudioToGain({
      context: this.context
    });
    /**
     * the node where the modulation happens
     */

    this._modulationNode = new _Gain.Gain({
      context: this.context
    });
    const options = (0, _Defaults.optionsFromArguments)(AMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    this._carrier = new _Oscillator.Oscillator({
      context: this.context,
      detune: options.detune,
      frequency: options.frequency,
      onstop: () => this.onstop(this),
      phase: options.phase,
      type: options.type
    });
    this.frequency = this._carrier.frequency, this.detune = this._carrier.detune;
    this._modulator = new _Oscillator.Oscillator({
      context: this.context,
      phase: options.phase,
      type: options.modulationType
    });
    this.harmonicity = new _Multiply.Multiply({
      context: this.context,
      units: "positive",
      value: options.harmonicity
    }); // connections

    this.frequency.chain(this.harmonicity, this._modulator.frequency);

    this._modulator.chain(this._modulationScale, this._modulationNode.gain);

    this._carrier.chain(this._modulationNode, this.output);

    (0, _Interface.readOnly)(this, ["frequency", "detune", "harmonicity"]);
  }

  static getDefaults() {
    return Object.assign(_Oscillator.Oscillator.getDefaults(), {
      harmonicity: 1,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */


  _start(time) {
    this._modulator.start(time);

    this._carrier.start(time);
  }
  /**
   * stop the oscillator
   */


  _stop(time) {
    this._modulator.stop(time);

    this._carrier.stop(time);
  }

  _restart(time) {
    this._modulator.restart(time);

    this._carrier.restart(time);
  }
  /**
   * The type of the carrier oscillator
   */


  get type() {
    return this._carrier.type;
  }

  set type(type) {
    this._carrier.type = type;
  }

  get baseType() {
    return this._carrier.baseType;
  }

  set baseType(baseType) {
    this._carrier.baseType = baseType;
  }

  get partialCount() {
    return this._carrier.partialCount;
  }

  set partialCount(partialCount) {
    this._carrier.partialCount = partialCount;
  }
  /**
   * The type of the modulator oscillator
   */


  get modulationType() {
    return this._modulator.type;
  }

  set modulationType(type) {
    this._modulator.type = type;
  }

  get phase() {
    return this._carrier.phase;
  }

  set phase(phase) {
    this._carrier.phase = phase;
    this._modulator.phase = phase;
  }

  get partials() {
    return this._carrier.partials;
  }

  set partials(partials) {
    this._carrier.partials = partials;
  }

  asArray(length = 1024) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _OscillatorInterface.generateWaveform)(this, length);
    });
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.detune.dispose();
    this.harmonicity.dispose();

    this._carrier.dispose();

    this._modulator.dispose();

    this._modulationNode.dispose();

    this._modulationScale.dispose();

    return this;
  }

}

exports.AMOscillator = AMOscillator;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../signal/AudioToGain":"../node_modules/tone/build/esm/signal/AudioToGain.js","../../signal/Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","../Source":"../node_modules/tone/build/esm/source/Source.js","./Oscillator":"../node_modules/tone/build/esm/source/oscillator/Oscillator.js","./OscillatorInterface":"../node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js"}],"../node_modules/tone/build/esm/source/oscillator/FMOscillator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FMOscillator = void 0;

var _tslib = require("tslib");

var _Gain = require("../../core/context/Gain");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _Multiply = require("../../signal/Multiply");

var _Signal = require("../../signal/Signal");

var _Source = require("../Source");

var _Oscillator = require("./Oscillator");

var _OscillatorInterface = require("./OscillatorInterface");

/**
 * FMOscillator implements a frequency modulation synthesis
 * ```
 *                                              +-------------+
 * +---------------+        +-------------+     | Carrier Osc |
 * | Modulator Osc +>-------> GainNode    |     |             +--->Output
 * +---------------+        |             +>----> frequency   |
 *                       +--> gain        |     +-------------+
 *                       |  +-------------+
 * +-----------------+   |
 * | modulationIndex +>--+
 * +-----------------+
 * ```
 *
 * @example
 * return Tone.Offline(() => {
 * 	const fmOsc = new Tone.FMOscillator({
 * 		frequency: 200,
 * 		type: "square",
 * 		modulationType: "triangle",
 * 		harmonicity: 0.2,
 * 		modulationIndex: 3
 * 	}).toDestination().start();
 * }, 0.1, 1);
 * @category Source
 */
class FMOscillator extends _Source.Source {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]));
    this.name = "FMOscillator";
    /**
     * the node where the modulation happens
     */

    this._modulationNode = new _Gain.Gain({
      context: this.context,
      gain: 0
    });
    const options = (0, _Defaults.optionsFromArguments)(FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
    this._carrier = new _Oscillator.Oscillator({
      context: this.context,
      detune: options.detune,
      frequency: 0,
      onstop: () => this.onstop(this),
      phase: options.phase,
      type: options.type
    });
    this.detune = this._carrier.detune;
    this.frequency = new _Signal.Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency
    });
    this._modulator = new _Oscillator.Oscillator({
      context: this.context,
      phase: options.phase,
      type: options.modulationType
    });
    this.harmonicity = new _Multiply.Multiply({
      context: this.context,
      units: "positive",
      value: options.harmonicity
    });
    this.modulationIndex = new _Multiply.Multiply({
      context: this.context,
      units: "positive",
      value: options.modulationIndex
    }); // connections

    this.frequency.connect(this._carrier.frequency);
    this.frequency.chain(this.harmonicity, this._modulator.frequency);
    this.frequency.chain(this.modulationIndex, this._modulationNode);

    this._modulator.connect(this._modulationNode.gain);

    this._modulationNode.connect(this._carrier.frequency);

    this._carrier.connect(this.output);

    this.detune.connect(this._modulator.detune);
    (0, _Interface.readOnly)(this, ["modulationIndex", "frequency", "detune", "harmonicity"]);
  }

  static getDefaults() {
    return Object.assign(_Oscillator.Oscillator.getDefaults(), {
      harmonicity: 1,
      modulationIndex: 2,
      modulationType: "square"
    });
  }
  /**
   * start the oscillator
   */


  _start(time) {
    this._modulator.start(time);

    this._carrier.start(time);
  }
  /**
   * stop the oscillator
   */


  _stop(time) {
    this._modulator.stop(time);

    this._carrier.stop(time);
  }

  _restart(time) {
    this._modulator.restart(time);

    this._carrier.restart(time);

    return this;
  }

  get type() {
    return this._carrier.type;
  }

  set type(type) {
    this._carrier.type = type;
  }

  get baseType() {
    return this._carrier.baseType;
  }

  set baseType(baseType) {
    this._carrier.baseType = baseType;
  }

  get partialCount() {
    return this._carrier.partialCount;
  }

  set partialCount(partialCount) {
    this._carrier.partialCount = partialCount;
  }
  /**
   * The type of the modulator oscillator
   */


  get modulationType() {
    return this._modulator.type;
  }

  set modulationType(type) {
    this._modulator.type = type;
  }

  get phase() {
    return this._carrier.phase;
  }

  set phase(phase) {
    this._carrier.phase = phase;
    this._modulator.phase = phase;
  }

  get partials() {
    return this._carrier.partials;
  }

  set partials(partials) {
    this._carrier.partials = partials;
  }

  asArray(length = 1024) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _OscillatorInterface.generateWaveform)(this, length);
    });
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.harmonicity.dispose();

    this._carrier.dispose();

    this._modulator.dispose();

    this._modulationNode.dispose();

    this.modulationIndex.dispose();
    return this;
  }

}

exports.FMOscillator = FMOscillator;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../signal/Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","../../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../Source":"../node_modules/tone/build/esm/source/Source.js","./Oscillator":"../node_modules/tone/build/esm/source/oscillator/Oscillator.js","./OscillatorInterface":"../node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js"}],"../node_modules/tone/build/esm/source/oscillator/PulseOscillator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PulseOscillator = void 0;

var _tslib = require("tslib");

var _Gain = require("../../core/context/Gain");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _Signal = require("../../signal/Signal");

var _WaveShaper = require("../../signal/WaveShaper");

var _Source = require("../Source");

var _Oscillator = require("./Oscillator");

var _OscillatorInterface = require("./OscillatorInterface");

/**
 * PulseOscillator is an oscillator with control over pulse width,
 * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is
 * a square wave.
 * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).
 * ```
 *    width = -0.25        width = 0.0          width = 0.25
 *
 *   +-----+            +-------+       +    +-------+     +-+
 *   |     |            |       |       |            |     |
 *   |     |            |       |       |            |     |
 * +-+     +-------+    +       +-------+            +-----+
 *
 *
 *    width = -0.5                              width = 0.5
 *
 *     +---+                                 +-------+   +---+
 *     |   |                                         |   |
 *     |   |                                         |   |
 * +---+   +-------+                                 +---+
 *
 *
 *    width = -0.75                             width = 0.75
 *
 *       +-+                                 +-------+ +-----+
 *       | |                                         | |
 *       | |                                         | |
 * +-----+ +-------+                                 +-+
 * ```
 * @example
 * return Tone.Offline(() => {
 * 	const pulse = new Tone.PulseOscillator(50, 0.4).toDestination().start();
 * }, 0.1, 1);
 * @category Source
 */
class PulseOscillator extends _Source.Source {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(PulseOscillator.getDefaults(), arguments, ["frequency", "width"]));
    this.name = "PulseOscillator";
    /**
     * gate the width amount
     */

    this._widthGate = new _Gain.Gain({
      context: this.context,
      gain: 0
    });
    /**
     * Threshold the signal to turn it into a square
     */

    this._thresh = new _WaveShaper.WaveShaper({
      context: this.context,
      mapping: val => val <= 0 ? -1 : 1
    });
    const options = (0, _Defaults.optionsFromArguments)(PulseOscillator.getDefaults(), arguments, ["frequency", "width"]);
    this.width = new _Signal.Signal({
      context: this.context,
      units: "audioRange",
      value: options.width
    });
    this._triangle = new _Oscillator.Oscillator({
      context: this.context,
      detune: options.detune,
      frequency: options.frequency,
      onstop: () => this.onstop(this),
      phase: options.phase,
      type: "triangle"
    });
    this.frequency = this._triangle.frequency;
    this.detune = this._triangle.detune; // connections

    this._triangle.chain(this._thresh, this.output);

    this.width.chain(this._widthGate, this._thresh);
    (0, _Interface.readOnly)(this, ["width", "frequency", "detune"]);
  }

  static getDefaults() {
    return Object.assign(_Source.Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      phase: 0,
      type: "pulse",
      width: 0.2
    });
  }
  /**
   * start the oscillator
   */


  _start(time) {
    time = this.toSeconds(time);

    this._triangle.start(time);

    this._widthGate.gain.setValueAtTime(1, time);
  }
  /**
   * stop the oscillator
   */


  _stop(time) {
    time = this.toSeconds(time);

    this._triangle.stop(time); // the width is still connected to the output.
    // that needs to be stopped also


    this._widthGate.gain.cancelScheduledValues(time);

    this._widthGate.gain.setValueAtTime(0, time);
  }

  _restart(time) {
    this._triangle.restart(time);

    this._widthGate.gain.cancelScheduledValues(time);

    this._widthGate.gain.setValueAtTime(1, time);
  }
  /**
   * The phase of the oscillator in degrees.
   */


  get phase() {
    return this._triangle.phase;
  }

  set phase(phase) {
    this._triangle.phase = phase;
  }
  /**
   * The type of the oscillator. Always returns "pulse".
   */


  get type() {
    return "pulse";
  }
  /**
   * The baseType of the oscillator. Always returns "pulse".
   */


  get baseType() {
    return "pulse";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */


  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */


  get partialCount() {
    return 0;
  }
  /**
   * *Internal use* The carrier oscillator type is fed through the
   * waveshaper node to create the pulse. Using different carrier oscillators
   * changes oscillator's behavior.
   */


  set carrierType(type) {
    this._triangle.type = type;
  }

  asArray(length = 1024) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _OscillatorInterface.generateWaveform)(this, length);
    });
  }
  /**
   * Clean up method.
   */


  dispose() {
    super.dispose();

    this._triangle.dispose();

    this.width.dispose();

    this._widthGate.dispose();

    this._thresh.dispose();

    return this;
  }

}

exports.PulseOscillator = PulseOscillator;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../../signal/WaveShaper":"../node_modules/tone/build/esm/signal/WaveShaper.js","../Source":"../node_modules/tone/build/esm/source/Source.js","./Oscillator":"../node_modules/tone/build/esm/source/oscillator/Oscillator.js","./OscillatorInterface":"../node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js"}],"../node_modules/tone/build/esm/source/oscillator/FatOscillator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FatOscillator = void 0;

var _tslib = require("tslib");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _Signal = require("../../signal/Signal");

var _Source = require("../Source");

var _Oscillator = require("./Oscillator");

var _OscillatorInterface = require("./OscillatorInterface");

var _Debug = require("../../core/util/Debug");

/**
 * FatOscillator is an array of oscillators with detune spread between the oscillators
 * @example
 * const fatOsc = new Tone.FatOscillator("Ab3", "sawtooth", 40).toDestination().start();
 * @category Source
 */
class FatOscillator extends _Source.Source {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]));
    this.name = "FatOscillator";
    /**
     * The array of oscillators
     */

    this._oscillators = [];
    const options = (0, _Defaults.optionsFromArguments)(FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]);
    this.frequency = new _Signal.Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency
    });
    this.detune = new _Signal.Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    });
    this._spread = options.spread;
    this._type = options.type;
    this._phase = options.phase;
    this._partials = options.partials;
    this._partialCount = options.partialCount; // set the count initially

    this.count = options.count;
    (0, _Interface.readOnly)(this, ["frequency", "detune"]);
  }

  static getDefaults() {
    return Object.assign(_Oscillator.Oscillator.getDefaults(), {
      count: 3,
      spread: 20,
      type: "sawtooth"
    });
  }
  /**
   * start the oscillator
   */


  _start(time) {
    time = this.toSeconds(time);

    this._forEach(osc => osc.start(time));
  }
  /**
   * stop the oscillator
   */


  _stop(time) {
    time = this.toSeconds(time);

    this._forEach(osc => osc.stop(time));
  }

  _restart(time) {
    this._forEach(osc => osc.restart(time));
  }
  /**
   * Iterate over all of the oscillators
   */


  _forEach(iterator) {
    for (let i = 0; i < this._oscillators.length; i++) {
      iterator(this._oscillators[i], i);
    }
  }
  /**
   * The type of the oscillator
   */


  get type() {
    return this._type;
  }

  set type(type) {
    this._type = type;

    this._forEach(osc => osc.type = type);
  }
  /**
   * The detune spread between the oscillators. If "count" is
   * set to 3 oscillators and the "spread" is set to 40,
   * the three oscillators would be detuned like this: [-20, 0, 20]
   * for a total detune spread of 40 cents.
   * @example
   * const fatOsc = new Tone.FatOscillator().toDestination().start();
   * fatOsc.spread = 70;
   */


  get spread() {
    return this._spread;
  }

  set spread(spread) {
    this._spread = spread;

    if (this._oscillators.length > 1) {
      const start = -spread / 2;
      const step = spread / (this._oscillators.length - 1);

      this._forEach((osc, i) => osc.detune.value = start + step * i);
    }
  }
  /**
   * The number of detuned oscillators. Must be an integer greater than 1.
   * @example
   * const fatOsc = new Tone.FatOscillator("C#3", "sawtooth").toDestination().start();
   * // use 4 sawtooth oscillators
   * fatOsc.count = 4;
   */


  get count() {
    return this._oscillators.length;
  }

  set count(count) {
    (0, _Debug.assertRange)(count, 1);

    if (this._oscillators.length !== count) {
      // dispose the previous oscillators
      this._forEach(osc => osc.dispose());

      this._oscillators = [];

      for (let i = 0; i < count; i++) {
        const osc = new _Oscillator.Oscillator({
          context: this.context,
          volume: -6 - count * 1.1,
          type: this._type,
          phase: this._phase + i / count * 360,
          partialCount: this._partialCount,
          onstop: i === 0 ? () => this.onstop(this) : _Interface.noOp
        });

        if (this.type === "custom") {
          osc.partials = this._partials;
        }

        this.frequency.connect(osc.frequency);
        this.detune.connect(osc.detune);
        osc.detune.overridden = false;
        osc.connect(this.output);
        this._oscillators[i] = osc;
      } // set the spread


      this.spread = this._spread;

      if (this.state === "started") {
        this._forEach(osc => osc.start());
      }
    }
  }

  get phase() {
    return this._phase;
  }

  set phase(phase) {
    this._phase = phase;

    this._forEach((osc, i) => osc.phase = this._phase + i / this.count * 360);
  }

  get baseType() {
    return this._oscillators[0].baseType;
  }

  set baseType(baseType) {
    this._forEach(osc => osc.baseType = baseType);

    this._type = this._oscillators[0].type;
  }

  get partials() {
    return this._oscillators[0].partials;
  }

  set partials(partials) {
    this._partials = partials;
    this._partialCount = this._partials.length;

    if (partials.length) {
      this._type = "custom";

      this._forEach(osc => osc.partials = partials);
    }
  }

  get partialCount() {
    return this._oscillators[0].partialCount;
  }

  set partialCount(partialCount) {
    this._partialCount = partialCount;

    this._forEach(osc => osc.partialCount = partialCount);

    this._type = this._oscillators[0].type;
  }

  asArray(length = 1024) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _OscillatorInterface.generateWaveform)(this, length);
    });
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();
    this.frequency.dispose();
    this.detune.dispose();

    this._forEach(osc => osc.dispose());

    return this;
  }

}

exports.FatOscillator = FatOscillator;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../Source":"../node_modules/tone/build/esm/source/Source.js","./Oscillator":"../node_modules/tone/build/esm/source/oscillator/Oscillator.js","./OscillatorInterface":"../node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/source/oscillator/PWMOscillator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PWMOscillator = void 0;

var _tslib = require("tslib");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _Multiply = require("../../signal/Multiply");

var _Source = require("../Source");

var _Oscillator = require("./Oscillator");

var _OscillatorInterface = require("./OscillatorInterface");

var _PulseOscillator = require("./PulseOscillator");

/**
 * PWMOscillator modulates the width of a Tone.PulseOscillator
 * at the modulationFrequency. This has the effect of continuously
 * changing the timbre of the oscillator by altering the harmonics
 * generated.
 * @example
 * return Tone.Offline(() => {
 * 	const pwm = new Tone.PWMOscillator(60, 0.3).toDestination().start();
 * }, 0.1, 1);
 * @category Source
 */
class PWMOscillator extends _Source.Source {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(PWMOscillator.getDefaults(), arguments, ["frequency", "modulationFrequency"]));
    this.name = "PWMOscillator";
    this.sourceType = "pwm";
    /**
     * Scale the oscillator so it doesn't go silent
     * at the extreme values.
     */

    this._scale = new _Multiply.Multiply({
      context: this.context,
      value: 2
    });
    const options = (0, _Defaults.optionsFromArguments)(PWMOscillator.getDefaults(), arguments, ["frequency", "modulationFrequency"]);
    this._pulse = new _PulseOscillator.PulseOscillator({
      context: this.context,
      frequency: options.modulationFrequency
    }); // change the pulse oscillator type

    this._pulse.carrierType = "sine";
    this.modulationFrequency = this._pulse.frequency;
    this._modulator = new _Oscillator.Oscillator({
      context: this.context,
      detune: options.detune,
      frequency: options.frequency,
      onstop: () => this.onstop(this),
      phase: options.phase
    });
    this.frequency = this._modulator.frequency;
    this.detune = this._modulator.detune; // connections

    this._modulator.chain(this._scale, this._pulse.width);

    this._pulse.connect(this.output);

    (0, _Interface.readOnly)(this, ["modulationFrequency", "frequency", "detune"]);
  }

  static getDefaults() {
    return Object.assign(_Source.Source.getDefaults(), {
      detune: 0,
      frequency: 440,
      modulationFrequency: 0.4,
      phase: 0,
      type: "pwm"
    });
  }
  /**
   * start the oscillator
   */


  _start(time) {
    time = this.toSeconds(time);

    this._modulator.start(time);

    this._pulse.start(time);
  }
  /**
   * stop the oscillator
   */


  _stop(time) {
    time = this.toSeconds(time);

    this._modulator.stop(time);

    this._pulse.stop(time);
  }
  /**
   * restart the oscillator
   */


  _restart(time) {
    this._modulator.restart(time);

    this._pulse.restart(time);
  }
  /**
   * The type of the oscillator. Always returns "pwm".
   */


  get type() {
    return "pwm";
  }
  /**
   * The baseType of the oscillator. Always returns "pwm".
   */


  get baseType() {
    return "pwm";
  }
  /**
   * The partials of the waveform. Cannot set partials for this waveform type
   */


  get partials() {
    return [];
  }
  /**
   * No partials for this waveform type.
   */


  get partialCount() {
    return 0;
  }
  /**
   * The phase of the oscillator in degrees.
   */


  get phase() {
    return this._modulator.phase;
  }

  set phase(phase) {
    this._modulator.phase = phase;
  }

  asArray(length = 1024) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _OscillatorInterface.generateWaveform)(this, length);
    });
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();

    this._pulse.dispose();

    this._scale.dispose();

    this._modulator.dispose();

    return this;
  }

}

exports.PWMOscillator = PWMOscillator;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../signal/Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","../Source":"../node_modules/tone/build/esm/source/Source.js","./Oscillator":"../node_modules/tone/build/esm/source/oscillator/Oscillator.js","./OscillatorInterface":"../node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js","./PulseOscillator":"../node_modules/tone/build/esm/source/oscillator/PulseOscillator.js"}],"../node_modules/tone/build/esm/source/oscillator/OmniOscillator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OmniOscillator = void 0;

var _tslib = require("tslib");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _TypeCheck = require("../../core/util/TypeCheck");

var _Signal = require("../../signal/Signal");

var _Source = require("../Source");

var _AMOscillator = require("./AMOscillator");

var _FatOscillator = require("./FatOscillator");

var _FMOscillator = require("./FMOscillator");

var _Oscillator = require("./Oscillator");

var _OscillatorInterface = require("./OscillatorInterface");

var _PulseOscillator = require("./PulseOscillator");

var _PWMOscillator = require("./PWMOscillator");

const OmniOscillatorSourceMap = {
  am: _AMOscillator.AMOscillator,
  fat: _FatOscillator.FatOscillator,
  fm: _FMOscillator.FMOscillator,
  oscillator: _Oscillator.Oscillator,
  pulse: _PulseOscillator.PulseOscillator,
  pwm: _PWMOscillator.PWMOscillator
};
/**
 * OmniOscillator aggregates all of the oscillator types into one.
 * @example
 * return Tone.Offline(() => {
 * 	const omniOsc = new Tone.OmniOscillator("C#4", "pwm").toDestination().start();
 * }, 0.1, 1);
 * @category Source
 */

class OmniOscillator extends _Source.Source {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(OmniOscillator.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "OmniOscillator";
    const options = (0, _Defaults.optionsFromArguments)(OmniOscillator.getDefaults(), arguments, ["frequency", "type"]);
    this.frequency = new _Signal.Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency
    });
    this.detune = new _Signal.Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    });
    (0, _Interface.readOnly)(this, ["frequency", "detune"]); // set the options

    this.set(options);
  }

  static getDefaults() {
    return Object.assign(_Oscillator.Oscillator.getDefaults(), _FMOscillator.FMOscillator.getDefaults(), _AMOscillator.AMOscillator.getDefaults(), _FatOscillator.FatOscillator.getDefaults(), _PulseOscillator.PulseOscillator.getDefaults(), _PWMOscillator.PWMOscillator.getDefaults());
  }
  /**
   * start the oscillator
   */


  _start(time) {
    this._oscillator.start(time);
  }
  /**
   * start the oscillator
   */


  _stop(time) {
    this._oscillator.stop(time);
  }

  _restart(time) {
    this._oscillator.restart(time);

    return this;
  }
  /**
   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
   * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
   * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
   * oscillator's class are accessible when the oscillator is set to that type, but throws an error
   * when it's not.
   * @example
   * const omniOsc = new Tone.OmniOscillator().toDestination().start();
   * omniOsc.type = "pwm";
   * // modulationFrequency is parameter which is available
   * // only when the type is "pwm".
   * omniOsc.modulationFrequency.value = 0.5;
   */


  get type() {
    let prefix = "";

    if (["am", "fm", "fat"].some(p => this._sourceType === p)) {
      prefix = this._sourceType;
    }

    return prefix + this._oscillator.type;
  }

  set type(type) {
    if (type.substr(0, 2) === "fm") {
      this._createNewOscillator("fm");

      this._oscillator = this._oscillator;
      this._oscillator.type = type.substr(2);
    } else if (type.substr(0, 2) === "am") {
      this._createNewOscillator("am");

      this._oscillator = this._oscillator;
      this._oscillator.type = type.substr(2);
    } else if (type.substr(0, 3) === "fat") {
      this._createNewOscillator("fat");

      this._oscillator = this._oscillator;
      this._oscillator.type = type.substr(3);
    } else if (type === "pwm") {
      this._createNewOscillator("pwm");

      this._oscillator = this._oscillator;
    } else if (type === "pulse") {
      this._createNewOscillator("pulse");
    } else {
      this._createNewOscillator("oscillator");

      this._oscillator = this._oscillator;
      this._oscillator.type = type;
    }
  }
  /**
   * The value is an empty array when the type is not "custom".
   * This is not available on "pwm" and "pulse" oscillator types.
   * See [[Oscillator.partials]]
   */


  get partials() {
    return this._oscillator.partials;
  }

  set partials(partials) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
      this._oscillator.partials = partials;
    }
  }

  get partialCount() {
    return this._oscillator.partialCount;
  }

  set partialCount(partialCount) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm")) {
      this._oscillator.partialCount = partialCount;
    }
  }

  set(props) {
    // make sure the type is set first
    if (Reflect.has(props, "type") && props.type) {
      this.type = props.type;
    } // then set the rest


    super.set(props);
    return this;
  }
  /**
   * connect the oscillator to the frequency and detune signals
   */


  _createNewOscillator(oscType) {
    if (oscType !== this._sourceType) {
      this._sourceType = oscType;
      const OscConstructor = OmniOscillatorSourceMap[oscType]; // short delay to avoid clicks on the change

      const now = this.now();

      if (this._oscillator) {
        const oldOsc = this._oscillator;
        oldOsc.stop(now); // dispose the old one

        this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);
      }

      this._oscillator = new OscConstructor({
        context: this.context
      });
      this.frequency.connect(this._oscillator.frequency);
      this.detune.connect(this._oscillator.detune);

      this._oscillator.connect(this.output);

      this._oscillator.onstop = () => this.onstop(this);

      if (this.state === "started") {
        this._oscillator.start(now);
      }
    }
  }

  get phase() {
    return this._oscillator.phase;
  }

  set phase(phase) {
    this._oscillator.phase = phase;
  }
  /**
   * The source type of the oscillator.
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare");
   * console.log(omniOsc.sourceType); // 'fm'
   */


  get sourceType() {
    return this._sourceType;
  }

  set sourceType(sType) {
    // the basetype defaults to sine
    let baseType = "sine";

    if (this._oscillator.type !== "pwm" && this._oscillator.type !== "pulse") {
      baseType = this._oscillator.type;
    } // set the type


    if (sType === "fm") {
      this.type = "fm" + baseType;
    } else if (sType === "am") {
      this.type = "am" + baseType;
    } else if (sType === "fat") {
      this.type = "fat" + baseType;
    } else if (sType === "oscillator") {
      this.type = baseType;
    } else if (sType === "pulse") {
      this.type = "pulse";
    } else if (sType === "pwm") {
      this.type = "pwm";
    }
  }

  _getOscType(osc, sourceType) {
    return osc instanceof OmniOscillatorSourceMap[sourceType];
  }
  /**
   * The base type of the oscillator. See [[Oscillator.baseType]]
   * @example
   * const omniOsc = new Tone.OmniOscillator(440, "fmsquare4");
   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);
   */


  get baseType() {
    return this._oscillator.baseType;
  }

  set baseType(baseType) {
    if (!this._getOscType(this._oscillator, "pulse") && !this._getOscType(this._oscillator, "pwm") && baseType !== "pulse" && baseType !== "pwm") {
      this._oscillator.baseType = baseType;
    }
  }
  /**
   * The width of the oscillator when sourceType === "pulse".
   * See [[PWMOscillator.width]]
   */


  get width() {
    if (this._getOscType(this._oscillator, "pulse")) {
      return this._oscillator.width;
    } else {
      return undefined;
    }
  }
  /**
   * The number of detuned oscillators when sourceType === "fat".
   * See [[FatOscillator.count]]
   */


  get count() {
    if (this._getOscType(this._oscillator, "fat")) {
      return this._oscillator.count;
    } else {
      return undefined;
    }
  }

  set count(count) {
    if (this._getOscType(this._oscillator, "fat") && (0, _TypeCheck.isNumber)(count)) {
      this._oscillator.count = count;
    }
  }
  /**
   * The detune spread between the oscillators when sourceType === "fat".
   * See [[FatOscillator.count]]
   */


  get spread() {
    if (this._getOscType(this._oscillator, "fat")) {
      return this._oscillator.spread;
    } else {
      return undefined;
    }
  }

  set spread(spread) {
    if (this._getOscType(this._oscillator, "fat") && (0, _TypeCheck.isNumber)(spread)) {
      this._oscillator.spread = spread;
    }
  }
  /**
   * The type of the modulator oscillator. Only if the oscillator is set to "am" or "fm" types.
   * See [[AMOscillator]] or [[FMOscillator]]
   */


  get modulationType() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
      return this._oscillator.modulationType;
    } else {
      return undefined;
    }
  }

  set modulationType(mType) {
    if ((this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) && (0, _TypeCheck.isString)(mType)) {
      this._oscillator.modulationType = mType;
    }
  }
  /**
   * The modulation index when the sourceType === "fm"
   * See [[FMOscillator]].
   */


  get modulationIndex() {
    if (this._getOscType(this._oscillator, "fm")) {
      return this._oscillator.modulationIndex;
    } else {
      return undefined;
    }
  }
  /**
   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.
   * See [[AMOscillator]] or [[FMOscillator]]
   */


  get harmonicity() {
    if (this._getOscType(this._oscillator, "fm") || this._getOscType(this._oscillator, "am")) {
      return this._oscillator.harmonicity;
    } else {
      return undefined;
    }
  }
  /**
   * The modulationFrequency Signal of the oscillator when sourceType === "pwm"
   * see [[PWMOscillator]]
   * @min 0.1
   * @max 5
   */


  get modulationFrequency() {
    if (this._getOscType(this._oscillator, "pwm")) {
      return this._oscillator.modulationFrequency;
    } else {
      return undefined;
    }
  }

  asArray(length = 1024) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      return (0, _OscillatorInterface.generateWaveform)(this, length);
    });
  }

  dispose() {
    super.dispose();
    this.detune.dispose();
    this.frequency.dispose();

    this._oscillator.dispose();

    return this;
  }

}

exports.OmniOscillator = OmniOscillator;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","../../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../Source":"../node_modules/tone/build/esm/source/Source.js","./AMOscillator":"../node_modules/tone/build/esm/source/oscillator/AMOscillator.js","./FatOscillator":"../node_modules/tone/build/esm/source/oscillator/FatOscillator.js","./FMOscillator":"../node_modules/tone/build/esm/source/oscillator/FMOscillator.js","./Oscillator":"../node_modules/tone/build/esm/source/oscillator/Oscillator.js","./OscillatorInterface":"../node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js","./PulseOscillator":"../node_modules/tone/build/esm/source/oscillator/PulseOscillator.js","./PWMOscillator":"../node_modules/tone/build/esm/source/oscillator/PWMOscillator.js"}],"../node_modules/tone/build/esm/signal/Add.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Add = void 0;

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Gain = require("../core/context/Gain");

var _Defaults = require("../core/util/Defaults");

var _Signal = require("./Signal");

/**
 * Add a signal and a number or two signals. When no value is
 * passed into the constructor, Tone.Add will sum input and `addend`
 * If a value is passed into the constructor, the it will be added to the input.
 *
 * @example
 * return Tone.Offline(() => {
 * 	const add = new Tone.Add(2).toDestination();
 * 	add.addend.setValueAtTime(1, 0.2);
 * 	const signal = new Tone.Signal(2);
 * 	// add a signal and a scalar
 * 	signal.connect(add);
 * 	signal.setValueAtTime(1, 0.1);
 * }, 0.5, 1);
 * @category Signal
 */
class Add extends _Signal.Signal {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(Add.getDefaults(), arguments, ["value"])));
    this.override = false;
    this.name = "Add";
    /**
     * the summing node
     */

    this._sum = new _Gain.Gain({
      context: this.context
    });
    this.input = this._sum;
    this.output = this._sum;
    /**
     * The value which is added to the input signal
     */

    this.addend = this._param;
    (0, _ToneAudioNode.connectSeries)(this._constantSource, this._sum);
  }

  static getDefaults() {
    return Object.assign(_Signal.Signal.getDefaults(), {
      value: 0
    });
  }

  dispose() {
    super.dispose();

    this._sum.dispose();

    return this;
  }

}

exports.Add = Add;
},{"../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Signal":"../node_modules/tone/build/esm/signal/Signal.js"}],"../node_modules/tone/build/esm/signal/Scale.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scale = void 0;

var _Defaults = require("../core/util/Defaults");

var _Add = require("./Add");

var _Multiply = require("./Multiply");

var _SignalOperator = require("./SignalOperator");

/**
 * Performs a linear scaling on an input signal.
 * Scales a NormalRange input to between
 * outputMin and outputMax.
 *
 * @example
 * const scale = new Tone.Scale(50, 100);
 * const signal = new Tone.Signal(0.5).connect(scale);
 * // the output of scale equals 75
 * @category Signal
 */
class Scale extends _SignalOperator.SignalOperator {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(Scale.getDefaults(), arguments, ["min", "max"])));
    this.name = "Scale";
    const options = (0, _Defaults.optionsFromArguments)(Scale.getDefaults(), arguments, ["min", "max"]);
    this._mult = this.input = new _Multiply.Multiply({
      context: this.context,
      value: options.max - options.min
    });
    this._add = this.output = new _Add.Add({
      context: this.context,
      value: options.min
    });
    this._min = options.min;
    this._max = options.max;
    this.input.connect(this.output);
  }

  static getDefaults() {
    return Object.assign(_SignalOperator.SignalOperator.getDefaults(), {
      max: 1,
      min: 0
    });
  }
  /**
   * The minimum output value. This number is output when the value input value is 0.
   */


  get min() {
    return this._min;
  }

  set min(min) {
    this._min = min;

    this._setRange();
  }
  /**
   * The maximum output value. This number is output when the value input value is 1.
   */


  get max() {
    return this._max;
  }

  set max(max) {
    this._max = max;

    this._setRange();
  }
  /**
   * set the values
   */


  _setRange() {
    this._add.value = this._min;
    this._mult.value = this._max - this._min;
  }

  dispose() {
    super.dispose();

    this._add.dispose();

    this._mult.dispose();

    return this;
  }

}

exports.Scale = Scale;
},{"../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Add":"../node_modules/tone/build/esm/signal/Add.js","./Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","./SignalOperator":"../node_modules/tone/build/esm/signal/SignalOperator.js"}],"../node_modules/tone/build/esm/signal/Zero.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Zero = void 0;

var _Gain = require("../core/context/Gain");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Defaults = require("../core/util/Defaults");

var _SignalOperator = require("./SignalOperator");

/**
 * Tone.Zero outputs 0's at audio-rate. The reason this has to be
 * it's own class is that many browsers optimize out Tone.Signal
 * with a value of 0 and will not process nodes further down the graph.
 * @category Signal
 */
class Zero extends _SignalOperator.SignalOperator {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(Zero.getDefaults(), arguments)));
    this.name = "Zero";
    /**
     * The gain node which connects the constant source to the output
     */

    this._gain = new _Gain.Gain({
      context: this.context
    });
    /**
     * Only outputs 0
     */

    this.output = this._gain;
    /**
     * no input node
     */

    this.input = undefined;
    (0, _ToneAudioNode.connect)(this.context.getConstant(0), this._gain);
  }
  /**
   * clean up
   */


  dispose() {
    super.dispose();
    (0, _ToneAudioNode.disconnect)(this.context.getConstant(0), this._gain);
    return this;
  }

}

exports.Zero = Zero;
},{"../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./SignalOperator":"../node_modules/tone/build/esm/signal/SignalOperator.js"}],"../node_modules/tone/build/esm/source/oscillator/LFO.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LFO = void 0;

var _Gain = require("../../core/context/Gain");

var _Param = require("../../core/context/Param");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _AudioToGain = require("../../signal/AudioToGain");

var _Scale = require("../../signal/Scale");

var _Signal = require("../../signal/Signal");

var _Zero = require("../../signal/Zero");

var _Oscillator = require("./Oscillator");

/**
 * LFO stands for low frequency oscillator. LFO produces an output signal
 * which can be attached to an AudioParam or Tone.Signal
 * in order to modulate that parameter with an oscillator. The LFO can
 * also be synced to the transport to start/stop and change when the tempo changes.
 * @example
 * return Tone.Offline(() => {
 * 	const lfo = new Tone.LFO("4n", 400, 4000).start().toDestination();
 * }, 0.5, 1);
 * @category Source
 */
class LFO extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(LFO.getDefaults(), arguments, ["frequency", "min", "max"]));
    this.name = "LFO";
    /**
     * The value that the LFO outputs when it's stopped
     */

    this._stoppedValue = 0;
    /**
     * A private placeholder for the units
     */

    this._units = "number";
    /**
     * If the input value is converted using the [[units]]
     */

    this.convert = true;
    /**
     * Private methods borrowed from Param
     */
    // @ts-ignore

    this._fromType = _Param.Param.prototype._fromType; // @ts-ignore

    this._toType = _Param.Param.prototype._toType; // @ts-ignore

    this._is = _Param.Param.prototype._is; // @ts-ignore

    this._clampValue = _Param.Param.prototype._clampValue;
    const options = (0, _Defaults.optionsFromArguments)(LFO.getDefaults(), arguments, ["frequency", "min", "max"]);
    this._oscillator = new _Oscillator.Oscillator(options);
    this.frequency = this._oscillator.frequency;
    this._amplitudeGain = new _Gain.Gain({
      context: this.context,
      gain: options.amplitude,
      units: "normalRange"
    });
    this.amplitude = this._amplitudeGain.gain;
    this._stoppedSignal = new _Signal.Signal({
      context: this.context,
      units: "audioRange",
      value: 0
    });
    this._zeros = new _Zero.Zero({
      context: this.context
    });
    this._a2g = new _AudioToGain.AudioToGain({
      context: this.context
    });
    this._scaler = this.output = new _Scale.Scale({
      context: this.context,
      max: options.max,
      min: options.min
    });
    this.units = options.units;
    this.min = options.min;
    this.max = options.max; // connect it up

    this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);

    this._zeros.connect(this._a2g);

    this._stoppedSignal.connect(this._a2g);

    (0, _Interface.readOnly)(this, ["amplitude", "frequency"]);
    this.phase = options.phase;
  }

  static getDefaults() {
    return Object.assign(_Oscillator.Oscillator.getDefaults(), {
      amplitude: 1,
      frequency: "4n",
      max: 1,
      min: 0,
      type: "sine",
      units: "number"
    });
  }
  /**
   * Start the LFO.
   * @param time The time the LFO will start
   */


  start(time) {
    time = this.toSeconds(time);

    this._stoppedSignal.setValueAtTime(0, time);

    this._oscillator.start(time);

    return this;
  }
  /**
   * Stop the LFO.
   * @param  time The time the LFO will stop
   */


  stop(time) {
    time = this.toSeconds(time);

    this._stoppedSignal.setValueAtTime(this._stoppedValue, time);

    this._oscillator.stop(time);

    return this;
  }
  /**
   * Sync the start/stop/pause to the transport
   * and the frequency to the bpm of the transport
   * @example
   * const lfo = new Tone.LFO("8n");
   * lfo.sync().start(0);
   * // the rate of the LFO will always be an eighth note, even as the tempo changes
   */


  sync() {
    this._oscillator.sync();

    this._oscillator.syncFrequency();

    return this;
  }
  /**
   * unsync the LFO from transport control
   */


  unsync() {
    this._oscillator.unsync();

    this._oscillator.unsyncFrequency();

    return this;
  }
  /**
   * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform
   */


  _setStoppedValue() {
    this._stoppedValue = this._oscillator.getInitialValue();
    this._stoppedSignal.value = this._stoppedValue;
  }
  /**
   * The minimum output of the LFO.
   */


  get min() {
    return this._toType(this._scaler.min);
  }

  set min(min) {
    min = this._fromType(min);
    this._scaler.min = min;
  }
  /**
   * The maximum output of the LFO.
   */


  get max() {
    return this._toType(this._scaler.max);
  }

  set max(max) {
    max = this._fromType(max);
    this._scaler.max = max;
  }
  /**
   * The type of the oscillator: See [[Oscillator.type]]
   */


  get type() {
    return this._oscillator.type;
  }

  set type(type) {
    this._oscillator.type = type;

    this._setStoppedValue();
  }
  /**
   * The oscillator's partials array: See [[Oscillator.partials]]
   */


  get partials() {
    return this._oscillator.partials;
  }

  set partials(partials) {
    this._oscillator.partials = partials;

    this._setStoppedValue();
  }
  /**
   * The phase of the LFO.
   */


  get phase() {
    return this._oscillator.phase;
  }

  set phase(phase) {
    this._oscillator.phase = phase;

    this._setStoppedValue();
  }
  /**
   * The output units of the LFO.
   */


  get units() {
    return this._units;
  }

  set units(val) {
    const currentMin = this.min;
    const currentMax = this.max; // convert the min and the max

    this._units = val;
    this.min = currentMin;
    this.max = currentMax;
  }
  /**
   * Returns the playback state of the source, either "started" or "stopped".
   */


  get state() {
    return this._oscillator.state;
  }
  /**
   * @param node the destination to connect to
   * @param outputNum the optional output number
   * @param inputNum the input number
   */


  connect(node, outputNum, inputNum) {
    if (node instanceof _Param.Param || node instanceof _Signal.Signal) {
      this.convert = node.convert;
      this.units = node.units;
    }

    (0, _Signal.connectSignal)(this, node, outputNum, inputNum);
    return this;
  }

  dispose() {
    super.dispose();

    this._oscillator.dispose();

    this._stoppedSignal.dispose();

    this._zeros.dispose();

    this._scaler.dispose();

    this._a2g.dispose();

    this._amplitudeGain.dispose();

    this.amplitude.dispose();
    return this;
  }

}

exports.LFO = LFO;
},{"../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../signal/AudioToGain":"../node_modules/tone/build/esm/signal/AudioToGain.js","../../signal/Scale":"../node_modules/tone/build/esm/signal/Scale.js","../../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../../signal/Zero":"../node_modules/tone/build/esm/signal/Zero.js","./Oscillator":"../node_modules/tone/build/esm/source/oscillator/Oscillator.js"}],"../node_modules/tone/build/esm/core/util/Decorator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.range = range;
exports.timeRange = timeRange;

var _Debug = require("./Debug");

/**
 * Assert that the number is in the given range.
 */
function range(min, max = Infinity) {
  const valueMap = new WeakMap();
  return function (target, propertyKey) {
    Reflect.defineProperty(target, propertyKey, {
      configurable: true,
      enumerable: true,
      get: function () {
        return valueMap.get(this);
      },
      set: function (newValue) {
        (0, _Debug.assertRange)(newValue, min, max);
        valueMap.set(this, newValue);
      }
    });
  };
}
/**
 * Convert the time to seconds and assert that the time is in between the two
 * values when being set.
 */


function timeRange(min, max = Infinity) {
  const valueMap = new WeakMap();
  return function (target, propertyKey) {
    Reflect.defineProperty(target, propertyKey, {
      configurable: true,
      enumerable: true,
      get: function () {
        return valueMap.get(this);
      },
      set: function (newValue) {
        (0, _Debug.assertRange)(this.toSeconds(newValue), min, max);
        valueMap.set(this, newValue);
      }
    });
  };
}
},{"./Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/source/buffer/Player.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Player = void 0;

var _tslib = require("tslib");

var _ToneAudioBuffer = require("../../core/context/ToneAudioBuffer");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _TypeCheck = require("../../core/util/TypeCheck");

var _Source = require("../Source");

var _ToneBufferSource = require("./ToneBufferSource");

var _Debug = require("../../core/util/Debug");

var _Decorator = require("../../core/util/Decorator");

/**
 * Player is an audio file player with start, loop, and stop functions.
 * @example
 * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/gong_1.mp3").toDestination();
 * // play as soon as the buffer is loaded
 * player.autostart = true;
 * @category Source
 */
class Player extends _Source.Source {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Player.getDefaults(), arguments, ["url", "onload"]));
    this.name = "Player";
    /**
     * All of the active buffer source nodes
     */

    this._activeSources = new Set();
    const options = (0, _Defaults.optionsFromArguments)(Player.getDefaults(), arguments, ["url", "onload"]);
    this._buffer = new _ToneAudioBuffer.ToneAudioBuffer({
      onload: this._onload.bind(this, options.onload),
      onerror: options.onerror,
      reverse: options.reverse,
      url: options.url
    });
    this.autostart = options.autostart;
    this._loop = options.loop;
    this._loopStart = options.loopStart;
    this._loopEnd = options.loopEnd;
    this._playbackRate = options.playbackRate;
    this.fadeIn = options.fadeIn;
    this.fadeOut = options.fadeOut;
  }

  static getDefaults() {
    return Object.assign(_Source.Source.getDefaults(), {
      autostart: false,
      fadeIn: 0,
      fadeOut: 0,
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      onload: _Interface.noOp,
      onerror: _Interface.noOp,
      playbackRate: 1,
      reverse: false
    });
  }
  /**
   * Load the audio file as an audio buffer.
   * Decodes the audio asynchronously and invokes
   * the callback once the audio buffer loads.
   * Note: this does not need to be called if a url
   * was passed in to the constructor. Only use this
   * if you want to manually load a new url.
   * @param url The url of the buffer to load. Filetype support depends on the browser.
   */


  load(url) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      yield this._buffer.load(url);

      this._onload();

      return this;
    });
  }
  /**
   * Internal callback when the buffer is loaded.
   */


  _onload(callback = _Interface.noOp) {
    callback();

    if (this.autostart) {
      this.start();
    }
  }
  /**
   * Internal callback when the buffer is done playing.
   */


  _onSourceEnd(source) {
    // invoke the onstop function
    this.onstop(this); // delete the source from the active sources

    this._activeSources.delete(source);

    if (this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === "started") {
      // remove the 'implicitEnd' event and replace with an explicit end
      this._state.cancel(this.now());

      this._state.setStateAtTime("stopped", this.now());
    }
  }
  /**
   * Play the buffer at the given startTime. Optionally add an offset
   * and/or duration which will play the buffer from a position
   * within the buffer for the given duration.
   *
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
   */


  start(time, offset, duration) {
    super.start(time, offset, duration);
    return this;
  }
  /**
   * Internal start method
   */


  _start(startTime, offset, duration) {
    // if it's a loop the default offset is the loopStart point
    if (this._loop) {
      offset = (0, _Defaults.defaultArg)(offset, this._loopStart);
    } else {
      // otherwise the default offset is 0
      offset = (0, _Defaults.defaultArg)(offset, 0);
    } // compute the values in seconds


    const computedOffset = this.toSeconds(offset); // compute the duration which is either the passed in duration of the buffer.duration - offset

    const origDuration = duration;
    duration = (0, _Defaults.defaultArg)(duration, Math.max(this._buffer.duration - computedOffset, 0));
    let computedDuration = this.toSeconds(duration); // scale it by the playback rate

    computedDuration = computedDuration / this._playbackRate; // get the start time

    startTime = this.toSeconds(startTime); // make the source

    const source = new _ToneBufferSource.ToneBufferSource({
      url: this._buffer,
      context: this.context,
      fadeIn: this.fadeIn,
      fadeOut: this.fadeOut,
      loop: this._loop,
      loopEnd: this._loopEnd,
      loopStart: this._loopStart,
      onended: this._onSourceEnd.bind(this),
      playbackRate: this._playbackRate
    }).connect(this.output); // set the looping properties

    if (!this._loop && !this._synced) {
      // cancel the previous stop
      this._state.cancel(startTime + computedDuration); // if it's not looping, set the state change at the end of the sample


      this._state.setStateAtTime("stopped", startTime + computedDuration, {
        implicitEnd: true
      });
    } // add it to the array of active sources


    this._activeSources.add(source); // start it


    if (this._loop && (0, _TypeCheck.isUndef)(origDuration)) {
      source.start(startTime, computedOffset);
    } else {
      // subtract the fade out time
      source.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));
    }
  }
  /**
   * Stop playback.
   */


  _stop(time) {
    const computedTime = this.toSeconds(time);

    this._activeSources.forEach(source => source.stop(computedTime));
  }
  /**
   * Stop and then restart the player from the beginning (or offset)
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given,
   * 					it will default to the full length of the sample (minus any offset)
   */


  restart(time, offset, duration) {
    super.restart(time, offset, duration);
    return this;
  }

  _restart(time, offset, duration) {
    this._stop(time);

    this._start(time, offset, duration);
  }
  /**
   * Seek to a specific time in the player's buffer. If the
   * source is no longer playing at that time, it will stop.
   * @param offset The time to seek to.
   * @param when The time for the seek event to occur.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3", () => {
   * 	player.start();
   * 	// seek to the offset in 1 second from now
   * 	player.seek(0.4, "+1");
   * }).toDestination();
   */


  seek(offset, when) {
    const computedTime = this.toSeconds(when);

    if (this._state.getValueAtTime(computedTime) === "started") {
      const computedOffset = this.toSeconds(offset); // if it's currently playing, stop it

      this._stop(computedTime); // restart it at the given time


      this._start(computedTime, computedOffset);
    }

    return this;
  }
  /**
   * Set the loop start and end. Will only loop if loop is set to true.
   * @param loopStart The loop start time
   * @param loopEnd The loop end time
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3").toDestination();
   * // loop between the given points
   * player.setLoopPoints(0.2, 0.3);
   * player.loop = true;
   * player.autostart = true;
   */


  setLoopPoints(loopStart, loopEnd) {
    this.loopStart = loopStart;
    this.loopEnd = loopEnd;
    return this;
  }
  /**
   * If loop is true, the loop will start at this position.
   */


  get loopStart() {
    return this._loopStart;
  }

  set loopStart(loopStart) {
    this._loopStart = loopStart;

    if (this.buffer.loaded) {
      (0, _Debug.assertRange)(this.toSeconds(loopStart), 0, this.buffer.duration);
    } // get the current source


    this._activeSources.forEach(source => {
      source.loopStart = loopStart;
    });
  }
  /**
   * If loop is true, the loop will end at this position.
   */


  get loopEnd() {
    return this._loopEnd;
  }

  set loopEnd(loopEnd) {
    this._loopEnd = loopEnd;

    if (this.buffer.loaded) {
      (0, _Debug.assertRange)(this.toSeconds(loopEnd), 0, this.buffer.duration);
    } // get the current source


    this._activeSources.forEach(source => {
      source.loopEnd = loopEnd;
    });
  }
  /**
   * The audio buffer belonging to the player.
   */


  get buffer() {
    return this._buffer;
  }

  set buffer(buffer) {
    this._buffer.set(buffer);
  }
  /**
   * If the buffer should loop once it's over.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/drum-samples/breakbeat.mp3").toDestination();
   * player.loop = true;
   * player.autostart = true;
   */


  get loop() {
    return this._loop;
  }

  set loop(loop) {
    // if no change, do nothing
    if (this._loop === loop) {
      return;
    }

    this._loop = loop; // set the loop of all of the sources

    this._activeSources.forEach(source => {
      source.loop = loop;
    });

    if (loop) {
      // remove the next stopEvent
      const stopEvent = this._state.getNextState("stopped", this.now());

      if (stopEvent) {
        this._state.cancel(stopEvent.time);
      }
    }
  }
  /**
   * Normal speed is 1. The pitch will change with the playback rate.
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3").toDestination();
   * // play at 1/4 speed
   * player.playbackRate = 0.25;
   * // play as soon as the buffer is loaded
   * player.autostart = true;
   */


  get playbackRate() {
    return this._playbackRate;
  }

  set playbackRate(rate) {
    this._playbackRate = rate;
    const now = this.now(); // cancel the stop event since it's at a different time now

    const stopEvent = this._state.getNextState("stopped", now);

    if (stopEvent && stopEvent.implicitEnd) {
      this._state.cancel(stopEvent.time);

      this._activeSources.forEach(source => source.cancelStop());
    } // set all the sources


    this._activeSources.forEach(source => {
      source.playbackRate.setValueAtTime(rate, now);
    });
  }
  /**
   * If the buffer should be reversed
   * @example
   * const player = new Tone.Player("https://tonejs.github.io/audio/berklee/chime_1.mp3").toDestination();
   * player.autostart = true;
   * player.reverse = true;
   */


  get reverse() {
    return this._buffer.reverse;
  }

  set reverse(rev) {
    this._buffer.reverse = rev;
  }
  /**
   * If the buffer is loaded
   */


  get loaded() {
    return this._buffer.loaded;
  }

  dispose() {
    super.dispose(); // disconnect all of the players

    this._activeSources.forEach(source => source.dispose());

    this._activeSources.clear();

    this._buffer.dispose();

    return this;
  }

}

exports.Player = Player;
(0, _tslib.__decorate)([(0, _Decorator.timeRange)(0)], Player.prototype, "fadeIn", void 0);
(0, _tslib.__decorate)([(0, _Decorator.timeRange)(0)], Player.prototype, "fadeOut", void 0);
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/context/ToneAudioBuffer":"../node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","../Source":"../node_modules/tone/build/esm/source/Source.js","./ToneBufferSource":"../node_modules/tone/build/esm/source/buffer/ToneBufferSource.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","../../core/util/Decorator":"../node_modules/tone/build/esm/core/util/Decorator.js"}],"../node_modules/tone/build/esm/source/buffer/Players.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Players = void 0;

var _Volume = require("../../component/channel/Volume");

var _ToneAudioBuffers = require("../../core/context/ToneAudioBuffers");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Debug = require("../../core/util/Debug");

var _Interface = require("../../core/util/Interface");

var _Source = require("../Source");

var _Player = require("./Player");

/**
 * Players combines multiple [[Player]] objects.
 * @category Source
 */
class Players extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Players.getDefaults(), arguments, ["urls", "onload"], "urls"));
    this.name = "Players";
    /**
     * Players has no input.
     */

    this.input = undefined;
    /**
     * The container of all of the players
     */

    this._players = new Map();
    const options = (0, _Defaults.optionsFromArguments)(Players.getDefaults(), arguments, ["urls", "onload"], "urls");
    /**
     * The output volume node
     */

    this._volume = this.output = new _Volume.Volume({
      context: this.context,
      volume: options.volume
    });
    this.volume = this._volume.volume;
    (0, _Interface.readOnly)(this, "volume");
    this._buffers = new _ToneAudioBuffers.ToneAudioBuffers({
      urls: options.urls,
      onload: options.onload,
      baseUrl: options.baseUrl,
      onerror: options.onerror
    }); // mute initially

    this.mute = options.mute;
    this._fadeIn = options.fadeIn;
    this._fadeOut = options.fadeOut;
  }

  static getDefaults() {
    return Object.assign(_Source.Source.getDefaults(), {
      baseUrl: "",
      fadeIn: 0,
      fadeOut: 0,
      mute: false,
      onload: _Interface.noOp,
      onerror: _Interface.noOp,
      urls: {},
      volume: 0
    });
  }
  /**
   * Mute the output.
   */


  get mute() {
    return this._volume.mute;
  }

  set mute(mute) {
    this._volume.mute = mute;
  }
  /**
   * The fadeIn time of the envelope applied to the source.
   */


  get fadeIn() {
    return this._fadeIn;
  }

  set fadeIn(fadeIn) {
    this._fadeIn = fadeIn;

    this._players.forEach(player => {
      player.fadeIn = fadeIn;
    });
  }
  /**
   * The fadeOut time of the each of the sources.
   */


  get fadeOut() {
    return this._fadeOut;
  }

  set fadeOut(fadeOut) {
    this._fadeOut = fadeOut;

    this._players.forEach(player => {
      player.fadeOut = fadeOut;
    });
  }
  /**
   * The state of the players object. Returns "started" if any of the players are playing.
   */


  get state() {
    const playing = Array.from(this._players).some(([_, player]) => player.state === "started");
    return playing ? "started" : "stopped";
  }
  /**
   * True if the buffers object has a buffer by that name.
   * @param name  The key or index of the buffer.
   */


  has(name) {
    return this._buffers.has(name);
  }
  /**
   * Get a player by name.
   * @param  name  The players name as defined in the constructor object or `add` method.
   */


  player(name) {
    (0, _Debug.assert)(this.has(name), `No Player with the name ${name} exists on this object`);

    if (!this._players.has(name)) {
      const player = new _Player.Player({
        context: this.context,
        fadeIn: this._fadeIn,
        fadeOut: this._fadeOut,
        url: this._buffers.get(name)
      }).connect(this.output);

      this._players.set(name, player);
    }

    return this._players.get(name);
  }
  /**
   * If all the buffers are loaded or not
   */


  get loaded() {
    return this._buffers.loaded;
  }
  /**
   * Add a player by name and url to the Players
   * @param  name A unique name to give the player
   * @param  url  Either the url of the bufer or a buffer which will be added with the given name.
   * @param callback  The callback to invoke when the url is loaded.
   */


  add(name, url, callback) {
    (0, _Debug.assert)(!this._buffers.has(name), "A buffer with that name already exists on this object");

    this._buffers.add(name, url, callback);

    return this;
  }
  /**
   * Stop all of the players at the given time
   * @param time The time to stop all of the players.
   */


  stopAll(time) {
    this._players.forEach(player => player.stop(time));

    return this;
  }

  dispose() {
    super.dispose();

    this._volume.dispose();

    this.volume.dispose();

    this._players.forEach(player => player.dispose());

    this._buffers.dispose();

    return this;
  }

}

exports.Players = Players;
},{"../../component/channel/Volume":"../node_modules/tone/build/esm/component/channel/Volume.js","../../core/context/ToneAudioBuffers":"../node_modules/tone/build/esm/core/context/ToneAudioBuffers.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../Source":"../node_modules/tone/build/esm/source/Source.js","./Player":"../node_modules/tone/build/esm/source/buffer/Player.js"}],"../node_modules/tone/build/esm/source/buffer/GrainPlayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GrainPlayer = void 0;

var _Source = require("../Source");

var _Interface = require("../../core/util/Interface");

var _ToneAudioBuffer = require("../../core/context/ToneAudioBuffer");

var _Defaults = require("../../core/util/Defaults");

var _Clock = require("../../core/clock/Clock");

var _ToneBufferSource = require("./ToneBufferSource");

var _Conversions = require("../../core/type/Conversions");

var _Debug = require("../../core/util/Debug");

/**
 * GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).
 * Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the
 * amount of time each small chunk of audio is played for and the overlap is the
 * amount of crossfading transition time between successive grains.
 * @category Source
 */
class GrainPlayer extends _Source.Source {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(GrainPlayer.getDefaults(), arguments, ["url", "onload"]));
    this.name = "GrainPlayer";
    /**
     * Internal loopStart value
     */

    this._loopStart = 0;
    /**
     * Internal loopStart value
     */

    this._loopEnd = 0;
    /**
     * All of the currently playing BufferSources
     */

    this._activeSources = [];
    const options = (0, _Defaults.optionsFromArguments)(GrainPlayer.getDefaults(), arguments, ["url", "onload"]);
    this.buffer = new _ToneAudioBuffer.ToneAudioBuffer({
      onload: options.onload,
      onerror: options.onerror,
      reverse: options.reverse,
      url: options.url
    });
    this._clock = new _Clock.Clock({
      context: this.context,
      callback: this._tick.bind(this),
      frequency: 1 / options.grainSize
    });
    this._playbackRate = options.playbackRate;
    this._grainSize = options.grainSize;
    this._overlap = options.overlap;
    this.detune = options.detune; // setup

    this.overlap = options.overlap;
    this.loop = options.loop;
    this.playbackRate = options.playbackRate;
    this.grainSize = options.grainSize;
    this.loopStart = options.loopStart;
    this.loopEnd = options.loopEnd;
    this.reverse = options.reverse;

    this._clock.on("stop", this._onstop.bind(this));
  }

  static getDefaults() {
    return Object.assign(_Source.Source.getDefaults(), {
      onload: _Interface.noOp,
      onerror: _Interface.noOp,
      overlap: 0.1,
      grainSize: 0.2,
      playbackRate: 1,
      detune: 0,
      loop: false,
      loopStart: 0,
      loopEnd: 0,
      reverse: false
    });
  }
  /**
   * Internal start method
   */


  _start(time, offset, duration) {
    offset = (0, _Defaults.defaultArg)(offset, 0);
    offset = this.toSeconds(offset);
    time = this.toSeconds(time);

    const grainSize = 1 / this._clock.frequency.getValueAtTime(time);

    this._clock.start(time, offset / grainSize);

    if (duration) {
      this.stop(time + this.toSeconds(duration));
    }
  }
  /**
   * Stop and then restart the player from the beginning (or offset)
   * @param  time When the player should start.
   * @param  offset The offset from the beginning of the sample to start at.
   * @param  duration How long the sample should play. If no duration is given,
   * 					it will default to the full length of the sample (minus any offset)
   */


  restart(time, offset, duration) {
    super.restart(time, offset, duration);
    return this;
  }

  _restart(time, offset, duration) {
    this._stop(time);

    this._start(time, offset, duration);
  }
  /**
   * Internal stop method
   */


  _stop(time) {
    this._clock.stop(time);
  }
  /**
   * Invoked when the clock is stopped
   */


  _onstop(time) {
    // stop the players
    this._activeSources.forEach(source => {
      source.fadeOut = 0;
      source.stop(time);
    });

    this.onstop(this);
  }
  /**
   * Invoked on each clock tick. scheduled a new grain at this time.
   */


  _tick(time) {
    // check if it should stop looping
    const ticks = this._clock.getTicksAtTime(time);

    const offset = ticks * this._grainSize;
    this.log("offset", offset);

    if (!this.loop && offset > this.buffer.duration) {
      this.stop(time);
      return;
    } // at the beginning of the file, the fade in should be 0


    const fadeIn = offset < this._overlap ? 0 : this._overlap; // create a buffer source

    const source = new _ToneBufferSource.ToneBufferSource({
      context: this.context,
      url: this.buffer,
      fadeIn: fadeIn,
      fadeOut: this._overlap,
      loop: this.loop,
      loopStart: this._loopStart,
      loopEnd: this._loopEnd,
      // compute the playbackRate based on the detune
      playbackRate: (0, _Conversions.intervalToFrequencyRatio)(this.detune / 100)
    }).connect(this.output);
    source.start(time, this._grainSize * ticks);
    source.stop(time + this._grainSize / this.playbackRate); // add it to the active sources

    this._activeSources.push(source); // remove it when it's done


    source.onended = () => {
      const index = this._activeSources.indexOf(source);

      if (index !== -1) {
        this._activeSources.splice(index, 1);
      }
    };
  }
  /**
   * The playback rate of the sample
   */


  get playbackRate() {
    return this._playbackRate;
  }

  set playbackRate(rate) {
    (0, _Debug.assertRange)(rate, 0.001);
    this._playbackRate = rate;
    this.grainSize = this._grainSize;
  }
  /**
   * The loop start time.
   */


  get loopStart() {
    return this._loopStart;
  }

  set loopStart(time) {
    if (this.buffer.loaded) {
      (0, _Debug.assertRange)(this.toSeconds(time), 0, this.buffer.duration);
    }

    this._loopStart = this.toSeconds(time);
  }
  /**
   * The loop end time.
   */


  get loopEnd() {
    return this._loopEnd;
  }

  set loopEnd(time) {
    if (this.buffer.loaded) {
      (0, _Debug.assertRange)(this.toSeconds(time), 0, this.buffer.duration);
    }

    this._loopEnd = this.toSeconds(time);
  }
  /**
   * The direction the buffer should play in
   */


  get reverse() {
    return this.buffer.reverse;
  }

  set reverse(rev) {
    this.buffer.reverse = rev;
  }
  /**
   * The size of each chunk of audio that the
   * buffer is chopped into and played back at.
   */


  get grainSize() {
    return this._grainSize;
  }

  set grainSize(size) {
    this._grainSize = this.toSeconds(size);

    this._clock.frequency.setValueAtTime(this._playbackRate / this._grainSize, this.now());
  }
  /**
   * The duration of the cross-fade between successive grains.
   */


  get overlap() {
    return this._overlap;
  }

  set overlap(time) {
    const computedTime = this.toSeconds(time);
    (0, _Debug.assertRange)(computedTime, 0);
    this._overlap = computedTime;
  }
  /**
   * If all the buffer is loaded
   */


  get loaded() {
    return this.buffer.loaded;
  }

  dispose() {
    super.dispose();
    this.buffer.dispose();

    this._clock.dispose();

    this._activeSources.forEach(source => source.dispose());

    return this;
  }

}

exports.GrainPlayer = GrainPlayer;
},{"../Source":"../node_modules/tone/build/esm/source/Source.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../core/context/ToneAudioBuffer":"../node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/clock/Clock":"../node_modules/tone/build/esm/core/clock/Clock.js","./ToneBufferSource":"../node_modules/tone/build/esm/source/buffer/ToneBufferSource.js","../../core/type/Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/source/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Noise = require("./Noise");

Object.keys(_Noise).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Noise[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Noise[key];
    }
  });
});

var _UserMedia = require("./UserMedia");

Object.keys(_UserMedia).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _UserMedia[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _UserMedia[key];
    }
  });
});

var _Oscillator = require("./oscillator/Oscillator");

Object.keys(_Oscillator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Oscillator[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Oscillator[key];
    }
  });
});

var _AMOscillator = require("./oscillator/AMOscillator");

Object.keys(_AMOscillator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _AMOscillator[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _AMOscillator[key];
    }
  });
});

var _FMOscillator = require("./oscillator/FMOscillator");

Object.keys(_FMOscillator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _FMOscillator[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FMOscillator[key];
    }
  });
});

var _PulseOscillator = require("./oscillator/PulseOscillator");

Object.keys(_PulseOscillator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PulseOscillator[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PulseOscillator[key];
    }
  });
});

var _FatOscillator = require("./oscillator/FatOscillator");

Object.keys(_FatOscillator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _FatOscillator[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FatOscillator[key];
    }
  });
});

var _PWMOscillator = require("./oscillator/PWMOscillator");

Object.keys(_PWMOscillator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PWMOscillator[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PWMOscillator[key];
    }
  });
});

var _OmniOscillator = require("./oscillator/OmniOscillator");

Object.keys(_OmniOscillator).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _OmniOscillator[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _OmniOscillator[key];
    }
  });
});

var _ToneOscillatorNode = require("./oscillator/ToneOscillatorNode");

Object.keys(_ToneOscillatorNode).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ToneOscillatorNode[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ToneOscillatorNode[key];
    }
  });
});

var _LFO = require("./oscillator/LFO");

Object.keys(_LFO).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _LFO[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _LFO[key];
    }
  });
});

var _ToneBufferSource = require("./buffer/ToneBufferSource");

Object.keys(_ToneBufferSource).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ToneBufferSource[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ToneBufferSource[key];
    }
  });
});

var _Player = require("./buffer/Player");

Object.keys(_Player).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Player[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Player[key];
    }
  });
});

var _Players = require("./buffer/Players");

Object.keys(_Players).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Players[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Players[key];
    }
  });
});

var _GrainPlayer = require("./buffer/GrainPlayer");

Object.keys(_GrainPlayer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _GrainPlayer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _GrainPlayer[key];
    }
  });
});
},{"./Noise":"../node_modules/tone/build/esm/source/Noise.js","./UserMedia":"../node_modules/tone/build/esm/source/UserMedia.js","./oscillator/Oscillator":"../node_modules/tone/build/esm/source/oscillator/Oscillator.js","./oscillator/AMOscillator":"../node_modules/tone/build/esm/source/oscillator/AMOscillator.js","./oscillator/FMOscillator":"../node_modules/tone/build/esm/source/oscillator/FMOscillator.js","./oscillator/PulseOscillator":"../node_modules/tone/build/esm/source/oscillator/PulseOscillator.js","./oscillator/FatOscillator":"../node_modules/tone/build/esm/source/oscillator/FatOscillator.js","./oscillator/PWMOscillator":"../node_modules/tone/build/esm/source/oscillator/PWMOscillator.js","./oscillator/OmniOscillator":"../node_modules/tone/build/esm/source/oscillator/OmniOscillator.js","./oscillator/ToneOscillatorNode":"../node_modules/tone/build/esm/source/oscillator/ToneOscillatorNode.js","./oscillator/LFO":"../node_modules/tone/build/esm/source/oscillator/LFO.js","./buffer/ToneBufferSource":"../node_modules/tone/build/esm/source/buffer/ToneBufferSource.js","./buffer/Player":"../node_modules/tone/build/esm/source/buffer/Player.js","./buffer/Players":"../node_modules/tone/build/esm/source/buffer/Players.js","./buffer/GrainPlayer":"../node_modules/tone/build/esm/source/buffer/GrainPlayer.js"}],"../node_modules/tone/build/esm/signal/Abs.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Abs = void 0;

var _SignalOperator = require("./SignalOperator");

var _WaveShaper = require("./WaveShaper");

/**
 * Return the absolute value of an incoming signal.
 *
 * @example
 * return Tone.Offline(() => {
 * 	const abs = new Tone.Abs().toDestination();
 * 	const signal = new Tone.Signal(1);
 * 	signal.rampTo(-1, 0.5);
 * 	signal.connect(abs);
 * }, 0.5, 1);
 * @category Signal
 */
class Abs extends _SignalOperator.SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "Abs";
    /**
     * The node which converts the audio ranges
     */

    this._abs = new _WaveShaper.WaveShaper({
      context: this.context,
      mapping: val => {
        if (Math.abs(val) < 0.001) {
          return 0;
        } else {
          return Math.abs(val);
        }
      }
    });
    /**
     * The AudioRange input [-1, 1]
     */

    this.input = this._abs;
    /**
     * The output range [0, 1]
     */

    this.output = this._abs;
  }
  /**
   * clean up
   */


  dispose() {
    super.dispose();

    this._abs.dispose();

    return this;
  }

}

exports.Abs = Abs;
},{"./SignalOperator":"../node_modules/tone/build/esm/signal/SignalOperator.js","./WaveShaper":"../node_modules/tone/build/esm/signal/WaveShaper.js"}],"../node_modules/tone/build/esm/signal/GainToAudio.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GainToAudio = void 0;

var _SignalOperator = require("./SignalOperator");

var _WaveShaper = require("./WaveShaper");

/**
 * GainToAudio converts an input in NormalRange [0,1] to AudioRange [-1,1].
 * See [[AudioToGain]].
 * @category Signal
 */
class GainToAudio extends _SignalOperator.SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "GainToAudio";
    /**
     * The node which converts the audio ranges
     */

    this._norm = new _WaveShaper.WaveShaper({
      context: this.context,
      mapping: x => Math.abs(x) * 2 - 1
    });
    /**
     * The NormalRange input [0, 1]
     */

    this.input = this._norm;
    /**
     * The AudioRange output [-1, 1]
     */

    this.output = this._norm;
  }
  /**
   * clean up
   */


  dispose() {
    super.dispose();

    this._norm.dispose();

    return this;
  }

}

exports.GainToAudio = GainToAudio;
},{"./SignalOperator":"../node_modules/tone/build/esm/signal/SignalOperator.js","./WaveShaper":"../node_modules/tone/build/esm/signal/WaveShaper.js"}],"../node_modules/tone/build/esm/signal/Negate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Negate = void 0;

var _Multiply = require("./Multiply");

var _SignalOperator = require("./SignalOperator");

/**
 * Negate the incoming signal. i.e. an input signal of 10 will output -10
 *
 * @example
 * const neg = new Tone.Negate();
 * const sig = new Tone.Signal(-2).connect(neg);
 * // output of neg is positive 2.
 * @category Signal
 */
class Negate extends _SignalOperator.SignalOperator {
  constructor() {
    super(...arguments);
    this.name = "Negate";
    /**
     * negation is done by multiplying by -1
     */

    this._multiply = new _Multiply.Multiply({
      context: this.context,
      value: -1
    });
    /**
     * The input and output are equal to the multiply node
     */

    this.input = this._multiply;
    this.output = this._multiply;
  }
  /**
   * clean up
   * @returns {Negate} this
   */


  dispose() {
    super.dispose();

    this._multiply.dispose();

    return this;
  }

}

exports.Negate = Negate;
},{"./Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","./SignalOperator":"../node_modules/tone/build/esm/signal/SignalOperator.js"}],"../node_modules/tone/build/esm/signal/Subtract.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Subtract = void 0;

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Gain = require("../core/context/Gain");

var _Defaults = require("../core/util/Defaults");

var _Negate = require("../signal/Negate");

var _Signal = require("../signal/Signal");

/**
 * Subtract the signal connected to the input is subtracted from the signal connected
 * The subtrahend.
 *
 * @example
 * // subtract a scalar from a signal
 * const sub = new Tone.Subtract(1);
 * const sig = new Tone.Signal(4).connect(sub);
 * // the output of sub is 3.
 * @example
 * // subtract two signals
 * const sub = new Tone.Subtract();
 * const sigA = new Tone.Signal(10);
 * const sigB = new Tone.Signal(2.5);
 * sigA.connect(sub);
 * sigB.connect(sub.subtrahend);
 * // output of sub is 7.5
 * @category Signal
 */
class Subtract extends _Signal.Signal {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(Subtract.getDefaults(), arguments, ["value"])));
    this.override = false;
    this.name = "Subtract";
    /**
     * the summing node
     */

    this._sum = new _Gain.Gain({
      context: this.context
    });
    this.input = this._sum;
    this.output = this._sum;
    /**
     * Negate the input of the second input before connecting it to the summing node.
     */

    this._neg = new _Negate.Negate({
      context: this.context
    });
    /**
     * The value which is subtracted from the main signal
     */

    this.subtrahend = this._param;
    (0, _ToneAudioNode.connectSeries)(this._constantSource, this._neg, this._sum);
  }

  static getDefaults() {
    return Object.assign(_Signal.Signal.getDefaults(), {
      value: 0
    });
  }

  dispose() {
    super.dispose();

    this._neg.dispose();

    this._sum.dispose();

    return this;
  }

}

exports.Subtract = Subtract;
},{"../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../signal/Negate":"../node_modules/tone/build/esm/signal/Negate.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js"}],"../node_modules/tone/build/esm/signal/GreaterThanZero.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GreaterThanZero = void 0;

var _SignalOperator = require("./SignalOperator");

var _Multiply = require("./Multiply");

var _WaveShaper = require("./WaveShaper");

var _Defaults = require("../core/util/Defaults");

/**
 * GreaterThanZero outputs 1 when the input is strictly greater than zero
 * @example
 * return Tone.Offline(() => {
 * 	const gt0 = new Tone.GreaterThanZero().toDestination();
 * 	const sig = new Tone.Signal(0.5).connect(gt0);
 * 	sig.setValueAtTime(-1, 0.05);
 * }, 0.1, 1);
 * @category Signal
 */
class GreaterThanZero extends _SignalOperator.SignalOperator {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(GreaterThanZero.getDefaults(), arguments)));
    this.name = "GreaterThanZero";
    this._thresh = this.output = new _WaveShaper.WaveShaper({
      context: this.context,
      length: 127,
      mapping: val => {
        if (val <= 0) {
          return 0;
        } else {
          return 1;
        }
      }
    });
    this._scale = this.input = new _Multiply.Multiply({
      context: this.context,
      value: 10000
    }); // connections

    this._scale.connect(this._thresh);
  }

  dispose() {
    super.dispose();

    this._scale.dispose();

    this._thresh.dispose();

    return this;
  }

}

exports.GreaterThanZero = GreaterThanZero;
},{"./SignalOperator":"../node_modules/tone/build/esm/signal/SignalOperator.js","./Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","./WaveShaper":"../node_modules/tone/build/esm/signal/WaveShaper.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js"}],"../node_modules/tone/build/esm/signal/GreaterThan.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GreaterThan = void 0;

var _Defaults = require("../core/util/Defaults");

var _Subtract = require("./Subtract");

var _Signal = require("./Signal");

var _GreaterThanZero = require("./GreaterThanZero");

var _Interface = require("../core/util/Interface");

/**
 * Output 1 if the signal is greater than the value, otherwise outputs 0.
 * can compare two signals or a signal and a number.
 *
 * @example
 * return Tone.Offline(() => {
 * 	const gt = new Tone.GreaterThan(2).toDestination();
 * 	const sig = new Tone.Signal(4).connect(gt);
 * }, 0.1, 1);
 * @category Signal
 */
class GreaterThan extends _Signal.Signal {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(GreaterThan.getDefaults(), arguments, ["value"])));
    this.name = "GreaterThan";
    this.override = false;
    const options = (0, _Defaults.optionsFromArguments)(GreaterThan.getDefaults(), arguments, ["value"]);
    this._subtract = this.input = new _Subtract.Subtract({
      context: this.context,
      value: options.value
    });
    this._gtz = this.output = new _GreaterThanZero.GreaterThanZero({
      context: this.context
    });
    this.comparator = this._param = this._subtract.subtrahend;
    (0, _Interface.readOnly)(this, "comparator"); // connect

    this._subtract.connect(this._gtz);
  }

  static getDefaults() {
    return Object.assign(_Signal.Signal.getDefaults(), {
      value: 0
    });
  }

  dispose() {
    super.dispose();

    this._gtz.dispose();

    this._subtract.dispose();

    this.comparator.dispose();
    return this;
  }

}

exports.GreaterThan = GreaterThan;
},{"../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Subtract":"../node_modules/tone/build/esm/signal/Subtract.js","./Signal":"../node_modules/tone/build/esm/signal/Signal.js","./GreaterThanZero":"../node_modules/tone/build/esm/signal/GreaterThanZero.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/signal/Pow.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pow = void 0;

var _WaveShaper = require("./WaveShaper");

var _Defaults = require("../core/util/Defaults");

var _SignalOperator = require("./SignalOperator");

/**
 * Pow applies an exponent to the incoming signal. The incoming signal must be AudioRange [-1, 1]
 *
 * @example
 * const pow = new Tone.Pow(2);
 * const sig = new Tone.Signal(0.5).connect(pow);
 * // output of pow is 0.25.
 * @category Signal
 */
class Pow extends _SignalOperator.SignalOperator {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(Pow.getDefaults(), arguments, ["value"])));
    this.name = "Pow";
    const options = (0, _Defaults.optionsFromArguments)(Pow.getDefaults(), arguments, ["value"]);
    this._exponentScaler = this.input = this.output = new _WaveShaper.WaveShaper({
      context: this.context,
      mapping: this._expFunc(options.value),
      length: 8192
    });
    this._exponent = options.value;
  }

  static getDefaults() {
    return Object.assign(_SignalOperator.SignalOperator.getDefaults(), {
      value: 1
    });
  }
  /**
   * the function which maps the waveshaper
   * @param exponent exponent value
   */


  _expFunc(exponent) {
    return val => {
      return Math.pow(Math.abs(val), exponent);
    };
  }
  /**
   * The value of the exponent.
   */


  get value() {
    return this._exponent;
  }

  set value(exponent) {
    this._exponent = exponent;

    this._exponentScaler.setMap(this._expFunc(this._exponent));
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();

    this._exponentScaler.dispose();

    return this;
  }

}

exports.Pow = Pow;
},{"./WaveShaper":"../node_modules/tone/build/esm/signal/WaveShaper.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./SignalOperator":"../node_modules/tone/build/esm/signal/SignalOperator.js"}],"../node_modules/tone/build/esm/signal/ScaleExp.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScaleExp = void 0;

var _Scale = require("./Scale");

var _Defaults = require("../core/util/Defaults");

var _Pow = require("./Pow");

/**
 * Performs an exponential scaling on an input signal.
 * Scales a NormalRange value [0,1] exponentially
 * to the output range of outputMin to outputMax.
 * @example
 * const scaleExp = new Tone.ScaleExp(0, 100, 2);
 * const signal = new Tone.Signal(0.5).connect(scaleExp);
 * @category Signal
 */
class ScaleExp extends _Scale.Scale {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(ScaleExp.getDefaults(), arguments, ["min", "max", "exponent"])));
    this.name = "ScaleExp";
    const options = (0, _Defaults.optionsFromArguments)(ScaleExp.getDefaults(), arguments, ["min", "max", "exponent"]);
    this.input = this._exp = new _Pow.Pow({
      context: this.context,
      value: options.exponent
    });

    this._exp.connect(this._mult);
  }

  static getDefaults() {
    return Object.assign(_Scale.Scale.getDefaults(), {
      exponent: 1
    });
  }
  /**
   * Instead of interpolating linearly between the [[min]] and
   * [[max]] values, setting the exponent will interpolate between
   * the two values with an exponential curve.
   */


  get exponent() {
    return this._exp.value;
  }

  set exponent(exp) {
    this._exp.value = exp;
  }

  dispose() {
    super.dispose();

    this._exp.dispose();

    return this;
  }

}

exports.ScaleExp = ScaleExp;
},{"./Scale":"../node_modules/tone/build/esm/signal/Scale.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Pow":"../node_modules/tone/build/esm/signal/Pow.js"}],"../node_modules/tone/build/esm/signal/SyncedSignal.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SyncedSignal = void 0;

var _Signal = require("./Signal");

var _Defaults = require("../core/util/Defaults");

var _TransportTime = require("../core/type/TransportTime");

var _ToneConstantSource = require("./ToneConstantSource");

/**
 * Adds the ability to synchronize the signal to the [[Transport]]
 */
class SyncedSignal extends _Signal.Signal {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(_Signal.Signal.getDefaults(), arguments, ["value", "units"]));
    this.name = "SyncedSignal";
    /**
     * Don't override when something is connected to the input
     */

    this.override = false;
    const options = (0, _Defaults.optionsFromArguments)(_Signal.Signal.getDefaults(), arguments, ["value", "units"]);
    this._lastVal = options.value;
    this._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), "1i");
    this._syncedCallback = this._anchorValue.bind(this);
    this.context.transport.on("start", this._syncedCallback);
    this.context.transport.on("pause", this._syncedCallback);
    this.context.transport.on("stop", this._syncedCallback); // disconnect the constant source from the output and replace it with another one

    this._constantSource.disconnect();

    this._constantSource.stop(0); // create a new one


    this._constantSource = this.output = new _ToneConstantSource.ToneConstantSource({
      context: this.context,
      offset: options.value,
      units: options.units
    }).start(0);
    this.setValueAtTime(options.value, 0);
  }
  /**
   * Callback which is invoked every tick.
   */


  _onTick(time) {
    const val = super.getValueAtTime(this.context.transport.seconds); // approximate ramp curves with linear ramps

    if (this._lastVal !== val) {
      this._lastVal = val;

      this._constantSource.offset.setValueAtTime(val, time);
    }
  }
  /**
   * Anchor the value at the start and stop of the Transport
   */


  _anchorValue(time) {
    const val = super.getValueAtTime(this.context.transport.seconds);
    this._lastVal = val;

    this._constantSource.offset.cancelAndHoldAtTime(time);

    this._constantSource.offset.setValueAtTime(val, time);
  }

  getValueAtTime(time) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, time).toSeconds();
    return super.getValueAtTime(computedTime);
  }

  setValueAtTime(value, time) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, time).toSeconds();
    super.setValueAtTime(value, computedTime);
    return this;
  }

  linearRampToValueAtTime(value, time) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, time).toSeconds();
    super.linearRampToValueAtTime(value, computedTime);
    return this;
  }

  exponentialRampToValueAtTime(value, time) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, time).toSeconds();
    super.exponentialRampToValueAtTime(value, computedTime);
    return this;
  }

  setTargetAtTime(value, startTime, timeConstant) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, startTime).toSeconds();
    super.setTargetAtTime(value, computedTime, timeConstant);
    return this;
  }

  cancelScheduledValues(startTime) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, startTime).toSeconds();
    super.cancelScheduledValues(computedTime);
    return this;
  }

  setValueCurveAtTime(values, startTime, duration, scaling) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, startTime).toSeconds();
    duration = this.toSeconds(duration);
    super.setValueCurveAtTime(values, computedTime, duration, scaling);
    return this;
  }

  cancelAndHoldAtTime(time) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, time).toSeconds();
    super.cancelAndHoldAtTime(computedTime);
    return this;
  }

  setRampPoint(time) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, time).toSeconds();
    super.setRampPoint(computedTime);
    return this;
  }

  exponentialRampTo(value, rampTime, startTime) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, startTime).toSeconds();
    super.exponentialRampTo(value, rampTime, computedTime);
    return this;
  }

  linearRampTo(value, rampTime, startTime) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, startTime).toSeconds();
    super.linearRampTo(value, rampTime, computedTime);
    return this;
  }

  targetRampTo(value, rampTime, startTime) {
    const computedTime = new _TransportTime.TransportTimeClass(this.context, startTime).toSeconds();
    super.targetRampTo(value, rampTime, computedTime);
    return this;
  }

  dispose() {
    super.dispose();
    this.context.transport.clear(this._synced);
    this.context.transport.off("start", this._syncedCallback);
    this.context.transport.off("pause", this._syncedCallback);
    this.context.transport.off("stop", this._syncedCallback);

    this._constantSource.dispose();

    return this;
  }

}

exports.SyncedSignal = SyncedSignal;
},{"./Signal":"../node_modules/tone/build/esm/signal/Signal.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/type/TransportTime":"../node_modules/tone/build/esm/core/type/TransportTime.js","./ToneConstantSource":"../node_modules/tone/build/esm/signal/ToneConstantSource.js"}],"../node_modules/tone/build/esm/signal/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Add = require("./Add");

Object.keys(_Add).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Add[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Add[key];
    }
  });
});

var _Abs = require("./Abs");

Object.keys(_Abs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Abs[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Abs[key];
    }
  });
});

var _AudioToGain = require("./AudioToGain");

Object.keys(_AudioToGain).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _AudioToGain[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _AudioToGain[key];
    }
  });
});

var _GainToAudio = require("./GainToAudio");

Object.keys(_GainToAudio).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _GainToAudio[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _GainToAudio[key];
    }
  });
});

var _GreaterThan = require("./GreaterThan");

Object.keys(_GreaterThan).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _GreaterThan[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _GreaterThan[key];
    }
  });
});

var _GreaterThanZero = require("./GreaterThanZero");

Object.keys(_GreaterThanZero).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _GreaterThanZero[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _GreaterThanZero[key];
    }
  });
});

var _Multiply = require("./Multiply");

Object.keys(_Multiply).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Multiply[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Multiply[key];
    }
  });
});

var _Negate = require("./Negate");

Object.keys(_Negate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Negate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Negate[key];
    }
  });
});

var _Pow = require("./Pow");

Object.keys(_Pow).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Pow[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Pow[key];
    }
  });
});

var _Signal = require("./Signal");

Object.keys(_Signal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Signal[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Signal[key];
    }
  });
});

var _Scale = require("./Scale");

Object.keys(_Scale).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Scale[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Scale[key];
    }
  });
});

var _ScaleExp = require("./ScaleExp");

Object.keys(_ScaleExp).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ScaleExp[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ScaleExp[key];
    }
  });
});

var _Subtract = require("./Subtract");

Object.keys(_Subtract).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Subtract[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Subtract[key];
    }
  });
});

var _SyncedSignal = require("./SyncedSignal");

Object.keys(_SyncedSignal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _SyncedSignal[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _SyncedSignal[key];
    }
  });
});

var _WaveShaper = require("./WaveShaper");

Object.keys(_WaveShaper).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _WaveShaper[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _WaveShaper[key];
    }
  });
});

var _Zero = require("./Zero");

Object.keys(_Zero).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Zero[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Zero[key];
    }
  });
});
},{"./Add":"../node_modules/tone/build/esm/signal/Add.js","./Abs":"../node_modules/tone/build/esm/signal/Abs.js","./AudioToGain":"../node_modules/tone/build/esm/signal/AudioToGain.js","./GainToAudio":"../node_modules/tone/build/esm/signal/GainToAudio.js","./GreaterThan":"../node_modules/tone/build/esm/signal/GreaterThan.js","./GreaterThanZero":"../node_modules/tone/build/esm/signal/GreaterThanZero.js","./Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","./Negate":"../node_modules/tone/build/esm/signal/Negate.js","./Pow":"../node_modules/tone/build/esm/signal/Pow.js","./Signal":"../node_modules/tone/build/esm/signal/Signal.js","./Scale":"../node_modules/tone/build/esm/signal/Scale.js","./ScaleExp":"../node_modules/tone/build/esm/signal/ScaleExp.js","./Subtract":"../node_modules/tone/build/esm/signal/Subtract.js","./SyncedSignal":"../node_modules/tone/build/esm/signal/SyncedSignal.js","./WaveShaper":"../node_modules/tone/build/esm/signal/WaveShaper.js","./Zero":"../node_modules/tone/build/esm/signal/Zero.js"}],"../node_modules/tone/build/esm/component/envelope/Envelope.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Envelope = void 0;

var _tslib = require("tslib");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _TypeCheck = require("../../core/util/TypeCheck");

var _Signal = require("../../signal/Signal");

var _OfflineContext = require("../../core/context/OfflineContext");

var _Debug = require("../../core/util/Debug");

var _Decorator = require("../../core/util/Decorator");

/**
 * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)
 * envelope generator. Envelope outputs a signal which
 * can be connected to an AudioParam or Tone.Signal.
 * ```
 *           /\
 *          /  \
 *         /    \
 *        /      \
 *       /        \___________
 *      /                     \
 *     /                       \
 *    /                         \
 *   /                           \
 * ```
 * @example
 * return Tone.Offline(() => {
 * 	const env = new Tone.Envelope({
 * 		attack: 0.1,
 * 		decay: 0.2,
 * 		sustain: 0.5,
 * 		release: 0.8,
 * 	}).toDestination();
 * 	env.triggerAttackRelease(0.5);
 * }, 1.5, 1);
 * @category Component
 */
class Envelope extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Envelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
    this.name = "Envelope";
    /**
     * the signal which is output.
     */

    this._sig = new _Signal.Signal({
      context: this.context,
      value: 0
    });
    /**
     * The output signal of the envelope
     */

    this.output = this._sig;
    /**
     * Envelope has no input
     */

    this.input = undefined;
    const options = (0, _Defaults.optionsFromArguments)(Envelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
    this.attack = options.attack;
    this.decay = options.decay;
    this.sustain = options.sustain;
    this.release = options.release;
    this.attackCurve = options.attackCurve;
    this.releaseCurve = options.releaseCurve;
    this.decayCurve = options.decayCurve;
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      attack: 0.01,
      attackCurve: "linear",
      decay: 0.1,
      decayCurve: "exponential",
      release: 1,
      releaseCurve: "exponential",
      sustain: 0.5
    });
  }
  /**
   * Read the current value of the envelope. Useful for
   * synchronizing visual output to the envelope.
   */


  get value() {
    return this.getValueAtTime(this.now());
  }
  /**
   * Get the curve
   * @param  curve
   * @param  direction  In/Out
   * @return The curve name
   */


  _getCurve(curve, direction) {
    if ((0, _TypeCheck.isString)(curve)) {
      return curve;
    } else {
      // look up the name in the curves array
      let curveName;

      for (curveName in EnvelopeCurves) {
        if (EnvelopeCurves[curveName][direction] === curve) {
          return curveName;
        }
      } // return the custom curve


      return curve;
    }
  }
  /**
   * Assign a the curve to the given name using the direction
   * @param  name
   * @param  direction In/Out
   * @param  curve
   */


  _setCurve(name, direction, curve) {
    // check if it's a valid type
    if ((0, _TypeCheck.isString)(curve) && Reflect.has(EnvelopeCurves, curve)) {
      const curveDef = EnvelopeCurves[curve];

      if ((0, _TypeCheck.isObject)(curveDef)) {
        if (name !== "_decayCurve") {
          this[name] = curveDef[direction];
        }
      } else {
        this[name] = curveDef;
      }
    } else if ((0, _TypeCheck.isArray)(curve) && name !== "_decayCurve") {
      this[name] = curve;
    } else {
      throw new Error("Envelope: invalid curve: " + curve);
    }
  }
  /**
   * The shape of the attack.
   * Can be any of these strings:
   * * "linear"
   * * "exponential"
   * * "sine"
   * * "cosine"
   * * "bounce"
   * * "ripple"
   * * "step"
   *
   * Can also be an array which describes the curve. Values
   * in the array are evenly subdivided and linearly
   * interpolated over the duration of the attack.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope(0.4).toDestination();
   * 	env.attackCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */


  get attackCurve() {
    return this._getCurve(this._attackCurve, "In");
  }

  set attackCurve(curve) {
    this._setCurve("_attackCurve", "In", curve);
  }
  /**
   * The shape of the release. See the attack curve types.
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		release: 0.8
   * 	}).toDestination();
   * 	env.triggerAttack();
   * 	// release curve could also be defined by an array
   * 	env.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];
   * 	env.triggerRelease(0.2);
   * }, 1, 1);
   */


  get releaseCurve() {
    return this._getCurve(this._releaseCurve, "Out");
  }

  set releaseCurve(curve) {
    this._setCurve("_releaseCurve", "Out", curve);
  }
  /**
   * The shape of the decay either "linear" or "exponential"
   * @example
   * return Tone.Offline(() => {
   * 	const env = new Tone.Envelope({
   * 		sustain: 0.1,
   * 		decay: 0.5
   * 	}).toDestination();
   * 	env.decayCurve = "linear";
   * 	env.triggerAttack();
   * }, 1, 1);
   */


  get decayCurve() {
    return this._decayCurve;
  }

  set decayCurve(curve) {
    (0, _Debug.assert)(["linear", "exponential"].some(c => c === curve), `Invalid envelope curve: ${curve}`);
    this._decayCurve = curve;
  }
  /**
   * Trigger the attack/decay portion of the ADSR envelope.
   * @param  time When the attack should start.
   * @param velocity The velocity of the envelope scales the vales.
   *                             number between 0-1
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the attack 0.5 seconds from now with a velocity of 0.2
   * env.triggerAttack("+0.5", 0.2);
   */


  triggerAttack(time, velocity = 1) {
    this.log("triggerAttack", time, velocity);
    time = this.toSeconds(time);
    const originalAttack = this.toSeconds(this.attack);
    let attack = originalAttack;
    const decay = this.toSeconds(this.decay); // check if it's not a complete attack

    const currentValue = this.getValueAtTime(time);

    if (currentValue > 0) {
      // subtract the current value from the attack time
      const attackRate = 1 / attack;
      const remainingDistance = 1 - currentValue; // the attack is now the remaining time

      attack = remainingDistance / attackRate;
    } // attack


    if (attack < this.sampleTime) {
      this._sig.cancelScheduledValues(time); // case where the attack time is 0 should set instantly


      this._sig.setValueAtTime(velocity, time);
    } else if (this._attackCurve === "linear") {
      this._sig.linearRampTo(velocity, attack, time);
    } else if (this._attackCurve === "exponential") {
      this._sig.targetRampTo(velocity, attack, time);
    } else {
      this._sig.cancelAndHoldAtTime(time);

      let curve = this._attackCurve; // find the starting position in the curve

      for (let i = 1; i < curve.length; i++) {
        // the starting index is between the two values
        if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {
          curve = this._attackCurve.slice(i); // the first index is the current value

          curve[0] = currentValue;
          break;
        }
      }

      this._sig.setValueCurveAtTime(curve, time, attack, velocity);
    } // decay


    if (decay && this.sustain < 1) {
      const decayValue = velocity * this.sustain;
      const decayStart = time + attack;
      this.log("decay", decayStart);

      if (this._decayCurve === "linear") {
        this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);
      } else {
        this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);
      }
    }

    return this;
  }
  /**
   * Triggers the release of the envelope.
   * @param  time When the release portion of the envelope should start.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator({
   * 	type: "sawtooth"
   * }).connect(env).start();
   * env.triggerAttack();
   * // trigger the release half a second after the attack
   * env.triggerRelease("+0.5");
   */


  triggerRelease(time) {
    this.log("triggerRelease", time);
    time = this.toSeconds(time);
    const currentValue = this.getValueAtTime(time);

    if (currentValue > 0) {
      const release = this.toSeconds(this.release);

      if (release < this.sampleTime) {
        this._sig.setValueAtTime(0, time);
      } else if (this._releaseCurve === "linear") {
        this._sig.linearRampTo(0, release, time);
      } else if (this._releaseCurve === "exponential") {
        this._sig.targetRampTo(0, release, time);
      } else {
        (0, _Debug.assert)((0, _TypeCheck.isArray)(this._releaseCurve), "releaseCurve must be either 'linear', 'exponential' or an array");

        this._sig.cancelAndHoldAtTime(time);

        this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);
      }
    }

    return this;
  }
  /**
   * Get the scheduled value at the given time. This will
   * return the unconverted (raw) value.
   * @example
   * const env = new Tone.Envelope(0.5, 1, 0.4, 2);
   * env.triggerAttackRelease(2);
   * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);
   */


  getValueAtTime(time) {
    return this._sig.getValueAtTime(time);
  }
  /**
   * triggerAttackRelease is shorthand for triggerAttack, then waiting
   * some duration, then triggerRelease.
   * @param duration The duration of the sustain.
   * @param time When the attack should be triggered.
   * @param velocity The velocity of the envelope.
   * @example
   * const env = new Tone.AmplitudeEnvelope().toDestination();
   * const osc = new Tone.Oscillator().connect(env).start();
   * // trigger the release 0.5 seconds after the attack
   * env.triggerAttackRelease(0.5);
   */


  triggerAttackRelease(duration, time, velocity = 1) {
    time = this.toSeconds(time);
    this.triggerAttack(time, velocity);
    this.triggerRelease(time + this.toSeconds(duration));
    return this;
  }
  /**
   * Cancels all scheduled envelope changes after the given time.
   */


  cancel(after) {
    this._sig.cancelScheduledValues(this.toSeconds(after));

    return this;
  }
  /**
   * Connect the envelope to a destination node.
   */


  connect(destination, outputNumber = 0, inputNumber = 0) {
    (0, _Signal.connectSignal)(this, destination, outputNumber, inputNumber);
    return this;
  }
  /**
   * Render the envelope curve to an array of the given length.
   * Good for visualizing the envelope curve. Rescales the duration of the
   * envelope to fit the length.
   */


  asArray(length = 1024) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const duration = length / this.context.sampleRate;
      const context = new _OfflineContext.OfflineContext(1, duration, this.context.sampleRate); // normalize the ADSR for the given duration with 20% sustain time

      const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);
      const envelopeDuration = attackPortion + this.toSeconds(this.release);
      const sustainTime = envelopeDuration * 0.1;
      const totalDuration = envelopeDuration + sustainTime; // @ts-ignore

      const clone = new this.constructor(Object.assign(this.get(), {
        attack: duration * this.toSeconds(this.attack) / totalDuration,
        decay: duration * this.toSeconds(this.decay) / totalDuration,
        release: duration * this.toSeconds(this.release) / totalDuration,
        context
      }));

      clone._sig.toDestination();

      clone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);
      const buffer = yield context.render();
      return buffer.getChannelData(0);
    });
  }

  dispose() {
    super.dispose();

    this._sig.dispose();

    return this;
  }

}

exports.Envelope = Envelope;
(0, _tslib.__decorate)([(0, _Decorator.timeRange)(0)], Envelope.prototype, "attack", void 0);
(0, _tslib.__decorate)([(0, _Decorator.timeRange)(0)], Envelope.prototype, "decay", void 0);
(0, _tslib.__decorate)([(0, _Decorator.range)(0, 1)], Envelope.prototype, "sustain", void 0);
(0, _tslib.__decorate)([(0, _Decorator.timeRange)(0)], Envelope.prototype, "release", void 0);
/**
 * Generate some complex envelope curves.
 */

const EnvelopeCurves = (() => {
  const curveLen = 128;
  let i;
  let k; // cosine curve

  const cosineCurve = [];

  for (i = 0; i < curveLen; i++) {
    cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));
  } // ripple curve


  const rippleCurve = [];
  const rippleCurveFreq = 6.4;

  for (i = 0; i < curveLen - 1; i++) {
    k = i / (curveLen - 1);
    const sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;
    rippleCurve[i] = sineWave / 10 + k * 0.83;
  }

  rippleCurve[curveLen - 1] = 1; // stairs curve

  const stairsCurve = [];
  const steps = 5;

  for (i = 0; i < curveLen; i++) {
    stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;
  } // in-out easing curve


  const sineCurve = [];

  for (i = 0; i < curveLen; i++) {
    k = i / (curveLen - 1);
    sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));
  } // a bounce curve


  const bounceCurve = [];

  for (i = 0; i < curveLen; i++) {
    k = i / (curveLen - 1);
    const freq = Math.pow(k, 3) * 4 + 0.2;
    const val = Math.cos(freq * Math.PI * 2 * k);
    bounceCurve[i] = Math.abs(val * (1 - k));
  }
  /**
   * Invert a value curve to make it work for the release
   */


  function invertCurve(curve) {
    const out = new Array(curve.length);

    for (let j = 0; j < curve.length; j++) {
      out[j] = 1 - curve[j];
    }

    return out;
  }
  /**
   * reverse the curve
   */


  function reverseCurve(curve) {
    return curve.slice(0).reverse();
  }
  /**
   * attack and release curve arrays
   */


  return {
    bounce: {
      In: invertCurve(bounceCurve),
      Out: bounceCurve
    },
    cosine: {
      In: cosineCurve,
      Out: reverseCurve(cosineCurve)
    },
    exponential: "exponential",
    linear: "linear",
    ripple: {
      In: rippleCurve,
      Out: invertCurve(rippleCurve)
    },
    sine: {
      In: sineCurve,
      Out: invertCurve(sineCurve)
    },
    step: {
      In: stairsCurve,
      Out: invertCurve(stairsCurve)
    }
  };
})();
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","../../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../../core/context/OfflineContext":"../node_modules/tone/build/esm/core/context/OfflineContext.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","../../core/util/Decorator":"../node_modules/tone/build/esm/core/util/Decorator.js"}],"../node_modules/tone/build/esm/instrument/Instrument.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Instrument = void 0;

var _Volume = require("../component/channel/Volume");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

/**
 * Base-class for all instruments
 */
class Instrument extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Instrument.getDefaults(), arguments));
    /**
     * Keep track of all events scheduled to the transport
     * when the instrument is 'synced'
     */

    this._scheduledEvents = [];
    /**
     * If the instrument is currently synced
     */

    this._synced = false;
    this._original_triggerAttack = this.triggerAttack;
    this._original_triggerRelease = this.triggerRelease;
    const options = (0, _Defaults.optionsFromArguments)(Instrument.getDefaults(), arguments);
    this._volume = this.output = new _Volume.Volume({
      context: this.context,
      volume: options.volume
    });
    this.volume = this._volume.volume;
    (0, _Interface.readOnly)(this, "volume");
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      volume: 0
    });
  }
  /**
   * Sync the instrument to the Transport. All subsequent calls of
   * [[triggerAttack]] and [[triggerRelease]] will be scheduled along the transport.
   * @example
   * const fmSynth = new Tone.FMSynth().toDestination();
   * fmSynth.volume.value = -6;
   * fmSynth.sync();
   * // schedule 3 notes when the transport first starts
   * fmSynth.triggerAttackRelease("C4", "8n", 0);
   * fmSynth.triggerAttackRelease("E4", "8n", "8n");
   * fmSynth.triggerAttackRelease("G4", "8n", "4n");
   * // start the transport to hear the notes
   * Tone.Transport.start();
   */


  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);

      this._syncMethod("triggerRelease", 0);
    }

    return this;
  }
  /**
   * set _sync
   */


  _syncState() {
    let changed = false;

    if (!this._synced) {
      this._synced = true;
      changed = true;
    }

    return changed;
  }
  /**
   * Wrap the given method so that it can be synchronized
   * @param method Which method to wrap and sync
   * @param  timePosition What position the time argument appears in
   */


  _syncMethod(method, timePosition) {
    const originalMethod = this["_original_" + method] = this[method];

    this[method] = (...args) => {
      const time = args[timePosition];
      const id = this.context.transport.schedule(t => {
        args[timePosition] = t;
        originalMethod.apply(this, args);
      }, time);

      this._scheduledEvents.push(id);
    };
  }
  /**
   * Unsync the instrument from the Transport
   */


  unsync() {
    this._scheduledEvents.forEach(id => this.context.transport.clear(id));

    this._scheduledEvents = [];

    if (this._synced) {
      this._synced = false;
      this.triggerAttack = this._original_triggerAttack;
      this.triggerRelease = this._original_triggerRelease;
    }

    return this;
  }
  /**
   * Trigger the attack and then the release after the duration.
   * @param  note     The note to trigger.
   * @param  duration How long the note should be held for before
   *                         triggering the release. This value must be greater than 0.
   * @param time  When the note should be triggered.
   * @param  velocity The velocity the note should be triggered at.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger "C4" for the duration of an 8th note
   * synth.triggerAttackRelease("C4", "8n");
   */


  triggerAttackRelease(note, duration, time, velocity) {
    const computedTime = this.toSeconds(time);
    const computedDuration = this.toSeconds(duration);
    this.triggerAttack(note, computedTime, velocity);
    this.triggerRelease(computedTime + computedDuration);
    return this;
  }
  /**
   * clean up
   * @returns {Instrument} this
   */


  dispose() {
    super.dispose();

    this._volume.dispose();

    this.unsync();
    this._scheduledEvents = [];
    return this;
  }

}

exports.Instrument = Instrument;
},{"../component/channel/Volume":"../node_modules/tone/build/esm/component/channel/Volume.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/instrument/Monophonic.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Monophonic = void 0;

var _tslib = require("tslib");

var _Frequency = require("../core/type/Frequency");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

var _Instrument = require("../instrument/Instrument");

var _Decorator = require("../core/util/Decorator");

/**
 * Abstract base class for other monophonic instruments to extend.
 */
class Monophonic extends _Instrument.Instrument {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Monophonic.getDefaults(), arguments));
    const options = (0, _Defaults.optionsFromArguments)(Monophonic.getDefaults(), arguments);
    this.portamento = options.portamento;
    this.onsilence = options.onsilence;
  }

  static getDefaults() {
    return Object.assign(_Instrument.Instrument.getDefaults(), {
      detune: 0,
      onsilence: _Interface.noOp,
      portamento: 0
    });
  }
  /**
   * Trigger the attack of the note optionally with a given velocity.
   * @param  note The note to trigger.
   * @param  time When the note should start.
   * @param  velocity The velocity scaler determines how "loud" the note will be triggered.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * // trigger the note a half second from now at half velocity
   * synth.triggerAttack("C4", "+0.5", 0.5);
   */


  triggerAttack(note, time, velocity = 1) {
    this.log("triggerAttack", note, time, velocity);
    const seconds = this.toSeconds(time);

    this._triggerEnvelopeAttack(seconds, velocity);

    this.setNote(note, seconds);
    return this;
  }
  /**
   * Trigger the release portion of the envelope
   * @param  time If no time is given, the release happens immediatly
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // trigger the release a second from now
   * synth.triggerRelease("+1");
   */


  triggerRelease(time) {
    this.log("triggerRelease", time);
    const seconds = this.toSeconds(time);

    this._triggerEnvelopeRelease(seconds);

    return this;
  }
  /**
   * Set the note at the given time. If no time is given, the note
   * will set immediately.
   * @param note The note to change to.
   * @param  time The time when the note should be set.
   * @example
   * const synth = new Tone.Synth().toDestination();
   * synth.triggerAttack("C4");
   * // change to F#6 in one quarter note from now.
   * synth.setNote("F#6", "+4n");
   */


  setNote(note, time) {
    const computedTime = this.toSeconds(time);
    const computedFrequency = note instanceof _Frequency.FrequencyClass ? note.toFrequency() : note;

    if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {
      const portTime = this.toSeconds(this.portamento);
      this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);
    } else {
      this.frequency.setValueAtTime(computedFrequency, computedTime);
    }

    return this;
  }

}

exports.Monophonic = Monophonic;
(0, _tslib.__decorate)([(0, _Decorator.timeRange)(0)], Monophonic.prototype, "portamento", void 0);
},{"tslib":"../node_modules/tslib/tslib.es6.js","../core/type/Frequency":"../node_modules/tone/build/esm/core/type/Frequency.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../instrument/Instrument":"../node_modules/tone/build/esm/instrument/Instrument.js","../core/util/Decorator":"../node_modules/tone/build/esm/core/util/Decorator.js"}],"../node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AmplitudeEnvelope = void 0;

var _Gain = require("../../core/context/Gain");

var _Defaults = require("../../core/util/Defaults");

var _Envelope = require("./Envelope");

/**
 * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.
 * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts
 * an audio signal as the input and will apply the envelope to the amplitude
 * of the signal.
 * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).
 *
 * @example
 * return Tone.Offline(() => {
 * 	const ampEnv = new Tone.AmplitudeEnvelope({
 * 		attack: 0.1,
 * 		decay: 0.2,
 * 		sustain: 1.0,
 * 		release: 0.8
 * 	}).toDestination();
 * 	// create an oscillator and connect it
 * 	const osc = new Tone.Oscillator().connect(ampEnv).start();
 * 	// trigger the envelopes attack and release "8t" apart
 * 	ampEnv.triggerAttackRelease("8t");
 * }, 1.5, 1);
 * @category Component
 */
class AmplitudeEnvelope extends _Envelope.Envelope {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(AmplitudeEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
    this.name = "AmplitudeEnvelope";
    this._gainNode = new _Gain.Gain({
      context: this.context,
      gain: 0
    });
    this.output = this._gainNode;
    this.input = this._gainNode;

    this._sig.connect(this._gainNode.gain);

    this.output = this._gainNode;
    this.input = this._gainNode;
  }
  /**
   * Clean up
   */


  dispose() {
    super.dispose();

    this._gainNode.dispose();

    return this;
  }

}

exports.AmplitudeEnvelope = AmplitudeEnvelope;
},{"../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Envelope":"../node_modules/tone/build/esm/component/envelope/Envelope.js"}],"../node_modules/tone/build/esm/instrument/Synth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Synth = void 0;

var _AmplitudeEnvelope = require("../component/envelope/AmplitudeEnvelope");

var _Envelope = require("../component/envelope/Envelope");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

var _OmniOscillator = require("../source/oscillator/OmniOscillator");

var _Source = require("../source/Source");

var _Monophonic = require("./Monophonic");

/**
 * Synth is composed simply of a [[OmniOscillator]] routed through an [[AmplitudeEnvelope]].
 * ```
 * +----------------+   +-------------------+
 * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output
 * +----------------+   +-------------------+
 * ```
 * @example
 * const synth = new Tone.Synth().toDestination();
 * synth.triggerAttackRelease("C4", "8n");
 * @category Instrument
 */
class Synth extends _Monophonic.Monophonic {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Synth.getDefaults(), arguments));
    this.name = "Synth";
    const options = (0, _Defaults.optionsFromArguments)(Synth.getDefaults(), arguments);
    this.oscillator = new _OmniOscillator.OmniOscillator(Object.assign({
      context: this.context,
      detune: options.detune,
      onstop: () => this.onsilence(this)
    }, options.oscillator));
    this.frequency = this.oscillator.frequency;
    this.detune = this.oscillator.detune;
    this.envelope = new _AmplitudeEnvelope.AmplitudeEnvelope(Object.assign({
      context: this.context
    }, options.envelope)); // connect the oscillators to the output

    this.oscillator.chain(this.envelope, this.output);
    (0, _Interface.readOnly)(this, ["oscillator", "frequency", "detune", "envelope"]);
  }

  static getDefaults() {
    return Object.assign(_Monophonic.Monophonic.getDefaults(), {
      envelope: Object.assign((0, _Defaults.omitFromObject)(_Envelope.Envelope.getDefaults(), Object.keys(_ToneAudioNode.ToneAudioNode.getDefaults())), {
        attack: 0.005,
        decay: 0.1,
        release: 1,
        sustain: 0.3
      }),
      oscillator: Object.assign((0, _Defaults.omitFromObject)(_OmniOscillator.OmniOscillator.getDefaults(), [...Object.keys(_Source.Source.getDefaults()), "frequency", "detune"]), {
        type: "triangle"
      })
    });
  }
  /**
   * start the attack portion of the envelope
   * @param time the time the attack should start
   * @param velocity the velocity of the note (0-1)
   */


  _triggerEnvelopeAttack(time, velocity) {
    // the envelopes
    this.envelope.triggerAttack(time, velocity);
    this.oscillator.start(time); // if there is no release portion, stop the oscillator

    if (this.envelope.sustain === 0) {
      const computedAttack = this.toSeconds(this.envelope.attack);
      const computedDecay = this.toSeconds(this.envelope.decay);
      this.oscillator.stop(time + computedAttack + computedDecay);
    }
  }
  /**
   * start the release portion of the envelope
   * @param time the time the release should start
   */


  _triggerEnvelopeRelease(time) {
    this.envelope.triggerRelease(time);
    this.oscillator.stop(time + this.toSeconds(this.envelope.release));
  }

  getLevelAtTime(time) {
    time = this.toSeconds(time);
    return this.envelope.getValueAtTime(time);
  }
  /**
   * clean up
   */


  dispose() {
    super.dispose();
    this.oscillator.dispose();
    this.envelope.dispose();
    return this;
  }

}

exports.Synth = Synth;
},{"../component/envelope/AmplitudeEnvelope":"../node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js","../component/envelope/Envelope":"../node_modules/tone/build/esm/component/envelope/Envelope.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../source/oscillator/OmniOscillator":"../node_modules/tone/build/esm/source/oscillator/OmniOscillator.js","../source/Source":"../node_modules/tone/build/esm/source/Source.js","./Monophonic":"../node_modules/tone/build/esm/instrument/Monophonic.js"}],"../node_modules/tone/build/esm/instrument/ModulationSynth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModulationSynth = void 0;

var _Signal = require("../signal/Signal");

var _Multiply = require("../signal/Multiply");

var _Gain = require("../core/context/Gain");

var _Envelope = require("../component/envelope/Envelope");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Monophonic = require("./Monophonic");

var _OmniOscillator = require("../source/oscillator/OmniOscillator");

var _Source = require("../source/Source");

var _Synth = require("./Synth");

var _Interface = require("../core/util/Interface");

var _Defaults = require("../core/util/Defaults");

/**
 * Base class for both AM and FM synths
 */
class ModulationSynth extends _Monophonic.Monophonic {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(ModulationSynth.getDefaults(), arguments));
    this.name = "ModulationSynth";
    const options = (0, _Defaults.optionsFromArguments)(ModulationSynth.getDefaults(), arguments);
    this._carrier = new _Synth.Synth({
      context: this.context,
      oscillator: options.oscillator,
      envelope: options.envelope,
      onsilence: () => this.onsilence(this),
      volume: -10
    });
    this._modulator = new _Synth.Synth({
      context: this.context,
      oscillator: options.modulation,
      envelope: options.modulationEnvelope,
      volume: -10
    });
    this.oscillator = this._carrier.oscillator;
    this.envelope = this._carrier.envelope;
    this.modulation = this._modulator.oscillator;
    this.modulationEnvelope = this._modulator.envelope;
    this.frequency = new _Signal.Signal({
      context: this.context,
      units: "frequency"
    });
    this.detune = new _Signal.Signal({
      context: this.context,
      value: options.detune,
      units: "cents"
    });
    this.harmonicity = new _Multiply.Multiply({
      context: this.context,
      value: options.harmonicity,
      minValue: 0
    });
    this._modulationNode = new _Gain.Gain({
      context: this.context,
      gain: 0
    });
    (0, _Interface.readOnly)(this, ["frequency", "harmonicity", "oscillator", "envelope", "modulation", "modulationEnvelope", "detune"]);
  }

  static getDefaults() {
    return Object.assign(_Monophonic.Monophonic.getDefaults(), {
      harmonicity: 3,
      oscillator: Object.assign((0, _Defaults.omitFromObject)(_OmniOscillator.OmniOscillator.getDefaults(), [...Object.keys(_Source.Source.getDefaults()), "frequency", "detune"]), {
        type: "sine"
      }),
      envelope: Object.assign((0, _Defaults.omitFromObject)(_Envelope.Envelope.getDefaults(), Object.keys(_ToneAudioNode.ToneAudioNode.getDefaults())), {
        attack: 0.01,
        decay: 0.01,
        sustain: 1,
        release: 0.5
      }),
      modulation: Object.assign((0, _Defaults.omitFromObject)(_OmniOscillator.OmniOscillator.getDefaults(), [...Object.keys(_Source.Source.getDefaults()), "frequency", "detune"]), {
        type: "square"
      }),
      modulationEnvelope: Object.assign((0, _Defaults.omitFromObject)(_Envelope.Envelope.getDefaults(), Object.keys(_ToneAudioNode.ToneAudioNode.getDefaults())), {
        attack: 0.5,
        decay: 0.0,
        sustain: 1,
        release: 0.5
      })
    });
  }
  /**
   * Trigger the attack portion of the note
   */


  _triggerEnvelopeAttack(time, velocity) {
    // @ts-ignore
    this._carrier._triggerEnvelopeAttack(time, velocity); // @ts-ignore


    this._modulator._triggerEnvelopeAttack(time, velocity);
  }
  /**
   * Trigger the release portion of the note
   */


  _triggerEnvelopeRelease(time) {
    // @ts-ignore
    this._carrier._triggerEnvelopeRelease(time); // @ts-ignore


    this._modulator._triggerEnvelopeRelease(time);

    return this;
  }

  getLevelAtTime(time) {
    time = this.toSeconds(time);
    return this.envelope.getValueAtTime(time);
  }

  dispose() {
    super.dispose();

    this._carrier.dispose();

    this._modulator.dispose();

    this.frequency.dispose();
    this.detune.dispose();
    this.harmonicity.dispose();

    this._modulationNode.dispose();

    return this;
  }

}

exports.ModulationSynth = ModulationSynth;
},{"../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../signal/Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../component/envelope/Envelope":"../node_modules/tone/build/esm/component/envelope/Envelope.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","./Monophonic":"../node_modules/tone/build/esm/instrument/Monophonic.js","../source/oscillator/OmniOscillator":"../node_modules/tone/build/esm/source/oscillator/OmniOscillator.js","../source/Source":"../node_modules/tone/build/esm/source/Source.js","./Synth":"../node_modules/tone/build/esm/instrument/Synth.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js"}],"../node_modules/tone/build/esm/instrument/AMSynth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AMSynth = void 0;

var _AudioToGain = require("../signal/AudioToGain");

var _Defaults = require("../core/util/Defaults");

var _ModulationSynth = require("./ModulationSynth");

/**
 * AMSynth uses the output of one Tone.Synth to modulate the
 * amplitude of another Tone.Synth. The harmonicity (the ratio between
 * the two signals) affects the timbre of the output signal greatly.
 * Read more about Amplitude Modulation Synthesis on
 * [SoundOnSound](https://web.archive.org/web/20160404103653/http://www.soundonsound.com:80/sos/mar00/articles/synthsecrets.htm).
 *
 * @example
 * const synth = new Tone.AMSynth().toDestination();
 * synth.triggerAttackRelease("C4", "4n");
 *
 * @category Instrument
 */
class AMSynth extends _ModulationSynth.ModulationSynth {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(AMSynth.getDefaults(), arguments));
    this.name = "AMSynth";
    this._modulationScale = new _AudioToGain.AudioToGain({
      context: this.context
    }); // control the two voices frequency

    this.frequency.connect(this._carrier.frequency);
    this.frequency.chain(this.harmonicity, this._modulator.frequency);
    this.detune.fan(this._carrier.detune, this._modulator.detune);

    this._modulator.chain(this._modulationScale, this._modulationNode.gain);

    this._carrier.chain(this._modulationNode, this.output);
  }

  dispose() {
    super.dispose();

    this._modulationScale.dispose();

    return this;
  }

}

exports.AMSynth = AMSynth;
},{"../signal/AudioToGain":"../node_modules/tone/build/esm/signal/AudioToGain.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./ModulationSynth":"../node_modules/tone/build/esm/instrument/ModulationSynth.js"}],"../node_modules/tone/build/esm/component/filter/BiquadFilter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BiquadFilter = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Param = require("../../core/context/Param");

var _Debug = require("../../core/util/Debug");

/**
 * Thin wrapper around the native Web Audio [BiquadFilterNode](https://webaudio.github.io/web-audio-api/#biquadfilternode).
 * BiquadFilter is similar to [[Filter]] but doesn't have the option to set the "rolloff" value.
 * @category Component
 */
class BiquadFilter extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(BiquadFilter.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "BiquadFilter";
    const options = (0, _Defaults.optionsFromArguments)(BiquadFilter.getDefaults(), arguments, ["frequency", "type"]);
    this._filter = this.context.createBiquadFilter();
    this.input = this.output = this._filter;
    this.Q = new _Param.Param({
      context: this.context,
      units: "number",
      value: options.Q,
      param: this._filter.Q
    });
    this.frequency = new _Param.Param({
      context: this.context,
      units: "frequency",
      value: options.frequency,
      param: this._filter.frequency
    });
    this.detune = new _Param.Param({
      context: this.context,
      units: "cents",
      value: options.detune,
      param: this._filter.detune
    });
    this.gain = new _Param.Param({
      context: this.context,
      units: "decibels",
      convert: false,
      value: options.gain,
      param: this._filter.gain
    });
    this.type = options.type;
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      Q: 1,
      type: "lowpass",
      frequency: 350,
      detune: 0,
      gain: 0
    });
  }
  /**
   * The type of this BiquadFilterNode. For a complete list of types and their attributes, see the
   * [Web Audio API](https://webaudio.github.io/web-audio-api/#dom-biquadfiltertype-lowpass)
   */


  get type() {
    return this._filter.type;
  }

  set type(type) {
    const types = ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"];
    (0, _Debug.assert)(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);
    this._filter.type = type;
  }
  /**
   * Get the frequency response curve. This curve represents how the filter
   * responses to frequencies between 20hz-20khz.
   * @param  len The number of values to return
   * @return The frequency response curve between 20-20kHz
   */


  getFrequencyResponse(len = 128) {
    // start with all 1s
    const freqValues = new Float32Array(len);

    for (let i = 0; i < len; i++) {
      const norm = Math.pow(i / len, 2);
      const freq = norm * (20000 - 20) + 20;
      freqValues[i] = freq;
    }

    const magValues = new Float32Array(len);
    const phaseValues = new Float32Array(len); // clone the filter to remove any connections which may be changing the value

    const filterClone = this.context.createBiquadFilter();
    filterClone.type = this.type;
    filterClone.Q.value = this.Q.value;
    filterClone.frequency.value = this.frequency.value;
    filterClone.gain.value = this.gain.value;
    filterClone.getFrequencyResponse(freqValues, magValues, phaseValues);
    return magValues;
  }

  dispose() {
    super.dispose();

    this._filter.disconnect();

    this.Q.dispose();
    this.frequency.dispose();
    this.gain.dispose();
    this.detune.dispose();
    return this;
  }

}

exports.BiquadFilter = BiquadFilter;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/component/filter/Filter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Filter = void 0;

var _Gain = require("../../core/context/Gain");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _TypeCheck = require("../../core/util/TypeCheck");

var _Signal = require("../../signal/Signal");

var _Debug = require("../../core/util/Debug");

var _BiquadFilter = require("./BiquadFilter");

/**
 * Tone.Filter is a filter which allows for all of the same native methods
 * as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).
 * Tone.Filter has the added ability to set the filter rolloff at -12
 * (default), -24 and -48.
 * @example
 * const filter = new Tone.Filter(1500, "highpass").toDestination();
 * filter.frequency.rampTo(20000, 10);
 * const noise = new Tone.Noise().connect(filter).start();
 * @category Component
 */
class Filter extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Filter.getDefaults(), arguments, ["frequency", "type", "rolloff"]));
    this.name = "Filter";
    this.input = new _Gain.Gain({
      context: this.context
    });
    this.output = new _Gain.Gain({
      context: this.context
    });
    this._filters = [];
    const options = (0, _Defaults.optionsFromArguments)(Filter.getDefaults(), arguments, ["frequency", "type", "rolloff"]);
    this._filters = [];
    this.Q = new _Signal.Signal({
      context: this.context,
      units: "positive",
      value: options.Q
    });
    this.frequency = new _Signal.Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency
    });
    this.detune = new _Signal.Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    });
    this.gain = new _Signal.Signal({
      context: this.context,
      units: "decibels",
      convert: false,
      value: options.gain
    });
    this._type = options.type;
    this.rolloff = options.rolloff;
    (0, _Interface.readOnly)(this, ["detune", "frequency", "gain", "Q"]);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      Q: 1,
      detune: 0,
      frequency: 350,
      gain: 0,
      rolloff: -12,
      type: "lowpass"
    });
  }
  /**
   * The type of the filter. Types: "lowpass", "highpass",
   * "bandpass", "lowshelf", "highshelf", "notch", "allpass", or "peaking".
   */


  get type() {
    return this._type;
  }

  set type(type) {
    const types = ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "notch", "allpass", "peaking"];
    (0, _Debug.assert)(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);
    this._type = type;

    this._filters.forEach(filter => filter.type = type);
  }
  /**
   * The rolloff of the filter which is the drop in db
   * per octave. Implemented internally by cascading filters.
   * Only accepts the values -12, -24, -48 and -96.
   */


  get rolloff() {
    return this._rolloff;
  }

  set rolloff(rolloff) {
    const rolloffNum = (0, _TypeCheck.isNumber)(rolloff) ? rolloff : parseInt(rolloff, 10);
    const possibilities = [-12, -24, -48, -96];
    let cascadingCount = possibilities.indexOf(rolloffNum); // check the rolloff is valid

    (0, _Debug.assert)(cascadingCount !== -1, `rolloff can only be ${possibilities.join(", ")}`);
    cascadingCount += 1;
    this._rolloff = rolloffNum;
    this.input.disconnect();

    this._filters.forEach(filter => filter.disconnect());

    this._filters = new Array(cascadingCount);

    for (let count = 0; count < cascadingCount; count++) {
      const filter = new _BiquadFilter.BiquadFilter({
        context: this.context
      });
      filter.type = this._type;
      this.frequency.connect(filter.frequency);
      this.detune.connect(filter.detune);
      this.Q.connect(filter.Q);
      this.gain.connect(filter.gain);
      this._filters[count] = filter;
    }

    this._internalChannels = this._filters;
    (0, _ToneAudioNode.connectSeries)(this.input, ...this._internalChannels, this.output);
  }
  /**
   * Get the frequency response curve. This curve represents how the filter
   * responses to frequencies between 20hz-20khz.
   * @param  len The number of values to return
   * @return The frequency response curve between 20-20kHz
   */


  getFrequencyResponse(len = 128) {
    const filterClone = new _BiquadFilter.BiquadFilter({
      frequency: this.frequency.value,
      gain: this.gain.value,
      Q: this.Q.value,
      type: this._type,
      detune: this.detune.value
    }); // start with all 1s

    const totalResponse = new Float32Array(len).map(() => 1);

    this._filters.forEach(() => {
      const response = filterClone.getFrequencyResponse(len);
      response.forEach((val, i) => totalResponse[i] *= val);
    });

    filterClone.dispose();
    return totalResponse;
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();

    this._filters.forEach(filter => {
      filter.dispose();
    });

    (0, _Interface.writable)(this, ["detune", "frequency", "gain", "Q"]);
    this.frequency.dispose();
    this.Q.dispose();
    this.detune.dispose();
    this.gain.dispose();
    return this;
  }

}

exports.Filter = Filter;
},{"../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","../../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","./BiquadFilter":"../node_modules/tone/build/esm/component/filter/BiquadFilter.js"}],"../node_modules/tone/build/esm/component/envelope/FrequencyEnvelope.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FrequencyEnvelope = void 0;

var _Defaults = require("../../core/util/Defaults");

var _Envelope = require("./Envelope");

var _Scale = require("../../signal/Scale");

var _Pow = require("../../signal/Pow");

var _Debug = require("../../core/util/Debug");

/**
 * FrequencyEnvelope is an [[Envelope]] which ramps between [[baseFrequency]]
 * and [[octaves]]. It can also have an optional [[exponent]] to adjust the curve
 * which it ramps.
 * @example
 * const oscillator = new Tone.Oscillator().toDestination().start();
 * const freqEnv = new Tone.FrequencyEnvelope({
 * 	attack: 0.2,
 * 	baseFrequency: "C2",
 * 	octaves: 4
 * });
 * freqEnv.connect(oscillator.frequency);
 * freqEnv.triggerAttack();
 * @category Component
 */
class FrequencyEnvelope extends _Envelope.Envelope {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(FrequencyEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]));
    this.name = "FrequencyEnvelope";
    const options = (0, _Defaults.optionsFromArguments)(FrequencyEnvelope.getDefaults(), arguments, ["attack", "decay", "sustain", "release"]);
    this._octaves = options.octaves;
    this._baseFrequency = this.toFrequency(options.baseFrequency);
    this._exponent = this.input = new _Pow.Pow({
      context: this.context,
      value: options.exponent
    });
    this._scale = this.output = new _Scale.Scale({
      context: this.context,
      min: this._baseFrequency,
      max: this._baseFrequency * Math.pow(2, this._octaves)
    });

    this._sig.chain(this._exponent, this._scale);
  }

  static getDefaults() {
    return Object.assign(_Envelope.Envelope.getDefaults(), {
      baseFrequency: 200,
      exponent: 1,
      octaves: 4
    });
  }
  /**
   * The envelope's minimum output value. This is the value which it
   * starts at.
   */


  get baseFrequency() {
    return this._baseFrequency;
  }

  set baseFrequency(min) {
    const freq = this.toFrequency(min);
    (0, _Debug.assertRange)(freq, 0);
    this._baseFrequency = freq;
    this._scale.min = this._baseFrequency; // update the max value when the min changes

    this.octaves = this._octaves;
  }
  /**
   * The number of octaves above the baseFrequency that the
   * envelope will scale to.
   */


  get octaves() {
    return this._octaves;
  }

  set octaves(octaves) {
    this._octaves = octaves;
    this._scale.max = this._baseFrequency * Math.pow(2, octaves);
  }
  /**
   * The envelope's exponent value.
   */


  get exponent() {
    return this._exponent.value;
  }

  set exponent(exponent) {
    this._exponent.value = exponent;
  }
  /**
   * Clean up
   */


  dispose() {
    super.dispose();

    this._exponent.dispose();

    this._scale.dispose();

    return this;
  }

}

exports.FrequencyEnvelope = FrequencyEnvelope;
},{"../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Envelope":"../node_modules/tone/build/esm/component/envelope/Envelope.js","../../signal/Scale":"../node_modules/tone/build/esm/signal/Scale.js","../../signal/Pow":"../node_modules/tone/build/esm/signal/Pow.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/instrument/MonoSynth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MonoSynth = void 0;

var _AmplitudeEnvelope = require("../component/envelope/AmplitudeEnvelope");

var _Envelope = require("../component/envelope/Envelope");

var _Filter = require("../component/filter/Filter");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

var _Monophonic = require("../instrument/Monophonic");

var _OmniOscillator = require("../source/oscillator/OmniOscillator");

var _Source = require("../source/Source");

var _FrequencyEnvelope = require("../component/envelope/FrequencyEnvelope");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

/**
 * MonoSynth is composed of one `oscillator`, one `filter`, and two `envelopes`.
 * The amplitude of the Oscillator and the cutoff frequency of the
 * Filter are controlled by Envelopes.
 * <img src="https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240">
 * @example
 * const synth = new Tone.MonoSynth({
 * 	oscillator: {
 * 		type: "square"
 * 	},
 * 	envelope: {
 * 		attack: 0.1
 * 	}
 * }).toDestination();
 * synth.triggerAttackRelease("C4", "8n");
 * @category Instrument
 */
class MonoSynth extends _Monophonic.Monophonic {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(MonoSynth.getDefaults(), arguments));
    this.name = "MonoSynth";
    const options = (0, _Defaults.optionsFromArguments)(MonoSynth.getDefaults(), arguments);
    this.oscillator = new _OmniOscillator.OmniOscillator(Object.assign(options.oscillator, {
      context: this.context,
      detune: options.detune,
      onstop: () => this.onsilence(this)
    }));
    this.frequency = this.oscillator.frequency;
    this.detune = this.oscillator.detune;
    this.filter = new _Filter.Filter(Object.assign(options.filter, {
      context: this.context
    }));
    this.filterEnvelope = new _FrequencyEnvelope.FrequencyEnvelope(Object.assign(options.filterEnvelope, {
      context: this.context
    }));
    this.envelope = new _AmplitudeEnvelope.AmplitudeEnvelope(Object.assign(options.envelope, {
      context: this.context
    })); // connect the oscillators to the output

    this.oscillator.chain(this.filter, this.envelope, this.output); // connect the filter envelope

    this.filterEnvelope.connect(this.filter.frequency);
    (0, _Interface.readOnly)(this, ["oscillator", "frequency", "detune", "filter", "filterEnvelope", "envelope"]);
  }

  static getDefaults() {
    return Object.assign(_Monophonic.Monophonic.getDefaults(), {
      envelope: Object.assign((0, _Defaults.omitFromObject)(_Envelope.Envelope.getDefaults(), Object.keys(_ToneAudioNode.ToneAudioNode.getDefaults())), {
        attack: 0.005,
        decay: 0.1,
        release: 1,
        sustain: 0.9
      }),
      filter: Object.assign((0, _Defaults.omitFromObject)(_Filter.Filter.getDefaults(), Object.keys(_ToneAudioNode.ToneAudioNode.getDefaults())), {
        Q: 1,
        rolloff: -12,
        type: "lowpass"
      }),
      filterEnvelope: Object.assign((0, _Defaults.omitFromObject)(_FrequencyEnvelope.FrequencyEnvelope.getDefaults(), Object.keys(_ToneAudioNode.ToneAudioNode.getDefaults())), {
        attack: 0.6,
        baseFrequency: 200,
        decay: 0.2,
        exponent: 2,
        octaves: 3,
        release: 2,
        sustain: 0.5
      }),
      oscillator: Object.assign((0, _Defaults.omitFromObject)(_OmniOscillator.OmniOscillator.getDefaults(), Object.keys(_Source.Source.getDefaults())), {
        type: "sawtooth"
      })
    });
  }
  /**
   * start the attack portion of the envelope
   * @param time the time the attack should start
   * @param velocity the velocity of the note (0-1)
   */


  _triggerEnvelopeAttack(time, velocity = 1) {
    this.envelope.triggerAttack(time, velocity);
    this.filterEnvelope.triggerAttack(time);
    this.oscillator.start(time);

    if (this.envelope.sustain === 0) {
      const computedAttack = this.toSeconds(this.envelope.attack);
      const computedDecay = this.toSeconds(this.envelope.decay);
      this.oscillator.stop(time + computedAttack + computedDecay);
    }
  }
  /**
   * start the release portion of the envelope
   * @param time the time the release should start
   */


  _triggerEnvelopeRelease(time) {
    this.envelope.triggerRelease(time);
    this.filterEnvelope.triggerRelease(time);
    this.oscillator.stop(time + this.toSeconds(this.envelope.release));
  }

  getLevelAtTime(time) {
    time = this.toSeconds(time);
    return this.envelope.getValueAtTime(time);
  }

  dispose() {
    super.dispose();
    this.oscillator.dispose();
    this.envelope.dispose();
    this.filterEnvelope.dispose();
    this.filter.dispose();
    return this;
  }

}

exports.MonoSynth = MonoSynth;
},{"../component/envelope/AmplitudeEnvelope":"../node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js","../component/envelope/Envelope":"../node_modules/tone/build/esm/component/envelope/Envelope.js","../component/filter/Filter":"../node_modules/tone/build/esm/component/filter/Filter.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../instrument/Monophonic":"../node_modules/tone/build/esm/instrument/Monophonic.js","../source/oscillator/OmniOscillator":"../node_modules/tone/build/esm/source/oscillator/OmniOscillator.js","../source/Source":"../node_modules/tone/build/esm/source/Source.js","../component/envelope/FrequencyEnvelope":"../node_modules/tone/build/esm/component/envelope/FrequencyEnvelope.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js"}],"../node_modules/tone/build/esm/instrument/DuoSynth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DuoSynth = void 0;

var _Monophonic = require("./Monophonic");

var _MonoSynth = require("./MonoSynth");

var _Signal = require("../signal/Signal");

var _Interface = require("../core/util/Interface");

var _LFO = require("../source/oscillator/LFO");

var _Gain = require("../core/context/Gain");

var _Multiply = require("../signal/Multiply");

var _Defaults = require("../core/util/Defaults");

/**
 * DuoSynth is a monophonic synth composed of two [[MonoSynths]] run in parallel with control over the
 * frequency ratio between the two voices and vibrato effect.
 * @example
 * const duoSynth = new Tone.DuoSynth().toDestination();
 * duoSynth.triggerAttackRelease("C4", "2n");
 * @category Instrument
 */
class DuoSynth extends _Monophonic.Monophonic {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(DuoSynth.getDefaults(), arguments));
    this.name = "DuoSynth";
    const options = (0, _Defaults.optionsFromArguments)(DuoSynth.getDefaults(), arguments);
    this.voice0 = new _MonoSynth.MonoSynth(Object.assign(options.voice0, {
      context: this.context,
      onsilence: () => this.onsilence(this)
    }));
    this.voice1 = new _MonoSynth.MonoSynth(Object.assign(options.voice1, {
      context: this.context
    }));
    this.harmonicity = new _Multiply.Multiply({
      context: this.context,
      units: "positive",
      value: options.harmonicity
    });
    this._vibrato = new _LFO.LFO({
      frequency: options.vibratoRate,
      context: this.context,
      min: -50,
      max: 50
    }); // start the vibrato immediately

    this._vibrato.start();

    this.vibratoRate = this._vibrato.frequency;
    this._vibratoGain = new _Gain.Gain({
      context: this.context,
      units: "normalRange",
      gain: options.vibratoAmount
    });
    this.vibratoAmount = this._vibratoGain.gain;
    this.frequency = new _Signal.Signal({
      context: this.context,
      units: "frequency",
      value: 440
    });
    this.detune = new _Signal.Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    }); // control the two voices frequency

    this.frequency.connect(this.voice0.frequency);
    this.frequency.chain(this.harmonicity, this.voice1.frequency);

    this._vibrato.connect(this._vibratoGain);

    this._vibratoGain.fan(this.voice0.detune, this.voice1.detune);

    this.detune.fan(this.voice0.detune, this.voice1.detune);
    this.voice0.connect(this.output);
    this.voice1.connect(this.output);
    (0, _Interface.readOnly)(this, ["voice0", "voice1", "frequency", "vibratoAmount", "vibratoRate"]);
  }

  getLevelAtTime(time) {
    time = this.toSeconds(time);
    return this.voice0.envelope.getValueAtTime(time) + this.voice1.envelope.getValueAtTime(time);
  }

  static getDefaults() {
    return (0, _Defaults.deepMerge)(_Monophonic.Monophonic.getDefaults(), {
      vibratoAmount: 0.5,
      vibratoRate: 5,
      harmonicity: 1.5,
      voice0: (0, _Defaults.deepMerge)((0, _Defaults.omitFromObject)(_MonoSynth.MonoSynth.getDefaults(), Object.keys(_Monophonic.Monophonic.getDefaults())), {
        filterEnvelope: {
          attack: 0.01,
          decay: 0.0,
          sustain: 1,
          release: 0.5
        },
        envelope: {
          attack: 0.01,
          decay: 0.0,
          sustain: 1,
          release: 0.5
        }
      }),
      voice1: (0, _Defaults.deepMerge)((0, _Defaults.omitFromObject)(_MonoSynth.MonoSynth.getDefaults(), Object.keys(_Monophonic.Monophonic.getDefaults())), {
        filterEnvelope: {
          attack: 0.01,
          decay: 0.0,
          sustain: 1,
          release: 0.5
        },
        envelope: {
          attack: 0.01,
          decay: 0.0,
          sustain: 1,
          release: 0.5
        }
      })
    });
  }
  /**
   * Trigger the attack portion of the note
   */


  _triggerEnvelopeAttack(time, velocity) {
    // @ts-ignore
    this.voice0._triggerEnvelopeAttack(time, velocity); // @ts-ignore


    this.voice1._triggerEnvelopeAttack(time, velocity);
  }
  /**
   * Trigger the release portion of the note
   */


  _triggerEnvelopeRelease(time) {
    // @ts-ignore
    this.voice0._triggerEnvelopeRelease(time); // @ts-ignore


    this.voice1._triggerEnvelopeRelease(time);

    return this;
  }

  dispose() {
    super.dispose();
    this.voice0.dispose();
    this.voice1.dispose();
    this.frequency.dispose();
    this.detune.dispose();

    this._vibrato.dispose();

    this.vibratoRate.dispose();

    this._vibratoGain.dispose();

    this.harmonicity.dispose();
    return this;
  }

}

exports.DuoSynth = DuoSynth;
},{"./Monophonic":"../node_modules/tone/build/esm/instrument/Monophonic.js","./MonoSynth":"../node_modules/tone/build/esm/instrument/MonoSynth.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../source/oscillator/LFO":"../node_modules/tone/build/esm/source/oscillator/LFO.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../signal/Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js"}],"../node_modules/tone/build/esm/instrument/FMSynth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FMSynth = void 0;

var _Defaults = require("../core/util/Defaults");

var _Multiply = require("../signal/Multiply");

var _ModulationSynth = require("./ModulationSynth");

/**
 * FMSynth is composed of two Tone.Synths where one Tone.Synth modulates
 * the frequency of a second Tone.Synth. A lot of spectral content
 * can be explored using the modulationIndex parameter. Read more about
 * frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).
 *
 * @example
 * const fmSynth = new Tone.FMSynth().toDestination();
 * fmSynth.triggerAttackRelease("C5", "4n");
 *
 * @category Instrument
 */
class FMSynth extends _ModulationSynth.ModulationSynth {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(FMSynth.getDefaults(), arguments));
    this.name = "FMSynth";
    const options = (0, _Defaults.optionsFromArguments)(FMSynth.getDefaults(), arguments);
    this.modulationIndex = new _Multiply.Multiply({
      context: this.context,
      value: options.modulationIndex
    }); // control the two voices frequency

    this.frequency.connect(this._carrier.frequency);
    this.frequency.chain(this.harmonicity, this._modulator.frequency);
    this.frequency.chain(this.modulationIndex, this._modulationNode);
    this.detune.fan(this._carrier.detune, this._modulator.detune);

    this._modulator.connect(this._modulationNode.gain);

    this._modulationNode.connect(this._carrier.frequency);

    this._carrier.connect(this.output);
  }

  static getDefaults() {
    return Object.assign(_ModulationSynth.ModulationSynth.getDefaults(), {
      modulationIndex: 10
    });
  }

  dispose() {
    super.dispose();
    this.modulationIndex.dispose();
    return this;
  }

}

exports.FMSynth = FMSynth;
},{"../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../signal/Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","./ModulationSynth":"../node_modules/tone/build/esm/instrument/ModulationSynth.js"}],"../node_modules/tone/build/esm/instrument/MetalSynth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MetalSynth = void 0;

var _Envelope = require("../component/envelope/Envelope");

var _Filter = require("../component/filter/Filter");

var _Gain = require("../core/context/Gain");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

var _Multiply = require("../signal/Multiply");

var _Scale = require("../signal/Scale");

var _Signal = require("../signal/Signal");

var _FMOscillator = require("../source/oscillator/FMOscillator");

var _Monophonic = require("./Monophonic");

/**
 * Inharmonic ratio of frequencies based on the Roland TR-808
 * Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model
 */
const inharmRatios = [1.0, 1.483, 1.932, 2.546, 2.630, 3.897];
/**
 * A highly inharmonic and spectrally complex source with a highpass filter
 * and amplitude envelope which is good for making metallophone sounds.
 * Based on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).
 * Inspiration from [Sound on Sound](https://shorturl.at/rSZ12).
 * @category Instrument
 */

class MetalSynth extends _Monophonic.Monophonic {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(MetalSynth.getDefaults(), arguments));
    this.name = "MetalSynth";
    /**
     * The array of FMOscillators
     */

    this._oscillators = [];
    /**
     * The frequency multipliers
     */

    this._freqMultipliers = [];
    const options = (0, _Defaults.optionsFromArguments)(MetalSynth.getDefaults(), arguments);
    this.detune = new _Signal.Signal({
      context: this.context,
      units: "cents",
      value: options.detune
    });
    this.frequency = new _Signal.Signal({
      context: this.context,
      units: "frequency"
    });
    this._amplitude = new _Gain.Gain({
      context: this.context,
      gain: 0
    }).connect(this.output);
    this._highpass = new _Filter.Filter({
      // Q: -3.0102999566398125,
      Q: 0,
      context: this.context,
      type: "highpass"
    }).connect(this._amplitude);

    for (let i = 0; i < inharmRatios.length; i++) {
      const osc = new _FMOscillator.FMOscillator({
        context: this.context,
        harmonicity: options.harmonicity,
        modulationIndex: options.modulationIndex,
        modulationType: "square",
        onstop: i === 0 ? () => this.onsilence(this) : _Interface.noOp,
        type: "square"
      });
      osc.connect(this._highpass);
      this._oscillators[i] = osc;
      const mult = new _Multiply.Multiply({
        context: this.context,
        value: inharmRatios[i]
      });
      this._freqMultipliers[i] = mult;
      this.frequency.chain(mult, osc.frequency);
      this.detune.connect(osc.detune);
    }

    this._filterFreqScaler = new _Scale.Scale({
      context: this.context,
      max: 7000,
      min: this.toFrequency(options.resonance)
    });
    this.envelope = new _Envelope.Envelope({
      attack: options.envelope.attack,
      attackCurve: "linear",
      context: this.context,
      decay: options.envelope.decay,
      release: options.envelope.release,
      sustain: 0
    });
    this.envelope.chain(this._filterFreqScaler, this._highpass.frequency);
    this.envelope.connect(this._amplitude.gain); // set the octaves

    this._octaves = options.octaves;
    this.octaves = options.octaves;
  }

  static getDefaults() {
    return (0, _Defaults.deepMerge)(_Monophonic.Monophonic.getDefaults(), {
      envelope: Object.assign((0, _Defaults.omitFromObject)(_Envelope.Envelope.getDefaults(), Object.keys(_ToneAudioNode.ToneAudioNode.getDefaults())), {
        attack: 0.001,
        decay: 1.4,
        release: 0.2
      }),
      harmonicity: 5.1,
      modulationIndex: 32,
      octaves: 1.5,
      resonance: 4000
    });
  }
  /**
   * Trigger the attack.
   * @param time When the attack should be triggered.
   * @param velocity The velocity that the envelope should be triggered at.
   */


  _triggerEnvelopeAttack(time, velocity = 1) {
    this.envelope.triggerAttack(time, velocity);

    this._oscillators.forEach(osc => osc.start(time));

    if (this.envelope.sustain === 0) {
      this._oscillators.forEach(osc => {
        osc.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));
      });
    }

    return this;
  }
  /**
   * Trigger the release of the envelope.
   * @param time When the release should be triggered.
   */


  _triggerEnvelopeRelease(time) {
    this.envelope.triggerRelease(time);

    this._oscillators.forEach(osc => osc.stop(time + this.toSeconds(this.envelope.release)));

    return this;
  }

  getLevelAtTime(time) {
    time = this.toSeconds(time);
    return this.envelope.getValueAtTime(time);
  }
  /**
   * The modulationIndex of the oscillators which make up the source.
   * see [[FMOscillator.modulationIndex]]
   * @min 1
   * @max 100
   */


  get modulationIndex() {
    return this._oscillators[0].modulationIndex.value;
  }

  set modulationIndex(val) {
    this._oscillators.forEach(osc => osc.modulationIndex.value = val);
  }
  /**
   * The harmonicity of the oscillators which make up the source.
   * see Tone.FMOscillator.harmonicity
   * @min 0.1
   * @max 10
   */


  get harmonicity() {
    return this._oscillators[0].harmonicity.value;
  }

  set harmonicity(val) {
    this._oscillators.forEach(osc => osc.harmonicity.value = val);
  }
  /**
   * The lower level of the highpass filter which is attached to the envelope.
   * This value should be between [0, 7000]
   * @min 0
   * @max 7000
   */


  get resonance() {
    return this._filterFreqScaler.min;
  }

  set resonance(val) {
    this._filterFreqScaler.min = this.toFrequency(val);
    this.octaves = this._octaves;
  }
  /**
   * The number of octaves above the "resonance" frequency
   * that the filter ramps during the attack/decay envelope
   * @min 0
   * @max 8
   */


  get octaves() {
    return this._octaves;
  }

  set octaves(val) {
    this._octaves = val;
    this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, val);
  }

  dispose() {
    super.dispose();

    this._oscillators.forEach(osc => osc.dispose());

    this._freqMultipliers.forEach(freqMult => freqMult.dispose());

    this.frequency.dispose();
    this.detune.dispose();

    this._filterFreqScaler.dispose();

    this._amplitude.dispose();

    this.envelope.dispose();

    this._highpass.dispose();

    return this;
  }

}

exports.MetalSynth = MetalSynth;
},{"../component/envelope/Envelope":"../node_modules/tone/build/esm/component/envelope/Envelope.js","../component/filter/Filter":"../node_modules/tone/build/esm/component/filter/Filter.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../signal/Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","../signal/Scale":"../node_modules/tone/build/esm/signal/Scale.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../source/oscillator/FMOscillator":"../node_modules/tone/build/esm/source/oscillator/FMOscillator.js","./Monophonic":"../node_modules/tone/build/esm/instrument/Monophonic.js"}],"../node_modules/tone/build/esm/instrument/MembraneSynth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MembraneSynth = void 0;

var _tslib = require("tslib");

var _Frequency = require("../core/type/Frequency");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

var _Monophonic = require("./Monophonic");

var _Synth = require("./Synth");

var _Decorator = require("../core/util/Decorator");

/**
 * MembraneSynth makes kick and tom sounds using a single oscillator
 * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator
 * is routed through a Tone.AmplitudeEnvelope to the output. The drum
 * quality of the sound comes from the frequency envelope applied
 * during MembraneSynth.triggerAttack(note). The frequency envelope
 * starts at <code>note * .octaves</code> and ramps to <code>note</code>
 * over the duration of <code>.pitchDecay</code>.
 * @example
 * const synth = new Tone.MembraneSynth().toDestination();
 * synth.triggerAttackRelease("C2", "8n");
 * @category Instrument
 */
class MembraneSynth extends _Synth.Synth {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(MembraneSynth.getDefaults(), arguments));
    this.name = "MembraneSynth";
    /**
     * Portamento is ignored in this synth. use pitch decay instead.
     */

    this.portamento = 0;
    const options = (0, _Defaults.optionsFromArguments)(MembraneSynth.getDefaults(), arguments);
    this.pitchDecay = options.pitchDecay;
    this.octaves = options.octaves;
    (0, _Interface.readOnly)(this, ["oscillator", "envelope"]);
  }

  static getDefaults() {
    return (0, _Defaults.deepMerge)(_Monophonic.Monophonic.getDefaults(), _Synth.Synth.getDefaults(), {
      envelope: {
        attack: 0.001,
        attackCurve: "exponential",
        decay: 0.4,
        release: 1.4,
        sustain: 0.01
      },
      octaves: 10,
      oscillator: {
        type: "sine"
      },
      pitchDecay: 0.05
    });
  }

  setNote(note, time) {
    const seconds = this.toSeconds(time);
    const hertz = this.toFrequency(note instanceof _Frequency.FrequencyClass ? note.toFrequency() : note);
    const maxNote = hertz * this.octaves;
    this.oscillator.frequency.setValueAtTime(maxNote, seconds);
    this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));
    return this;
  }

  dispose() {
    super.dispose();
    return this;
  }

}

exports.MembraneSynth = MembraneSynth;
(0, _tslib.__decorate)([(0, _Decorator.range)(0)], MembraneSynth.prototype, "octaves", void 0);
(0, _tslib.__decorate)([(0, _Decorator.timeRange)(0)], MembraneSynth.prototype, "pitchDecay", void 0);
},{"tslib":"../node_modules/tslib/tslib.es6.js","../core/type/Frequency":"../node_modules/tone/build/esm/core/type/Frequency.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","./Monophonic":"../node_modules/tone/build/esm/instrument/Monophonic.js","./Synth":"../node_modules/tone/build/esm/instrument/Synth.js","../core/util/Decorator":"../node_modules/tone/build/esm/core/util/Decorator.js"}],"../node_modules/tone/build/esm/instrument/NoiseSynth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NoiseSynth = void 0;

var _AmplitudeEnvelope = require("../component/envelope/AmplitudeEnvelope");

var _Defaults = require("../core/util/Defaults");

var _Noise = require("../source/Noise");

var _Instrument = require("./Instrument");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Envelope = require("../component/envelope/Envelope");

var _Source = require("../source/Source");

/**
 * Tone.NoiseSynth is composed of [[Noise]] through an [[AmplitudeEnvelope]].
 * ```
 * +-------+   +-------------------+
 * | Noise +>--> AmplitudeEnvelope +>--> Output
 * +-------+   +-------------------+
 * ```
 * @example
 * const noiseSynth = new Tone.NoiseSynth().toDestination();
 * noiseSynth.triggerAttackRelease("8n", 0.05);
 * @category Instrument
 */
class NoiseSynth extends _Instrument.Instrument {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(NoiseSynth.getDefaults(), arguments));
    this.name = "NoiseSynth";
    const options = (0, _Defaults.optionsFromArguments)(NoiseSynth.getDefaults(), arguments);
    this.noise = new _Noise.Noise(Object.assign({
      context: this.context
    }, options.noise));
    this.envelope = new _AmplitudeEnvelope.AmplitudeEnvelope(Object.assign({
      context: this.context
    }, options.envelope)); // connect the noise to the output

    this.noise.chain(this.envelope, this.output);
  }

  static getDefaults() {
    return Object.assign(_Instrument.Instrument.getDefaults(), {
      envelope: Object.assign((0, _Defaults.omitFromObject)(_Envelope.Envelope.getDefaults(), Object.keys(_ToneAudioNode.ToneAudioNode.getDefaults())), {
        decay: 0.1,
        sustain: 0.0
      }),
      noise: Object.assign((0, _Defaults.omitFromObject)(_Noise.Noise.getDefaults(), Object.keys(_Source.Source.getDefaults())), {
        type: "white"
      })
    });
  }
  /**
   * Start the attack portion of the envelopes. Unlike other
   * instruments, Tone.NoiseSynth doesn't have a note.
   * @example
   * const noiseSynth = new Tone.NoiseSynth().toDestination();
   * noiseSynth.triggerAttack();
   */


  triggerAttack(time, velocity = 1) {
    time = this.toSeconds(time); // the envelopes

    this.envelope.triggerAttack(time, velocity); // start the noise

    this.noise.start(time);

    if (this.envelope.sustain === 0) {
      this.noise.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));
    }

    return this;
  }
  /**
   * Start the release portion of the envelopes.
   */


  triggerRelease(time) {
    time = this.toSeconds(time);
    this.envelope.triggerRelease(time);
    this.noise.stop(time + this.toSeconds(this.envelope.release));
    return this;
  }

  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 0);

      this._syncMethod("triggerRelease", 0);
    }

    return this;
  }

  triggerAttackRelease(duration, time, velocity = 1) {
    time = this.toSeconds(time);
    duration = this.toSeconds(duration);
    this.triggerAttack(time, velocity);
    this.triggerRelease(time + duration);
    return this;
  }

  dispose() {
    super.dispose();
    this.noise.dispose();
    this.envelope.dispose();
    return this;
  }

}

exports.NoiseSynth = NoiseSynth;
},{"../component/envelope/AmplitudeEnvelope":"../node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../source/Noise":"../node_modules/tone/build/esm/source/Noise.js","./Instrument":"../node_modules/tone/build/esm/instrument/Instrument.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../component/envelope/Envelope":"../node_modules/tone/build/esm/component/envelope/Envelope.js","../source/Source":"../node_modules/tone/build/esm/source/Source.js"}],"../node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addToWorklet = addToWorklet;
exports.getWorkletGlobalScope = getWorkletGlobalScope;
exports.registerProcessor = registerProcessor;

/**
 * All of the classes or functions which are loaded into the AudioWorkletGlobalScope
 */
const workletContext = new Set();
/**
 * Add a class to the AudioWorkletGlobalScope
 */

function addToWorklet(classOrFunction) {
  workletContext.add(classOrFunction);
}
/**
 * Register a processor in the AudioWorkletGlobalScope with the given name
 */


function registerProcessor(name, classDesc) {
  const processor =
  /* javascript */
  `registerProcessor("${name}", ${classDesc})`;
  workletContext.add(processor);
}
/**
 * Get all of the modules which have been registered to the AudioWorkletGlobalScope
 */


function getWorkletGlobalScope() {
  return Array.from(workletContext).join("\n");
}
},{}],"../node_modules/tone/build/esm/core/worklet/ToneAudioWorklet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToneAudioWorklet = void 0;

var _ToneAudioNode = require("../context/ToneAudioNode");

var _Interface = require("../util/Interface");

var _WorkletGlobalScope = require("./WorkletGlobalScope");

class ToneAudioWorklet extends _ToneAudioNode.ToneAudioNode {
  constructor(options) {
    super(options);
    this.name = "ToneAudioWorklet";
    /**
     * The constructor options for the node
     */

    this.workletOptions = {};
    /**
     * Callback which is invoked when there is an error in the processing
     */

    this.onprocessorerror = _Interface.noOp;
    const blobUrl = URL.createObjectURL(new Blob([(0, _WorkletGlobalScope.getWorkletGlobalScope)()], {
      type: "text/javascript"
    }));

    const name = this._audioWorkletName();

    this._dummyGain = this.context.createGain();
    this._dummyParam = this._dummyGain.gain; // Register the processor

    this.context.addAudioWorkletModule(blobUrl, name).then(() => {
      // create the worklet when it's read
      if (!this.disposed) {
        this._worklet = this.context.createAudioWorkletNode(name, this.workletOptions);
        this._worklet.onprocessorerror = this.onprocessorerror.bind(this);
        this.onReady(this._worklet);
      }
    });
  }

  dispose() {
    super.dispose();

    this._dummyGain.disconnect();

    if (this._worklet) {
      this._worklet.port.postMessage("dispose");

      this._worklet.disconnect();
    }

    return this;
  }

}

exports.ToneAudioWorklet = ToneAudioWorklet;
},{"../context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","./WorkletGlobalScope":"../node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js"}],"../node_modules/tone/build/esm/core/worklet/ToneAudioWorkletProcessor.worklet.js":[function(require,module,exports) {
"use strict";

var _WorkletGlobalScope = require("./WorkletGlobalScope");

const toneAudioWorkletProcessor =
/* javascript */
`
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;
(0, _WorkletGlobalScope.addToWorklet)(toneAudioWorkletProcessor);
},{"./WorkletGlobalScope":"../node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js"}],"../node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.singleIOProcess = void 0;

require("./ToneAudioWorkletProcessor.worklet");

var _WorkletGlobalScope = require("./WorkletGlobalScope");

const singleIOProcess =
/* javascript */
`
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;
exports.singleIOProcess = singleIOProcess;
(0, _WorkletGlobalScope.addToWorklet)(singleIOProcess);
},{"./ToneAudioWorkletProcessor.worklet":"../node_modules/tone/build/esm/core/worklet/ToneAudioWorkletProcessor.worklet.js","./WorkletGlobalScope":"../node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js"}],"../node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js":[function(require,module,exports) {
"use strict";

var _WorkletGlobalScope = require("./WorkletGlobalScope");

const delayLine =
/* javascript */
`
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;
(0, _WorkletGlobalScope.addToWorklet)(delayLine);
},{"./WorkletGlobalScope":"../node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js"}],"../node_modules/tone/build/esm/component/filter/FeedbackCombFilter.worklet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.workletName = void 0;

require("../../core/worklet/SingleIOProcessor.worklet");

require("../../core/worklet/DelayLine.worklet");

var _WorkletGlobalScope = require("../../core/worklet/WorkletGlobalScope");

const workletName = "feedback-comb-filter";
exports.workletName = workletName;
const feedbackCombFilter =
/* javascript */
`
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`;
(0, _WorkletGlobalScope.registerProcessor)(workletName, feedbackCombFilter);
},{"../../core/worklet/SingleIOProcessor.worklet":"../node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js","../../core/worklet/DelayLine.worklet":"../node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js","../../core/worklet/WorkletGlobalScope":"../node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js"}],"../node_modules/tone/build/esm/component/filter/FeedbackCombFilter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FeedbackCombFilter = void 0;

var _Gain = require("../../core/context/Gain");

var _Param = require("../../core/context/Param");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _ToneAudioWorklet = require("../../core/worklet/ToneAudioWorklet");

var _FeedbackCombFilter = require("./FeedbackCombFilter.worklet");

/**
 * Comb filters are basic building blocks for physical modeling. Read more
 * about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).
 *
 * This comb filter is implemented with the AudioWorkletNode which allows it to have feedback delays less than the
 * Web Audio processing block of 128 samples. There is a polyfill for browsers that don't yet support the
 * AudioWorkletNode, but it will add some latency and have slower performance than the AudioWorkletNode.
 * @category Component
 */
class FeedbackCombFilter extends _ToneAudioWorklet.ToneAudioWorklet {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(FeedbackCombFilter.getDefaults(), arguments, ["delayTime", "resonance"]));
    this.name = "FeedbackCombFilter";
    const options = (0, _Defaults.optionsFromArguments)(FeedbackCombFilter.getDefaults(), arguments, ["delayTime", "resonance"]);
    this.input = new _Gain.Gain({
      context: this.context
    });
    this.output = new _Gain.Gain({
      context: this.context
    });
    this.delayTime = new _Param.Param({
      context: this.context,
      value: options.delayTime,
      units: "time",
      minValue: 0,
      maxValue: 1,
      param: this._dummyParam,
      swappable: true
    });
    this.resonance = new _Param.Param({
      context: this.context,
      value: options.resonance,
      units: "normalRange",
      param: this._dummyParam,
      swappable: true
    });
    (0, _Interface.readOnly)(this, ["resonance", "delayTime"]);
  }

  _audioWorkletName() {
    return _FeedbackCombFilter.workletName;
  }
  /**
   * The default parameters
   */


  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      delayTime: 0.1,
      resonance: 0.5
    });
  }

  onReady(node) {
    (0, _ToneAudioNode.connectSeries)(this.input, node, this.output);
    const delayTime = node.parameters.get("delayTime");
    ;
    this.delayTime.setParam(delayTime);
    const feedback = node.parameters.get("feedback");
    ;
    this.resonance.setParam(feedback);
  }

  dispose() {
    super.dispose();
    this.input.dispose();
    this.output.dispose();
    this.delayTime.dispose();
    this.resonance.dispose();
    return this;
  }

}

exports.FeedbackCombFilter = FeedbackCombFilter;
},{"../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../core/worklet/ToneAudioWorklet":"../node_modules/tone/build/esm/core/worklet/ToneAudioWorklet.js","./FeedbackCombFilter.worklet":"../node_modules/tone/build/esm/component/filter/FeedbackCombFilter.worklet.js"}],"../node_modules/tone/build/esm/component/filter/OnePoleFilter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OnePoleFilter = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Gain = require("../../core/context/Gain");

/**
 * A one pole filter with 6db-per-octave rolloff. Either "highpass" or "lowpass".
 * Note that changing the type or frequency may result in a discontinuity which
 * can sound like a click or pop.
 * References:
 * * http://www.earlevel.com/main/2012/12/15/a-one-pole-filter/
 * * http://www.dspguide.com/ch19/2.htm
 * * https://github.com/vitaliy-bobrov/js-rocks/blob/master/src/app/audio/effects/one-pole-filters.ts
 * @category Component
 */
class OnePoleFilter extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(OnePoleFilter.getDefaults(), arguments, ["frequency", "type"]));
    this.name = "OnePoleFilter";
    const options = (0, _Defaults.optionsFromArguments)(OnePoleFilter.getDefaults(), arguments, ["frequency", "type"]);
    this._frequency = options.frequency;
    this._type = options.type;
    this.input = new _Gain.Gain({
      context: this.context
    });
    this.output = new _Gain.Gain({
      context: this.context
    });

    this._createFilter();
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      frequency: 880,
      type: "lowpass"
    });
  }
  /**
   * Create a filter and dispose the old one
   */


  _createFilter() {
    const oldFilter = this._filter;
    const freq = this.toFrequency(this._frequency);
    const t = 1 / (2 * Math.PI * freq);

    if (this._type === "lowpass") {
      const a0 = 1 / (t * this.context.sampleRate);
      const b1 = a0 - 1;
      this._filter = this.context.createIIRFilter([a0, 0], [1, b1]);
    } else {
      const b1 = 1 / (t * this.context.sampleRate) - 1;
      this._filter = this.context.createIIRFilter([1, -1], [1, b1]);
    }

    this.input.chain(this._filter, this.output);

    if (oldFilter) {
      // dispose it on the next block
      this.context.setTimeout(() => {
        if (!this.disposed) {
          this.input.disconnect(oldFilter);
          oldFilter.disconnect();
        }
      }, this.blockTime);
    }
  }
  /**
   * The frequency value.
   */


  get frequency() {
    return this._frequency;
  }

  set frequency(fq) {
    this._frequency = fq;

    this._createFilter();
  }
  /**
   * The OnePole Filter type, either "highpass" or "lowpass"
   */


  get type() {
    return this._type;
  }

  set type(t) {
    this._type = t;

    this._createFilter();
  }
  /**
   * Get the frequency response curve. This curve represents how the filter
   * responses to frequencies between 20hz-20khz.
   * @param  len The number of values to return
   * @return The frequency response curve between 20-20kHz
   */


  getFrequencyResponse(len = 128) {
    const freqValues = new Float32Array(len);

    for (let i = 0; i < len; i++) {
      const norm = Math.pow(i / len, 2);
      const freq = norm * (20000 - 20) + 20;
      freqValues[i] = freq;
    }

    const magValues = new Float32Array(len);
    const phaseValues = new Float32Array(len);

    this._filter.getFrequencyResponse(freqValues, magValues, phaseValues);

    return magValues;
  }

  dispose() {
    super.dispose();
    this.input.dispose();
    this.output.dispose();

    this._filter.disconnect();

    return this;
  }

}

exports.OnePoleFilter = OnePoleFilter;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js"}],"../node_modules/tone/build/esm/component/filter/LowpassCombFilter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LowpassCombFilter = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _FeedbackCombFilter = require("./FeedbackCombFilter");

var _OnePoleFilter = require("./OnePoleFilter");

/**
 * A lowpass feedback comb filter. It is similar to
 * [[FeedbackCombFilter]], but includes a lowpass filter.
 * @category Component
 */
class LowpassCombFilter extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(LowpassCombFilter.getDefaults(), arguments, ["delayTime", "resonance", "dampening"]));
    this.name = "LowpassCombFilter";
    const options = (0, _Defaults.optionsFromArguments)(LowpassCombFilter.getDefaults(), arguments, ["delayTime", "resonance", "dampening"]);
    this._combFilter = this.output = new _FeedbackCombFilter.FeedbackCombFilter({
      context: this.context,
      delayTime: options.delayTime,
      resonance: options.resonance
    });
    this.delayTime = this._combFilter.delayTime;
    this.resonance = this._combFilter.resonance;
    this._lowpass = this.input = new _OnePoleFilter.OnePoleFilter({
      context: this.context,
      frequency: options.dampening,
      type: "lowpass"
    }); // connections

    this._lowpass.connect(this._combFilter);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      dampening: 3000,
      delayTime: 0.1,
      resonance: 0.5
    });
  }
  /**
   * The dampening control of the feedback
   */


  get dampening() {
    return this._lowpass.frequency;
  }

  set dampening(fq) {
    this._lowpass.frequency = fq;
  }

  dispose() {
    super.dispose();

    this._combFilter.dispose();

    this._lowpass.dispose();

    return this;
  }

}

exports.LowpassCombFilter = LowpassCombFilter;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./FeedbackCombFilter":"../node_modules/tone/build/esm/component/filter/FeedbackCombFilter.js","./OnePoleFilter":"../node_modules/tone/build/esm/component/filter/OnePoleFilter.js"}],"../node_modules/tone/build/esm/instrument/PluckSynth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PluckSynth = void 0;

var _LowpassCombFilter = require("../component/filter/LowpassCombFilter");

var _Defaults = require("../core/util/Defaults");

var _Noise = require("../source/Noise");

var _Instrument = require("./Instrument");

/**
 * Karplus-String string synthesis.
 * @example
 * const plucky = new Tone.PluckSynth().toDestination();
 * plucky.triggerAttack("C4", "+0.5");
 * plucky.triggerAttack("C3", "+1");
 * plucky.triggerAttack("C2", "+1.5");
 * plucky.triggerAttack("C1", "+2");
 * @category Instrument
 */
class PluckSynth extends _Instrument.Instrument {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(PluckSynth.getDefaults(), arguments));
    this.name = "PluckSynth";
    const options = (0, _Defaults.optionsFromArguments)(PluckSynth.getDefaults(), arguments);
    this._noise = new _Noise.Noise({
      context: this.context,
      type: "pink"
    });
    this.attackNoise = options.attackNoise;
    this._lfcf = new _LowpassCombFilter.LowpassCombFilter({
      context: this.context,
      dampening: options.dampening,
      resonance: options.resonance
    });
    this.resonance = options.resonance;
    this.release = options.release;

    this._noise.connect(this._lfcf);

    this._lfcf.connect(this.output);
  }

  static getDefaults() {
    return (0, _Defaults.deepMerge)(_Instrument.Instrument.getDefaults(), {
      attackNoise: 1,
      dampening: 4000,
      resonance: 0.7,
      release: 1
    });
  }
  /**
   * The dampening control. i.e. the lowpass filter frequency of the comb filter
   * @min 0
   * @max 7000
   */


  get dampening() {
    return this._lfcf.dampening;
  }

  set dampening(fq) {
    this._lfcf.dampening = fq;
  }

  triggerAttack(note, time) {
    const freq = this.toFrequency(note);
    time = this.toSeconds(time);
    const delayAmount = 1 / freq;

    this._lfcf.delayTime.setValueAtTime(delayAmount, time);

    this._noise.start(time);

    this._noise.stop(time + delayAmount * this.attackNoise);

    this._lfcf.resonance.cancelScheduledValues(time);

    this._lfcf.resonance.setValueAtTime(this.resonance, time);

    return this;
  }
  /**
   * Ramp down the [[resonance]] to 0 over the duration of the release time.
   */


  triggerRelease(time) {
    this._lfcf.resonance.linearRampTo(0, this.release, time);

    return this;
  }

  dispose() {
    super.dispose();

    this._noise.dispose();

    this._lfcf.dispose();

    return this;
  }

}

exports.PluckSynth = PluckSynth;
},{"../component/filter/LowpassCombFilter":"../node_modules/tone/build/esm/component/filter/LowpassCombFilter.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../source/Noise":"../node_modules/tone/build/esm/source/Noise.js","./Instrument":"../node_modules/tone/build/esm/instrument/Instrument.js"}],"../node_modules/tone/build/esm/instrument/PolySynth.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolySynth = void 0;

var _Midi = require("../core/type/Midi");

var _Defaults = require("../core/util/Defaults");

var _TypeCheck = require("../core/util/TypeCheck");

var _Instrument = require("./Instrument");

var _Synth = require("./Synth");

var _Debug = require("../core/util/Debug");

/**
 * PolySynth handles voice creation and allocation for any
 * instruments passed in as the second paramter. PolySynth is
 * not a synthesizer by itself, it merely manages voices of
 * one of the other types of synths, allowing any of the
 * monophonic synthesizers to be polyphonic.
 *
 * @example
 * const synth = new Tone.PolySynth().toDestination();
 * // set the attributes across all the voices using 'set'
 * synth.set({ detune: -1200 });
 * // play a chord
 * synth.triggerAttackRelease(["C4", "E4", "A4"], 1);
 * @category Instrument
 */
class PolySynth extends _Instrument.Instrument {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(PolySynth.getDefaults(), arguments, ["voice", "options"]));
    this.name = "PolySynth";
    /**
     * The voices which are not currently in use
     */

    this._availableVoices = [];
    /**
     * The currently active voices
     */

    this._activeVoices = [];
    /**
     * All of the allocated voices for this synth.
     */

    this._voices = [];
    /**
     * The GC timeout. Held so that it could be cancelled when the node is disposed.
     */

    this._gcTimeout = -1;
    /**
     * A moving average of the number of active voices
     */

    this._averageActiveVoices = 0;
    const options = (0, _Defaults.optionsFromArguments)(PolySynth.getDefaults(), arguments, ["voice", "options"]); // check against the old API (pre 14.3.0)

    (0, _Debug.assert)(!(0, _TypeCheck.isNumber)(options.voice), "DEPRECATED: The polyphony count is no longer the first argument.");
    const defaults = options.voice.getDefaults();
    this.options = Object.assign(defaults, options.options);
    this.voice = options.voice;
    this.maxPolyphony = options.maxPolyphony; // create the first voice

    this._dummyVoice = this._getNextAvailableVoice(); // remove it from the voices list

    const index = this._voices.indexOf(this._dummyVoice);

    this._voices.splice(index, 1); // kick off the GC interval


    this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);
  }

  static getDefaults() {
    return Object.assign(_Instrument.Instrument.getDefaults(), {
      maxPolyphony: 32,
      options: {},
      voice: _Synth.Synth
    });
  }
  /**
   * The number of active voices.
   */


  get activeVoices() {
    return this._activeVoices.length;
  }
  /**
   * Invoked when the source is done making sound, so that it can be
   * readded to the pool of available voices
   */


  _makeVoiceAvailable(voice) {
    this._availableVoices.push(voice); // remove the midi note from 'active voices'


    const activeVoiceIndex = this._activeVoices.findIndex(e => e.voice === voice);

    this._activeVoices.splice(activeVoiceIndex, 1);
  }
  /**
   * Get an available voice from the pool of available voices.
   * If one is not available and the maxPolyphony limit is reached,
   * steal a voice, otherwise return null.
   */


  _getNextAvailableVoice() {
    // if there are available voices, return the first one
    if (this._availableVoices.length) {
      return this._availableVoices.shift();
    } else if (this._voices.length < this.maxPolyphony) {
      // otherwise if there is still more maxPolyphony, make a new voice
      const voice = new this.voice(Object.assign(this.options, {
        context: this.context,
        onsilence: this._makeVoiceAvailable.bind(this)
      }));
      voice.connect(this.output);

      this._voices.push(voice);

      return voice;
    } else {
      (0, _Debug.warn)("Max polyphony exceeded. Note dropped.");
    }
  }
  /**
   * Occasionally check if there are any allocated voices which can be cleaned up.
   */


  _collectGarbage() {
    this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);

    if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {
      // take off an available note
      const firstAvail = this._availableVoices.shift();

      const index = this._voices.indexOf(firstAvail);

      this._voices.splice(index, 1);

      if (!this.context.isOffline) {
        firstAvail.dispose();
      }
    }
  }
  /**
   * Internal method which triggers the attack
   */


  _triggerAttack(notes, time, velocity) {
    notes.forEach(note => {
      const midiNote = new _Midi.MidiClass(this.context, note).toMidi();

      const voice = this._getNextAvailableVoice();

      if (voice) {
        voice.triggerAttack(note, time, velocity);

        this._activeVoices.push({
          midi: midiNote,
          voice,
          released: false
        });

        this.log("triggerAttack", note, time);
      }
    });
  }
  /**
   * Internal method which triggers the release
   */


  _triggerRelease(notes, time) {
    notes.forEach(note => {
      const midiNote = new _Midi.MidiClass(this.context, note).toMidi();

      const event = this._activeVoices.find(({
        midi,
        released
      }) => midi === midiNote && !released);

      if (event) {
        // trigger release on that note
        event.voice.triggerRelease(time); // mark it as released

        event.released = true;
        this.log("triggerRelease", note, time);
      }
    });
  }
  /**
   * Schedule the attack/release events. If the time is in the future, then it should set a timeout
   * to wait for just-in-time scheduling
   */


  _scheduleEvent(type, notes, time, velocity) {
    (0, _Debug.assert)(!this.disposed, "Synth was already disposed"); // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout

    if (time <= this.now()) {
      // do it immediately
      if (type === "attack") {
        this._triggerAttack(notes, time, velocity);
      } else {
        this._triggerRelease(notes, time);
      }
    } else {
      // schedule it to start in the future
      this.context.setTimeout(() => {
        this._scheduleEvent(type, notes, time, velocity);
      }, time - this.now());
    }
  }
  /**
   * Trigger the attack portion of the note
   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
   * @param  time  The start time of the note.
   * @param velocity The velocity of the note.
   * @example
   * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();
   * // trigger a chord immediately with a velocity of 0.2
   * synth.triggerAttack(["Ab3", "C4", "F5"], Tone.now(), 0.2);
   */


  triggerAttack(notes, time, velocity) {
    if (!Array.isArray(notes)) {
      notes = [notes];
    }

    const computedTime = this.toSeconds(time);

    this._scheduleEvent("attack", notes, computedTime, velocity);

    return this;
  }
  /**
   * Trigger the release of the note. Unlike monophonic instruments,
   * a note (or array of notes) needs to be passed in as the first argument.
   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
   * @param  time  When the release will be triggered.
   * @example
   * @example
   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();
   * poly.triggerAttack(["Ab3", "C4", "F5"]);
   * // trigger the release of the given notes.
   * poly.triggerRelease(["Ab3", "C4"], "+1");
   * poly.triggerRelease("F5", "+3");
   */


  triggerRelease(notes, time) {
    if (!Array.isArray(notes)) {
      notes = [notes];
    }

    const computedTime = this.toSeconds(time);

    this._scheduleEvent("release", notes, computedTime);

    return this;
  }
  /**
   * Trigger the attack and release after the specified duration
   * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.
   * @param  duration the duration of the note
   * @param  time  if no time is given, defaults to now
   * @param  velocity the velocity of the attack (0-1)
   * @example
   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();
   * // can pass in an array of durations as well
   * poly.triggerAttackRelease(["Eb3", "G4", "Bb4", "D5"], [4, 3, 2, 1]);
   */


  triggerAttackRelease(notes, duration, time, velocity) {
    const computedTime = this.toSeconds(time);
    this.triggerAttack(notes, computedTime, velocity);

    if ((0, _TypeCheck.isArray)(duration)) {
      (0, _Debug.assert)((0, _TypeCheck.isArray)(notes), "If the duration is an array, the notes must also be an array");
      notes = notes;

      for (let i = 0; i < notes.length; i++) {
        const d = duration[Math.min(i, duration.length - 1)];
        const durationSeconds = this.toSeconds(d);
        (0, _Debug.assert)(durationSeconds > 0, "The duration must be greater than 0");
        this.triggerRelease(notes[i], computedTime + durationSeconds);
      }
    } else {
      const durationSeconds = this.toSeconds(duration);
      (0, _Debug.assert)(durationSeconds > 0, "The duration must be greater than 0");
      this.triggerRelease(notes, computedTime + durationSeconds);
    }

    return this;
  }

  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);

      this._syncMethod("triggerRelease", 1);
    }

    return this;
  }
  /**
   * Set a member/attribute of the voices
   * @example
   * const poly = new Tone.PolySynth().toDestination();
   * // set all of the voices using an options object for the synth type
   * poly.set({
   * 	envelope: {
   * 		attack: 0.25
   * 	}
   * });
   * poly.triggerAttackRelease("Bb3", 0.2);
   */


  set(options) {
    // remove options which are controlled by the PolySynth
    const sanitizedOptions = (0, _Defaults.omitFromObject)(options, ["onsilence", "context"]); // store all of the options

    this.options = (0, _Defaults.deepMerge)(this.options, sanitizedOptions);

    this._voices.forEach(voice => voice.set(sanitizedOptions));

    this._dummyVoice.set(sanitizedOptions);

    return this;
  }

  get() {
    return this._dummyVoice.get();
  }
  /**
   * Trigger the release portion of all the currently active voices immediately.
   * Useful for silencing the synth.
   */


  releaseAll(time) {
    const computedTime = this.toSeconds(time);

    this._activeVoices.forEach(({
      voice
    }) => {
      voice.triggerRelease(computedTime);
    });

    return this;
  }

  dispose() {
    super.dispose();

    this._dummyVoice.dispose();

    this._voices.forEach(v => v.dispose());

    this._activeVoices = [];
    this._availableVoices = [];
    this.context.clearInterval(this._gcTimeout);
    return this;
  }

}

exports.PolySynth = PolySynth;
},{"../core/type/Midi":"../node_modules/tone/build/esm/core/type/Midi.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","./Instrument":"../node_modules/tone/build/esm/instrument/Instrument.js","./Synth":"../node_modules/tone/build/esm/instrument/Synth.js","../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/instrument/Sampler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sampler = void 0;

var _tslib = require("tslib");

var _ToneAudioBuffers = require("../core/context/ToneAudioBuffers");

var _Conversions = require("../core/type/Conversions");

var _Frequency = require("../core/type/Frequency");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

var _TypeCheck = require("../core/util/TypeCheck");

var _Instrument = require("../instrument/Instrument");

var _ToneBufferSource = require("../source/buffer/ToneBufferSource");

var _Decorator = require("../core/util/Decorator");

var _Debug = require("../core/util/Debug");

/**
 * Pass in an object which maps the note's pitch or midi value to the url,
 * then you can trigger the attack and release of that note like other instruments.
 * By automatically repitching the samples, it is possible to play pitches which
 * were not explicitly included which can save loading time.
 *
 * For sample or buffer playback where repitching is not necessary,
 * use [[Player]].
 * @example
 * const sampler = new Tone.Sampler({
 * 	urls: {
 * 		A1: "A1.mp3",
 * 		A2: "A2.mp3",
 * 	},
 * 	baseUrl: "https://tonejs.github.io/audio/casio/",
 * 	onload: () => {
 * 		sampler.triggerAttackRelease(["C1", "E1", "G1", "B1"], 0.5);
 * 	}
 * }).toDestination();
 * @category Instrument
 */
class Sampler extends _Instrument.Instrument {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Sampler.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls"));
    this.name = "Sampler";
    /**
     * The object of all currently playing BufferSources
     */

    this._activeSources = new Map();
    const options = (0, _Defaults.optionsFromArguments)(Sampler.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
    const urlMap = {};
    Object.keys(options.urls).forEach(note => {
      const noteNumber = parseInt(note, 10);
      (0, _Debug.assert)((0, _TypeCheck.isNote)(note) || (0, _TypeCheck.isNumber)(noteNumber) && isFinite(noteNumber), `url key is neither a note or midi pitch: ${note}`);

      if ((0, _TypeCheck.isNote)(note)) {
        // convert the note name to MIDI
        const mid = new _Frequency.FrequencyClass(this.context, note).toMidi();
        urlMap[mid] = options.urls[note];
      } else if ((0, _TypeCheck.isNumber)(noteNumber) && isFinite(noteNumber)) {
        // otherwise if it's numbers assume it's midi
        urlMap[noteNumber] = options.urls[noteNumber];
      }
    });
    this._buffers = new _ToneAudioBuffers.ToneAudioBuffers({
      urls: urlMap,
      onload: options.onload,
      baseUrl: options.baseUrl,
      onerror: options.onerror
    });
    this.attack = options.attack;
    this.release = options.release;
    this.curve = options.curve; // invoke the callback if it's already loaded

    if (this._buffers.loaded) {
      // invoke onload deferred
      Promise.resolve().then(options.onload);
    }
  }

  static getDefaults() {
    return Object.assign(_Instrument.Instrument.getDefaults(), {
      attack: 0,
      baseUrl: "",
      curve: "exponential",
      onload: _Interface.noOp,
      onerror: _Interface.noOp,
      release: 0.1,
      urls: {}
    });
  }
  /**
   * Returns the difference in steps between the given midi note at the closets sample.
   */


  _findClosest(midi) {
    // searches within 8 octaves of the given midi note
    const MAX_INTERVAL = 96;
    let interval = 0;

    while (interval < MAX_INTERVAL) {
      // check above and below
      if (this._buffers.has(midi + interval)) {
        return -interval;
      } else if (this._buffers.has(midi - interval)) {
        return interval;
      }

      interval++;
    }

    throw new Error(`No available buffers for note: ${midi}`);
  }
  /**
   * @param  notes	The note to play, or an array of notes.
   * @param  time     When to play the note
   * @param  velocity The velocity to play the sample back.
   */


  triggerAttack(notes, time, velocity = 1) {
    this.log("triggerAttack", notes, time, velocity);

    if (!Array.isArray(notes)) {
      notes = [notes];
    }

    notes.forEach(note => {
      const midiFloat = (0, _Conversions.ftomf)(new _Frequency.FrequencyClass(this.context, note).toFrequency());
      const midi = Math.round(midiFloat);
      const remainder = midiFloat - midi; // find the closest note pitch

      const difference = this._findClosest(midi);

      const closestNote = midi - difference;

      const buffer = this._buffers.get(closestNote);

      const playbackRate = (0, _Conversions.intervalToFrequencyRatio)(difference + remainder); // play that note

      const source = new _ToneBufferSource.ToneBufferSource({
        url: buffer,
        context: this.context,
        curve: this.curve,
        fadeIn: this.attack,
        fadeOut: this.release,
        playbackRate
      }).connect(this.output);
      source.start(time, 0, buffer.duration / playbackRate, velocity); // add it to the active sources

      if (!(0, _TypeCheck.isArray)(this._activeSources.get(midi))) {
        this._activeSources.set(midi, []);
      }

      this._activeSources.get(midi).push(source); // remove it when it's done


      source.onended = () => {
        if (this._activeSources && this._activeSources.has(midi)) {
          const sources = this._activeSources.get(midi);

          const index = sources.indexOf(source);

          if (index !== -1) {
            sources.splice(index, 1);
          }
        }
      };
    });
    return this;
  }
  /**
   * @param  notes	The note to release, or an array of notes.
   * @param  time     	When to release the note.
   */


  triggerRelease(notes, time) {
    this.log("triggerRelease", notes, time);

    if (!Array.isArray(notes)) {
      notes = [notes];
    }

    notes.forEach(note => {
      const midi = new _Frequency.FrequencyClass(this.context, note).toMidi(); // find the note

      if (this._activeSources.has(midi) && this._activeSources.get(midi).length) {
        const sources = this._activeSources.get(midi);

        time = this.toSeconds(time);
        sources.forEach(source => {
          source.stop(time);
        });

        this._activeSources.set(midi, []);
      }
    });
    return this;
  }
  /**
   * Release all currently active notes.
   * @param  time     	When to release the notes.
   */


  releaseAll(time) {
    const computedTime = this.toSeconds(time);

    this._activeSources.forEach(sources => {
      while (sources.length) {
        const source = sources.shift();
        source.stop(computedTime);
      }
    });

    return this;
  }

  sync() {
    if (this._syncState()) {
      this._syncMethod("triggerAttack", 1);

      this._syncMethod("triggerRelease", 1);
    }

    return this;
  }
  /**
   * Invoke the attack phase, then after the duration, invoke the release.
   * @param  notes	The note to play and release, or an array of notes.
   * @param  duration The time the note should be held
   * @param  time     When to start the attack
   * @param  velocity The velocity of the attack
   */


  triggerAttackRelease(notes, duration, time, velocity = 1) {
    const computedTime = this.toSeconds(time);
    this.triggerAttack(notes, computedTime, velocity);

    if ((0, _TypeCheck.isArray)(duration)) {
      (0, _Debug.assert)((0, _TypeCheck.isArray)(notes), "notes must be an array when duration is array");
      notes.forEach((note, index) => {
        const d = duration[Math.min(index, duration.length - 1)];
        this.triggerRelease(note, computedTime + this.toSeconds(d));
      });
    } else {
      this.triggerRelease(notes, computedTime + this.toSeconds(duration));
    }

    return this;
  }
  /**
   * Add a note to the sampler.
   * @param  note      The buffer's pitch.
   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.
   * @param  callback  The callback to invoke when the url is loaded.
   */


  add(note, url, callback) {
    (0, _Debug.assert)((0, _TypeCheck.isNote)(note) || isFinite(note), `note must be a pitch or midi: ${note}`);

    if ((0, _TypeCheck.isNote)(note)) {
      // convert the note name to MIDI
      const mid = new _Frequency.FrequencyClass(this.context, note).toMidi();

      this._buffers.add(mid, url, callback);
    } else {
      // otherwise if it's numbers assume it's midi
      this._buffers.add(note, url, callback);
    }

    return this;
  }
  /**
   * If the buffers are loaded or not
   */


  get loaded() {
    return this._buffers.loaded;
  }
  /**
   * Clean up
   */


  dispose() {
    super.dispose();

    this._buffers.dispose();

    this._activeSources.forEach(sources => {
      sources.forEach(source => source.dispose());
    });

    this._activeSources.clear();

    return this;
  }

}

exports.Sampler = Sampler;
(0, _tslib.__decorate)([(0, _Decorator.timeRange)(0)], Sampler.prototype, "attack", void 0);
(0, _tslib.__decorate)([(0, _Decorator.timeRange)(0)], Sampler.prototype, "release", void 0);
},{"tslib":"../node_modules/tslib/tslib.es6.js","../core/context/ToneAudioBuffers":"../node_modules/tone/build/esm/core/context/ToneAudioBuffers.js","../core/type/Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js","../core/type/Frequency":"../node_modules/tone/build/esm/core/type/Frequency.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","../instrument/Instrument":"../node_modules/tone/build/esm/instrument/Instrument.js","../source/buffer/ToneBufferSource":"../node_modules/tone/build/esm/source/buffer/ToneBufferSource.js","../core/util/Decorator":"../node_modules/tone/build/esm/core/util/Decorator.js","../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/instrument/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AMSynth = require("./AMSynth");

Object.keys(_AMSynth).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _AMSynth[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _AMSynth[key];
    }
  });
});

var _DuoSynth = require("./DuoSynth");

Object.keys(_DuoSynth).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _DuoSynth[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _DuoSynth[key];
    }
  });
});

var _FMSynth = require("./FMSynth");

Object.keys(_FMSynth).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _FMSynth[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FMSynth[key];
    }
  });
});

var _MetalSynth = require("./MetalSynth");

Object.keys(_MetalSynth).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _MetalSynth[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _MetalSynth[key];
    }
  });
});

var _MembraneSynth = require("./MembraneSynth");

Object.keys(_MembraneSynth).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _MembraneSynth[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _MembraneSynth[key];
    }
  });
});

var _MonoSynth = require("./MonoSynth");

Object.keys(_MonoSynth).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _MonoSynth[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _MonoSynth[key];
    }
  });
});

var _NoiseSynth = require("./NoiseSynth");

Object.keys(_NoiseSynth).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _NoiseSynth[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _NoiseSynth[key];
    }
  });
});

var _PluckSynth = require("./PluckSynth");

Object.keys(_PluckSynth).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PluckSynth[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PluckSynth[key];
    }
  });
});

var _PolySynth = require("./PolySynth");

Object.keys(_PolySynth).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PolySynth[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PolySynth[key];
    }
  });
});

var _Sampler = require("./Sampler");

Object.keys(_Sampler).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Sampler[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Sampler[key];
    }
  });
});

var _Synth = require("./Synth");

Object.keys(_Synth).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Synth[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Synth[key];
    }
  });
});
},{"./AMSynth":"../node_modules/tone/build/esm/instrument/AMSynth.js","./DuoSynth":"../node_modules/tone/build/esm/instrument/DuoSynth.js","./FMSynth":"../node_modules/tone/build/esm/instrument/FMSynth.js","./MetalSynth":"../node_modules/tone/build/esm/instrument/MetalSynth.js","./MembraneSynth":"../node_modules/tone/build/esm/instrument/MembraneSynth.js","./MonoSynth":"../node_modules/tone/build/esm/instrument/MonoSynth.js","./NoiseSynth":"../node_modules/tone/build/esm/instrument/NoiseSynth.js","./PluckSynth":"../node_modules/tone/build/esm/instrument/PluckSynth.js","./PolySynth":"../node_modules/tone/build/esm/instrument/PolySynth.js","./Sampler":"../node_modules/tone/build/esm/instrument/Sampler.js","./Synth":"../node_modules/tone/build/esm/instrument/Synth.js"}],"../node_modules/tone/build/esm/event/ToneEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToneEvent = void 0;

require("../core/clock/Transport");

var _ToneWithContext = require("../core/context/ToneWithContext");

var _Ticks = require("../core/type/Ticks");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

var _StateTimeline = require("../core/util/StateTimeline");

var _TypeCheck = require("../core/util/TypeCheck");

/**
 * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable
 * callback for a single or repeatable events along the timeline.
 *
 * @example
 * const synth = new Tone.PolySynth().toDestination();
 * const chordEvent = new Tone.ToneEvent(((time, chord) => {
 * 	// the chord as well as the exact time of the event
 * 	// are passed in as arguments to the callback function
 * 	synth.triggerAttackRelease(chord, 0.5, time);
 * }), ["D4", "E4", "F4"]);
 * // start the chord at the beginning of the transport timeline
 * chordEvent.start();
 * // loop it every measure for 8 measures
 * chordEvent.loop = 8;
 * chordEvent.loopEnd = "1m";
 * @category Event
 */
class ToneEvent extends _ToneWithContext.ToneWithContext {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(ToneEvent.getDefaults(), arguments, ["callback", "value"]));
    this.name = "ToneEvent";
    /**
     * Tracks the scheduled events
     */

    this._state = new _StateTimeline.StateTimeline("stopped");
    /**
     * A delay time from when the event is scheduled to start
     */

    this._startOffset = 0;
    const options = (0, _Defaults.optionsFromArguments)(ToneEvent.getDefaults(), arguments, ["callback", "value"]);
    this._loop = options.loop;
    this.callback = options.callback;
    this.value = options.value;
    this._loopStart = this.toTicks(options.loopStart);
    this._loopEnd = this.toTicks(options.loopEnd);
    this._playbackRate = options.playbackRate;
    this._probability = options.probability;
    this._humanize = options.humanize;
    this.mute = options.mute;
    this._playbackRate = options.playbackRate;
    this._state.increasing = true; // schedule the events for the first time

    this._rescheduleEvents();
  }

  static getDefaults() {
    return Object.assign(_ToneWithContext.ToneWithContext.getDefaults(), {
      callback: _Interface.noOp,
      humanize: false,
      loop: false,
      loopEnd: "1m",
      loopStart: 0,
      mute: false,
      playbackRate: 1,
      probability: 1,
      value: null
    });
  }
  /**
   * Reschedule all of the events along the timeline
   * with the updated values.
   * @param after Only reschedules events after the given time.
   */


  _rescheduleEvents(after = -1) {
    // if no argument is given, schedules all of the events
    this._state.forEachFrom(after, event => {
      let duration;

      if (event.state === "started") {
        if (event.id !== -1) {
          this.context.transport.clear(event.id);
        }

        const startTick = event.time + Math.round(this.startOffset / this._playbackRate);

        if (this._loop === true || (0, _TypeCheck.isNumber)(this._loop) && this._loop > 1) {
          duration = Infinity;

          if ((0, _TypeCheck.isNumber)(this._loop)) {
            duration = this._loop * this._getLoopDuration();
          }

          const nextEvent = this._state.getAfter(startTick);

          if (nextEvent !== null) {
            duration = Math.min(duration, nextEvent.time - startTick);
          }

          if (duration !== Infinity) {
            // schedule a stop since it's finite duration
            this._state.setStateAtTime("stopped", startTick + duration + 1, {
              id: -1
            });

            duration = new _Ticks.TicksClass(this.context, duration);
          }

          const interval = new _Ticks.TicksClass(this.context, this._getLoopDuration());
          event.id = this.context.transport.scheduleRepeat(this._tick.bind(this), interval, new _Ticks.TicksClass(this.context, startTick), duration);
        } else {
          event.id = this.context.transport.schedule(this._tick.bind(this), new _Ticks.TicksClass(this.context, startTick));
        }
      }
    });
  }
  /**
   * Returns the playback state of the note, either "started" or "stopped".
   */


  get state() {
    return this._state.getValueAtTime(this.context.transport.ticks);
  }
  /**
   * The start from the scheduled start time.
   */


  get startOffset() {
    return this._startOffset;
  }

  set startOffset(offset) {
    this._startOffset = offset;
  }
  /**
   * The probability of the notes being triggered.
   */


  get probability() {
    return this._probability;
  }

  set probability(prob) {
    this._probability = prob;
  }
  /**
   * If set to true, will apply small random variation
   * to the callback time. If the value is given as a time, it will randomize
   * by that amount.
   * @example
   * const event = new Tone.ToneEvent();
   * event.humanize = true;
   */


  get humanize() {
    return this._humanize;
  }

  set humanize(variation) {
    this._humanize = variation;
  }
  /**
   * Start the note at the given time.
   * @param  time  When the event should start.
   */


  start(time) {
    const ticks = this.toTicks(time);

    if (this._state.getValueAtTime(ticks) === "stopped") {
      this._state.add({
        id: -1,
        state: "started",
        time: ticks
      });

      this._rescheduleEvents(ticks);
    }

    return this;
  }
  /**
   * Stop the Event at the given time.
   * @param  time  When the event should stop.
   */


  stop(time) {
    this.cancel(time);
    const ticks = this.toTicks(time);

    if (this._state.getValueAtTime(ticks) === "started") {
      this._state.setStateAtTime("stopped", ticks, {
        id: -1
      });

      const previousEvent = this._state.getBefore(ticks);

      let reschedulTime = ticks;

      if (previousEvent !== null) {
        reschedulTime = previousEvent.time;
      }

      this._rescheduleEvents(reschedulTime);
    }

    return this;
  }
  /**
   * Cancel all scheduled events greater than or equal to the given time
   * @param  time  The time after which events will be cancel.
   */


  cancel(time) {
    time = (0, _Defaults.defaultArg)(time, -Infinity);
    const ticks = this.toTicks(time);

    this._state.forEachFrom(ticks, event => {
      this.context.transport.clear(event.id);
    });

    this._state.cancel(ticks);

    return this;
  }
  /**
   * The callback function invoker. Also
   * checks if the Event is done playing
   * @param  time  The time of the event in seconds
   */


  _tick(time) {
    const ticks = this.context.transport.getTicksAtTime(time);

    if (!this.mute && this._state.getValueAtTime(ticks) === "started") {
      if (this.probability < 1 && Math.random() > this.probability) {
        return;
      }

      if (this.humanize) {
        let variation = 0.02;

        if (!(0, _TypeCheck.isBoolean)(this.humanize)) {
          variation = this.toSeconds(this.humanize);
        }

        time += (Math.random() * 2 - 1) * variation;
      }

      this.callback(time, this.value);
    }
  }
  /**
   * Get the duration of the loop.
   */


  _getLoopDuration() {
    return Math.round((this._loopEnd - this._loopStart) / this._playbackRate);
  }
  /**
   * If the note should loop or not
   * between ToneEvent.loopStart and
   * ToneEvent.loopEnd. If set to true,
   * the event will loop indefinitely,
   * if set to a number greater than 1
   * it will play a specific number of
   * times, if set to false, 0 or 1, the
   * part will only play once.
   */


  get loop() {
    return this._loop;
  }

  set loop(loop) {
    this._loop = loop;

    this._rescheduleEvents();
  }
  /**
   * The playback rate of the note. Defaults to 1.
   * @example
   * const note = new Tone.ToneEvent();
   * note.loop = true;
   * // repeat the note twice as fast
   * note.playbackRate = 2;
   */


  get playbackRate() {
    return this._playbackRate;
  }

  set playbackRate(rate) {
    this._playbackRate = rate;

    this._rescheduleEvents();
  }
  /**
   * The loopEnd point is the time the event will loop
   * if ToneEvent.loop is true.
   */


  get loopEnd() {
    return new _Ticks.TicksClass(this.context, this._loopEnd).toSeconds();
  }

  set loopEnd(loopEnd) {
    this._loopEnd = this.toTicks(loopEnd);

    if (this._loop) {
      this._rescheduleEvents();
    }
  }
  /**
   * The time when the loop should start.
   */


  get loopStart() {
    return new _Ticks.TicksClass(this.context, this._loopStart).toSeconds();
  }

  set loopStart(loopStart) {
    this._loopStart = this.toTicks(loopStart);

    if (this._loop) {
      this._rescheduleEvents();
    }
  }
  /**
   * The current progress of the loop interval.
   * Returns 0 if the event is not started yet or
   * it is not set to loop.
   */


  get progress() {
    if (this._loop) {
      const ticks = this.context.transport.ticks;

      const lastEvent = this._state.get(ticks);

      if (lastEvent !== null && lastEvent.state === "started") {
        const loopDuration = this._getLoopDuration();

        const progress = (ticks - lastEvent.time) % loopDuration;
        return progress / loopDuration;
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  }

  dispose() {
    super.dispose();
    this.cancel();

    this._state.dispose();

    return this;
  }

}

exports.ToneEvent = ToneEvent;
},{"../core/clock/Transport":"../node_modules/tone/build/esm/core/clock/Transport.js","../core/context/ToneWithContext":"../node_modules/tone/build/esm/core/context/ToneWithContext.js","../core/type/Ticks":"../node_modules/tone/build/esm/core/type/Ticks.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../core/util/StateTimeline":"../node_modules/tone/build/esm/core/util/StateTimeline.js","../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js"}],"../node_modules/tone/build/esm/event/Loop.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Loop = void 0;

var _ToneEvent = require("./ToneEvent");

var _ToneWithContext = require("../core/context/ToneWithContext");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

/**
 * Loop creates a looped callback at the
 * specified interval. The callback can be
 * started, stopped and scheduled along
 * the Transport's timeline.
 * @example
 * const loop = new Tone.Loop((time) => {
 * 	// triggered every eighth note.
 * 	console.log(time);
 * }, "8n").start(0);
 * Tone.Transport.start();
 * @category Event
 */
class Loop extends _ToneWithContext.ToneWithContext {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Loop.getDefaults(), arguments, ["callback", "interval"]));
    this.name = "Loop";
    const options = (0, _Defaults.optionsFromArguments)(Loop.getDefaults(), arguments, ["callback", "interval"]);
    this._event = new _ToneEvent.ToneEvent({
      context: this.context,
      callback: this._tick.bind(this),
      loop: true,
      loopEnd: options.interval,
      playbackRate: options.playbackRate,
      probability: options.probability
    });
    this.callback = options.callback; // set the iterations

    this.iterations = options.iterations;
  }

  static getDefaults() {
    return Object.assign(_ToneWithContext.ToneWithContext.getDefaults(), {
      interval: "4n",
      callback: _Interface.noOp,
      playbackRate: 1,
      iterations: Infinity,
      probability: 1,
      mute: false,
      humanize: false
    });
  }
  /**
   * Start the loop at the specified time along the Transport's timeline.
   * @param  time  When to start the Loop.
   */


  start(time) {
    this._event.start(time);

    return this;
  }
  /**
   * Stop the loop at the given time.
   * @param  time  When to stop the Loop.
   */


  stop(time) {
    this._event.stop(time);

    return this;
  }
  /**
   * Cancel all scheduled events greater than or equal to the given time
   * @param  time  The time after which events will be cancel.
   */


  cancel(time) {
    this._event.cancel(time);

    return this;
  }
  /**
   * Internal function called when the notes should be called
   * @param time  The time the event occurs
   */


  _tick(time) {
    this.callback(time);
  }
  /**
   * The state of the Loop, either started or stopped.
   */


  get state() {
    return this._event.state;
  }
  /**
   * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.
   */


  get progress() {
    return this._event.progress;
  }
  /**
   * The time between successive callbacks.
   * @example
   * const loop = new Tone.Loop();
   * loop.interval = "8n"; // loop every 8n
   */


  get interval() {
    return this._event.loopEnd;
  }

  set interval(interval) {
    this._event.loopEnd = interval;
  }
  /**
   * The playback rate of the loop. The normal playback rate is 1 (no change).
   * A `playbackRate` of 2 would be twice as fast.
   */


  get playbackRate() {
    return this._event.playbackRate;
  }

  set playbackRate(rate) {
    this._event.playbackRate = rate;
  }
  /**
   * Random variation +/-0.01s to the scheduled time.
   * Or give it a time value which it will randomize by.
   */


  get humanize() {
    return this._event.humanize;
  }

  set humanize(variation) {
    this._event.humanize = variation;
  }
  /**
   * The probably of the callback being invoked.
   */


  get probability() {
    return this._event.probability;
  }

  set probability(prob) {
    this._event.probability = prob;
  }
  /**
   * Muting the Loop means that no callbacks are invoked.
   */


  get mute() {
    return this._event.mute;
  }

  set mute(mute) {
    this._event.mute = mute;
  }
  /**
   * The number of iterations of the loop. The default value is `Infinity` (loop forever).
   */


  get iterations() {
    if (this._event.loop === true) {
      return Infinity;
    } else {
      return this._event.loop;
    }
  }

  set iterations(iters) {
    if (iters === Infinity) {
      this._event.loop = true;
    } else {
      this._event.loop = iters;
    }
  }

  dispose() {
    super.dispose();

    this._event.dispose();

    return this;
  }

}

exports.Loop = Loop;
},{"./ToneEvent":"../node_modules/tone/build/esm/event/ToneEvent.js","../core/context/ToneWithContext":"../node_modules/tone/build/esm/core/context/ToneWithContext.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/event/Part.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Part = void 0;

var _Ticks = require("../core/type/Ticks");

var _TransportTime = require("../core/type/TransportTime");

var _Defaults = require("../core/util/Defaults");

var _StateTimeline = require("../core/util/StateTimeline");

var _TypeCheck = require("../core/util/TypeCheck");

var _ToneEvent = require("./ToneEvent");

/**
 * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.
 *
 * @example
 * const synth = new Tone.Synth().toDestination();
 * const part = new Tone.Part(((time, note) => {
 * 	// the notes given as the second element in the array
 * 	// will be passed in as the second argument
 * 	synth.triggerAttackRelease(note, "8n", time);
 * }), [[0, "C2"], ["0:2", "C3"], ["0:3:2", "G2"]]);
 * Tone.Transport.start();
 * @example
 * const synth = new Tone.Synth().toDestination();
 * // use an array of objects as long as the object has a "time" attribute
 * const part = new Tone.Part(((time, value) => {
 * 	// the value is an object which contains both the note and the velocity
 * 	synth.triggerAttackRelease(value.note, "8n", time, value.velocity);
 * }), [{ time: 0, note: "C3", velocity: 0.9 },
 * 	{ time: "0:2", note: "C4", velocity: 0.5 }
 * ]).start(0);
 * Tone.Transport.start();
 * @category Event
 */
class Part extends _ToneEvent.ToneEvent {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Part.getDefaults(), arguments, ["callback", "events"]));
    this.name = "Part";
    /**
     * Tracks the scheduled events
     */

    this._state = new _StateTimeline.StateTimeline("stopped");
    /**
     * The events that belong to this part
     */

    this._events = new Set();
    const options = (0, _Defaults.optionsFromArguments)(Part.getDefaults(), arguments, ["callback", "events"]); // make sure things are assigned in the right order

    this._state.increasing = true; // add the events

    options.events.forEach(event => {
      if ((0, _TypeCheck.isArray)(event)) {
        this.add(event[0], event[1]);
      } else {
        this.add(event);
      }
    });
  }

  static getDefaults() {
    return Object.assign(_ToneEvent.ToneEvent.getDefaults(), {
      events: []
    });
  }
  /**
   * Start the part at the given time.
   * @param  time    When to start the part.
   * @param  offset  The offset from the start of the part to begin playing at.
   */


  start(time, offset) {
    const ticks = this.toTicks(time);

    if (this._state.getValueAtTime(ticks) !== "started") {
      offset = (0, _Defaults.defaultArg)(offset, this._loop ? this._loopStart : 0);

      if (this._loop) {
        offset = (0, _Defaults.defaultArg)(offset, this._loopStart);
      } else {
        offset = (0, _Defaults.defaultArg)(offset, 0);
      }

      const computedOffset = this.toTicks(offset);

      this._state.add({
        id: -1,
        offset: computedOffset,
        state: "started",
        time: ticks
      });

      this._forEach(event => {
        this._startNote(event, ticks, computedOffset);
      });
    }

    return this;
  }
  /**
   * Start the event in the given event at the correct time given
   * the ticks and offset and looping.
   * @param  event
   * @param  ticks
   * @param  offset
   */


  _startNote(event, ticks, offset) {
    ticks -= offset;

    if (this._loop) {
      if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {
        if (event.startOffset < offset) {
          // start it on the next loop
          ticks += this._getLoopDuration();
        }

        event.start(new _Ticks.TicksClass(this.context, ticks));
      } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {
        event.loop = false;
        event.start(new _Ticks.TicksClass(this.context, ticks));
      }
    } else if (event.startOffset >= offset) {
      event.start(new _Ticks.TicksClass(this.context, ticks));
    }
  }

  get startOffset() {
    return this._startOffset;
  }

  set startOffset(offset) {
    this._startOffset = offset;

    this._forEach(event => {
      event.startOffset += this._startOffset;
    });
  }
  /**
   * Stop the part at the given time.
   * @param  time  When to stop the part.
   */


  stop(time) {
    const ticks = this.toTicks(time);

    this._state.cancel(ticks);

    this._state.setStateAtTime("stopped", ticks);

    this._forEach(event => {
      event.stop(time);
    });

    return this;
  }
  /**
   * Get/Set an Event's value at the given time.
   * If a value is passed in and no event exists at
   * the given time, one will be created with that value.
   * If two events are at the same time, the first one will
   * be returned.
   * @example
   * const part = new Tone.Part();
   * part.at("1m"); // returns the part at the first measure
   * part.at("2m", "C2"); // set the value at "2m" to C2.
   * // if an event didn't exist at that time, it will be created.
   * @param time The time of the event to get or set.
   * @param value If a value is passed in, the value of the event at the given time will be set to it.
   */


  at(time, value) {
    const timeInTicks = new _TransportTime.TransportTimeClass(this.context, time).toTicks();
    const tickTime = new _Ticks.TicksClass(this.context, 1).toSeconds();

    const iterator = this._events.values();

    let result = iterator.next();

    while (!result.done) {
      const event = result.value;

      if (Math.abs(timeInTicks - event.startOffset) < tickTime) {
        if ((0, _TypeCheck.isDefined)(value)) {
          event.value = value;
        }

        return event;
      }

      result = iterator.next();
    } // if there was no event at that time, create one


    if ((0, _TypeCheck.isDefined)(value)) {
      this.add(time, value); // return the new event

      return this.at(time);
    } else {
      return null;
    }
  }

  add(time, value) {
    // extract the parameters
    if (time instanceof Object && Reflect.has(time, "time")) {
      value = time;
      time = value.time;
    }

    const ticks = this.toTicks(time);
    let event;

    if (value instanceof _ToneEvent.ToneEvent) {
      event = value;
      event.callback = this._tick.bind(this);
    } else {
      event = new _ToneEvent.ToneEvent({
        callback: this._tick.bind(this),
        context: this.context,
        value
      });
    } // the start offset


    event.startOffset = ticks; // initialize the values

    event.set({
      humanize: this.humanize,
      loop: this.loop,
      loopEnd: this.loopEnd,
      loopStart: this.loopStart,
      playbackRate: this.playbackRate,
      probability: this.probability
    });

    this._events.add(event); // start the note if it should be played right now


    this._restartEvent(event);

    return this;
  }
  /**
   * Restart the given event
   */


  _restartEvent(event) {
    this._state.forEach(stateEvent => {
      if (stateEvent.state === "started") {
        this._startNote(event, stateEvent.time, stateEvent.offset);
      } else {
        // stop the note
        event.stop(new _Ticks.TicksClass(this.context, stateEvent.time));
      }
    });
  }

  remove(time, value) {
    // extract the parameters
    if ((0, _TypeCheck.isObject)(time) && time.hasOwnProperty("time")) {
      value = time;
      time = value.time;
    }

    time = this.toTicks(time);

    this._events.forEach(event => {
      if (event.startOffset === time) {
        if ((0, _TypeCheck.isUndef)(value) || (0, _TypeCheck.isDefined)(value) && event.value === value) {
          this._events.delete(event);

          event.dispose();
        }
      }
    });

    return this;
  }
  /**
   * Remove all of the notes from the group.
   */


  clear() {
    this._forEach(event => event.dispose());

    this._events.clear();

    return this;
  }
  /**
   * Cancel scheduled state change events: i.e. "start" and "stop".
   * @param after The time after which to cancel the scheduled events.
   */


  cancel(after) {
    this._forEach(event => event.cancel(after));

    this._state.cancel(this.toTicks(after));

    return this;
  }
  /**
   * Iterate over all of the events
   */


  _forEach(callback) {
    if (this._events) {
      this._events.forEach(event => {
        if (event instanceof Part) {
          event._forEach(callback);
        } else {
          callback(event);
        }
      });
    }

    return this;
  }
  /**
   * Set the attribute of all of the events
   * @param  attr  the attribute to set
   * @param  value      The value to set it to
   */


  _setAll(attr, value) {
    this._forEach(event => {
      event[attr] = value;
    });
  }
  /**
   * Internal tick method
   * @param  time  The time of the event in seconds
   */


  _tick(time, value) {
    if (!this.mute) {
      this.callback(time, value);
    }
  }
  /**
   * Determine if the event should be currently looping
   * given the loop boundries of this Part.
   * @param  event  The event to test
   */


  _testLoopBoundries(event) {
    if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {
      event.cancel(0);
    } else if (event.state === "stopped") {
      // reschedule it if it's stopped
      this._restartEvent(event);
    }
  }

  get probability() {
    return this._probability;
  }

  set probability(prob) {
    this._probability = prob;

    this._setAll("probability", prob);
  }

  get humanize() {
    return this._humanize;
  }

  set humanize(variation) {
    this._humanize = variation;

    this._setAll("humanize", variation);
  }
  /**
   * If the part should loop or not
   * between Part.loopStart and
   * Part.loopEnd. If set to true,
   * the part will loop indefinitely,
   * if set to a number greater than 1
   * it will play a specific number of
   * times, if set to false, 0 or 1, the
   * part will only play once.
   * @example
   * const part = new Tone.Part();
   * // loop the part 8 times
   * part.loop = 8;
   */


  get loop() {
    return this._loop;
  }

  set loop(loop) {
    this._loop = loop;

    this._forEach(event => {
      event.loopStart = this.loopStart;
      event.loopEnd = this.loopEnd;
      event.loop = loop;

      this._testLoopBoundries(event);
    });
  }
  /**
   * The loopEnd point determines when it will
   * loop if Part.loop is true.
   */


  get loopEnd() {
    return new _Ticks.TicksClass(this.context, this._loopEnd).toSeconds();
  }

  set loopEnd(loopEnd) {
    this._loopEnd = this.toTicks(loopEnd);

    if (this._loop) {
      this._forEach(event => {
        event.loopEnd = loopEnd;

        this._testLoopBoundries(event);
      });
    }
  }
  /**
   * The loopStart point determines when it will
   * loop if Part.loop is true.
   */


  get loopStart() {
    return new _Ticks.TicksClass(this.context, this._loopStart).toSeconds();
  }

  set loopStart(loopStart) {
    this._loopStart = this.toTicks(loopStart);

    if (this._loop) {
      this._forEach(event => {
        event.loopStart = this.loopStart;

        this._testLoopBoundries(event);
      });
    }
  }
  /**
   * The playback rate of the part
   */


  get playbackRate() {
    return this._playbackRate;
  }

  set playbackRate(rate) {
    this._playbackRate = rate;

    this._setAll("playbackRate", rate);
  }
  /**
   * The number of scheduled notes in the part.
   */


  get length() {
    return this._events.size;
  }

  dispose() {
    super.dispose();
    this.clear();
    return this;
  }

}

exports.Part = Part;
},{"../core/type/Ticks":"../node_modules/tone/build/esm/core/type/Ticks.js","../core/type/TransportTime":"../node_modules/tone/build/esm/core/type/TransportTime.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/StateTimeline":"../node_modules/tone/build/esm/core/util/StateTimeline.js","../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","./ToneEvent":"../node_modules/tone/build/esm/event/ToneEvent.js"}],"../node_modules/tone/build/esm/event/PatternGenerator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PatternGenerator = PatternGenerator;

var _Debug = require("../core/util/Debug");

var _Math = require("../core/util/Math");

/**
 * Start at the first value and go up to the last
 */
function* upPatternGen(values) {
  let index = 0;

  while (index < values.length) {
    index = clampToArraySize(index, values);
    yield values[index];
    index++;
  }
}
/**
 * Start at the last value and go down to 0
 */


function* downPatternGen(values) {
  let index = values.length - 1;

  while (index >= 0) {
    index = clampToArraySize(index, values);
    yield values[index];
    index--;
  }
}
/**
 * Infinitely yield the generator
 */


function* infiniteGen(values, gen) {
  while (true) {
    yield* gen(values);
  }
}
/**
 * Make sure that the index is in the given range
 */


function clampToArraySize(index, values) {
  return (0, _Math.clamp)(index, 0, values.length - 1);
}
/**
 * Alternate between two generators
 */


function* alternatingGenerator(values, directionUp) {
  let index = directionUp ? 0 : values.length - 1;

  while (true) {
    index = clampToArraySize(index, values);
    yield values[index];

    if (directionUp) {
      index++;

      if (index >= values.length - 1) {
        directionUp = false;
      }
    } else {
      index--;

      if (index <= 0) {
        directionUp = true;
      }
    }
  }
}
/**
 * Starting from the bottom move up 2, down 1
 */


function* jumpUp(values) {
  let index = 0;
  let stepIndex = 0;

  while (index < values.length) {
    index = clampToArraySize(index, values);
    yield values[index];
    stepIndex++;
    index += stepIndex % 2 ? 2 : -1;
  }
}
/**
 * Starting from the top move down 2, up 1
 */


function* jumpDown(values) {
  let index = values.length - 1;
  let stepIndex = 0;

  while (index >= 0) {
    index = clampToArraySize(index, values);
    yield values[index];
    stepIndex++;
    index += stepIndex % 2 ? -2 : 1;
  }
}
/**
 * Choose a random index each time
 */


function* randomGen(values) {
  while (true) {
    const randomIndex = Math.floor(Math.random() * values.length);
    yield values[randomIndex];
  }
}
/**
 * Randomly go through all of the values once before choosing a new random order
 */


function* randomOnce(values) {
  // create an array of indices
  const copy = [];

  for (let i = 0; i < values.length; i++) {
    copy.push(i);
  }

  while (copy.length > 0) {
    // random choose an index, and then remove it so it's not chosen again
    const randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);
    const index = clampToArraySize(randVal[0], values);
    yield values[index];
  }
}
/**
 * Randomly choose to walk up or down 1 index in the values array
 */


function* randomWalk(values) {
  // randomly choose a starting index in the values array
  let index = Math.floor(Math.random() * values.length);

  while (true) {
    if (index === 0) {
      index++; // at bottom of array, so force upward step
    } else if (index === values.length - 1) {
      index--; // at top of array, so force downward step
    } else if (Math.random() < 0.5) {
      // else choose random downward or upward step
      index--;
    } else {
      index++;
    }

    yield values[index];
  }
}
/**
 * PatternGenerator returns a generator which will iterate over the given array
 * of values and yield the items according to the passed in pattern
 * @param values An array of values to iterate over
 * @param pattern The name of the pattern use when iterating over
 * @param index Where to start in the offset of the values array
 */


function* PatternGenerator(values, pattern = "up", index = 0) {
  // safeguards
  (0, _Debug.assert)(values.length > 0, "The array must have more than one value in it");

  switch (pattern) {
    case "up":
      yield* infiniteGen(values, upPatternGen);

    case "down":
      yield* infiniteGen(values, downPatternGen);

    case "upDown":
      yield* alternatingGenerator(values, true);

    case "downUp":
      yield* alternatingGenerator(values, false);

    case "alternateUp":
      yield* infiniteGen(values, jumpUp);

    case "alternateDown":
      yield* infiniteGen(values, jumpDown);

    case "random":
      yield* randomGen(values);

    case "randomOnce":
      yield* infiniteGen(values, randomOnce);

    case "randomWalk":
      yield* randomWalk(values);
  }
}
},{"../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","../core/util/Math":"../node_modules/tone/build/esm/core/util/Math.js"}],"../node_modules/tone/build/esm/event/Pattern.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pattern = void 0;

var _Loop = require("./Loop");

var _PatternGenerator = require("./PatternGenerator");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

/**
 * Pattern arpeggiates between the given notes
 * in a number of patterns.
 * @example
 * const pattern = new Tone.Pattern((time, note) => {
 * 	// the order of the notes passed in depends on the pattern
 * }, ["C2", "D4", "E5", "A6"], "upDown");
 * @category Event
 */
class Pattern extends _Loop.Loop {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Pattern.getDefaults(), arguments, ["callback", "values", "pattern"]));
    this.name = "Pattern";
    const options = (0, _Defaults.optionsFromArguments)(Pattern.getDefaults(), arguments, ["callback", "values", "pattern"]);
    this.callback = options.callback;
    this._values = options.values;
    this._pattern = (0, _PatternGenerator.PatternGenerator)(options.values, options.pattern);
    this._type = options.pattern;
  }

  static getDefaults() {
    return Object.assign(_Loop.Loop.getDefaults(), {
      pattern: "up",
      values: [],
      callback: _Interface.noOp
    });
  }
  /**
   * Internal function called when the notes should be called
   */


  _tick(time) {
    const value = this._pattern.next();

    this._value = value.value;
    this.callback(time, this._value);
  }
  /**
   * The array of events.
   */


  get values() {
    return this._values;
  }

  set values(val) {
    this._values = val; // reset the pattern

    this.pattern = this._type;
  }
  /**
   * The current value of the pattern.
   */


  get value() {
    return this._value;
  }
  /**
   * The pattern type. See Tone.CtrlPattern for the full list of patterns.
   */


  get pattern() {
    return this._type;
  }

  set pattern(pattern) {
    this._type = pattern;
    this._pattern = (0, _PatternGenerator.PatternGenerator)(this._values, this._type);
  }

}

exports.Pattern = Pattern;
},{"./Loop":"../node_modules/tone/build/esm/event/Loop.js","./PatternGenerator":"../node_modules/tone/build/esm/event/PatternGenerator.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/event/Sequence.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sequence = void 0;

var _Ticks = require("../core/type/Ticks");

var _Defaults = require("../core/util/Defaults");

var _TypeCheck = require("../core/util/TypeCheck");

var _Part = require("./Part");

var _ToneEvent = require("./ToneEvent");

/**
 * A sequence is an alternate notation of a part. Instead
 * of passing in an array of [time, event] pairs, pass
 * in an array of events which will be spaced at the
 * given subdivision. Sub-arrays will subdivide that beat
 * by the number of items are in the array.
 * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)
 * @example
 * const synth = new Tone.Synth().toDestination();
 * const seq = new Tone.Sequence((time, note) => {
 * 	synth.triggerAttackRelease(note, 0.1, time);
 * 	// subdivisions are given as subarrays
 * }, ["C4", ["E4", "D4", "E4"], "G4", ["A4", "G4"]]).start(0);
 * Tone.Transport.start();
 * @category Event
 */
class Sequence extends _ToneEvent.ToneEvent {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Sequence.getDefaults(), arguments, ["callback", "events", "subdivision"]));
    this.name = "Sequence";
    /**
     * The object responsible for scheduling all of the events
     */

    this._part = new _Part.Part({
      callback: this._seqCallback.bind(this),
      context: this.context
    });
    /**
     * private reference to all of the sequence proxies
     */

    this._events = [];
    /**
     * The proxied array
     */

    this._eventsArray = [];
    const options = (0, _Defaults.optionsFromArguments)(Sequence.getDefaults(), arguments, ["callback", "events", "subdivision"]);
    this._subdivision = this.toTicks(options.subdivision);
    this.events = options.events; // set all of the values

    this.loop = options.loop;
    this.loopStart = options.loopStart;
    this.loopEnd = options.loopEnd;
    this.playbackRate = options.playbackRate;
    this.probability = options.probability;
    this.humanize = options.humanize;
    this.mute = options.mute;
    this.playbackRate = options.playbackRate;
  }

  static getDefaults() {
    return Object.assign((0, _Defaults.omitFromObject)(_ToneEvent.ToneEvent.getDefaults(), ["value"]), {
      events: [],
      loop: true,
      loopEnd: 0,
      loopStart: 0,
      subdivision: "8n"
    });
  }
  /**
   * The internal callback for when an event is invoked
   */


  _seqCallback(time, value) {
    if (value !== null) {
      this.callback(time, value);
    }
  }
  /**
   * The sequence
   */


  get events() {
    return this._events;
  }

  set events(s) {
    this.clear();
    this._eventsArray = s;
    this._events = this._createSequence(this._eventsArray);

    this._eventsUpdated();
  }
  /**
   * Start the part at the given time.
   * @param  time    When to start the part.
   * @param  offset  The offset index to start at
   */


  start(time, offset) {
    this._part.start(time, offset ? this._indexTime(offset) : offset);

    return this;
  }
  /**
   * Stop the part at the given time.
   * @param  time  When to stop the part.
   */


  stop(time) {
    this._part.stop(time);

    return this;
  }
  /**
   * The subdivision of the sequence. This can only be
   * set in the constructor. The subdivision is the
   * interval between successive steps.
   */


  get subdivision() {
    return new _Ticks.TicksClass(this.context, this._subdivision).toSeconds();
  }
  /**
   * Create a sequence proxy which can be monitored to create subsequences
   */


  _createSequence(array) {
    return new Proxy(array, {
      get: (target, property) => {
        // property is index in this case
        return target[property];
      },
      set: (target, property, value) => {
        if ((0, _TypeCheck.isString)(property) && isFinite(parseInt(property, 10))) {
          if ((0, _TypeCheck.isArray)(value)) {
            target[property] = this._createSequence(value);
          } else {
            target[property] = value;
          }
        } else {
          target[property] = value;
        }

        this._eventsUpdated(); // return true to accept the changes


        return true;
      }
    });
  }
  /**
   * When the sequence has changed, all of the events need to be recreated
   */


  _eventsUpdated() {
    this._part.clear();

    this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset); // update the loopEnd


    this.loopEnd = this.loopEnd;
  }
  /**
   * reschedule all of the events that need to be rescheduled
   */


  _rescheduleSequence(sequence, subdivision, startOffset) {
    sequence.forEach((value, index) => {
      const eventOffset = index * subdivision + startOffset;

      if ((0, _TypeCheck.isArray)(value)) {
        this._rescheduleSequence(value, subdivision / value.length, eventOffset);
      } else {
        const startTime = new _Ticks.TicksClass(this.context, eventOffset, "i").toSeconds();

        this._part.add(startTime, value);
      }
    });
  }
  /**
   * Get the time of the index given the Sequence's subdivision
   * @param  index
   * @return The time of that index
   */


  _indexTime(index) {
    return new _Ticks.TicksClass(this.context, index * this._subdivision + this.startOffset).toSeconds();
  }
  /**
   * Clear all of the events
   */


  clear() {
    this._part.clear();

    return this;
  }

  dispose() {
    super.dispose();

    this._part.dispose();

    return this;
  } //-------------------------------------
  // PROXY CALLS
  //-------------------------------------


  get loop() {
    return this._part.loop;
  }

  set loop(l) {
    this._part.loop = l;
  }
  /**
   * The index at which the sequence should start looping
   */


  get loopStart() {
    return this._loopStart;
  }

  set loopStart(index) {
    this._loopStart = index;
    this._part.loopStart = this._indexTime(index);
  }
  /**
   * The index at which the sequence should end looping
   */


  get loopEnd() {
    return this._loopEnd;
  }

  set loopEnd(index) {
    this._loopEnd = index;

    if (index === 0) {
      this._part.loopEnd = this._indexTime(this._eventsArray.length);
    } else {
      this._part.loopEnd = this._indexTime(index);
    }
  }

  get startOffset() {
    return this._part.startOffset;
  }

  set startOffset(start) {
    this._part.startOffset = start;
  }

  get playbackRate() {
    return this._part.playbackRate;
  }

  set playbackRate(rate) {
    this._part.playbackRate = rate;
  }

  get probability() {
    return this._part.probability;
  }

  set probability(prob) {
    this._part.probability = prob;
  }

  get progress() {
    return this._part.progress;
  }

  get humanize() {
    return this._part.humanize;
  }

  set humanize(variation) {
    this._part.humanize = variation;
  }
  /**
   * The number of scheduled events
   */


  get length() {
    return this._part.length;
  }

}

exports.Sequence = Sequence;
},{"../core/type/Ticks":"../node_modules/tone/build/esm/core/type/Ticks.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/TypeCheck":"../node_modules/tone/build/esm/core/util/TypeCheck.js","./Part":"../node_modules/tone/build/esm/event/Part.js","./ToneEvent":"../node_modules/tone/build/esm/event/ToneEvent.js"}],"../node_modules/tone/build/esm/event/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Loop = require("./Loop");

Object.keys(_Loop).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Loop[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Loop[key];
    }
  });
});

var _Part = require("./Part");

Object.keys(_Part).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Part[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Part[key];
    }
  });
});

var _Pattern = require("./Pattern");

Object.keys(_Pattern).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Pattern[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Pattern[key];
    }
  });
});

var _Sequence = require("./Sequence");

Object.keys(_Sequence).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Sequence[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Sequence[key];
    }
  });
});

var _ToneEvent = require("./ToneEvent");

Object.keys(_ToneEvent).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ToneEvent[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ToneEvent[key];
    }
  });
});
},{"./Loop":"../node_modules/tone/build/esm/event/Loop.js","./Part":"../node_modules/tone/build/esm/event/Part.js","./Pattern":"../node_modules/tone/build/esm/event/Pattern.js","./Sequence":"../node_modules/tone/build/esm/event/Sequence.js","./ToneEvent":"../node_modules/tone/build/esm/event/ToneEvent.js"}],"../node_modules/tone/build/esm/component/channel/CrossFade.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CrossFade = void 0;

var _Gain = require("../../core/context/Gain");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _GainToAudio = require("../../signal/GainToAudio");

var _Signal = require("../../signal/Signal");

/**
 * Tone.Crossfade provides equal power fading between two inputs.
 * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).
 * ```
 *                                             +---------+
 *                                            +> input a +>--+
 * +-----------+   +---------------------+     |         |   |
 * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |
 * +-----------+   |                     |     +---------+   |
 *               +-> pan               R +>-+                |   +--------+
 *               | +---------------------+  |                +---> output +>
 *  +------+     |                          |  +---------+   |   +--------+
 *  | fade +>----+                          | +> input b +>--+
 *  +------+                                |  |         |
 *                                          +--> gain    |
 *                                             +---------+
 * ```
 * @example
 * const crossFade = new Tone.CrossFade().toDestination();
 * // connect two inputs Tone.to a/b
 * const inputA = new Tone.Oscillator(440, "square").connect(crossFade.a).start();
 * const inputB = new Tone.Oscillator(440, "sine").connect(crossFade.b).start();
 * // use the fade to control the mix between the two
 * crossFade.fade.value = 0.5;
 * @category Component
 */
class CrossFade extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(CrossFade.getDefaults(), arguments, ["fade"])));
    this.name = "CrossFade";
    /**
     * The crossfading is done by a StereoPannerNode
     */

    this._panner = this.context.createStereoPanner();
    /**
     * Split the output of the panner node into two values used to control the gains.
     */

    this._split = this.context.createChannelSplitter(2);
    /**
     * Convert the fade value into an audio range value so it can be connected
     * to the panner.pan AudioParam
     */

    this._g2a = new _GainToAudio.GainToAudio({
      context: this.context
    });
    /**
     * The input which is at full level when fade = 0
     */

    this.a = new _Gain.Gain({
      context: this.context,
      gain: 0
    });
    /**
     * The input which is at full level when fade = 1
     */

    this.b = new _Gain.Gain({
      context: this.context,
      gain: 0
    });
    /**
     * The output is a mix between `a` and `b` at the ratio of `fade`
     */

    this.output = new _Gain.Gain({
      context: this.context
    });
    this._internalChannels = [this.a, this.b];
    const options = (0, _Defaults.optionsFromArguments)(CrossFade.getDefaults(), arguments, ["fade"]);
    this.fade = new _Signal.Signal({
      context: this.context,
      units: "normalRange",
      value: options.fade
    });
    (0, _Interface.readOnly)(this, "fade");
    this.context.getConstant(1).connect(this._panner);

    this._panner.connect(this._split); // this is necessary for standardized-audio-context
    // doesn't make any difference for the native AudioContext
    // https://github.com/chrisguttandin/standardized-audio-context/issues/647


    this._panner.channelCount = 1;
    this._panner.channelCountMode = "explicit";
    (0, _ToneAudioNode.connect)(this._split, this.a.gain, 0);
    (0, _ToneAudioNode.connect)(this._split, this.b.gain, 1);
    this.fade.chain(this._g2a, this._panner.pan);
    this.a.connect(this.output);
    this.b.connect(this.output);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      fade: 0.5
    });
  }

  dispose() {
    super.dispose();
    this.a.dispose();
    this.b.dispose();
    this.output.dispose();
    this.fade.dispose();

    this._g2a.dispose();

    this._panner.disconnect();

    this._split.disconnect();

    return this;
  }

}

exports.CrossFade = CrossFade;
},{"../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../signal/GainToAudio":"../node_modules/tone/build/esm/signal/GainToAudio.js","../../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js"}],"../node_modules/tone/build/esm/effect/Effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Effect = void 0;

var _CrossFade = require("../component/channel/CrossFade");

var _Gain = require("../core/context/Gain");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Interface = require("../core/util/Interface");

/**
 * Effect is the base class for effects. Connect the effect between
 * the effectSend and effectReturn GainNodes, then control the amount of
 * effect which goes to the output using the wet control.
 */
class Effect extends _ToneAudioNode.ToneAudioNode {
  constructor(options) {
    super(options);
    this.name = "Effect";
    /**
     * the drywet knob to control the amount of effect
     */

    this._dryWet = new _CrossFade.CrossFade({
      context: this.context
    });
    /**
     * The wet control is how much of the effected
     * will pass through to the output. 1 = 100% effected
     * signal, 0 = 100% dry signal.
     */

    this.wet = this._dryWet.fade;
    /**
     * connect the effectSend to the input of hte effect
     */

    this.effectSend = new _Gain.Gain({
      context: this.context
    });
    /**
     * connect the output of the effect to the effectReturn
     */

    this.effectReturn = new _Gain.Gain({
      context: this.context
    });
    /**
     * The effect input node
     */

    this.input = new _Gain.Gain({
      context: this.context
    });
    /**
     * The effect output
     */

    this.output = this._dryWet; // connections

    this.input.fan(this._dryWet.a, this.effectSend);
    this.effectReturn.connect(this._dryWet.b);
    this.wet.setValueAtTime(options.wet, 0);
    this._internalChannels = [this.effectReturn, this.effectSend];
    (0, _Interface.readOnly)(this, "wet");
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      wet: 1
    });
  }
  /**
   * chains the effect in between the effectSend and effectReturn
   */


  connectEffect(effect) {
    // add it to the internal channels
    this._internalChannels.push(effect);

    this.effectSend.chain(effect, this.effectReturn);
    return this;
  }

  dispose() {
    super.dispose();

    this._dryWet.dispose();

    this.effectSend.dispose();
    this.effectReturn.dispose();
    this.wet.dispose();
    return this;
  }

}

exports.Effect = Effect;
},{"../component/channel/CrossFade":"../node_modules/tone/build/esm/component/channel/CrossFade.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/LFOEffect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LFOEffect = void 0;

var _Effect = require("../effect/Effect");

var _LFO = require("../source/oscillator/LFO");

var _Interface = require("../core/util/Interface");

/**
 * Base class for LFO-based effects.
 */
class LFOEffect extends _Effect.Effect {
  constructor(options) {
    super(options);
    this.name = "LFOEffect";
    this._lfo = new _LFO.LFO({
      context: this.context,
      frequency: options.frequency,
      amplitude: options.depth
    });
    this.depth = this._lfo.amplitude;
    this.frequency = this._lfo.frequency;
    this.type = options.type;
    (0, _Interface.readOnly)(this, ["frequency", "depth"]);
  }

  static getDefaults() {
    return Object.assign(_Effect.Effect.getDefaults(), {
      frequency: 1,
      type: "sine",
      depth: 1
    });
  }
  /**
   * Start the effect.
   */


  start(time) {
    this._lfo.start(time);

    return this;
  }
  /**
   * Stop the lfo
   */


  stop(time) {
    this._lfo.stop(time);

    return this;
  }
  /**
   * Sync the filter to the transport. See [[LFO.sync]]
   */


  sync() {
    this._lfo.sync();

    return this;
  }
  /**
   * Unsync the filter from the transport.
   */


  unsync() {
    this._lfo.unsync();

    return this;
  }
  /**
   * The type of the LFO's oscillator: See [[Oscillator.type]]
   * @example
   * const autoFilter = new Tone.AutoFilter().start().toDestination();
   * const noise = new Tone.Noise().start().connect(autoFilter);
   * autoFilter.type = "square";
   */


  get type() {
    return this._lfo.type;
  }

  set type(type) {
    this._lfo.type = type;
  }

  dispose() {
    super.dispose();

    this._lfo.dispose();

    this.frequency.dispose();
    this.depth.dispose();
    return this;
  }

}

exports.LFOEffect = LFOEffect;
},{"../effect/Effect":"../node_modules/tone/build/esm/effect/Effect.js","../source/oscillator/LFO":"../node_modules/tone/build/esm/source/oscillator/LFO.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/AutoFilter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AutoFilter = void 0;

var _Filter = require("../component/filter/Filter");

var _Defaults = require("../core/util/Defaults");

var _LFOEffect = require("./LFOEffect");

/**
 * AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.
 * Setting the LFO rate and depth allows for control over the filter modulation rate
 * and depth.
 *
 * @example
 * // create an autofilter and start it's LFO
 * const autoFilter = new Tone.AutoFilter("4n").toDestination().start();
 * // route an oscillator through the filter and start it
 * const oscillator = new Tone.Oscillator().connect(autoFilter).start();
 * @category Effect
 */
class AutoFilter extends _LFOEffect.LFOEffect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(AutoFilter.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]));
    this.name = "AutoFilter";
    const options = (0, _Defaults.optionsFromArguments)(AutoFilter.getDefaults(), arguments, ["frequency", "baseFrequency", "octaves"]);
    this.filter = new _Filter.Filter(Object.assign(options.filter, {
      context: this.context
    })); // connections

    this.connectEffect(this.filter);

    this._lfo.connect(this.filter.frequency);

    this.octaves = options.octaves;
    this.baseFrequency = options.baseFrequency;
  }

  static getDefaults() {
    return Object.assign(_LFOEffect.LFOEffect.getDefaults(), {
      baseFrequency: 200,
      octaves: 2.6,
      filter: {
        type: "lowpass",
        rolloff: -12,
        Q: 1
      }
    });
  }
  /**
   * The minimum value of the filter's cutoff frequency.
   */


  get baseFrequency() {
    return this._lfo.min;
  }

  set baseFrequency(freq) {
    this._lfo.min = this.toFrequency(freq); // and set the max

    this.octaves = this._octaves;
  }
  /**
   * The maximum value of the filter's cutoff frequency.
   */


  get octaves() {
    return this._octaves;
  }

  set octaves(oct) {
    this._octaves = oct;
    this._lfo.max = this._lfo.min * Math.pow(2, oct);
  }

  dispose() {
    super.dispose();
    this.filter.dispose();
    return this;
  }

}

exports.AutoFilter = AutoFilter;
},{"../component/filter/Filter":"../node_modules/tone/build/esm/component/filter/Filter.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./LFOEffect":"../node_modules/tone/build/esm/effect/LFOEffect.js"}],"../node_modules/tone/build/esm/component/channel/Panner.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Panner = void 0;

var _Param = require("../../core/context/Param");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

/**
 * Panner is an equal power Left/Right Panner. It is a wrapper around the StereoPannerNode.
 * @example
 * return Tone.Offline(() => {
 * // move the input signal from right to left
 * 	const panner = new Tone.Panner(1).toDestination();
 * 	panner.pan.rampTo(-1, 0.5);
 * 	const osc = new Tone.Oscillator(100).connect(panner).start();
 * }, 0.5, 2);
 * @category Component
 */
class Panner extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(Panner.getDefaults(), arguments, ["pan"])));
    this.name = "Panner";
    /**
     * the panner node
     */

    this._panner = this.context.createStereoPanner();
    this.input = this._panner;
    this.output = this._panner;
    const options = (0, _Defaults.optionsFromArguments)(Panner.getDefaults(), arguments, ["pan"]);
    this.pan = new _Param.Param({
      context: this.context,
      param: this._panner.pan,
      value: options.pan,
      minValue: -1,
      maxValue: 1
    }); // this is necessary for standardized-audio-context
    // doesn't make any difference for the native AudioContext
    // https://github.com/chrisguttandin/standardized-audio-context/issues/647

    this._panner.channelCount = options.channelCount;
    this._panner.channelCountMode = "explicit"; // initial value

    (0, _Interface.readOnly)(this, "pan");
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      pan: 0,
      channelCount: 1
    });
  }

  dispose() {
    super.dispose();

    this._panner.disconnect();

    this.pan.dispose();
    return this;
  }

}

exports.Panner = Panner;
},{"../../core/context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/AutoPanner.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AutoPanner = void 0;

var _Panner = require("../component/channel/Panner");

var _Defaults = require("../core/util/Defaults");

var _LFOEffect = require("./LFOEffect");

/**
 * AutoPanner is a [[Panner]] with an [[LFO]] connected to the pan amount.
 * [Related Reading](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).
 *
 * @example
 * // create an autopanner and start it
 * const autoPanner = new Tone.AutoPanner("4n").toDestination().start();
 * // route an oscillator through the panner and start it
 * const oscillator = new Tone.Oscillator().connect(autoPanner).start();
 * @category Effect
 */
class AutoPanner extends _LFOEffect.LFOEffect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(AutoPanner.getDefaults(), arguments, ["frequency"]));
    this.name = "AutoPanner";
    const options = (0, _Defaults.optionsFromArguments)(AutoPanner.getDefaults(), arguments, ["frequency"]);
    this._panner = new _Panner.Panner({
      context: this.context,
      channelCount: options.channelCount
    }); // connections

    this.connectEffect(this._panner);

    this._lfo.connect(this._panner.pan);

    this._lfo.min = -1;
    this._lfo.max = 1;
  }

  static getDefaults() {
    return Object.assign(_LFOEffect.LFOEffect.getDefaults(), {
      channelCount: 1
    });
  }

  dispose() {
    super.dispose();

    this._panner.dispose();

    return this;
  }

}

exports.AutoPanner = AutoPanner;
},{"../component/channel/Panner":"../node_modules/tone/build/esm/component/channel/Panner.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./LFOEffect":"../node_modules/tone/build/esm/effect/LFOEffect.js"}],"../node_modules/tone/build/esm/component/analysis/Follower.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Follower = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _OnePoleFilter = require("../filter/OnePoleFilter");

var _Abs = require("../../signal/Abs");

/**
 * Follower is a simple envelope follower.
 * It's implemented by applying a lowpass filter to the absolute value of the incoming signal.
 * ```
 *          +-----+    +---------------+
 * Input +--> Abs +----> OnePoleFilter +--> Output
 *          +-----+    +---------------+
 * ```
 * @category Component
 */
class Follower extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Follower.getDefaults(), arguments, ["smoothing"]));
    this.name = "Follower";
    const options = (0, _Defaults.optionsFromArguments)(Follower.getDefaults(), arguments, ["smoothing"]);
    this._abs = this.input = new _Abs.Abs({
      context: this.context
    });
    this._lowpass = this.output = new _OnePoleFilter.OnePoleFilter({
      context: this.context,
      frequency: 1 / this.toSeconds(options.smoothing),
      type: "lowpass"
    });

    this._abs.connect(this._lowpass);

    this._smoothing = options.smoothing;
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      smoothing: 0.05
    });
  }
  /**
   * The amount of time it takes a value change to arrive at the updated value.
   */


  get smoothing() {
    return this._smoothing;
  }

  set smoothing(smoothing) {
    this._smoothing = smoothing;
    this._lowpass.frequency = 1 / this.toSeconds(this.smoothing);
  }

  dispose() {
    super.dispose();

    this._abs.dispose();

    this._lowpass.dispose();

    return this;
  }

}

exports.Follower = Follower;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../filter/OnePoleFilter":"../node_modules/tone/build/esm/component/filter/OnePoleFilter.js","../../signal/Abs":"../node_modules/tone/build/esm/signal/Abs.js"}],"../node_modules/tone/build/esm/effect/AutoWah.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AutoWah = void 0;

var _Effect = require("./Effect");

var _Filter = require("../component/filter/Filter");

var _Follower = require("../component/analysis/Follower");

var _Defaults = require("../core/util/Defaults");

var _Gain = require("../core/context/Gain");

var _Conversions = require("../core/type/Conversions");

var _ScaleExp = require("../signal/ScaleExp");

var _Interface = require("../core/util/Interface");

/**
 * AutoWah connects a [[Follower]] to a [[Filter]].
 * The frequency of the filter, follows the input amplitude curve.
 * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).
 *
 * @example
 * const autoWah = new Tone.AutoWah(50, 6, -30).toDestination();
 * // initialize the synth and connect to autowah
 * const synth = new Tone.Synth().connect(autoWah);
 * // Q value influences the effect of the wah - default is 2
 * autoWah.Q.value = 6;
 * // more audible on higher notes
 * synth.triggerAttackRelease("C4", "8n");
 * @category Effect
 */
class AutoWah extends _Effect.Effect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(AutoWah.getDefaults(), arguments, ["baseFrequency", "octaves", "sensitivity"]));
    this.name = "AutoWah";
    const options = (0, _Defaults.optionsFromArguments)(AutoWah.getDefaults(), arguments, ["baseFrequency", "octaves", "sensitivity"]);
    this._follower = new _Follower.Follower({
      context: this.context,
      smoothing: options.follower
    });
    this._sweepRange = new _ScaleExp.ScaleExp({
      context: this.context,
      min: 0,
      max: 1,
      exponent: 0.5
    });
    this._baseFrequency = this.toFrequency(options.baseFrequency);
    this._octaves = options.octaves;
    this._inputBoost = new _Gain.Gain({
      context: this.context
    });
    this._bandpass = new _Filter.Filter({
      context: this.context,
      rolloff: -48,
      frequency: 0,
      Q: options.Q
    });
    this._peaking = new _Filter.Filter({
      context: this.context,
      type: "peaking"
    });
    this._peaking.gain.value = options.gain;
    this.gain = this._peaking.gain;
    this.Q = this._bandpass.Q; // the control signal path

    this.effectSend.chain(this._inputBoost, this._follower, this._sweepRange);

    this._sweepRange.connect(this._bandpass.frequency);

    this._sweepRange.connect(this._peaking.frequency); // the filtered path


    this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn); // set the initial value

    this._setSweepRange();

    this.sensitivity = options.sensitivity;
    (0, _Interface.readOnly)(this, ["gain", "Q"]);
  }

  static getDefaults() {
    return Object.assign(_Effect.Effect.getDefaults(), {
      baseFrequency: 100,
      octaves: 6,
      sensitivity: 0,
      Q: 2,
      gain: 2,
      follower: 0.2
    });
  }
  /**
   * The number of octaves that the filter will sweep above the baseFrequency.
   */


  get octaves() {
    return this._octaves;
  }

  set octaves(octaves) {
    this._octaves = octaves;

    this._setSweepRange();
  }
  /**
   * The follower's smoothing time
   */


  get follower() {
    return this._follower.smoothing;
  }

  set follower(follower) {
    this._follower.smoothing = follower;
  }
  /**
   * The base frequency from which the sweep will start from.
   */


  get baseFrequency() {
    return this._baseFrequency;
  }

  set baseFrequency(baseFreq) {
    this._baseFrequency = this.toFrequency(baseFreq);

    this._setSweepRange();
  }
  /**
   * The sensitivity to control how responsive to the input signal the filter is.
   */


  get sensitivity() {
    return (0, _Conversions.gainToDb)(1 / this._inputBoost.gain.value);
  }

  set sensitivity(sensitivity) {
    this._inputBoost.gain.value = 1 / (0, _Conversions.dbToGain)(sensitivity);
  }
  /**
   * sets the sweep range of the scaler
   */


  _setSweepRange() {
    this._sweepRange.min = this._baseFrequency;
    this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);
  }

  dispose() {
    super.dispose();

    this._follower.dispose();

    this._sweepRange.dispose();

    this._bandpass.dispose();

    this._peaking.dispose();

    this._inputBoost.dispose();

    return this;
  }

}

exports.AutoWah = AutoWah;
},{"./Effect":"../node_modules/tone/build/esm/effect/Effect.js","../component/filter/Filter":"../node_modules/tone/build/esm/component/filter/Filter.js","../component/analysis/Follower":"../node_modules/tone/build/esm/component/analysis/Follower.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/type/Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js","../signal/ScaleExp":"../node_modules/tone/build/esm/signal/ScaleExp.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/BitCrusher.worklet.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.workletName = exports.bitCrusherWorklet = void 0;

require("../core/worklet/SingleIOProcessor.worklet");

var _WorkletGlobalScope = require("../core/worklet/WorkletGlobalScope");

const workletName = "bit-crusher";
exports.workletName = workletName;
const bitCrusherWorklet =
/* javascript */
`
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;
exports.bitCrusherWorklet = bitCrusherWorklet;
(0, _WorkletGlobalScope.registerProcessor)(workletName, bitCrusherWorklet);
},{"../core/worklet/SingleIOProcessor.worklet":"../node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js","../core/worklet/WorkletGlobalScope":"../node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js"}],"../node_modules/tone/build/esm/effect/BitCrusher.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BitCrusher = void 0;

var _ToneAudioWorklet = require("../core/worklet/ToneAudioWorklet");

var _Effect = require("./Effect");

var _Gain = require("../core/context/Gain");

var _Defaults = require("../core/util/Defaults");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _Param = require("../core/context/Param");

var _BitCrusher = require("./BitCrusher.worklet");

/**
 * BitCrusher down-samples the incoming signal to a different bit depth.
 * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing
 * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).
 * @example
 * // initialize crusher and route a synth through it
 * const crusher = new Tone.BitCrusher(4).toDestination();
 * const synth = new Tone.Synth().connect(crusher);
 * synth.triggerAttackRelease("C2", 2);
 *
 * @category Effect
 */
class BitCrusher extends _Effect.Effect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(BitCrusher.getDefaults(), arguments, ["bits"]));
    this.name = "BitCrusher";
    const options = (0, _Defaults.optionsFromArguments)(BitCrusher.getDefaults(), arguments, ["bits"]);
    this._bitCrusherWorklet = new BitCrusherWorklet({
      context: this.context,
      bits: options.bits
    }); // connect it up

    this.connectEffect(this._bitCrusherWorklet);
    this.bits = this._bitCrusherWorklet.bits;
  }

  static getDefaults() {
    return Object.assign(_Effect.Effect.getDefaults(), {
      bits: 4
    });
  }

  dispose() {
    super.dispose();

    this._bitCrusherWorklet.dispose();

    return this;
  }

}
/**
 * Internal class which creates an AudioWorklet to do the bit crushing
 */


exports.BitCrusher = BitCrusher;

class BitCrusherWorklet extends _ToneAudioWorklet.ToneAudioWorklet {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(BitCrusherWorklet.getDefaults(), arguments));
    this.name = "BitCrusherWorklet";
    const options = (0, _Defaults.optionsFromArguments)(BitCrusherWorklet.getDefaults(), arguments);
    this.input = new _Gain.Gain({
      context: this.context
    });
    this.output = new _Gain.Gain({
      context: this.context
    });
    this.bits = new _Param.Param({
      context: this.context,
      value: options.bits,
      units: "positive",
      minValue: 1,
      maxValue: 16,
      param: this._dummyParam,
      swappable: true
    });
  }

  static getDefaults() {
    return Object.assign(_ToneAudioWorklet.ToneAudioWorklet.getDefaults(), {
      bits: 12
    });
  }

  _audioWorkletName() {
    return _BitCrusher.workletName;
  }

  onReady(node) {
    (0, _ToneAudioNode.connectSeries)(this.input, node, this.output);
    const bits = node.parameters.get("bits");
    this.bits.setParam(bits);
  }

  dispose() {
    super.dispose();
    this.input.dispose();
    this.output.dispose();
    this.bits.dispose();
    return this;
  }

}
},{"../core/worklet/ToneAudioWorklet":"../node_modules/tone/build/esm/core/worklet/ToneAudioWorklet.js","./Effect":"../node_modules/tone/build/esm/effect/Effect.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../core/context/Param":"../node_modules/tone/build/esm/core/context/Param.js","./BitCrusher.worklet":"../node_modules/tone/build/esm/effect/BitCrusher.worklet.js"}],"../node_modules/tone/build/esm/effect/Chebyshev.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chebyshev = void 0;

var _Effect = require("./Effect");

var _Defaults = require("../core/util/Defaults");

var _WaveShaper = require("../signal/WaveShaper");

/**
 * Chebyshev is a waveshaper which is good
 * for making different types of distortion sounds.
 * Note that odd orders sound very different from even ones,
 * and order = 1 is no change.
 * Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).
 * @example
 * // create a new cheby
 * const cheby = new Tone.Chebyshev(50).toDestination();
 * // create a monosynth connected to our cheby
 * const synth = new Tone.MonoSynth().connect(cheby);
 * synth.triggerAttackRelease("C2", 0.4);
 * @category Effect
 */
class Chebyshev extends _Effect.Effect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Chebyshev.getDefaults(), arguments, ["order"]));
    this.name = "Chebyshev";
    const options = (0, _Defaults.optionsFromArguments)(Chebyshev.getDefaults(), arguments, ["order"]);
    this._shaper = new _WaveShaper.WaveShaper({
      context: this.context,
      length: 4096
    });
    this._order = options.order;
    this.connectEffect(this._shaper);
    this.order = options.order;
    this.oversample = options.oversample;
  }

  static getDefaults() {
    return Object.assign(_Effect.Effect.getDefaults(), {
      order: 1,
      oversample: "none"
    });
  }
  /**
   * get the coefficient for that degree
   * @param  x the x value
   * @param  degree
   * @param  memo memoize the computed value. this speeds up computation greatly.
   */


  _getCoefficient(x, degree, memo) {
    if (memo.has(degree)) {
      return memo.get(degree);
    } else if (degree === 0) {
      memo.set(degree, 0);
    } else if (degree === 1) {
      memo.set(degree, x);
    } else {
      memo.set(degree, 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo));
    }

    return memo.get(degree);
  }
  /**
   * The order of the Chebyshev polynomial which creates the equation which is applied to the incoming
   * signal through a Tone.WaveShaper. The equations are in the form:
   * ```
   * order 2: 2x^2 + 1
   * order 3: 4x^3 + 3x
   * ```
   * @min 1
   * @max 100
   */


  get order() {
    return this._order;
  }

  set order(order) {
    this._order = order;

    this._shaper.setMap(x => {
      return this._getCoefficient(x, order, new Map());
    });
  }
  /**
   * The oversampling of the effect. Can either be "none", "2x" or "4x".
   */


  get oversample() {
    return this._shaper.oversample;
  }

  set oversample(oversampling) {
    this._shaper.oversample = oversampling;
  }

  dispose() {
    super.dispose();

    this._shaper.dispose();

    return this;
  }

}

exports.Chebyshev = Chebyshev;
},{"./Effect":"../node_modules/tone/build/esm/effect/Effect.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../signal/WaveShaper":"../node_modules/tone/build/esm/signal/WaveShaper.js"}],"../node_modules/tone/build/esm/component/channel/Split.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Split = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

/**
 * Split splits an incoming signal into the number of given channels.
 *
 * @example
 * const split = new Tone.Split();
 * // stereoSignal.connect(split);
 * @category Component
 */
class Split extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Split.getDefaults(), arguments, ["channels"]));
    this.name = "Split";
    const options = (0, _Defaults.optionsFromArguments)(Split.getDefaults(), arguments, ["channels"]);
    this._splitter = this.input = this.output = this.context.createChannelSplitter(options.channels);
    this._internalChannels = [this._splitter];
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      channels: 2
    });
  }

  dispose() {
    super.dispose();

    this._splitter.disconnect();

    return this;
  }

}

exports.Split = Split;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js"}],"../node_modules/tone/build/esm/component/channel/Merge.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Merge = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

/**
 * Merge brings multiple mono input channels into a single multichannel output channel.
 *
 * @example
 * const merge = new Tone.Merge().toDestination();
 * // routing a sine tone in the left channel
 * const osc = new Tone.Oscillator().connect(merge, 0, 0).start();
 * // and noise in the right channel
 * const noise = new Tone.Noise().connect(merge, 0, 1).start();;
 * @category Component
 */
class Merge extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Merge.getDefaults(), arguments, ["channels"]));
    this.name = "Merge";
    const options = (0, _Defaults.optionsFromArguments)(Merge.getDefaults(), arguments, ["channels"]);
    this._merger = this.output = this.input = this.context.createChannelMerger(options.channels);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      channels: 2
    });
  }

  dispose() {
    super.dispose();

    this._merger.disconnect();

    return this;
  }

}

exports.Merge = Merge;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js"}],"../node_modules/tone/build/esm/effect/StereoEffect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StereoEffect = void 0;

var _ToneAudioNode = require("../core/context/ToneAudioNode");

var _CrossFade = require("../component/channel/CrossFade");

var _Split = require("../component/channel/Split");

var _Gain = require("../core/context/Gain");

var _Merge = require("../component/channel/Merge");

var _Interface = require("../core/util/Interface");

/**
 * Base class for Stereo effects.
 */
class StereoEffect extends _ToneAudioNode.ToneAudioNode {
  constructor(options) {
    super(options);
    this.name = "StereoEffect";
    this.input = new _Gain.Gain({
      context: this.context
    }); // force mono sources to be stereo

    this.input.channelCount = 2;
    this.input.channelCountMode = "explicit";
    this._dryWet = this.output = new _CrossFade.CrossFade({
      context: this.context,
      fade: options.wet
    });
    this.wet = this._dryWet.fade;
    this._split = new _Split.Split({
      context: this.context,
      channels: 2
    });
    this._merge = new _Merge.Merge({
      context: this.context,
      channels: 2
    }); // connections

    this.input.connect(this._split); // dry wet connections

    this.input.connect(this._dryWet.a);

    this._merge.connect(this._dryWet.b);

    (0, _Interface.readOnly)(this, ["wet"]);
  }
  /**
   * Connect the left part of the effect
   */


  connectEffectLeft(...nodes) {
    this._split.connect(nodes[0], 0, 0);

    (0, _ToneAudioNode.connectSeries)(...nodes);
    (0, _ToneAudioNode.connect)(nodes[nodes.length - 1], this._merge, 0, 0);
  }
  /**
   * Connect the right part of the effect
   */


  connectEffectRight(...nodes) {
    this._split.connect(nodes[0], 1, 0);

    (0, _ToneAudioNode.connectSeries)(...nodes);
    (0, _ToneAudioNode.connect)(nodes[nodes.length - 1], this._merge, 0, 1);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      wet: 1
    });
  }

  dispose() {
    super.dispose();

    this._dryWet.dispose();

    this._split.dispose();

    this._merge.dispose();

    return this;
  }

}

exports.StereoEffect = StereoEffect;
},{"../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../component/channel/CrossFade":"../node_modules/tone/build/esm/component/channel/CrossFade.js","../component/channel/Split":"../node_modules/tone/build/esm/component/channel/Split.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../component/channel/Merge":"../node_modules/tone/build/esm/component/channel/Merge.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/StereoFeedbackEffect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StereoFeedbackEffect = void 0;

var _StereoEffect = require("./StereoEffect");

var _Signal = require("../signal/Signal");

var _Gain = require("../core/context/Gain");

var _Interface = require("../core/util/Interface");

var _Split = require("../component/channel/Split");

var _Merge = require("../component/channel/Merge");

/**
 * Base class for stereo feedback effects where the effectReturn is fed back into the same channel.
 */
class StereoFeedbackEffect extends _StereoEffect.StereoEffect {
  constructor(options) {
    super(options);
    this.feedback = new _Signal.Signal({
      context: this.context,
      value: options.feedback,
      units: "normalRange"
    });
    this._feedbackL = new _Gain.Gain({
      context: this.context
    });
    this._feedbackR = new _Gain.Gain({
      context: this.context
    });
    this._feedbackSplit = new _Split.Split({
      context: this.context,
      channels: 2
    });
    this._feedbackMerge = new _Merge.Merge({
      context: this.context,
      channels: 2
    });

    this._merge.connect(this._feedbackSplit);

    this._feedbackMerge.connect(this._split); // the left output connected to the left input


    this._feedbackSplit.connect(this._feedbackL, 0, 0);

    this._feedbackL.connect(this._feedbackMerge, 0, 0); // the right output connected to the right input


    this._feedbackSplit.connect(this._feedbackR, 1, 0);

    this._feedbackR.connect(this._feedbackMerge, 0, 1); // the feedback control


    this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);
    (0, _Interface.readOnly)(this, ["feedback"]);
  }

  static getDefaults() {
    return Object.assign(_StereoEffect.StereoEffect.getDefaults(), {
      feedback: 0.5
    });
  }

  dispose() {
    super.dispose();
    this.feedback.dispose();

    this._feedbackL.dispose();

    this._feedbackR.dispose();

    this._feedbackSplit.dispose();

    this._feedbackMerge.dispose();

    return this;
  }

}

exports.StereoFeedbackEffect = StereoFeedbackEffect;
},{"./StereoEffect":"../node_modules/tone/build/esm/effect/StereoEffect.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../component/channel/Split":"../node_modules/tone/build/esm/component/channel/Split.js","../component/channel/Merge":"../node_modules/tone/build/esm/component/channel/Merge.js"}],"../node_modules/tone/build/esm/effect/Chorus.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chorus = void 0;

var _StereoFeedbackEffect = require("../effect/StereoFeedbackEffect");

var _Defaults = require("../core/util/Defaults");

var _LFO = require("../source/oscillator/LFO");

var _Delay = require("../core/context/Delay");

var _Interface = require("../core/util/Interface");

/**
 * Chorus is a stereo chorus effect composed of a left and right delay with an [[LFO]] applied to the delayTime of each channel.
 * When [[feedback]] is set to a value larger than 0, you also get Flanger-type effects.
 * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).
 * Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).
 *
 * @example
 * const chorus = new Tone.Chorus(4, 2.5, 0.5).toDestination().start();
 * const synth = new Tone.PolySynth().connect(chorus);
 * synth.triggerAttackRelease(["C3", "E3", "G3"], "8n");
 *
 * @category Effect
 */
class Chorus extends _StereoFeedbackEffect.StereoFeedbackEffect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Chorus.getDefaults(), arguments, ["frequency", "delayTime", "depth"]));
    this.name = "Chorus";
    const options = (0, _Defaults.optionsFromArguments)(Chorus.getDefaults(), arguments, ["frequency", "delayTime", "depth"]);
    this._depth = options.depth;
    this._delayTime = options.delayTime / 1000;
    this._lfoL = new _LFO.LFO({
      context: this.context,
      frequency: options.frequency,
      min: 0,
      max: 1
    });
    this._lfoR = new _LFO.LFO({
      context: this.context,
      frequency: options.frequency,
      min: 0,
      max: 1,
      phase: 180
    });
    this._delayNodeL = new _Delay.Delay({
      context: this.context
    });
    this._delayNodeR = new _Delay.Delay({
      context: this.context
    });
    this.frequency = this._lfoL.frequency;
    (0, _Interface.readOnly)(this, ["frequency"]); // have one LFO frequency control the other

    this._lfoL.frequency.connect(this._lfoR.frequency); // connections


    this.connectEffectLeft(this._delayNodeL);
    this.connectEffectRight(this._delayNodeR); // lfo setup

    this._lfoL.connect(this._delayNodeL.delayTime);

    this._lfoR.connect(this._delayNodeR.delayTime); // set the initial values


    this.depth = this._depth;
    this.type = options.type;
    this.spread = options.spread;
  }

  static getDefaults() {
    return Object.assign(_StereoFeedbackEffect.StereoFeedbackEffect.getDefaults(), {
      frequency: 1.5,
      delayTime: 3.5,
      depth: 0.7,
      type: "sine",
      spread: 180,
      feedback: 0,
      wet: 0.5
    });
  }
  /**
   * The depth of the effect. A depth of 1 makes the delayTime
   * modulate between 0 and 2*delayTime (centered around the delayTime).
   */


  get depth() {
    return this._depth;
  }

  set depth(depth) {
    this._depth = depth;
    const deviation = this._delayTime * depth;
    this._lfoL.min = Math.max(this._delayTime - deviation, 0);
    this._lfoL.max = this._delayTime + deviation;
    this._lfoR.min = Math.max(this._delayTime - deviation, 0);
    this._lfoR.max = this._delayTime + deviation;
  }
  /**
   * The delayTime in milliseconds of the chorus. A larger delayTime
   * will give a more pronounced effect. Nominal range a delayTime
   * is between 2 and 20ms.
   */


  get delayTime() {
    return this._delayTime * 1000;
  }

  set delayTime(delayTime) {
    this._delayTime = delayTime / 1000;
    this.depth = this._depth;
  }
  /**
   * The oscillator type of the LFO.
   */


  get type() {
    return this._lfoL.type;
  }

  set type(type) {
    this._lfoL.type = type;
    this._lfoR.type = type;
  }
  /**
   * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
   * When set to 180, LFO's will be panned hard left and right respectively.
   */


  get spread() {
    return this._lfoR.phase - this._lfoL.phase;
  }

  set spread(spread) {
    this._lfoL.phase = 90 - spread / 2;
    this._lfoR.phase = spread / 2 + 90;
  }
  /**
   * Start the effect.
   */


  start(time) {
    this._lfoL.start(time);

    this._lfoR.start(time);

    return this;
  }
  /**
   * Stop the lfo
   */


  stop(time) {
    this._lfoL.stop(time);

    this._lfoR.stop(time);

    return this;
  }
  /**
   * Sync the filter to the transport. See [[LFO.sync]]
   */


  sync() {
    this._lfoL.sync();

    this._lfoR.sync();

    return this;
  }
  /**
   * Unsync the filter from the transport.
   */


  unsync() {
    this._lfoL.unsync();

    this._lfoR.unsync();

    return this;
  }

  dispose() {
    super.dispose();

    this._lfoL.dispose();

    this._lfoR.dispose();

    this._delayNodeL.dispose();

    this._delayNodeR.dispose();

    this.frequency.dispose();
    return this;
  }

}

exports.Chorus = Chorus;
},{"../effect/StereoFeedbackEffect":"../node_modules/tone/build/esm/effect/StereoFeedbackEffect.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../source/oscillator/LFO":"../node_modules/tone/build/esm/source/oscillator/LFO.js","../core/context/Delay":"../node_modules/tone/build/esm/core/context/Delay.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/Distortion.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Distortion = void 0;

var _Defaults = require("../core/util/Defaults");

var _WaveShaper = require("../signal/WaveShaper");

var _Effect = require("./Effect");

/**
 * A simple distortion effect using Tone.WaveShaper.
 * Algorithm from [this stackoverflow answer](http://stackoverflow.com/a/22313408).
 *
 * @example
 * const dist = new Tone.Distortion(0.8).toDestination();
 * const fm = new Tone.FMSynth().connect(dist);
 * fm.triggerAttackRelease("A1", "8n");
 * @category Effect
 */
class Distortion extends _Effect.Effect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Distortion.getDefaults(), arguments, ["distortion"]));
    this.name = "Distortion";
    const options = (0, _Defaults.optionsFromArguments)(Distortion.getDefaults(), arguments, ["distortion"]);
    this._shaper = new _WaveShaper.WaveShaper({
      context: this.context,
      length: 4096
    });
    this._distortion = options.distortion;
    this.connectEffect(this._shaper);
    this.distortion = options.distortion;
    this.oversample = options.oversample;
  }

  static getDefaults() {
    return Object.assign(_Effect.Effect.getDefaults(), {
      distortion: 0.4,
      oversample: "none"
    });
  }
  /**
   * The amount of distortion. Nominal range is between 0 and 1.
   */


  get distortion() {
    return this._distortion;
  }

  set distortion(amount) {
    this._distortion = amount;
    const k = amount * 100;
    const deg = Math.PI / 180;

    this._shaper.setMap(x => {
      if (Math.abs(x) < 0.001) {
        // should output 0 when input is 0
        return 0;
      } else {
        return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
      }
    });
  }
  /**
   * The oversampling of the effect. Can either be "none", "2x" or "4x".
   */


  get oversample() {
    return this._shaper.oversample;
  }

  set oversample(oversampling) {
    this._shaper.oversample = oversampling;
  }

  dispose() {
    super.dispose();

    this._shaper.dispose();

    return this;
  }

}

exports.Distortion = Distortion;
},{"../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../signal/WaveShaper":"../node_modules/tone/build/esm/signal/WaveShaper.js","./Effect":"../node_modules/tone/build/esm/effect/Effect.js"}],"../node_modules/tone/build/esm/effect/FeedbackEffect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FeedbackEffect = void 0;

var _Gain = require("../core/context/Gain");

var _Interface = require("../core/util/Interface");

var _Effect = require("./Effect");

/**
 * FeedbackEffect provides a loop between an audio source and its own output.
 * This is a base-class for feedback effects.
 */
class FeedbackEffect extends _Effect.Effect {
  constructor(options) {
    super(options);
    this.name = "FeedbackEffect";
    this._feedbackGain = new _Gain.Gain({
      context: this.context,
      gain: options.feedback,
      units: "normalRange"
    });
    this.feedback = this._feedbackGain.gain;
    (0, _Interface.readOnly)(this, "feedback"); // the feedback loop

    this.effectReturn.chain(this._feedbackGain, this.effectSend);
  }

  static getDefaults() {
    return Object.assign(_Effect.Effect.getDefaults(), {
      feedback: 0.125
    });
  }

  dispose() {
    super.dispose();

    this._feedbackGain.dispose();

    this.feedback.dispose();
    return this;
  }

}

exports.FeedbackEffect = FeedbackEffect;
},{"../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","./Effect":"../node_modules/tone/build/esm/effect/Effect.js"}],"../node_modules/tone/build/esm/effect/FeedbackDelay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FeedbackDelay = void 0;

var _Delay = require("../core/context/Delay");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

var _FeedbackEffect = require("./FeedbackEffect");

/**
 * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.
 *
 * @param delayTime The delay applied to the incoming signal.
 * @param feedback The amount of the effected signal which is fed back through the delay.
 * @example
 * const feedbackDelay = new Tone.FeedbackDelay("8n", 0.5).toDestination();
 * const tom = new Tone.MembraneSynth({
 * 	octaves: 4,
 * 	pitchDecay: 0.1
 * }).connect(feedbackDelay);
 * tom.triggerAttackRelease("A2", "32n");
 * @category Effect
 */
class FeedbackDelay extends _FeedbackEffect.FeedbackEffect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(FeedbackDelay.getDefaults(), arguments, ["delayTime", "feedback"]));
    this.name = "FeedbackDelay";
    const options = (0, _Defaults.optionsFromArguments)(FeedbackDelay.getDefaults(), arguments, ["delayTime", "feedback"]);
    this._delayNode = new _Delay.Delay({
      context: this.context,
      delayTime: options.delayTime,
      maxDelay: options.maxDelay
    });
    this.delayTime = this._delayNode.delayTime; // connect it up

    this.connectEffect(this._delayNode);
    (0, _Interface.readOnly)(this, "delayTime");
  }

  static getDefaults() {
    return Object.assign(_FeedbackEffect.FeedbackEffect.getDefaults(), {
      delayTime: 0.25,
      maxDelay: 1
    });
  }

  dispose() {
    super.dispose();

    this._delayNode.dispose();

    this.delayTime.dispose();
    return this;
  }

}

exports.FeedbackDelay = FeedbackDelay;
},{"../core/context/Delay":"../node_modules/tone/build/esm/core/context/Delay.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","./FeedbackEffect":"../node_modules/tone/build/esm/effect/FeedbackEffect.js"}],"../node_modules/tone/build/esm/component/filter/PhaseShiftAllpass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhaseShiftAllpass = void 0;

var _Gain = require("../../core/context/Gain");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

/**
 * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform
 * using two Allpass filter banks whose outputs have a phase difference of 90°.
 * Here the `offset90` phase is offset by +90° in relation to `output`.
 * Coefficients and structure was developed by Olli Niemitalo.
 * For more details see: http://yehar.com/blog/?p=368
 * @category Component
 */
class PhaseShiftAllpass extends _ToneAudioNode.ToneAudioNode {
  constructor(options) {
    super(options);
    this.name = "PhaseShiftAllpass";
    this.input = new _Gain.Gain({
      context: this.context
    });
    /**
     * The phase shifted output
     */

    this.output = new _Gain.Gain({
      context: this.context
    });
    /**
     * The PhaseShifted allpass output
     */

    this.offset90 = new _Gain.Gain({
      context: this.context
    });
    const allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];
    const allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];
    this._bank0 = this._createAllPassFilterBank(allpassBank1Values);
    this._bank1 = this._createAllPassFilterBank(allpassBank2Values);
    this._oneSampleDelay = this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]); // connect Allpass filter banks

    (0, _ToneAudioNode.connectSeries)(this.input, ...this._bank0, this._oneSampleDelay, this.output);
    (0, _ToneAudioNode.connectSeries)(this.input, ...this._bank1, this.offset90);
  }
  /**
   * Create all of the IIR filters from an array of values using the coefficient calculation.
   */


  _createAllPassFilterBank(bankValues) {
    const nodes = bankValues.map(value => {
      const coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];
      return this.context.createIIRFilter(coefficients[0], coefficients[1]);
    });
    return nodes;
  }

  dispose() {
    super.dispose();
    this.input.dispose();
    this.output.dispose();
    this.offset90.dispose();

    this._bank0.forEach(f => f.disconnect());

    this._bank1.forEach(f => f.disconnect());

    this._oneSampleDelay.disconnect();

    return this;
  }

}

exports.PhaseShiftAllpass = PhaseShiftAllpass;
},{"../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js"}],"../node_modules/tone/build/esm/effect/FrequencyShifter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FrequencyShifter = void 0;

var _PhaseShiftAllpass = require("../component/filter/PhaseShiftAllpass");

var _Defaults = require("../core/util/Defaults");

var _Effect = require("../effect/Effect");

var _Add = require("../signal/Add");

var _Multiply = require("../signal/Multiply");

var _Negate = require("../signal/Negate");

var _Signal = require("../signal/Signal");

var _Oscillator = require("../source/oscillator/Oscillator");

var _ToneOscillatorNode = require("../source/oscillator/ToneOscillatorNode");

/**
 * FrequencyShifter can be used to shift all frequencies of a signal by a fixed amount.
 * The amount can be changed at audio rate and the effect is applied in real time.
 * The frequency shifting is implemented with a technique called single side band modulation using a ring modulator.
 * Note: Contrary to pitch shifting, all frequencies are shifted by the same amount,
 * destroying the harmonic relationship between them. This leads to the classic ring modulator timbre distortion.
 * The algorithm will produces some aliasing towards the high end, especially if your source material
 * contains a lot of high frequencies. Unfortunatelly the webaudio API does not support resampling
 * buffers in real time, so it is not possible to fix it properly. Depending on the use case it might
 * be an option to low pass filter your input before frequency shifting it to get ride of the aliasing.
 * You can find a very detailed description of the algorithm here: https://larzeitlin.github.io/RMFS/
 *
 * @example
 * const input = new Tone.Oscillator(230, "sawtooth").start();
 * const shift = new Tone.FrequencyShifter(42).toDestination();
 * input.connect(shift);
 * @category Effect
 */
class FrequencyShifter extends _Effect.Effect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(FrequencyShifter.getDefaults(), arguments, ["frequency"]));
    this.name = "FrequencyShifter";
    const options = (0, _Defaults.optionsFromArguments)(FrequencyShifter.getDefaults(), arguments, ["frequency"]);
    this.frequency = new _Signal.Signal({
      context: this.context,
      units: "frequency",
      value: options.frequency,
      minValue: -this.context.sampleRate / 2,
      maxValue: this.context.sampleRate / 2
    });
    this._sine = new _ToneOscillatorNode.ToneOscillatorNode({
      context: this.context,
      type: "sine"
    });
    this._cosine = new _Oscillator.Oscillator({
      context: this.context,
      phase: -90,
      type: "sine"
    });
    this._sineMultiply = new _Multiply.Multiply({
      context: this.context
    });
    this._cosineMultiply = new _Multiply.Multiply({
      context: this.context
    });
    this._negate = new _Negate.Negate({
      context: this.context
    });
    this._add = new _Add.Add({
      context: this.context
    });
    this._phaseShifter = new _PhaseShiftAllpass.PhaseShiftAllpass({
      context: this.context
    });
    this.effectSend.connect(this._phaseShifter); // connect the carrier frequency signal to the two oscillators

    this.frequency.fan(this._sine.frequency, this._cosine.frequency);

    this._phaseShifter.offset90.connect(this._cosineMultiply);

    this._cosine.connect(this._cosineMultiply.factor);

    this._phaseShifter.connect(this._sineMultiply);

    this._sine.connect(this._sineMultiply.factor);

    this._sineMultiply.connect(this._negate);

    this._cosineMultiply.connect(this._add);

    this._negate.connect(this._add.addend);

    this._add.connect(this.effectReturn); // start the oscillators at the same time


    const now = this.immediate();

    this._sine.start(now);

    this._cosine.start(now);
  }

  static getDefaults() {
    return Object.assign(_Effect.Effect.getDefaults(), {
      frequency: 0
    });
  }

  dispose() {
    super.dispose();
    this.frequency.dispose();

    this._add.dispose();

    this._cosine.dispose();

    this._cosineMultiply.dispose();

    this._negate.dispose();

    this._phaseShifter.dispose();

    this._sine.dispose();

    this._sineMultiply.dispose();

    return this;
  }

}

exports.FrequencyShifter = FrequencyShifter;
},{"../component/filter/PhaseShiftAllpass":"../node_modules/tone/build/esm/component/filter/PhaseShiftAllpass.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../effect/Effect":"../node_modules/tone/build/esm/effect/Effect.js","../signal/Add":"../node_modules/tone/build/esm/signal/Add.js","../signal/Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","../signal/Negate":"../node_modules/tone/build/esm/signal/Negate.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../source/oscillator/Oscillator":"../node_modules/tone/build/esm/source/oscillator/Oscillator.js","../source/oscillator/ToneOscillatorNode":"../node_modules/tone/build/esm/source/oscillator/ToneOscillatorNode.js"}],"../node_modules/tone/build/esm/effect/Freeverb.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Freeverb = void 0;

var _StereoEffect = require("./StereoEffect");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

var _Signal = require("../signal/Signal");

var _LowpassCombFilter = require("../component/filter/LowpassCombFilter");

/**
 * An array of comb filter delay values from Freeverb implementation
 */
const combFilterTunings = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100];
/**
 * An array of allpass filter frequency values from Freeverb implementation
 */

const allpassFilterFrequencies = [225, 556, 441, 341];
/**
 * Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).
 * Read more on reverb on [Sound On Sound](https://web.archive.org/web/20160404083902/http://www.soundonsound.com:80/sos/feb01/articles/synthsecrets.asp).
 * Freeverb is now implemented with an AudioWorkletNode which may result on performance degradation on some platforms. Consider using [[Reverb]].
 * @example
 * const freeverb = new Tone.Freeverb().toDestination();
 * freeverb.dampening = 1000;
 * // routing synth through the reverb
 * const synth = new Tone.NoiseSynth().connect(freeverb);
 * synth.triggerAttackRelease(0.05);
 * @category Effect
 */

class Freeverb extends _StereoEffect.StereoEffect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Freeverb.getDefaults(), arguments, ["roomSize", "dampening"]));
    this.name = "Freeverb";
    /**
     * the comb filters
     */

    this._combFilters = [];
    /**
     * the allpass filters on the left
     */

    this._allpassFiltersL = [];
    /**
     * the allpass filters on the right
     */

    this._allpassFiltersR = [];
    const options = (0, _Defaults.optionsFromArguments)(Freeverb.getDefaults(), arguments, ["roomSize", "dampening"]);
    this.roomSize = new _Signal.Signal({
      context: this.context,
      value: options.roomSize,
      units: "normalRange"
    }); // make the allpass filters on the right

    this._allpassFiltersL = allpassFilterFrequencies.map(freq => {
      const allpassL = this.context.createBiquadFilter();
      allpassL.type = "allpass";
      allpassL.frequency.value = freq;
      return allpassL;
    }); // make the allpass filters on the left

    this._allpassFiltersR = allpassFilterFrequencies.map(freq => {
      const allpassR = this.context.createBiquadFilter();
      allpassR.type = "allpass";
      allpassR.frequency.value = freq;
      return allpassR;
    }); // make the comb filters

    this._combFilters = combFilterTunings.map((delayTime, index) => {
      const lfpf = new _LowpassCombFilter.LowpassCombFilter({
        context: this.context,
        dampening: options.dampening,
        delayTime
      });

      if (index < combFilterTunings.length / 2) {
        this.connectEffectLeft(lfpf, ...this._allpassFiltersL);
      } else {
        this.connectEffectRight(lfpf, ...this._allpassFiltersR);
      }

      this.roomSize.connect(lfpf.resonance);
      return lfpf;
    });
    (0, _Interface.readOnly)(this, ["roomSize"]);
  }

  static getDefaults() {
    return Object.assign(_StereoEffect.StereoEffect.getDefaults(), {
      roomSize: 0.7,
      dampening: 3000
    });
  }
  /**
   * The amount of dampening of the reverberant signal.
   */


  get dampening() {
    return this._combFilters[0].dampening;
  }

  set dampening(d) {
    this._combFilters.forEach(c => c.dampening = d);
  }

  dispose() {
    super.dispose();

    this._allpassFiltersL.forEach(al => al.disconnect());

    this._allpassFiltersR.forEach(ar => ar.disconnect());

    this._combFilters.forEach(cf => cf.dispose());

    this.roomSize.dispose();
    return this;
  }

}

exports.Freeverb = Freeverb;
},{"./StereoEffect":"../node_modules/tone/build/esm/effect/StereoEffect.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../component/filter/LowpassCombFilter":"../node_modules/tone/build/esm/component/filter/LowpassCombFilter.js"}],"../node_modules/tone/build/esm/effect/JCReverb.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JCReverb = void 0;

var _StereoEffect = require("./StereoEffect");

var _Defaults = require("../core/util/Defaults");

var _Scale = require("../signal/Scale");

var _Signal = require("../signal/Signal");

var _FeedbackCombFilter = require("../component/filter/FeedbackCombFilter");

var _Interface = require("../core/util/Interface");

/**
 * an array of the comb filter delay time values
 */
const combFilterDelayTimes = [1687 / 25000, 1601 / 25000, 2053 / 25000, 2251 / 25000];
/**
 * the resonances of each of the comb filters
 */

const combFilterResonances = [0.773, 0.802, 0.753, 0.733];
/**
 * the allpass filter frequencies
 */

const allpassFilterFreqs = [347, 113, 37];
/**
 * JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)
 * tuned by John Chowning in 1970.
 * It is made up of three allpass filters and four [[FeedbackCombFilter]].
 * JCReverb is now implemented with an AudioWorkletNode which may result on performance degradation on some platforms. Consider using [[Reverb]].
 * @example
 * const reverb = new Tone.JCReverb(0.4).toDestination();
 * const delay = new Tone.FeedbackDelay(0.5);
 * // connecting the synth to reverb through delay
 * const synth = new Tone.DuoSynth().chain(delay, reverb);
 * synth.triggerAttackRelease("A4", "8n");
 *
 * @category Effect
 */

class JCReverb extends _StereoEffect.StereoEffect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(JCReverb.getDefaults(), arguments, ["roomSize"]));
    this.name = "JCReverb";
    /**
     * a series of allpass filters
     */

    this._allpassFilters = [];
    /**
     * parallel feedback comb filters
     */

    this._feedbackCombFilters = [];
    const options = (0, _Defaults.optionsFromArguments)(JCReverb.getDefaults(), arguments, ["roomSize"]);
    this.roomSize = new _Signal.Signal({
      context: this.context,
      value: options.roomSize,
      units: "normalRange"
    });
    this._scaleRoomSize = new _Scale.Scale({
      context: this.context,
      min: -0.733,
      max: 0.197
    }); // make the allpass filters

    this._allpassFilters = allpassFilterFreqs.map(freq => {
      const allpass = this.context.createBiquadFilter();
      allpass.type = "allpass";
      allpass.frequency.value = freq;
      return allpass;
    }); // and the comb filters

    this._feedbackCombFilters = combFilterDelayTimes.map((delayTime, index) => {
      const fbcf = new _FeedbackCombFilter.FeedbackCombFilter({
        context: this.context,
        delayTime
      });

      this._scaleRoomSize.connect(fbcf.resonance);

      fbcf.resonance.value = combFilterResonances[index];

      if (index < combFilterDelayTimes.length / 2) {
        this.connectEffectLeft(...this._allpassFilters, fbcf);
      } else {
        this.connectEffectRight(...this._allpassFilters, fbcf);
      }

      return fbcf;
    }); // chain the allpass filters together

    this.roomSize.connect(this._scaleRoomSize);
    (0, _Interface.readOnly)(this, ["roomSize"]);
  }

  static getDefaults() {
    return Object.assign(_StereoEffect.StereoEffect.getDefaults(), {
      roomSize: 0.5
    });
  }

  dispose() {
    super.dispose();

    this._allpassFilters.forEach(apf => apf.disconnect());

    this._feedbackCombFilters.forEach(fbcf => fbcf.dispose());

    this.roomSize.dispose();

    this._scaleRoomSize.dispose();

    return this;
  }

}

exports.JCReverb = JCReverb;
},{"./StereoEffect":"../node_modules/tone/build/esm/effect/StereoEffect.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../signal/Scale":"../node_modules/tone/build/esm/signal/Scale.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../component/filter/FeedbackCombFilter":"../node_modules/tone/build/esm/component/filter/FeedbackCombFilter.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/StereoXFeedbackEffect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StereoXFeedbackEffect = void 0;

var _StereoFeedbackEffect = require("./StereoFeedbackEffect");

var _Interface = require("../core/util/Interface");

/**
 * Just like a [[StereoFeedbackEffect]], but the feedback is routed from left to right
 * and right to left instead of on the same channel.
 * ```
 * +--------------------------------+ feedbackL <-----------------------------------+
 * |                                                                                |
 * +-->                          +----->        +---->                          +-----+
 *      feedbackMerge +--> split        (EFFECT)       merge +--> feedbackSplit     | |
 * +-->                          +----->        +---->                          +---+ |
 * |                                                                                  |
 * +--------------------------------+ feedbackR <-------------------------------------+
 * ```
 */
class StereoXFeedbackEffect extends _StereoFeedbackEffect.StereoFeedbackEffect {
  constructor(options) {
    super(options); // the left output connected to the right input

    this._feedbackL.disconnect();

    this._feedbackL.connect(this._feedbackMerge, 0, 1); // the left output connected to the right input


    this._feedbackR.disconnect();

    this._feedbackR.connect(this._feedbackMerge, 0, 0);

    (0, _Interface.readOnly)(this, ["feedback"]);
  }

}

exports.StereoXFeedbackEffect = StereoXFeedbackEffect;
},{"./StereoFeedbackEffect":"../node_modules/tone/build/esm/effect/StereoFeedbackEffect.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/PingPongDelay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PingPongDelay = void 0;

var _StereoXFeedbackEffect = require("./StereoXFeedbackEffect");

var _Defaults = require("../core/util/Defaults");

var _Delay = require("../core/context/Delay");

var _Signal = require("../signal/Signal");

var _Interface = require("../core/util/Interface");

/**
 * PingPongDelay is a feedback delay effect where the echo is heard
 * first in one channel and next in the opposite channel. In a stereo
 * system these are the right and left channels.
 * PingPongDelay in more simplified terms is two Tone.FeedbackDelays
 * with independent delay values. Each delay is routed to one channel
 * (left or right), and the channel triggered second will always
 * trigger at the same interval after the first.
 * @example
 * const pingPong = new Tone.PingPongDelay("4n", 0.2).toDestination();
 * const drum = new Tone.MembraneSynth().connect(pingPong);
 * drum.triggerAttackRelease("C4", "32n");
 * @category Effect
 */
class PingPongDelay extends _StereoXFeedbackEffect.StereoXFeedbackEffect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(PingPongDelay.getDefaults(), arguments, ["delayTime", "feedback"]));
    this.name = "PingPongDelay";
    const options = (0, _Defaults.optionsFromArguments)(PingPongDelay.getDefaults(), arguments, ["delayTime", "feedback"]);
    this._leftDelay = new _Delay.Delay({
      context: this.context,
      maxDelay: options.maxDelay
    });
    this._rightDelay = new _Delay.Delay({
      context: this.context,
      maxDelay: options.maxDelay
    });
    this._rightPreDelay = new _Delay.Delay({
      context: this.context,
      maxDelay: options.maxDelay
    });
    this.delayTime = new _Signal.Signal({
      context: this.context,
      units: "time",
      value: options.delayTime
    }); // connect it up

    this.connectEffectLeft(this._leftDelay);
    this.connectEffectRight(this._rightPreDelay, this._rightDelay);
    this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime); // rearranged the feedback to be after the rightPreDelay

    this._feedbackL.disconnect();

    this._feedbackL.connect(this._rightDelay);

    (0, _Interface.readOnly)(this, ["delayTime"]);
  }

  static getDefaults() {
    return Object.assign(_StereoXFeedbackEffect.StereoXFeedbackEffect.getDefaults(), {
      delayTime: 0.25,
      maxDelay: 1
    });
  }

  dispose() {
    super.dispose();

    this._leftDelay.dispose();

    this._rightDelay.dispose();

    this._rightPreDelay.dispose();

    this.delayTime.dispose();
    return this;
  }

}

exports.PingPongDelay = PingPongDelay;
},{"./StereoXFeedbackEffect":"../node_modules/tone/build/esm/effect/StereoXFeedbackEffect.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/context/Delay":"../node_modules/tone/build/esm/core/context/Delay.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/PitchShift.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PitchShift = void 0;

var _FeedbackEffect = require("./FeedbackEffect");

var _Defaults = require("../core/util/Defaults");

var _LFO = require("../source/oscillator/LFO");

var _Delay = require("../core/context/Delay");

var _CrossFade = require("../component/channel/CrossFade");

var _Signal = require("../signal/Signal");

var _Interface = require("../core/util/Interface");

var _Conversions = require("../core/type/Conversions");

/**
 * PitchShift does near-realtime pitch shifting to the incoming signal.
 * The effect is achieved by speeding up or slowing down the delayTime
 * of a DelayNode using a sawtooth wave.
 * Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).
 * Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).
 * @category Effect
 */
class PitchShift extends _FeedbackEffect.FeedbackEffect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(PitchShift.getDefaults(), arguments, ["pitch"]));
    this.name = "PitchShift";
    const options = (0, _Defaults.optionsFromArguments)(PitchShift.getDefaults(), arguments, ["pitch"]);
    this._frequency = new _Signal.Signal({
      context: this.context
    });
    this._delayA = new _Delay.Delay({
      maxDelay: 1,
      context: this.context
    });
    this._lfoA = new _LFO.LFO({
      context: this.context,
      min: 0,
      max: 0.1,
      type: "sawtooth"
    }).connect(this._delayA.delayTime);
    this._delayB = new _Delay.Delay({
      maxDelay: 1,
      context: this.context
    });
    this._lfoB = new _LFO.LFO({
      context: this.context,
      min: 0,
      max: 0.1,
      type: "sawtooth",
      phase: 180
    }).connect(this._delayB.delayTime);
    this._crossFade = new _CrossFade.CrossFade({
      context: this.context
    });
    this._crossFadeLFO = new _LFO.LFO({
      context: this.context,
      min: 0,
      max: 1,
      type: "triangle",
      phase: 90
    }).connect(this._crossFade.fade);
    this._feedbackDelay = new _Delay.Delay({
      delayTime: options.delayTime,
      context: this.context
    });
    this.delayTime = this._feedbackDelay.delayTime;
    (0, _Interface.readOnly)(this, "delayTime");
    this._pitch = options.pitch;
    this._windowSize = options.windowSize; // connect the two delay lines up

    this._delayA.connect(this._crossFade.a);

    this._delayB.connect(this._crossFade.b); // connect the frequency


    this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency); // route the input


    this.effectSend.fan(this._delayA, this._delayB);

    this._crossFade.chain(this._feedbackDelay, this.effectReturn); // start the LFOs at the same time


    const now = this.now();

    this._lfoA.start(now);

    this._lfoB.start(now);

    this._crossFadeLFO.start(now); // set the initial value


    this.windowSize = this._windowSize;
  }

  static getDefaults() {
    return Object.assign(_FeedbackEffect.FeedbackEffect.getDefaults(), {
      pitch: 0,
      windowSize: 0.1,
      delayTime: 0,
      feedback: 0
    });
  }
  /**
   * Repitch the incoming signal by some interval (measured in semi-tones).
   * @example
   * const pitchShift = new Tone.PitchShift().toDestination();
   * const osc = new Tone.Oscillator().connect(pitchShift).start().toDestination();
   * pitchShift.pitch = -12; // down one octave
   * pitchShift.pitch = 7; // up a fifth
   */


  get pitch() {
    return this._pitch;
  }

  set pitch(interval) {
    this._pitch = interval;
    let factor = 0;

    if (interval < 0) {
      this._lfoA.min = 0;
      this._lfoA.max = this._windowSize;
      this._lfoB.min = 0;
      this._lfoB.max = this._windowSize;
      factor = (0, _Conversions.intervalToFrequencyRatio)(interval - 1) + 1;
    } else {
      this._lfoA.min = this._windowSize;
      this._lfoA.max = 0;
      this._lfoB.min = this._windowSize;
      this._lfoB.max = 0;
      factor = (0, _Conversions.intervalToFrequencyRatio)(interval) - 1;
    }

    this._frequency.value = factor * (1.2 / this._windowSize);
  }
  /**
   * The window size corresponds roughly to the sample length in a looping sampler.
   * Smaller values are desirable for a less noticeable delay time of the pitch shifted
   * signal, but larger values will result in smoother pitch shifting for larger intervals.
   * A nominal range of 0.03 to 0.1 is recommended.
   */


  get windowSize() {
    return this._windowSize;
  }

  set windowSize(size) {
    this._windowSize = this.toSeconds(size);
    this.pitch = this._pitch;
  }

  dispose() {
    super.dispose();

    this._frequency.dispose();

    this._delayA.dispose();

    this._delayB.dispose();

    this._lfoA.dispose();

    this._lfoB.dispose();

    this._crossFade.dispose();

    this._crossFadeLFO.dispose();

    this._feedbackDelay.dispose();

    return this;
  }

}

exports.PitchShift = PitchShift;
},{"./FeedbackEffect":"../node_modules/tone/build/esm/effect/FeedbackEffect.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../source/oscillator/LFO":"../node_modules/tone/build/esm/source/oscillator/LFO.js","../core/context/Delay":"../node_modules/tone/build/esm/core/context/Delay.js","../component/channel/CrossFade":"../node_modules/tone/build/esm/component/channel/CrossFade.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../core/type/Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js"}],"../node_modules/tone/build/esm/effect/Phaser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Phaser = void 0;

var _StereoEffect = require("./StereoEffect");

var _Defaults = require("../core/util/Defaults");

var _LFO = require("../source/oscillator/LFO");

var _Signal = require("../signal/Signal");

var _Interface = require("../core/util/Interface");

/**
 * Phaser is a phaser effect. Phasers work by changing the phase
 * of different frequency components of an incoming signal. Read more on
 * [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)).
 * Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).
 * @example
 * const phaser = new Tone.Phaser({
 * 	frequency: 15,
 * 	octaves: 5,
 * 	baseFrequency: 1000
 * }).toDestination();
 * const synth = new Tone.FMSynth().connect(phaser);
 * synth.triggerAttackRelease("E3", "2n");
 * @category Effect
 */
class Phaser extends _StereoEffect.StereoEffect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Phaser.getDefaults(), arguments, ["frequency", "octaves", "baseFrequency"]));
    this.name = "Phaser";
    const options = (0, _Defaults.optionsFromArguments)(Phaser.getDefaults(), arguments, ["frequency", "octaves", "baseFrequency"]);
    this._lfoL = new _LFO.LFO({
      context: this.context,
      frequency: options.frequency,
      min: 0,
      max: 1
    });
    this._lfoR = new _LFO.LFO({
      context: this.context,
      frequency: options.frequency,
      min: 0,
      max: 1,
      phase: 180
    });
    this._baseFrequency = this.toFrequency(options.baseFrequency);
    this._octaves = options.octaves;
    this.Q = new _Signal.Signal({
      context: this.context,
      value: options.Q,
      units: "positive"
    });
    this._filtersL = this._makeFilters(options.stages, this._lfoL);
    this._filtersR = this._makeFilters(options.stages, this._lfoR);
    this.frequency = this._lfoL.frequency;
    this.frequency.value = options.frequency; // connect them up

    this.connectEffectLeft(...this._filtersL);
    this.connectEffectRight(...this._filtersR); // control the frequency with one LFO

    this._lfoL.frequency.connect(this._lfoR.frequency); // set the options


    this.baseFrequency = options.baseFrequency;
    this.octaves = options.octaves; // start the lfo

    this._lfoL.start();

    this._lfoR.start();

    (0, _Interface.readOnly)(this, ["frequency", "Q"]);
  }

  static getDefaults() {
    return Object.assign(_StereoEffect.StereoEffect.getDefaults(), {
      frequency: 0.5,
      octaves: 3,
      stages: 10,
      Q: 10,
      baseFrequency: 350
    });
  }

  _makeFilters(stages, connectToFreq) {
    const filters = []; // make all the filters

    for (let i = 0; i < stages; i++) {
      const filter = this.context.createBiquadFilter();
      filter.type = "allpass";
      this.Q.connect(filter.Q);
      connectToFreq.connect(filter.frequency);
      filters.push(filter);
    }

    return filters;
  }
  /**
   * The number of octaves the phase goes above the baseFrequency
   */


  get octaves() {
    return this._octaves;
  }

  set octaves(octaves) {
    this._octaves = octaves;
    const max = this._baseFrequency * Math.pow(2, octaves);
    this._lfoL.max = max;
    this._lfoR.max = max;
  }
  /**
   * The the base frequency of the filters.
   */


  get baseFrequency() {
    return this._baseFrequency;
  }

  set baseFrequency(freq) {
    this._baseFrequency = this.toFrequency(freq);
    this._lfoL.min = this._baseFrequency;
    this._lfoR.min = this._baseFrequency;
    this.octaves = this._octaves;
  }

  dispose() {
    super.dispose();
    this.Q.dispose();

    this._lfoL.dispose();

    this._lfoR.dispose();

    this._filtersL.forEach(f => f.disconnect());

    this._filtersR.forEach(f => f.disconnect());

    this.frequency.dispose();
    return this;
  }

}

exports.Phaser = Phaser;
},{"./StereoEffect":"../node_modules/tone/build/esm/effect/StereoEffect.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../source/oscillator/LFO":"../node_modules/tone/build/esm/source/oscillator/LFO.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/Reverb.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Reverb = void 0;

var _tslib = require("tslib");

var _Merge = require("../component/channel/Merge");

var _Gain = require("../core/context/Gain");

var _Defaults = require("../core/util/Defaults");

var _Noise = require("../source/Noise");

var _Effect = require("./Effect");

var _OfflineContext = require("../core/context/OfflineContext");

var _Interface = require("../core/util/Interface");

var _Debug = require("../core/util/Debug");

/**
 * Simple convolution created with decaying noise.
 * Generates an Impulse Response Buffer
 * with Tone.Offline then feeds the IR into ConvolverNode.
 * The impulse response generation is async, so you have
 * to wait until [[ready]] resolves before it will make a sound.
 *
 * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).
 * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.
 *
 * @category Effect
 */
class Reverb extends _Effect.Effect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Reverb.getDefaults(), arguments, ["decay"]));
    this.name = "Reverb";
    /**
     * Convolver node
     */

    this._convolver = this.context.createConvolver();
    /**
     * Resolves when the reverb buffer is generated. Whenever either [[decay]]
     * or [[preDelay]] are set, you have to wait until [[ready]] resolves
     * before the IR is generated with the latest values.
     */

    this.ready = Promise.resolve();
    const options = (0, _Defaults.optionsFromArguments)(Reverb.getDefaults(), arguments, ["decay"]);
    this._decay = options.decay;
    this._preDelay = options.preDelay;
    this.generate();
    this.connectEffect(this._convolver);
  }

  static getDefaults() {
    return Object.assign(_Effect.Effect.getDefaults(), {
      decay: 1.5,
      preDelay: 0.01
    });
  }
  /**
   * The duration of the reverb.
   */


  get decay() {
    return this._decay;
  }

  set decay(time) {
    time = this.toSeconds(time);
    (0, _Debug.assertRange)(time, 0.001);
    this._decay = time;
    this.generate();
  }
  /**
   * The amount of time before the reverb is fully ramped in.
   */


  get preDelay() {
    return this._preDelay;
  }

  set preDelay(time) {
    time = this.toSeconds(time);
    (0, _Debug.assertRange)(time, 0);
    this._preDelay = time;
    this.generate();
  }
  /**
   * Generate the Impulse Response. Returns a promise while the IR is being generated.
   * @return Promise which returns this object.
   */


  generate() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      const previousReady = this.ready; // create a noise burst which decays over the duration in each channel

      const context = new _OfflineContext.OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);
      const noiseL = new _Noise.Noise({
        context
      });
      const noiseR = new _Noise.Noise({
        context
      });
      const merge = new _Merge.Merge({
        context
      });
      noiseL.connect(merge, 0, 0);
      noiseR.connect(merge, 0, 1);
      const gainNode = new _Gain.Gain({
        context
      }).toDestination();
      merge.connect(gainNode);
      noiseL.start(0);
      noiseR.start(0); // predelay

      gainNode.gain.setValueAtTime(0, 0);
      gainNode.gain.setValueAtTime(1, this._preDelay); // decay

      gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay); // render the buffer

      const renderPromise = context.render();
      this.ready = renderPromise.then(_Interface.noOp); // wait for the previous `ready` to resolve

      yield previousReady; // set the buffer

      this._convolver.buffer = (yield renderPromise).get();
      return this;
    });
  }

  dispose() {
    super.dispose();

    this._convolver.disconnect();

    return this;
  }

}

exports.Reverb = Reverb;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../component/channel/Merge":"../node_modules/tone/build/esm/component/channel/Merge.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../source/Noise":"../node_modules/tone/build/esm/source/Noise.js","./Effect":"../node_modules/tone/build/esm/effect/Effect.js","../core/context/OfflineContext":"../node_modules/tone/build/esm/core/context/OfflineContext.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/component/channel/MidSideSplit.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MidSideSplit = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Split = require("./Split");

var _Add = require("../../signal/Add");

var _Multiply = require("../../signal/Multiply");

var _Subtract = require("../../signal/Subtract");

var _Defaults = require("../../core/util/Defaults");

/**
 * Mid/Side processing separates the the 'mid' signal (which comes out of both the left and the right channel)
 * and the 'side' (which only comes out of the the side channels).
 * ```
 * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right
 * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and right
 * ```
 * @category Component
 */
class MidSideSplit extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(MidSideSplit.getDefaults(), arguments));
    this.name = "MidSideSplit";
    this._split = this.input = new _Split.Split({
      channels: 2,
      context: this.context
    });
    this._midAdd = new _Add.Add({
      context: this.context
    });
    this.mid = new _Multiply.Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });
    this._sideSubtract = new _Subtract.Subtract({
      context: this.context
    });
    this.side = new _Multiply.Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });

    this._split.connect(this._midAdd, 0);

    this._split.connect(this._midAdd.addend, 1);

    this._split.connect(this._sideSubtract, 0);

    this._split.connect(this._sideSubtract.subtrahend, 1);

    this._midAdd.connect(this.mid);

    this._sideSubtract.connect(this.side);
  }

  dispose() {
    super.dispose();
    this.mid.dispose();
    this.side.dispose();

    this._midAdd.dispose();

    this._sideSubtract.dispose();

    this._split.dispose();

    return this;
  }

}

exports.MidSideSplit = MidSideSplit;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","./Split":"../node_modules/tone/build/esm/component/channel/Split.js","../../signal/Add":"../node_modules/tone/build/esm/signal/Add.js","../../signal/Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","../../signal/Subtract":"../node_modules/tone/build/esm/signal/Subtract.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js"}],"../node_modules/tone/build/esm/component/channel/MidSideMerge.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MidSideMerge = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Merge = require("./Merge");

var _Add = require("../../signal/Add");

var _Multiply = require("../../signal/Multiply");

var _Subtract = require("../../signal/Subtract");

var _Gain = require("../../core/context/Gain");

var _Defaults = require("../../core/util/Defaults");

/**
 * MidSideMerge merges the mid and side signal after they've been separated by [[MidSideSplit]]
 * ```
 * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right
 * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and right
 * ```
 * @category Component
 */
class MidSideMerge extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(MidSideMerge.getDefaults(), arguments));
    this.name = "MidSideMerge";
    this.mid = new _Gain.Gain({
      context: this.context
    });
    this.side = new _Gain.Gain({
      context: this.context
    });
    this._left = new _Add.Add({
      context: this.context
    });
    this._leftMult = new _Multiply.Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });
    this._right = new _Subtract.Subtract({
      context: this.context
    });
    this._rightMult = new _Multiply.Multiply({
      context: this.context,
      value: Math.SQRT1_2
    });
    this._merge = this.output = new _Merge.Merge({
      context: this.context
    });
    this.mid.fan(this._left);
    this.side.connect(this._left.addend);
    this.mid.connect(this._right);
    this.side.connect(this._right.subtrahend);

    this._left.connect(this._leftMult);

    this._right.connect(this._rightMult);

    this._leftMult.connect(this._merge, 0, 0);

    this._rightMult.connect(this._merge, 0, 1);
  }

  dispose() {
    super.dispose();
    this.mid.dispose();
    this.side.dispose();

    this._leftMult.dispose();

    this._rightMult.dispose();

    this._left.dispose();

    this._right.dispose();

    return this;
  }

}

exports.MidSideMerge = MidSideMerge;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","./Merge":"../node_modules/tone/build/esm/component/channel/Merge.js","../../signal/Add":"../node_modules/tone/build/esm/signal/Add.js","../../signal/Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","../../signal/Subtract":"../node_modules/tone/build/esm/signal/Subtract.js","../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js"}],"../node_modules/tone/build/esm/effect/MidSideEffect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MidSideEffect = void 0;

var _Effect = require("./Effect");

var _MidSideSplit = require("../component/channel/MidSideSplit");

var _MidSideMerge = require("../component/channel/MidSideMerge");

/**
 * Mid/Side processing separates the the 'mid' signal
 * (which comes out of both the left and the right channel)
 * and the 'side' (which only comes out of the the side channels)
 * and effects them separately before being recombined.
 * Applies a Mid/Side seperation and recombination.
 * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
 * This is a base-class for Mid/Side Effects.
 * @category Effect
 */
class MidSideEffect extends _Effect.Effect {
  constructor(options) {
    super(options);
    this.name = "MidSideEffect";
    this._midSideMerge = new _MidSideMerge.MidSideMerge({
      context: this.context
    });
    this._midSideSplit = new _MidSideSplit.MidSideSplit({
      context: this.context
    });
    this._midSend = this._midSideSplit.mid;
    this._sideSend = this._midSideSplit.side;
    this._midReturn = this._midSideMerge.mid;
    this._sideReturn = this._midSideMerge.side; // the connections

    this.effectSend.connect(this._midSideSplit);

    this._midSideMerge.connect(this.effectReturn);
  }
  /**
   * Connect the mid chain of the effect
   */


  connectEffectMid(...nodes) {
    this._midSend.chain(...nodes, this._midReturn);
  }
  /**
   * Connect the side chain of the effect
   */


  connectEffectSide(...nodes) {
    this._sideSend.chain(...nodes, this._sideReturn);
  }

  dispose() {
    super.dispose();

    this._midSideSplit.dispose();

    this._midSideMerge.dispose();

    this._midSend.dispose();

    this._sideSend.dispose();

    this._midReturn.dispose();

    this._sideReturn.dispose();

    return this;
  }

}

exports.MidSideEffect = MidSideEffect;
},{"./Effect":"../node_modules/tone/build/esm/effect/Effect.js","../component/channel/MidSideSplit":"../node_modules/tone/build/esm/component/channel/MidSideSplit.js","../component/channel/MidSideMerge":"../node_modules/tone/build/esm/component/channel/MidSideMerge.js"}],"../node_modules/tone/build/esm/effect/StereoWidener.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StereoWidener = void 0;

var _MidSideEffect = require("../effect/MidSideEffect");

var _Signal = require("../signal/Signal");

var _Multiply = require("../signal/Multiply");

var _Subtract = require("../signal/Subtract");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

var _ToneAudioNode = require("../core/context/ToneAudioNode");

/**
 * Applies a width factor to the mid/side seperation.
 * 0 is all mid and 1 is all side.
 * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
 * ```
 * Mid *= 2*(1-width)<br>
 * Side *= 2*width
 * ```
 * @category Effect
 */
class StereoWidener extends _MidSideEffect.MidSideEffect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(StereoWidener.getDefaults(), arguments, ["width"]));
    this.name = "StereoWidener";
    const options = (0, _Defaults.optionsFromArguments)(StereoWidener.getDefaults(), arguments, ["width"]);
    this.width = new _Signal.Signal({
      context: this.context,
      value: options.width,
      units: "normalRange"
    });
    (0, _Interface.readOnly)(this, ["width"]);
    this._twoTimesWidthMid = new _Multiply.Multiply({
      context: this.context,
      value: 2
    });
    this._twoTimesWidthSide = new _Multiply.Multiply({
      context: this.context,
      value: 2
    });
    this._midMult = new _Multiply.Multiply({
      context: this.context
    });

    this._twoTimesWidthMid.connect(this._midMult.factor);

    this.connectEffectMid(this._midMult);
    this._oneMinusWidth = new _Subtract.Subtract({
      context: this.context
    });

    this._oneMinusWidth.connect(this._twoTimesWidthMid);

    (0, _ToneAudioNode.connect)(this.context.getConstant(1), this._oneMinusWidth);
    this.width.connect(this._oneMinusWidth.subtrahend);
    this._sideMult = new _Multiply.Multiply({
      context: this.context
    });
    this.width.connect(this._twoTimesWidthSide);

    this._twoTimesWidthSide.connect(this._sideMult.factor);

    this.connectEffectSide(this._sideMult);
  }

  static getDefaults() {
    return Object.assign(_MidSideEffect.MidSideEffect.getDefaults(), {
      width: 0.5
    });
  }

  dispose() {
    super.dispose();
    this.width.dispose();

    this._midMult.dispose();

    this._sideMult.dispose();

    this._twoTimesWidthMid.dispose();

    this._twoTimesWidthSide.dispose();

    this._oneMinusWidth.dispose();

    return this;
  }

}

exports.StereoWidener = StereoWidener;
},{"../effect/MidSideEffect":"../node_modules/tone/build/esm/effect/MidSideEffect.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../signal/Multiply":"../node_modules/tone/build/esm/signal/Multiply.js","../signal/Subtract":"../node_modules/tone/build/esm/signal/Subtract.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js"}],"../node_modules/tone/build/esm/effect/Tremolo.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tremolo = void 0;

var _StereoEffect = require("./StereoEffect");

var _LFO = require("../source/oscillator/LFO");

var _Gain = require("../core/context/Gain");

var _Signal = require("../signal/Signal");

var _Defaults = require("../core/util/Defaults");

var _Interface = require("../core/util/Interface");

/**
 * Tremolo modulates the amplitude of an incoming signal using an [[LFO]].
 * The effect is a stereo effect where the modulation phase is inverted in each channel.
 *
 * @example
 * // create a tremolo and start it's LFO
 * const tremolo = new Tone.Tremolo(9, 0.75).toDestination().start();
 * // route an oscillator through the tremolo and start it
 * const oscillator = new Tone.Oscillator().connect(tremolo).start();
 *
 * @category Effect
 */
class Tremolo extends _StereoEffect.StereoEffect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Tremolo.getDefaults(), arguments, ["frequency", "depth"]));
    this.name = "Tremolo";
    const options = (0, _Defaults.optionsFromArguments)(Tremolo.getDefaults(), arguments, ["frequency", "depth"]);
    this._lfoL = new _LFO.LFO({
      context: this.context,
      type: options.type,
      min: 1,
      max: 0
    });
    this._lfoR = new _LFO.LFO({
      context: this.context,
      type: options.type,
      min: 1,
      max: 0
    });
    this._amplitudeL = new _Gain.Gain({
      context: this.context
    });
    this._amplitudeR = new _Gain.Gain({
      context: this.context
    });
    this.frequency = new _Signal.Signal({
      context: this.context,
      value: options.frequency,
      units: "frequency"
    });
    this.depth = new _Signal.Signal({
      context: this.context,
      value: options.depth,
      units: "normalRange"
    });
    (0, _Interface.readOnly)(this, ["frequency", "depth"]);
    this.connectEffectLeft(this._amplitudeL);
    this.connectEffectRight(this._amplitudeR);

    this._lfoL.connect(this._amplitudeL.gain);

    this._lfoR.connect(this._amplitudeR.gain);

    this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);
    this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);
    this.spread = options.spread;
  }

  static getDefaults() {
    return Object.assign(_StereoEffect.StereoEffect.getDefaults(), {
      frequency: 10,
      type: "sine",
      depth: 0.5,
      spread: 180
    });
  }
  /**
   * Start the tremolo.
   */


  start(time) {
    this._lfoL.start(time);

    this._lfoR.start(time);

    return this;
  }
  /**
   * Stop the tremolo.
   */


  stop(time) {
    this._lfoL.stop(time);

    this._lfoR.stop(time);

    return this;
  }
  /**
   * Sync the effect to the transport.
   */


  sync() {
    this._lfoL.sync();

    this._lfoR.sync();

    this.context.transport.syncSignal(this.frequency);
    return this;
  }
  /**
   * Unsync the filter from the transport
   */


  unsync() {
    this._lfoL.unsync();

    this._lfoR.unsync();

    this.context.transport.unsyncSignal(this.frequency);
    return this;
  }
  /**
   * The oscillator type.
   */


  get type() {
    return this._lfoL.type;
  }

  set type(type) {
    this._lfoL.type = type;
    this._lfoR.type = type;
  }
  /**
   * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
   * When set to 180, LFO's will be panned hard left and right respectively.
   */


  get spread() {
    return this._lfoR.phase - this._lfoL.phase; // 180
  }

  set spread(spread) {
    this._lfoL.phase = 90 - spread / 2;
    this._lfoR.phase = spread / 2 + 90;
  }

  dispose() {
    super.dispose();

    this._lfoL.dispose();

    this._lfoR.dispose();

    this._amplitudeL.dispose();

    this._amplitudeR.dispose();

    this.frequency.dispose();
    this.depth.dispose();
    return this;
  }

}

exports.Tremolo = Tremolo;
},{"./StereoEffect":"../node_modules/tone/build/esm/effect/StereoEffect.js","../source/oscillator/LFO":"../node_modules/tone/build/esm/source/oscillator/LFO.js","../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/Vibrato.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Vibrato = void 0;

var _Effect = require("./Effect");

var _Defaults = require("../core/util/Defaults");

var _LFO = require("../source/oscillator/LFO");

var _Delay = require("../core/context/Delay");

var _Interface = require("../core/util/Interface");

/**
 * A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO
 * modulates the delayTime of the delay, causing the pitch to rise and fall.
 * @category Effect
 */
class Vibrato extends _Effect.Effect {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Vibrato.getDefaults(), arguments, ["frequency", "depth"]));
    this.name = "Vibrato";
    const options = (0, _Defaults.optionsFromArguments)(Vibrato.getDefaults(), arguments, ["frequency", "depth"]);
    this._delayNode = new _Delay.Delay({
      context: this.context,
      delayTime: 0,
      maxDelay: options.maxDelay
    });
    this._lfo = new _LFO.LFO({
      context: this.context,
      type: options.type,
      min: 0,
      max: options.maxDelay,
      frequency: options.frequency,
      phase: -90 // offse the phase so the resting position is in the center

    }).start().connect(this._delayNode.delayTime);
    this.frequency = this._lfo.frequency;
    this.depth = this._lfo.amplitude;
    this.depth.value = options.depth;
    (0, _Interface.readOnly)(this, ["frequency", "depth"]);
    this.effectSend.chain(this._delayNode, this.effectReturn);
  }

  static getDefaults() {
    return Object.assign(_Effect.Effect.getDefaults(), {
      maxDelay: 0.005,
      frequency: 5,
      depth: 0.1,
      type: "sine"
    });
  }
  /**
   * Type of oscillator attached to the Vibrato.
   */


  get type() {
    return this._lfo.type;
  }

  set type(type) {
    this._lfo.type = type;
  }

  dispose() {
    super.dispose();

    this._delayNode.dispose();

    this._lfo.dispose();

    this.frequency.dispose();
    this.depth.dispose();
    return this;
  }

}

exports.Vibrato = Vibrato;
},{"./Effect":"../node_modules/tone/build/esm/effect/Effect.js","../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../source/oscillator/LFO":"../node_modules/tone/build/esm/source/oscillator/LFO.js","../core/context/Delay":"../node_modules/tone/build/esm/core/context/Delay.js","../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/effect/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AutoFilter = require("./AutoFilter");

Object.keys(_AutoFilter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _AutoFilter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _AutoFilter[key];
    }
  });
});

var _AutoPanner = require("./AutoPanner");

Object.keys(_AutoPanner).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _AutoPanner[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _AutoPanner[key];
    }
  });
});

var _AutoWah = require("./AutoWah");

Object.keys(_AutoWah).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _AutoWah[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _AutoWah[key];
    }
  });
});

var _BitCrusher = require("./BitCrusher");

Object.keys(_BitCrusher).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _BitCrusher[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _BitCrusher[key];
    }
  });
});

var _Chebyshev = require("./Chebyshev");

Object.keys(_Chebyshev).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Chebyshev[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Chebyshev[key];
    }
  });
});

var _Chorus = require("./Chorus");

Object.keys(_Chorus).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Chorus[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Chorus[key];
    }
  });
});

var _Distortion = require("./Distortion");

Object.keys(_Distortion).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Distortion[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Distortion[key];
    }
  });
});

var _FeedbackDelay = require("./FeedbackDelay");

Object.keys(_FeedbackDelay).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _FeedbackDelay[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FeedbackDelay[key];
    }
  });
});

var _FrequencyShifter = require("./FrequencyShifter");

Object.keys(_FrequencyShifter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _FrequencyShifter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FrequencyShifter[key];
    }
  });
});

var _Freeverb = require("./Freeverb");

Object.keys(_Freeverb).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Freeverb[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Freeverb[key];
    }
  });
});

var _JCReverb = require("./JCReverb");

Object.keys(_JCReverb).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _JCReverb[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _JCReverb[key];
    }
  });
});

var _PingPongDelay = require("./PingPongDelay");

Object.keys(_PingPongDelay).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PingPongDelay[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PingPongDelay[key];
    }
  });
});

var _PitchShift = require("./PitchShift");

Object.keys(_PitchShift).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PitchShift[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PitchShift[key];
    }
  });
});

var _Phaser = require("./Phaser");

Object.keys(_Phaser).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Phaser[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Phaser[key];
    }
  });
});

var _Reverb = require("./Reverb");

Object.keys(_Reverb).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Reverb[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Reverb[key];
    }
  });
});

var _StereoWidener = require("./StereoWidener");

Object.keys(_StereoWidener).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _StereoWidener[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _StereoWidener[key];
    }
  });
});

var _Tremolo = require("./Tremolo");

Object.keys(_Tremolo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Tremolo[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Tremolo[key];
    }
  });
});

var _Vibrato = require("./Vibrato");

Object.keys(_Vibrato).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Vibrato[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Vibrato[key];
    }
  });
});
},{"./AutoFilter":"../node_modules/tone/build/esm/effect/AutoFilter.js","./AutoPanner":"../node_modules/tone/build/esm/effect/AutoPanner.js","./AutoWah":"../node_modules/tone/build/esm/effect/AutoWah.js","./BitCrusher":"../node_modules/tone/build/esm/effect/BitCrusher.js","./Chebyshev":"../node_modules/tone/build/esm/effect/Chebyshev.js","./Chorus":"../node_modules/tone/build/esm/effect/Chorus.js","./Distortion":"../node_modules/tone/build/esm/effect/Distortion.js","./FeedbackDelay":"../node_modules/tone/build/esm/effect/FeedbackDelay.js","./FrequencyShifter":"../node_modules/tone/build/esm/effect/FrequencyShifter.js","./Freeverb":"../node_modules/tone/build/esm/effect/Freeverb.js","./JCReverb":"../node_modules/tone/build/esm/effect/JCReverb.js","./PingPongDelay":"../node_modules/tone/build/esm/effect/PingPongDelay.js","./PitchShift":"../node_modules/tone/build/esm/effect/PitchShift.js","./Phaser":"../node_modules/tone/build/esm/effect/Phaser.js","./Reverb":"../node_modules/tone/build/esm/effect/Reverb.js","./StereoWidener":"../node_modules/tone/build/esm/effect/StereoWidener.js","./Tremolo":"../node_modules/tone/build/esm/effect/Tremolo.js","./Vibrato":"../node_modules/tone/build/esm/effect/Vibrato.js"}],"../node_modules/tone/build/esm/component/analysis/Analyser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Analyser = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Split = require("../channel/Split");

var _Gain = require("../../core/context/Gain");

var _Debug = require("../../core/util/Debug");

/**
 * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).
 * Extracts FFT or Waveform data from the incoming signal.
 * @category Component
 */
class Analyser extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Analyser.getDefaults(), arguments, ["type", "size"]));
    this.name = "Analyser";
    /**
     * The analyser node.
     */

    this._analysers = [];
    /**
     * The buffer that the FFT data is written to
     */

    this._buffers = [];
    const options = (0, _Defaults.optionsFromArguments)(Analyser.getDefaults(), arguments, ["type", "size"]);
    this.input = this.output = this._gain = new _Gain.Gain({
      context: this.context
    });
    this._split = new _Split.Split({
      context: this.context,
      channels: options.channels
    });
    this.input.connect(this._split);
    (0, _Debug.assertRange)(options.channels, 1); // create the analysers

    for (let channel = 0; channel < options.channels; channel++) {
      this._analysers[channel] = this.context.createAnalyser();

      this._split.connect(this._analysers[channel], channel, 0);
    } // set the values initially


    this.size = options.size;
    this.type = options.type;
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      size: 1024,
      smoothing: 0.8,
      type: "fft",
      channels: 1
    });
  }
  /**
   * Run the analysis given the current settings. If [[channels]] = 1,
   * it will return a Float32Array. If [[channels]] > 1, it will
   * return an array of Float32Arrays where each index in the array
   * represents the analysis done on a channel.
   */


  getValue() {
    this._analysers.forEach((analyser, index) => {
      const buffer = this._buffers[index];

      if (this._type === "fft") {
        analyser.getFloatFrequencyData(buffer);
      } else if (this._type === "waveform") {
        analyser.getFloatTimeDomainData(buffer);
      }
    });

    if (this.channels === 1) {
      return this._buffers[0];
    } else {
      return this._buffers;
    }
  }
  /**
   * The size of analysis. This must be a power of two in the range 16 to 16384.
   */


  get size() {
    return this._analysers[0].frequencyBinCount;
  }

  set size(size) {
    this._analysers.forEach((analyser, index) => {
      analyser.fftSize = size * 2;
      this._buffers[index] = new Float32Array(size);
    });
  }
  /**
   * The number of channels the analyser does the analysis on. Channel
   * separation is done using [[Split]]
   */


  get channels() {
    return this._analysers.length;
  }
  /**
   * The analysis function returned by analyser.getValue(), either "fft" or "waveform".
   */


  get type() {
    return this._type;
  }

  set type(type) {
    (0, _Debug.assert)(type === "waveform" || type === "fft", `Analyser: invalid type: ${type}`);
    this._type = type;
  }
  /**
   * 0 represents no time averaging with the last analysis frame.
   */


  get smoothing() {
    return this._analysers[0].smoothingTimeConstant;
  }

  set smoothing(val) {
    this._analysers.forEach(a => a.smoothingTimeConstant = val);
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();

    this._analysers.forEach(a => a.disconnect());

    this._split.dispose();

    this._gain.dispose();

    return this;
  }

}

exports.Analyser = Analyser;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../channel/Split":"../node_modules/tone/build/esm/component/channel/Split.js","../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/component/analysis/MeterBase.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeterBase = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Analyser = require("./Analyser");

/**
 * The base class for Metering classes.
 */
class MeterBase extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(MeterBase.getDefaults(), arguments));
    this.name = "MeterBase";
    this.input = this.output = this._analyser = new _Analyser.Analyser({
      context: this.context,
      size: 256,
      type: "waveform"
    });
  }

  dispose() {
    super.dispose();

    this._analyser.dispose();

    return this;
  }

}

exports.MeterBase = MeterBase;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Analyser":"../node_modules/tone/build/esm/component/analysis/Analyser.js"}],"../node_modules/tone/build/esm/component/analysis/Meter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Meter = void 0;

var _Conversions = require("../../core/type/Conversions");

var _Defaults = require("../../core/util/Defaults");

var _MeterBase = require("./MeterBase");

var _Debug = require("../../core/util/Debug");

var _Analyser = require("./Analyser");

/**
 * Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)
 * of an input signal. It can also get the raw value of the input signal.
 *
 * @example
 * const meter = new Tone.Meter();
 * const mic = new Tone.UserMedia();
 * mic.open();
 * // connect mic to the meter
 * mic.connect(meter);
 * // the current level of the mic
 * setInterval(() => console.log(meter.getValue()), 100);
 * @category Component
 */
class Meter extends _MeterBase.MeterBase {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Meter.getDefaults(), arguments, ["smoothing"]));
    this.name = "Meter";
    /**
     * The previous frame's value
     */

    this._rms = 0;
    const options = (0, _Defaults.optionsFromArguments)(Meter.getDefaults(), arguments, ["smoothing"]);
    this.input = this.output = this._analyser = new _Analyser.Analyser({
      context: this.context,
      size: 256,
      type: "waveform",
      channels: options.channels
    });
    this.smoothing = options.smoothing, this.normalRange = options.normalRange;
  }

  static getDefaults() {
    return Object.assign(_MeterBase.MeterBase.getDefaults(), {
      smoothing: 0.8,
      normalRange: false,
      channels: 1
    });
  }
  /**
   * Use [[getValue]] instead. For the previous getValue behavior, use DCMeter.
   * @deprecated
   */


  getLevel() {
    (0, _Debug.warn)("'getLevel' has been changed to 'getValue'");
    return this.getValue();
  }
  /**
   * Get the current value of the incoming signal.
   * Output is in decibels when [[normalRange]] is `false`.
   * If [[channels]] = 1, then the output is a single number
   * representing the value of the input signal. When [[channels]] > 1,
   * then each channel is returned as a value in a number array.
   */


  getValue() {
    const aValues = this._analyser.getValue();

    const channelValues = this.channels === 1 ? [aValues] : aValues;
    const vals = channelValues.map(values => {
      const totalSquared = values.reduce((total, current) => total + current * current, 0);
      const rms = Math.sqrt(totalSquared / values.length); // the rms can only fall at the rate of the smoothing
      // but can jump up instantly

      this._rms = Math.max(rms, this._rms * this.smoothing);
      return this.normalRange ? this._rms : (0, _Conversions.gainToDb)(this._rms);
    });

    if (this.channels === 1) {
      return vals[0];
    } else {
      return vals;
    }
  }
  /**
   * The number of channels of analysis.
   */


  get channels() {
    return this._analyser.channels;
  }

  dispose() {
    super.dispose();

    this._analyser.dispose();

    return this;
  }

}

exports.Meter = Meter;
},{"../../core/type/Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./MeterBase":"../node_modules/tone/build/esm/component/analysis/MeterBase.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","./Analyser":"../node_modules/tone/build/esm/component/analysis/Analyser.js"}],"../node_modules/tone/build/esm/component/analysis/FFT.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FFT = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Conversions = require("../../core/type/Conversions");

var _Defaults = require("../../core/util/Defaults");

var _MeterBase = require("./MeterBase");

var _Debug = require("../../core/util/Debug");

/**
 * Get the current frequency data of the connected audio source using a fast Fourier transform.
 * @category Component
 */
class FFT extends _MeterBase.MeterBase {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(FFT.getDefaults(), arguments, ["size"]));
    this.name = "FFT";
    const options = (0, _Defaults.optionsFromArguments)(FFT.getDefaults(), arguments, ["size"]);
    this.normalRange = options.normalRange;
    this._analyser.type = "fft";
    this.size = options.size;
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      normalRange: false,
      size: 1024,
      smoothing: 0.8
    });
  }
  /**
   * Gets the current frequency data from the connected audio source.
   * Returns the frequency data of length [[size]] as a Float32Array of decibel values.
   */


  getValue() {
    const values = this._analyser.getValue();

    return values.map(v => this.normalRange ? (0, _Conversions.dbToGain)(v) : v);
  }
  /**
   * The size of analysis. This must be a power of two in the range 16 to 16384.
   * Determines the size of the array returned by [[getValue]] (i.e. the number of
   * frequency bins). Large FFT sizes may be costly to compute.
   */


  get size() {
    return this._analyser.size;
  }

  set size(size) {
    this._analyser.size = size;
  }
  /**
   * 0 represents no time averaging with the last analysis frame.
   */


  get smoothing() {
    return this._analyser.smoothing;
  }

  set smoothing(val) {
    this._analyser.smoothing = val;
  }
  /**
   * Returns the frequency value in hertz of each of the indices of the FFT's [[getValue]] response.
   * @example
   * const fft = new Tone.FFT(32);
   * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));
   */


  getFrequencyOfIndex(index) {
    (0, _Debug.assert)(0 <= index && index < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);
    return index * this.context.sampleRate / (this.size * 2);
  }

}

exports.FFT = FFT;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/type/Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./MeterBase":"../node_modules/tone/build/esm/component/analysis/MeterBase.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js"}],"../node_modules/tone/build/esm/component/analysis/DCMeter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DCMeter = void 0;

var _Defaults = require("../../core/util/Defaults");

var _MeterBase = require("./MeterBase");

/**
 * DCMeter gets the raw value of the input signal at the current time.
 *
 * @example
 * const meter = new Tone.DCMeter();
 * const mic = new Tone.UserMedia();
 * mic.open();
 * // connect mic to the meter
 * mic.connect(meter);
 * // the current level of the mic
 * const level = meter.getValue();
 * @category Component
 */
class DCMeter extends _MeterBase.MeterBase {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(DCMeter.getDefaults(), arguments));
    this.name = "DCMeter";
    this._analyser.type = "waveform";
    this._analyser.size = 256;
  }
  /**
   * Get the signal value of the incoming signal
   */


  getValue() {
    const value = this._analyser.getValue();

    return value[0];
  }

}

exports.DCMeter = DCMeter;
},{"../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./MeterBase":"../node_modules/tone/build/esm/component/analysis/MeterBase.js"}],"../node_modules/tone/build/esm/component/analysis/Waveform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Waveform = void 0;

var _Defaults = require("../../core/util/Defaults");

var _MeterBase = require("./MeterBase");

/**
 * Get the current waveform data of the connected audio source.
 * @category Component
 */
class Waveform extends _MeterBase.MeterBase {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Waveform.getDefaults(), arguments, ["size"]));
    this.name = "Waveform";
    const options = (0, _Defaults.optionsFromArguments)(Waveform.getDefaults(), arguments, ["size"]);
    this._analyser.type = "waveform";
    this.size = options.size;
  }

  static getDefaults() {
    return Object.assign(_MeterBase.MeterBase.getDefaults(), {
      size: 1024
    });
  }
  /**
   * Return the waveform for the current time as a Float32Array where each value in the array
   * represents a sample in the waveform.
   */


  getValue() {
    return this._analyser.getValue();
  }
  /**
   * The size of analysis. This must be a power of two in the range 16 to 16384.
   * Determines the size of the array returned by [[getValue]].
   */


  get size() {
    return this._analyser.size;
  }

  set size(size) {
    this._analyser.size = size;
  }

}

exports.Waveform = Waveform;
},{"../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./MeterBase":"../node_modules/tone/build/esm/component/analysis/MeterBase.js"}],"../node_modules/tone/build/esm/component/channel/Solo.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Solo = void 0;

var _Gain = require("../../core/context/Gain");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

/**
 * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,
 * it will mute all other instances of Solo.
 * @example
 * const soloA = new Tone.Solo().toDestination();
 * const oscA = new Tone.Oscillator("C4", "sawtooth").connect(soloA);
 * const soloB = new Tone.Solo().toDestination();
 * const oscB = new Tone.Oscillator("E4", "square").connect(soloB);
 * soloA.solo = true;
 * // no audio will pass through soloB
 * @category Component
 */
class Solo extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Solo.getDefaults(), arguments, ["solo"]));
    this.name = "Solo";
    const options = (0, _Defaults.optionsFromArguments)(Solo.getDefaults(), arguments, ["solo"]);
    this.input = this.output = new _Gain.Gain({
      context: this.context
    });

    if (!Solo._allSolos.has(this.context)) {
      Solo._allSolos.set(this.context, new Set());
    }

    Solo._allSolos.get(this.context).add(this); // set initially


    this.solo = options.solo;
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      solo: false
    });
  }
  /**
   * Isolates this instance and mutes all other instances of Solo.
   * Only one instance can be soloed at a time. A soloed
   * instance will report `solo=false` when another instance is soloed.
   */


  get solo() {
    return this._isSoloed();
  }

  set solo(solo) {
    if (solo) {
      this._addSolo();
    } else {
      this._removeSolo();
    }

    Solo._allSolos.get(this.context).forEach(instance => instance._updateSolo());
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed
   */


  get muted() {
    return this.input.gain.value === 0;
  }
  /**
   * Add this to the soloed array
   */


  _addSolo() {
    if (!Solo._soloed.has(this.context)) {
      Solo._soloed.set(this.context, new Set());
    }

    Solo._soloed.get(this.context).add(this);
  }
  /**
   * Remove this from the soloed array
   */


  _removeSolo() {
    if (Solo._soloed.has(this.context)) {
      Solo._soloed.get(this.context).delete(this);
    }
  }
  /**
   * Is this on the soloed array
   */


  _isSoloed() {
    return Solo._soloed.has(this.context) && Solo._soloed.get(this.context).has(this);
  }
  /**
   * Returns true if no one is soloed
   */


  _noSolos() {
    // either does not have any soloed added
    return !Solo._soloed.has(this.context) || // or has a solo set but doesn't include any items
    Solo._soloed.has(this.context) && Solo._soloed.get(this.context).size === 0;
  }
  /**
   * Solo the current instance and unsolo all other instances.
   */


  _updateSolo() {
    if (this._isSoloed()) {
      this.input.gain.value = 1;
    } else if (this._noSolos()) {
      // no one is soloed
      this.input.gain.value = 1;
    } else {
      this.input.gain.value = 0;
    }
  }

  dispose() {
    super.dispose();

    Solo._allSolos.get(this.context).delete(this);

    this._removeSolo();

    return this;
  }

}
/**
 * Hold all of the solo'ed tracks belonging to a specific context
 */


exports.Solo = Solo;
Solo._allSolos = new Map();
/**
 * Hold the currently solo'ed instance(s)
 */

Solo._soloed = new Map();
},{"../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js"}],"../node_modules/tone/build/esm/component/channel/PanVol.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PanVol = void 0;

var _Interface = require("../../core/util/Interface");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Panner = require("./Panner");

var _Volume = require("./Volume");

/**
 * PanVol is a Tone.Panner and Tone.Volume in one.
 * @example
 * // pan the incoming signal left and drop the volume
 * const panVol = new Tone.PanVol(-0.25, -12).toDestination();
 * const osc = new Tone.Oscillator().connect(panVol).start();
 * @category Component
 */
class PanVol extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(PanVol.getDefaults(), arguments, ["pan", "volume"]));
    this.name = "PanVol";
    const options = (0, _Defaults.optionsFromArguments)(PanVol.getDefaults(), arguments, ["pan", "volume"]);
    this._panner = this.input = new _Panner.Panner({
      context: this.context,
      pan: options.pan,
      channelCount: options.channelCount
    });
    this.pan = this._panner.pan;
    this._volume = this.output = new _Volume.Volume({
      context: this.context,
      volume: options.volume
    });
    this.volume = this._volume.volume; // connections

    this._panner.connect(this._volume);

    this.mute = options.mute;
    (0, _Interface.readOnly)(this, ["pan", "volume"]);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      mute: false,
      pan: 0,
      volume: 0,
      channelCount: 1
    });
  }
  /**
   * Mute/unmute the volume
   */


  get mute() {
    return this._volume.mute;
  }

  set mute(mute) {
    this._volume.mute = mute;
  }

  dispose() {
    super.dispose();

    this._panner.dispose();

    this.pan.dispose();

    this._volume.dispose();

    this.volume.dispose();
    return this;
  }

}

exports.PanVol = PanVol;
},{"../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Panner":"../node_modules/tone/build/esm/component/channel/Panner.js","./Volume":"../node_modules/tone/build/esm/component/channel/Volume.js"}],"../node_modules/tone/build/esm/component/channel/Channel.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Channel = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Solo = require("./Solo");

var _PanVol = require("./PanVol");

var _Interface = require("../../core/util/Interface");

var _Gain = require("../../core/context/Gain");

/**
 * Channel provides a channel strip interface with volume, pan, solo and mute controls.
 * See [[PanVol]] and [[Solo]]
 * @example
 * // pan the incoming signal left and drop the volume 12db
 * const channel = new Tone.Channel(-0.25, -12);
 * @category Component
 */
class Channel extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Channel.getDefaults(), arguments, ["volume", "pan"]));
    this.name = "Channel";
    const options = (0, _Defaults.optionsFromArguments)(Channel.getDefaults(), arguments, ["volume", "pan"]);
    this._solo = this.input = new _Solo.Solo({
      solo: options.solo,
      context: this.context
    });
    this._panVol = this.output = new _PanVol.PanVol({
      context: this.context,
      pan: options.pan,
      volume: options.volume,
      mute: options.mute,
      channelCount: options.channelCount
    });
    this.pan = this._panVol.pan;
    this.volume = this._panVol.volume;

    this._solo.connect(this._panVol);

    (0, _Interface.readOnly)(this, ["pan", "volume"]);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      pan: 0,
      volume: 0,
      mute: false,
      solo: false,
      channelCount: 1
    });
  }
  /**
   * Solo/unsolo the channel. Soloing is only relative to other [[Channels]] and [[Solo]] instances
   */


  get solo() {
    return this._solo.solo;
  }

  set solo(solo) {
    this._solo.solo = solo;
  }
  /**
   * If the current instance is muted, i.e. another instance is soloed,
   * or the channel is muted
   */


  get muted() {
    return this._solo.muted || this.mute;
  }
  /**
   * Mute/unmute the volume
   */


  get mute() {
    return this._panVol.mute;
  }

  set mute(mute) {
    this._panVol.mute = mute;
  }
  /**
   * Get the gain node belonging to the bus name. Create it if
   * it doesn't exist
   * @param name The bus name
   */


  _getBus(name) {
    if (!Channel.buses.has(name)) {
      Channel.buses.set(name, new _Gain.Gain({
        context: this.context
      }));
    }

    return Channel.buses.get(name);
  }
  /**
   * Send audio to another channel using a string. `send` is a lot like
   * [[connect]], except it uses a string instead of an object. This can
   * be useful in large applications to decouple sections since [[send]]
   * and [[receive]] can be invoked separately in order to connect an object
   * @param name The channel name to send the audio
   * @param volume The amount of the signal to send.
   * 	Defaults to 0db, i.e. send the entire signal
   * @returns Returns the gain node of this connection.
   */


  send(name, volume = 0) {
    const bus = this._getBus(name);

    const sendKnob = new _Gain.Gain({
      context: this.context,
      units: "decibels",
      gain: volume
    });
    this.connect(sendKnob);
    sendKnob.connect(bus);
    return sendKnob;
  }
  /**
   * Receive audio from a channel which was connected with [[send]].
   * @param name The channel name to receive audio from.
   */


  receive(name) {
    const bus = this._getBus(name);

    bus.connect(this);
    return this;
  }

  dispose() {
    super.dispose();

    this._panVol.dispose();

    this.pan.dispose();
    this.volume.dispose();

    this._solo.dispose();

    return this;
  }

}
/**
 * Store the send/receive channels by name.
 */


exports.Channel = Channel;
Channel.buses = new Map();
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Solo":"../node_modules/tone/build/esm/component/channel/Solo.js","./PanVol":"../node_modules/tone/build/esm/component/channel/PanVol.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js"}],"../node_modules/tone/build/esm/component/channel/Mono.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mono = void 0;

var _Gain = require("../../core/context/Gain");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Merge = require("./Merge");

/**
 * Mono coerces the incoming mono or stereo signal into a mono signal
 * where both left and right channels have the same value. This can be useful
 * for [stereo imaging](https://en.wikipedia.org/wiki/Stereo_imaging).
 * @category Component
 */
class Mono extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Mono.getDefaults(), arguments));
    this.name = "Mono";
    this.input = new _Gain.Gain({
      context: this.context
    });
    this._merge = this.output = new _Merge.Merge({
      channels: 2,
      context: this.context
    });
    this.input.connect(this._merge, 0, 0);
    this.input.connect(this._merge, 0, 1);
  }

  dispose() {
    super.dispose();

    this._merge.dispose();

    this.input.dispose();
    return this;
  }

}

exports.Mono = Mono;
},{"../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Merge":"../node_modules/tone/build/esm/component/channel/Merge.js"}],"../node_modules/tone/build/esm/component/channel/MultibandSplit.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultibandSplit = void 0;

var _Gain = require("../../core/context/Gain");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _Signal = require("../../signal/Signal");

var _Filter = require("../filter/Filter");

/**
 * Split the incoming signal into three bands (low, mid, high)
 * with two crossover frequency controls.
 * ```
 *            +----------------------+
 *          +-> input < lowFrequency +------------------> low
 *          | +----------------------+
 *          |
 *          | +--------------------------------------+
 * input ---+-> lowFrequency < input < highFrequency +--> mid
 *          | +--------------------------------------+
 *          |
 *          | +-----------------------+
 *          +-> highFrequency < input +-----------------> high
 *            +-----------------------+
 * ```
 * @category Component
 */
class MultibandSplit extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(MultibandSplit.getDefaults(), arguments, ["lowFrequency", "highFrequency"]));
    this.name = "MultibandSplit";
    /**
     * the input
     */

    this.input = new _Gain.Gain({
      context: this.context
    });
    /**
     * no output node, use either low, mid or high outputs
     */

    this.output = undefined;
    /**
     * The low band.
     */

    this.low = new _Filter.Filter({
      context: this.context,
      frequency: 0,
      type: "lowpass"
    });
    /**
     * the lower filter of the mid band
     */

    this._lowMidFilter = new _Filter.Filter({
      context: this.context,
      frequency: 0,
      type: "highpass"
    });
    /**
     * The mid band output.
     */

    this.mid = new _Filter.Filter({
      context: this.context,
      frequency: 0,
      type: "lowpass"
    });
    /**
     * The high band output.
     */

    this.high = new _Filter.Filter({
      context: this.context,
      frequency: 0,
      type: "highpass"
    });
    this._internalChannels = [this.low, this.mid, this.high];
    const options = (0, _Defaults.optionsFromArguments)(MultibandSplit.getDefaults(), arguments, ["lowFrequency", "highFrequency"]);
    this.lowFrequency = new _Signal.Signal({
      context: this.context,
      units: "frequency",
      value: options.lowFrequency
    });
    this.highFrequency = new _Signal.Signal({
      context: this.context,
      units: "frequency",
      value: options.highFrequency
    });
    this.Q = new _Signal.Signal({
      context: this.context,
      units: "positive",
      value: options.Q
    });
    this.input.fan(this.low, this.high);
    this.input.chain(this._lowMidFilter, this.mid); // the frequency control signal

    this.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency);
    this.highFrequency.fan(this.mid.frequency, this.high.frequency); // the Q value

    this.Q.connect(this.low.Q);
    this.Q.connect(this._lowMidFilter.Q);
    this.Q.connect(this.mid.Q);
    this.Q.connect(this.high.Q);
    (0, _Interface.readOnly)(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      Q: 1,
      highFrequency: 2500,
      lowFrequency: 400
    });
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();
    (0, _Interface.writable)(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]);
    this.low.dispose();

    this._lowMidFilter.dispose();

    this.mid.dispose();
    this.high.dispose();
    this.lowFrequency.dispose();
    this.highFrequency.dispose();
    this.Q.dispose();
    return this;
  }

}

exports.MultibandSplit = MultibandSplit;
},{"../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../../signal/Signal":"../node_modules/tone/build/esm/signal/Signal.js","../filter/Filter":"../node_modules/tone/build/esm/component/filter/Filter.js"}],"../node_modules/tone/build/esm/core/context/Listener.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Listener = void 0;

var _ToneAudioNode = require("./ToneAudioNode");

var _Param = require("./Param");

var _ContextInitialization = require("./ContextInitialization");

/**
 * Tone.Listener is a thin wrapper around the AudioListener. Listener combined
 * with [[Panner3D]] makes up the Web Audio API's 3D panning system. Panner3D allows you
 * to place sounds in 3D and Listener allows you to navigate the 3D sound environment from
 * a first-person perspective. There is only one listener per audio context.
 */
class Listener extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super(...arguments);
    this.name = "Listener";
    this.positionX = new _Param.Param({
      context: this.context,
      param: this.context.rawContext.listener.positionX
    });
    this.positionY = new _Param.Param({
      context: this.context,
      param: this.context.rawContext.listener.positionY
    });
    this.positionZ = new _Param.Param({
      context: this.context,
      param: this.context.rawContext.listener.positionZ
    });
    this.forwardX = new _Param.Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardX
    });
    this.forwardY = new _Param.Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardY
    });
    this.forwardZ = new _Param.Param({
      context: this.context,
      param: this.context.rawContext.listener.forwardZ
    });
    this.upX = new _Param.Param({
      context: this.context,
      param: this.context.rawContext.listener.upX
    });
    this.upY = new _Param.Param({
      context: this.context,
      param: this.context.rawContext.listener.upY
    });
    this.upZ = new _Param.Param({
      context: this.context,
      param: this.context.rawContext.listener.upZ
    });
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      positionX: 0,
      positionY: 0,
      positionZ: 0,
      forwardX: 0,
      forwardY: 0,
      forwardZ: -1,
      upX: 0,
      upY: 1,
      upZ: 0
    });
  }

  dispose() {
    super.dispose();
    this.positionX.dispose();
    this.positionY.dispose();
    this.positionZ.dispose();
    this.forwardX.dispose();
    this.forwardY.dispose();
    this.forwardZ.dispose();
    this.upX.dispose();
    this.upY.dispose();
    this.upZ.dispose();
    return this;
  }

} //-------------------------------------
// 	INITIALIZATION
//-------------------------------------


exports.Listener = Listener;
(0, _ContextInitialization.onContextInit)(context => {
  context.listener = new Listener({
    context
  });
});
(0, _ContextInitialization.onContextClose)(context => {
  context.listener.dispose();
});
},{"./ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","./Param":"../node_modules/tone/build/esm/core/context/Param.js","./ContextInitialization":"../node_modules/tone/build/esm/core/context/ContextInitialization.js"}],"../node_modules/tone/build/esm/component/channel/Panner3D.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Panner3D = void 0;

var _Param = require("../../core/context/Param");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

require("../../core/context/Listener");

/**
 * A spatialized panner node which supports equalpower or HRTF panning.
 * @category Component
 */
class Panner3D extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Panner3D.getDefaults(), arguments, ["positionX", "positionY", "positionZ"]));
    this.name = "Panner3D";
    const options = (0, _Defaults.optionsFromArguments)(Panner3D.getDefaults(), arguments, ["positionX", "positionY", "positionZ"]);
    this._panner = this.input = this.output = this.context.createPanner(); // set some values

    this.panningModel = options.panningModel;
    this.maxDistance = options.maxDistance;
    this.distanceModel = options.distanceModel;
    this.coneOuterGain = options.coneOuterGain;
    this.coneOuterAngle = options.coneOuterAngle;
    this.coneInnerAngle = options.coneInnerAngle;
    this.refDistance = options.refDistance;
    this.rolloffFactor = options.rolloffFactor;
    this.positionX = new _Param.Param({
      context: this.context,
      param: this._panner.positionX,
      value: options.positionX
    });
    this.positionY = new _Param.Param({
      context: this.context,
      param: this._panner.positionY,
      value: options.positionY
    });
    this.positionZ = new _Param.Param({
      context: this.context,
      param: this._panner.positionZ,
      value: options.positionZ
    });
    this.orientationX = new _Param.Param({
      context: this.context,
      param: this._panner.orientationX,
      value: options.orientationX
    });
    this.orientationY = new _Param.Param({
      context: this.context,
      param: this._panner.orientationY,
      value: options.orientationY
    });
    this.orientationZ = new _Param.Param({
      context: this.context,
      param: this._panner.orientationZ,
      value: options.orientationZ
    });
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      coneInnerAngle: 360,
      coneOuterAngle: 360,
      coneOuterGain: 0,
      distanceModel: "inverse",
      maxDistance: 10000,
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      panningModel: "equalpower",
      positionX: 0,
      positionY: 0,
      positionZ: 0,
      refDistance: 1,
      rolloffFactor: 1
    });
  }
  /**
   * Sets the position of the source in 3d space.
   */


  setPosition(x, y, z) {
    this.positionX.value = x;
    this.positionY.value = y;
    this.positionZ.value = z;
    return this;
  }
  /**
   * Sets the orientation of the source in 3d space.
   */


  setOrientation(x, y, z) {
    this.orientationX.value = x;
    this.orientationY.value = y;
    this.orientationZ.value = z;
    return this;
  }
  /**
   * The panning model. Either "equalpower" or "HRTF".
   */


  get panningModel() {
    return this._panner.panningModel;
  }

  set panningModel(val) {
    this._panner.panningModel = val;
  }
  /**
   * A reference distance for reducing volume as source move further from the listener
   */


  get refDistance() {
    return this._panner.refDistance;
  }

  set refDistance(val) {
    this._panner.refDistance = val;
  }
  /**
   * Describes how quickly the volume is reduced as source moves away from listener.
   */


  get rolloffFactor() {
    return this._panner.rolloffFactor;
  }

  set rolloffFactor(val) {
    this._panner.rolloffFactor = val;
  }
  /**
   * The distance model used by,  "linear", "inverse", or "exponential".
   */


  get distanceModel() {
    return this._panner.distanceModel;
  }

  set distanceModel(val) {
    this._panner.distanceModel = val;
  }
  /**
   * The angle, in degrees, inside of which there will be no volume reduction
   */


  get coneInnerAngle() {
    return this._panner.coneInnerAngle;
  }

  set coneInnerAngle(val) {
    this._panner.coneInnerAngle = val;
  }
  /**
   * The angle, in degrees, outside of which the volume will be reduced
   * to a constant value of coneOuterGain
   */


  get coneOuterAngle() {
    return this._panner.coneOuterAngle;
  }

  set coneOuterAngle(val) {
    this._panner.coneOuterAngle = val;
  }
  /**
   * The gain outside of the coneOuterAngle
   */


  get coneOuterGain() {
    return this._panner.coneOuterGain;
  }

  set coneOuterGain(val) {
    this._panner.coneOuterGain = val;
  }
  /**
   * The maximum distance between source and listener,
   * after which the volume will not be reduced any further.
   */


  get maxDistance() {
    return this._panner.maxDistance;
  }

  set maxDistance(val) {
    this._panner.maxDistance = val;
  }

  dispose() {
    super.dispose();

    this._panner.disconnect();

    this.orientationX.dispose();
    this.orientationY.dispose();
    this.orientationZ.dispose();
    this.positionX.dispose();
    this.positionY.dispose();
    this.positionZ.dispose();
    return this;
  }

}

exports.Panner3D = Panner3D;
},{"../../core/context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/context/Listener":"../node_modules/tone/build/esm/core/context/Listener.js"}],"../node_modules/tone/build/esm/component/channel/Recorder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Recorder = void 0;

var _tslib = require("tslib");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Gain = require("../../core/context/Gain");

var _Debug = require("../../core/util/Debug");

var _AudioContext = require("../../core/context/AudioContext");

var _Defaults = require("../../core/util/Defaults");

/**
 * A wrapper around the MediaRecorder API. Unlike the rest of Tone.js, this module does not offer
 * any sample-accurate scheduling because it is not a feature of the MediaRecorder API.
 * This is only natively supported in Chrome and Firefox.
 * For a cross-browser shim, install (audio-recorder-polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].
 * @example
 * const recorder = new Tone.Recorder();
 * const synth = new Tone.Synth().connect(recorder);
 * // start recording
 * recorder.start();
 * // generate a few notes
 * synth.triggerAttackRelease("C3", 0.5);
 * synth.triggerAttackRelease("C4", 0.5, "+1");
 * synth.triggerAttackRelease("C5", 0.5, "+2");
 * // wait for the notes to end and stop the recording
 * setTimeout(async () => {
 * 	// the recorded audio is returned as a blob
 * 	const recording = await recorder.stop();
 * 	// download the recording by creating an anchor element and blob url
 * 	const url = URL.createObjectURL(recording);
 * 	const anchor = document.createElement("a");
 * 	anchor.download = "recording.webm";
 * 	anchor.href = url;
 * 	anchor.click();
 * }, 4000);
 * @category Component
 */
class Recorder extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Recorder.getDefaults(), arguments));
    this.name = "Recorder";
    const options = (0, _Defaults.optionsFromArguments)(Recorder.getDefaults(), arguments);
    this.input = new _Gain.Gain({
      context: this.context
    });
    (0, _Debug.assert)(Recorder.supported, "Media Recorder API is not available");
    this._stream = this.context.createMediaStreamDestination();
    this.input.connect(this._stream);
    this._recorder = new MediaRecorder(this._stream.stream, {
      mimeType: options.mimeType
    });
  }

  static getDefaults() {
    return _ToneAudioNode.ToneAudioNode.getDefaults();
  }
  /**
   * The mime type is the format that the audio is encoded in. For Chrome
   * that is typically webm encoded as "vorbis".
   */


  get mimeType() {
    return this._recorder.mimeType;
  }
  /**
   * Test if your platform supports the Media Recorder API. If it's not available,
   * try installing this (polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].
   */


  static get supported() {
    return _AudioContext.theWindow !== null && Reflect.has(_AudioContext.theWindow, "MediaRecorder");
  }
  /**
   * Get the playback state of the Recorder, either "started", "stopped" or "paused"
   */


  get state() {
    if (this._recorder.state === "inactive") {
      return "stopped";
    } else if (this._recorder.state === "paused") {
      return "paused";
    } else {
      return "started";
    }
  }
  /**
   * Start the Recorder. Returns a promise which resolves
   * when the recorder has started.
   */


  start() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _Debug.assert)(this.state !== "started", "Recorder is already started");
      const startPromise = new Promise(done => {
        const handleStart = () => {
          this._recorder.removeEventListener("start", handleStart, false);

          done();
        };

        this._recorder.addEventListener("start", handleStart, false);
      });

      this._recorder.start();

      return yield startPromise;
    });
  }
  /**
   * Stop the recorder. Returns a promise with the recorded content until this point
   * encoded as [[mimeType]]
   */


  stop() {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      (0, _Debug.assert)(this.state !== "stopped", "Recorder is not started");
      const dataPromise = new Promise(done => {
        const handleData = e => {
          this._recorder.removeEventListener("dataavailable", handleData, false);

          done(e.data);
        };

        this._recorder.addEventListener("dataavailable", handleData, false);
      });

      this._recorder.stop();

      return yield dataPromise;
    });
  }
  /**
   * Pause the recorder
   */


  pause() {
    (0, _Debug.assert)(this.state === "started", "Recorder must be started");

    this._recorder.pause();

    return this;
  }

  dispose() {
    super.dispose();
    this.input.dispose();

    this._stream.disconnect();

    return this;
  }

}

exports.Recorder = Recorder;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/util/Debug":"../node_modules/tone/build/esm/core/util/Debug.js","../../core/context/AudioContext":"../node_modules/tone/build/esm/core/context/AudioContext.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js"}],"../node_modules/tone/build/esm/component/dynamics/Compressor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Compressor = void 0;

var _Param = require("../../core/context/Param");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

/**
 * Compressor is a thin wrapper around the Web Audio
 * [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).
 * Compression reduces the volume of loud sounds or amplifies quiet sounds
 * by narrowing or "compressing" an audio signal's dynamic range.
 * Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).
 * @example
 * const comp = new Tone.Compressor(-30, 3);
 * @category Component
 */
class Compressor extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Compressor.getDefaults(), arguments, ["threshold", "ratio"]));
    this.name = "Compressor";
    /**
     * the compressor node
     */

    this._compressor = this.context.createDynamicsCompressor();
    this.input = this._compressor;
    this.output = this._compressor;
    const options = (0, _Defaults.optionsFromArguments)(Compressor.getDefaults(), arguments, ["threshold", "ratio"]);
    this.threshold = new _Param.Param({
      minValue: this._compressor.threshold.minValue,
      maxValue: this._compressor.threshold.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.threshold,
      units: "decibels",
      value: options.threshold
    });
    this.attack = new _Param.Param({
      minValue: this._compressor.attack.minValue,
      maxValue: this._compressor.attack.maxValue,
      context: this.context,
      param: this._compressor.attack,
      units: "time",
      value: options.attack
    });
    this.release = new _Param.Param({
      minValue: this._compressor.release.minValue,
      maxValue: this._compressor.release.maxValue,
      context: this.context,
      param: this._compressor.release,
      units: "time",
      value: options.release
    });
    this.knee = new _Param.Param({
      minValue: this._compressor.knee.minValue,
      maxValue: this._compressor.knee.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.knee,
      units: "decibels",
      value: options.knee
    });
    this.ratio = new _Param.Param({
      minValue: this._compressor.ratio.minValue,
      maxValue: this._compressor.ratio.maxValue,
      context: this.context,
      convert: false,
      param: this._compressor.ratio,
      units: "positive",
      value: options.ratio
    }); // set the defaults

    (0, _Interface.readOnly)(this, ["knee", "release", "attack", "ratio", "threshold"]);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      attack: 0.003,
      knee: 30,
      ratio: 12,
      release: 0.25,
      threshold: -24
    });
  }
  /**
   * A read-only decibel value for metering purposes, representing the current amount of gain
   * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).
   */


  get reduction() {
    return this._compressor.reduction;
  }

  dispose() {
    super.dispose();

    this._compressor.disconnect();

    this.attack.dispose();
    this.release.dispose();
    this.threshold.dispose();
    this.ratio.dispose();
    this.knee.dispose();
    return this;
  }

}

exports.Compressor = Compressor;
},{"../../core/context/Param":"../node_modules/tone/build/esm/core/context/Param.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/component/dynamics/Gate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Gate = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _GreaterThan = require("../../signal/GreaterThan");

var _Gain = require("../../core/context/Gain");

var _Follower = require("../analysis/Follower");

var _Defaults = require("../../core/util/Defaults");

var _Conversions = require("../../core/type/Conversions");

/**
 * Gate only passes a signal through when the incoming
 * signal exceeds a specified threshold. It uses [[Follower]] to follow the ampltiude
 * of the incoming signal and compares it to the [[threshold]] value using [[GreaterThan]].
 *
 * @example
 * const gate = new Tone.Gate(-30, 0.2).toDestination();
 * const mic = new Tone.UserMedia().connect(gate);
 * // the gate will only pass through the incoming
 * // signal when it's louder than -30db
 * @category Component
 */
class Gate extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(Gate.getDefaults(), arguments, ["threshold", "smoothing"])));
    this.name = "Gate";
    const options = (0, _Defaults.optionsFromArguments)(Gate.getDefaults(), arguments, ["threshold", "smoothing"]);
    this._follower = new _Follower.Follower({
      context: this.context,
      smoothing: options.smoothing
    });
    this._gt = new _GreaterThan.GreaterThan({
      context: this.context,
      value: (0, _Conversions.dbToGain)(options.threshold)
    });
    this.input = new _Gain.Gain({
      context: this.context
    });
    this._gate = this.output = new _Gain.Gain({
      context: this.context
    }); // connections

    this.input.connect(this._gate); // the control signal

    this.input.chain(this._follower, this._gt, this._gate.gain);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      smoothing: 0.1,
      threshold: -40
    });
  }
  /**
   * The threshold of the gate in decibels
   */


  get threshold() {
    return (0, _Conversions.gainToDb)(this._gt.value);
  }

  set threshold(thresh) {
    this._gt.value = (0, _Conversions.dbToGain)(thresh);
  }
  /**
   * The attack/decay speed of the gate. See [[Follower.smoothing]]
   */


  get smoothing() {
    return this._follower.smoothing;
  }

  set smoothing(smoothingTime) {
    this._follower.smoothing = smoothingTime;
  }

  dispose() {
    super.dispose();
    this.input.dispose();

    this._follower.dispose();

    this._gt.dispose();

    this._gate.dispose();

    return this;
  }

}

exports.Gate = Gate;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../signal/GreaterThan":"../node_modules/tone/build/esm/signal/GreaterThan.js","../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../analysis/Follower":"../node_modules/tone/build/esm/component/analysis/Follower.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/type/Conversions":"../node_modules/tone/build/esm/core/type/Conversions.js"}],"../node_modules/tone/build/esm/component/dynamics/Limiter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Limiter = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Compressor = require("./Compressor");

var _Interface = require("../../core/util/Interface");

;
/**
 * Limiter will limit the loudness of an incoming signal.
 * Under the hood it's composed of a [[Compressor]] with a fast attack
 * and release and max compression ratio.
 *
 * @example
 * const limiter = new Tone.Limiter(-20).toDestination();
 * const oscillator = new Tone.Oscillator().connect(limiter);
 * oscillator.start();
 * @category Component
 */

class Limiter extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(Limiter.getDefaults(), arguments, ["threshold"])));
    this.name = "Limiter";
    const options = (0, _Defaults.optionsFromArguments)(Limiter.getDefaults(), arguments, ["threshold"]);
    this._compressor = this.input = this.output = new _Compressor.Compressor({
      context: this.context,
      ratio: 20,
      attack: 0.003,
      release: 0.01,
      threshold: options.threshold
    });
    this.threshold = this._compressor.threshold;
    (0, _Interface.readOnly)(this, "threshold");
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      threshold: -12
    });
  }
  /**
   * A read-only decibel value for metering purposes, representing the current amount of gain
   * reduction that the compressor is applying to the signal.
   */


  get reduction() {
    return this._compressor.reduction;
  }

  dispose() {
    super.dispose();

    this._compressor.dispose();

    this.threshold.dispose();
    return this;
  }

}

exports.Limiter = Limiter;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","./Compressor":"../node_modules/tone/build/esm/component/dynamics/Compressor.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/component/dynamics/MidSideCompressor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MidSideCompressor = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Compressor = require("./Compressor");

var _Defaults = require("../../core/util/Defaults");

var _MidSideSplit = require("../channel/MidSideSplit");

var _MidSideMerge = require("../channel/MidSideMerge");

var _Interface = require("../../core/util/Interface");

/**
 * MidSideCompressor applies two different compressors to the [[mid]]
 * and [[side]] signal components of the input. See [[MidSideSplit]] and [[MidSideMerge]].
 * @category Component
 */
class MidSideCompressor extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(MidSideCompressor.getDefaults(), arguments)));
    this.name = "MidSideCompressor";
    const options = (0, _Defaults.optionsFromArguments)(MidSideCompressor.getDefaults(), arguments);
    this._midSideSplit = this.input = new _MidSideSplit.MidSideSplit({
      context: this.context
    });
    this._midSideMerge = this.output = new _MidSideMerge.MidSideMerge({
      context: this.context
    });
    this.mid = new _Compressor.Compressor(Object.assign(options.mid, {
      context: this.context
    }));
    this.side = new _Compressor.Compressor(Object.assign(options.side, {
      context: this.context
    }));

    this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);

    this._midSideSplit.side.chain(this.side, this._midSideMerge.side);

    (0, _Interface.readOnly)(this, ["mid", "side"]);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      mid: {
        ratio: 3,
        threshold: -24,
        release: 0.03,
        attack: 0.02,
        knee: 16
      },
      side: {
        ratio: 6,
        threshold: -30,
        release: 0.25,
        attack: 0.03,
        knee: 10
      }
    });
  }

  dispose() {
    super.dispose();
    this.mid.dispose();
    this.side.dispose();

    this._midSideSplit.dispose();

    this._midSideMerge.dispose();

    return this;
  }

}

exports.MidSideCompressor = MidSideCompressor;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","./Compressor":"../node_modules/tone/build/esm/component/dynamics/Compressor.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../channel/MidSideSplit":"../node_modules/tone/build/esm/component/channel/MidSideSplit.js","../channel/MidSideMerge":"../node_modules/tone/build/esm/component/channel/MidSideMerge.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/component/dynamics/MultibandCompressor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultibandCompressor = void 0;

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Compressor = require("./Compressor");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _MultibandSplit = require("../channel/MultibandSplit");

var _Gain = require("../../core/context/Gain");

/**
 * A compressor with separate controls over low/mid/high dynamics. See [[Compressor]] and [[MultibandSplit]]
 *
 * @example
 * const multiband = new Tone.MultibandCompressor({
 * 	lowFrequency: 200,
 * 	highFrequency: 1300,
 * 	low: {
 * 		threshold: -12
 * 	}
 * });
 * @category Component
 */
class MultibandCompressor extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super(Object.assign((0, _Defaults.optionsFromArguments)(MultibandCompressor.getDefaults(), arguments)));
    this.name = "MultibandCompressor";
    const options = (0, _Defaults.optionsFromArguments)(MultibandCompressor.getDefaults(), arguments);
    this._splitter = this.input = new _MultibandSplit.MultibandSplit({
      context: this.context,
      lowFrequency: options.lowFrequency,
      highFrequency: options.highFrequency
    });
    this.lowFrequency = this._splitter.lowFrequency;
    this.highFrequency = this._splitter.highFrequency;
    this.output = new _Gain.Gain({
      context: this.context
    });
    this.low = new _Compressor.Compressor(Object.assign(options.low, {
      context: this.context
    }));
    this.mid = new _Compressor.Compressor(Object.assign(options.mid, {
      context: this.context
    }));
    this.high = new _Compressor.Compressor(Object.assign(options.high, {
      context: this.context
    })); // connect the compressor

    this._splitter.low.chain(this.low, this.output);

    this._splitter.mid.chain(this.mid, this.output);

    this._splitter.high.chain(this.high, this.output);

    (0, _Interface.readOnly)(this, ["high", "mid", "low", "highFrequency", "lowFrequency"]);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      lowFrequency: 250,
      highFrequency: 2000,
      low: {
        ratio: 6,
        threshold: -30,
        release: 0.25,
        attack: 0.03,
        knee: 10
      },
      mid: {
        ratio: 3,
        threshold: -24,
        release: 0.03,
        attack: 0.02,
        knee: 16
      },
      high: {
        ratio: 3,
        threshold: -24,
        release: 0.03,
        attack: 0.02,
        knee: 16
      }
    });
  }

  dispose() {
    super.dispose();

    this._splitter.dispose();

    this.low.dispose();
    this.mid.dispose();
    this.high.dispose();
    this.output.dispose();
    return this;
  }

}

exports.MultibandCompressor = MultibandCompressor;
},{"../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","./Compressor":"../node_modules/tone/build/esm/component/dynamics/Compressor.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../channel/MultibandSplit":"../node_modules/tone/build/esm/component/channel/MultibandSplit.js","../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js"}],"../node_modules/tone/build/esm/component/filter/EQ3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EQ3 = void 0;

var _Gain = require("../../core/context/Gain");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _Defaults = require("../../core/util/Defaults");

var _Interface = require("../../core/util/Interface");

var _MultibandSplit = require("../channel/MultibandSplit");

/**
 * EQ3 provides 3 equalizer bins: Low/Mid/High.
 * @category Component
 */
class EQ3 extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(EQ3.getDefaults(), arguments, ["low", "mid", "high"]));
    this.name = "EQ3";
    /**
     * the output
     */

    this.output = new _Gain.Gain({
      context: this.context
    });
    this._internalChannels = [];
    const options = (0, _Defaults.optionsFromArguments)(EQ3.getDefaults(), arguments, ["low", "mid", "high"]);
    this.input = this._multibandSplit = new _MultibandSplit.MultibandSplit({
      context: this.context,
      highFrequency: options.highFrequency,
      lowFrequency: options.lowFrequency
    });
    this._lowGain = new _Gain.Gain({
      context: this.context,
      gain: options.low,
      units: "decibels"
    });
    this._midGain = new _Gain.Gain({
      context: this.context,
      gain: options.mid,
      units: "decibels"
    });
    this._highGain = new _Gain.Gain({
      context: this.context,
      gain: options.high,
      units: "decibels"
    });
    this.low = this._lowGain.gain;
    this.mid = this._midGain.gain;
    this.high = this._highGain.gain;
    this.Q = this._multibandSplit.Q;
    this.lowFrequency = this._multibandSplit.lowFrequency;
    this.highFrequency = this._multibandSplit.highFrequency; // the frequency bands

    this._multibandSplit.low.chain(this._lowGain, this.output);

    this._multibandSplit.mid.chain(this._midGain, this.output);

    this._multibandSplit.high.chain(this._highGain, this.output);

    (0, _Interface.readOnly)(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]);
    this._internalChannels = [this._multibandSplit];
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      high: 0,
      highFrequency: 2500,
      low: 0,
      lowFrequency: 400,
      mid: 0
    });
  }
  /**
   * Clean up.
   */


  dispose() {
    super.dispose();
    (0, _Interface.writable)(this, ["low", "mid", "high", "lowFrequency", "highFrequency"]);

    this._multibandSplit.dispose();

    this.lowFrequency.dispose();
    this.highFrequency.dispose();

    this._lowGain.dispose();

    this._midGain.dispose();

    this._highGain.dispose();

    this.low.dispose();
    this.mid.dispose();
    this.high.dispose();
    this.Q.dispose();
    return this;
  }

}

exports.EQ3 = EQ3;
},{"../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js","../channel/MultibandSplit":"../node_modules/tone/build/esm/component/channel/MultibandSplit.js"}],"../node_modules/tone/build/esm/component/filter/Convolver.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Convolver = void 0;

var _tslib = require("tslib");

var _ToneAudioNode = require("../../core/context/ToneAudioNode");

var _ToneAudioBuffer = require("../../core/context/ToneAudioBuffer");

var _Defaults = require("../../core/util/Defaults");

var _Gain = require("../../core/context/Gain");

var _Interface = require("../../core/util/Interface");

/**
 * Convolver is a wrapper around the Native Web Audio
 * [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).
 * Convolution is useful for reverb and filter emulation. Read more about convolution reverb on
 * [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).
 *
 * @example
 * // initializing the convolver with an impulse response
 * const convolver = new Tone.Convolver("./path/to/ir.wav").toDestination();
 * @category Component
 */
class Convolver extends _ToneAudioNode.ToneAudioNode {
  constructor() {
    super((0, _Defaults.optionsFromArguments)(Convolver.getDefaults(), arguments, ["url", "onload"]));
    this.name = "Convolver";
    /**
     * The native ConvolverNode
     */

    this._convolver = this.context.createConvolver();
    const options = (0, _Defaults.optionsFromArguments)(Convolver.getDefaults(), arguments, ["url", "onload"]);
    this._buffer = new _ToneAudioBuffer.ToneAudioBuffer(options.url, buffer => {
      this.buffer = buffer;
      options.onload();
    });
    this.input = new _Gain.Gain({
      context: this.context
    });
    this.output = new _Gain.Gain({
      context: this.context
    }); // set if it's already loaded, set it immediately

    if (this._buffer.loaded) {
      this.buffer = this._buffer;
    } // initially set normalization


    this.normalize = options.normalize; // connect it up

    this.input.chain(this._convolver, this.output);
  }

  static getDefaults() {
    return Object.assign(_ToneAudioNode.ToneAudioNode.getDefaults(), {
      normalize: true,
      onload: _Interface.noOp
    });
  }
  /**
   * Load an impulse response url as an audio buffer.
   * Decodes the audio asynchronously and invokes
   * the callback once the audio buffer loads.
   * @param url The url of the buffer to load. filetype support depends on the browser.
   */


  load(url) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function* () {
      this.buffer = yield this._buffer.load(url);
    });
  }
  /**
   * The convolver's buffer
   */


  get buffer() {
    if (this._buffer.length) {
      return this._buffer;
    } else {
      return null;
    }
  }

  set buffer(buffer) {
    if (buffer) {
      this._buffer.set(buffer);
    } // if it's already got a buffer, create a new one


    if (this._convolver.buffer) {
      // disconnect the old one
      this.input.disconnect();

      this._convolver.disconnect(); // create and connect a new one


      this._convolver = this.context.createConvolver();
      this.input.chain(this._convolver, this.output);
    }

    const buff = this._buffer.get();

    this._convolver.buffer = buff ? buff : null;
  }
  /**
   * The normalize property of the ConvolverNode interface is a boolean that
   * controls whether the impulse response from the buffer will be scaled by
   * an equal-power normalization when the buffer attribute is set, or not.
   */


  get normalize() {
    return this._convolver.normalize;
  }

  set normalize(norm) {
    this._convolver.normalize = norm;
  }

  dispose() {
    super.dispose();

    this._buffer.dispose();

    this._convolver.disconnect();

    return this;
  }

}

exports.Convolver = Convolver;
},{"tslib":"../node_modules/tslib/tslib.es6.js","../../core/context/ToneAudioNode":"../node_modules/tone/build/esm/core/context/ToneAudioNode.js","../../core/context/ToneAudioBuffer":"../node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","../../core/util/Defaults":"../node_modules/tone/build/esm/core/util/Defaults.js","../../core/context/Gain":"../node_modules/tone/build/esm/core/context/Gain.js","../../core/util/Interface":"../node_modules/tone/build/esm/core/util/Interface.js"}],"../node_modules/tone/build/esm/component/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Analyser = require("./analysis/Analyser");

Object.keys(_Analyser).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Analyser[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Analyser[key];
    }
  });
});

var _Meter = require("./analysis/Meter");

Object.keys(_Meter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Meter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Meter[key];
    }
  });
});

var _FFT = require("./analysis/FFT");

Object.keys(_FFT).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _FFT[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FFT[key];
    }
  });
});

var _DCMeter = require("./analysis/DCMeter");

Object.keys(_DCMeter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _DCMeter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _DCMeter[key];
    }
  });
});

var _Waveform = require("./analysis/Waveform");

Object.keys(_Waveform).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Waveform[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Waveform[key];
    }
  });
});

var _Follower = require("./analysis/Follower");

Object.keys(_Follower).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Follower[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Follower[key];
    }
  });
});

var _Channel = require("./channel/Channel");

Object.keys(_Channel).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Channel[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Channel[key];
    }
  });
});

var _CrossFade = require("./channel/CrossFade");

Object.keys(_CrossFade).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _CrossFade[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _CrossFade[key];
    }
  });
});

var _Merge = require("./channel/Merge");

Object.keys(_Merge).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Merge[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Merge[key];
    }
  });
});

var _MidSideMerge = require("./channel/MidSideMerge");

Object.keys(_MidSideMerge).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _MidSideMerge[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _MidSideMerge[key];
    }
  });
});

var _MidSideSplit = require("./channel/MidSideSplit");

Object.keys(_MidSideSplit).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _MidSideSplit[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _MidSideSplit[key];
    }
  });
});

var _Mono = require("./channel/Mono");

Object.keys(_Mono).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Mono[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Mono[key];
    }
  });
});

var _MultibandSplit = require("./channel/MultibandSplit");

Object.keys(_MultibandSplit).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _MultibandSplit[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _MultibandSplit[key];
    }
  });
});

var _Panner = require("./channel/Panner");

Object.keys(_Panner).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Panner[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Panner[key];
    }
  });
});

var _Panner3D = require("./channel/Panner3D");

Object.keys(_Panner3D).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Panner3D[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Panner3D[key];
    }
  });
});

var _PanVol = require("./channel/PanVol");

Object.keys(_PanVol).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PanVol[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PanVol[key];
    }
  });
});

var _Recorder = require("./channel/Recorder");

Object.keys(_Recorder).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Recorder[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Recorder[key];
    }
  });
});

var _Solo = require("./channel/Solo");

Object.keys(_Solo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Solo[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Solo[key];
    }
  });
});

var _Split = require("./channel/Split");

Object.keys(_Split).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Split[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Split[key];
    }
  });
});

var _Volume = require("./channel/Volume");

Object.keys(_Volume).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Volume[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Volume[key];
    }
  });
});

var _Compressor = require("./dynamics/Compressor");

Object.keys(_Compressor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Compressor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Compressor[key];
    }
  });
});

var _Gate = require("./dynamics/Gate");

Object.keys(_Gate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Gate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Gate[key];
    }
  });
});

var _Limiter = require("./dynamics/Limiter");

Object.keys(_Limiter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Limiter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Limiter[key];
    }
  });
});

var _MidSideCompressor = require("./dynamics/MidSideCompressor");

Object.keys(_MidSideCompressor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _MidSideCompressor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _MidSideCompressor[key];
    }
  });
});

var _MultibandCompressor = require("./dynamics/MultibandCompressor");

Object.keys(_MultibandCompressor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _MultibandCompressor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _MultibandCompressor[key];
    }
  });
});

var _AmplitudeEnvelope = require("./envelope/AmplitudeEnvelope");

Object.keys(_AmplitudeEnvelope).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _AmplitudeEnvelope[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _AmplitudeEnvelope[key];
    }
  });
});

var _Envelope = require("./envelope/Envelope");

Object.keys(_Envelope).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Envelope[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Envelope[key];
    }
  });
});

var _FrequencyEnvelope = require("./envelope/FrequencyEnvelope");

Object.keys(_FrequencyEnvelope).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _FrequencyEnvelope[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FrequencyEnvelope[key];
    }
  });
});

var _EQ = require("./filter/EQ3");

Object.keys(_EQ).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _EQ[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _EQ[key];
    }
  });
});

var _Filter = require("./filter/Filter");

Object.keys(_Filter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Filter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Filter[key];
    }
  });
});

var _OnePoleFilter = require("./filter/OnePoleFilter");

Object.keys(_OnePoleFilter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _OnePoleFilter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _OnePoleFilter[key];
    }
  });
});

var _FeedbackCombFilter = require("./filter/FeedbackCombFilter");

Object.keys(_FeedbackCombFilter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _FeedbackCombFilter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FeedbackCombFilter[key];
    }
  });
});

var _LowpassCombFilter = require("./filter/LowpassCombFilter");

Object.keys(_LowpassCombFilter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _LowpassCombFilter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _LowpassCombFilter[key];
    }
  });
});

var _Convolver = require("./filter/Convolver");

Object.keys(_Convolver).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _Convolver[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Convolver[key];
    }
  });
});

var _BiquadFilter = require("./filter/BiquadFilter");

Object.keys(_BiquadFilter).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _BiquadFilter[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _BiquadFilter[key];
    }
  });
});
},{"./analysis/Analyser":"../node_modules/tone/build/esm/component/analysis/Analyser.js","./analysis/Meter":"../node_modules/tone/build/esm/component/analysis/Meter.js","./analysis/FFT":"../node_modules/tone/build/esm/component/analysis/FFT.js","./analysis/DCMeter":"../node_modules/tone/build/esm/component/analysis/DCMeter.js","./analysis/Waveform":"../node_modules/tone/build/esm/component/analysis/Waveform.js","./analysis/Follower":"../node_modules/tone/build/esm/component/analysis/Follower.js","./channel/Channel":"../node_modules/tone/build/esm/component/channel/Channel.js","./channel/CrossFade":"../node_modules/tone/build/esm/component/channel/CrossFade.js","./channel/Merge":"../node_modules/tone/build/esm/component/channel/Merge.js","./channel/MidSideMerge":"../node_modules/tone/build/esm/component/channel/MidSideMerge.js","./channel/MidSideSplit":"../node_modules/tone/build/esm/component/channel/MidSideSplit.js","./channel/Mono":"../node_modules/tone/build/esm/component/channel/Mono.js","./channel/MultibandSplit":"../node_modules/tone/build/esm/component/channel/MultibandSplit.js","./channel/Panner":"../node_modules/tone/build/esm/component/channel/Panner.js","./channel/Panner3D":"../node_modules/tone/build/esm/component/channel/Panner3D.js","./channel/PanVol":"../node_modules/tone/build/esm/component/channel/PanVol.js","./channel/Recorder":"../node_modules/tone/build/esm/component/channel/Recorder.js","./channel/Solo":"../node_modules/tone/build/esm/component/channel/Solo.js","./channel/Split":"../node_modules/tone/build/esm/component/channel/Split.js","./channel/Volume":"../node_modules/tone/build/esm/component/channel/Volume.js","./dynamics/Compressor":"../node_modules/tone/build/esm/component/dynamics/Compressor.js","./dynamics/Gate":"../node_modules/tone/build/esm/component/dynamics/Gate.js","./dynamics/Limiter":"../node_modules/tone/build/esm/component/dynamics/Limiter.js","./dynamics/MidSideCompressor":"../node_modules/tone/build/esm/component/dynamics/MidSideCompressor.js","./dynamics/MultibandCompressor":"../node_modules/tone/build/esm/component/dynamics/MultibandCompressor.js","./envelope/AmplitudeEnvelope":"../node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js","./envelope/Envelope":"../node_modules/tone/build/esm/component/envelope/Envelope.js","./envelope/FrequencyEnvelope":"../node_modules/tone/build/esm/component/envelope/FrequencyEnvelope.js","./filter/EQ3":"../node_modules/tone/build/esm/component/filter/EQ3.js","./filter/Filter":"../node_modules/tone/build/esm/component/filter/Filter.js","./filter/OnePoleFilter":"../node_modules/tone/build/esm/component/filter/OnePoleFilter.js","./filter/FeedbackCombFilter":"../node_modules/tone/build/esm/component/filter/FeedbackCombFilter.js","./filter/LowpassCombFilter":"../node_modules/tone/build/esm/component/filter/LowpassCombFilter.js","./filter/Convolver":"../node_modules/tone/build/esm/component/filter/Convolver.js","./filter/BiquadFilter":"../node_modules/tone/build/esm/component/filter/BiquadFilter.js"}],"../node_modules/tone/build/esm/classes.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./core/index");

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});

var _index2 = require("./source/index");

Object.keys(_index2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index2[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index2[key];
    }
  });
});

var _index3 = require("./signal/index");

Object.keys(_index3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index3[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index3[key];
    }
  });
});

var _index4 = require("./instrument/index");

Object.keys(_index4).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index4[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index4[key];
    }
  });
});

var _index5 = require("./event/index");

Object.keys(_index5).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index5[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index5[key];
    }
  });
});

var _index6 = require("./effect/index");

Object.keys(_index6).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index6[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index6[key];
    }
  });
});

var _index7 = require("./component/index");

Object.keys(_index7).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _index7[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index7[key];
    }
  });
});
},{"./core/index":"../node_modules/tone/build/esm/core/index.js","./source/index":"../node_modules/tone/build/esm/source/index.js","./signal/index":"../node_modules/tone/build/esm/signal/index.js","./instrument/index":"../node_modules/tone/build/esm/instrument/index.js","./event/index":"../node_modules/tone/build/esm/event/index.js","./effect/index":"../node_modules/tone/build/esm/effect/index.js","./component/index":"../node_modules/tone/build/esm/component/index.js"}],"../node_modules/tone/build/esm/index.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  now: true,
  immediate: true,
  Transport: true,
  getTransport: true,
  Destination: true,
  Master: true,
  getDestination: true,
  Listener: true,
  getListener: true,
  Draw: true,
  getDraw: true,
  context: true,
  loaded: true,
  Buffer: true,
  Buffers: true,
  BufferSource: true,
  getContext: true,
  setContext: true,
  start: true,
  supported: true
};
exports.context = exports.Transport = exports.Master = exports.Listener = exports.Draw = exports.Destination = exports.Buffers = exports.BufferSource = exports.Buffer = void 0;
Object.defineProperty(exports, "getContext", {
  enumerable: true,
  get: function () {
    return _Global.getContext;
  }
});
exports.getDestination = getDestination;
exports.getDraw = getDraw;
exports.getListener = getListener;
exports.getTransport = getTransport;
exports.immediate = immediate;
exports.loaded = loaded;
exports.now = now;
Object.defineProperty(exports, "setContext", {
  enumerable: true,
  get: function () {
    return _Global.setContext;
  }
});
Object.defineProperty(exports, "start", {
  enumerable: true,
  get: function () {
    return _Global.start;
  }
});
Object.defineProperty(exports, "supported", {
  enumerable: true,
  get: function () {
    return _AudioContext.supported;
  }
});

var _Global = require("./core/Global");

var _classes = require("./classes");

Object.keys(_classes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _classes[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _classes[key];
    }
  });
});

var _version = require("./version");

Object.keys(_version).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _version[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _version[key];
    }
  });
});

var _ToneAudioBuffer = require("./core/context/ToneAudioBuffer");

var _AudioContext = require("./core/context/AudioContext");

var _ToneAudioBuffers = require("./core/context/ToneAudioBuffers");

var _ToneBufferSource = require("./source/buffer/ToneBufferSource");

/**
 * The current audio context time of the global [[Context]].
 * See [[Context.now]]
 * @category Core
 */
function now() {
  return (0, _Global.getContext)().now();
}
/**
 * The current audio context time of the global [[Context]] without the [[Context.lookAhead]]
 * See [[Context.immediate]]
 * @category Core
 */


function immediate() {
  return (0, _Global.getContext)().immediate();
}
/**
 * The Transport object belonging to the global Tone.js Context.
 * See [[Transport]]
 * @category Core
 */


const Transport = (0, _Global.getContext)().transport;
/**
 * The Transport object belonging to the global Tone.js Context.
 * See [[Transport]]
 * @category Core
 */

exports.Transport = Transport;

function getTransport() {
  return (0, _Global.getContext)().transport;
}
/**
 * The Destination (output) belonging to the global Tone.js Context.
 * See [[Destination]]
 * @category Core
 */


const Destination = (0, _Global.getContext)().destination;
/**
 * @deprecated Use [[Destination]]
 */

exports.Destination = Destination;
const Master = (0, _Global.getContext)().destination;
/**
 * The Destination (output) belonging to the global Tone.js Context.
 * See [[Destination]]
 * @category Core
 */

exports.Master = Master;

function getDestination() {
  return (0, _Global.getContext)().destination;
}
/**
 * The [[Listener]] belonging to the global Tone.js Context.
 * @category Core
 */


const Listener = (0, _Global.getContext)().listener;
/**
 * The [[Listener]] belonging to the global Tone.js Context.
 * @category Core
 */

exports.Listener = Listener;

function getListener() {
  return (0, _Global.getContext)().listener;
}
/**
 * Draw is used to synchronize the draw frame with the Transport's callbacks.
 * See [[Draw]]
 * @category Core
 */


const Draw = (0, _Global.getContext)().draw;
/**
 * Get the singleton attached to the global context.
 * Draw is used to synchronize the draw frame with the Transport's callbacks.
 * See [[Draw]]
 * @category Core
 */

exports.Draw = Draw;

function getDraw() {
  return (0, _Global.getContext)().draw;
}
/**
 * A reference to the global context
 * See [[Context]]
 */


const context = (0, _Global.getContext)();
/**
 * Promise which resolves when all of the loading promises are resolved.
 * Alias for static [[ToneAudioBuffer.loaded]] method.
 * @category Core
 */

exports.context = context;

function loaded() {
  return _ToneAudioBuffer.ToneAudioBuffer.loaded();
} // this fills in name changes from 13.x to 14.x


const Buffer = _ToneAudioBuffer.ToneAudioBuffer;
exports.Buffer = Buffer;
const Buffers = _ToneAudioBuffers.ToneAudioBuffers;
exports.Buffers = Buffers;
const BufferSource = _ToneBufferSource.ToneBufferSource;
exports.BufferSource = BufferSource;
},{"./core/Global":"../node_modules/tone/build/esm/core/Global.js","./classes":"../node_modules/tone/build/esm/classes.js","./version":"../node_modules/tone/build/esm/version.js","./core/context/ToneAudioBuffer":"../node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","./core/context/AudioContext":"../node_modules/tone/build/esm/core/context/AudioContext.js","./core/context/ToneAudioBuffers":"../node_modules/tone/build/esm/core/context/ToneAudioBuffers.js","./source/buffer/ToneBufferSource":"../node_modules/tone/build/esm/source/buffer/ToneBufferSource.js"}],"../node_modules/dat.gui/build/dat.gui.module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gui = exports.dom = exports.default = exports.controllers = exports.color = exports.GUI = void 0;

/**
 * dat-gui JavaScript Controller Library
 * https://github.com/dataarts/dat.gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */
function ___$insertStyle(css) {
  if (!css) {
    return;
  }

  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');
  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);
  return css;
}

function colorToString(color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();

  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);

  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);

    while (str.length < 6) {
      str = '0' + str;
    }

    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }

  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);

      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }

      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }

    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;

      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;

      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }

      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);

      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }

    isNaN.toString = function () {
      return _isNaN.toString();
    };

    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return obj instanceof Function;
  }
};
var INTERPRETATIONS = [{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);

        if (test === null) {
          return false;
        }

        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);

        if (test === null) {
          return false;
        }

        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);

        if (test === null) {
          return false;
        }

        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);

        if (test === null) {
          return false;
        }

        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
}, {
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
}, {
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }

        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
}, {
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }

        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }

        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }

        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }

        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;

var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);

        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;

    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }

    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }

    h /= 6;

    if (h < 0) {
      h += 1;
    }

    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }

    this.__state.a = this.__state.a || 1;
  }

  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();

function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }

      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }

      this.__state[component] = v;
    }
  });
}

function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }

      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }

      this.__state[component] = v;
    }
  });
}

Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};

Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });

  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};

Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
      this.__state.space = 'HEX';
    }

    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }

  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;

      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }

      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }

  var match = val.match(CSS_VALUE_PIXELS);

  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }

  return 0;
}

var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;

    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }

    if (Common.isUndefined(vertical)) {
      vertical = true;
    }

    elem.style.position = 'absolute';

    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }

    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];

    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }

    var evt = document.createEvent(className);

    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0, 0, clientX, clientY, false, false, false, false, 0, null);
          break;
        }

      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }

      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }

    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;

    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }

    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;

    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }

    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);

      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }

    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);

        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }

    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = {
      left: 0,
      top: 0
    };

    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }

    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);

  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);

    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));

    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');

    _this2.__checkbox.setAttribute('type', 'checkbox');

    function onChange() {
      _this.setValue(!_this.__prev);
    }

    dom.bind(_this2.__checkbox, 'change', onChange, false);

    _this2.domElement.appendChild(_this2.__checkbox);

    _this2.updateDisplay();

    return _this2;
  }

  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);

      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }

      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');

        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }

      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);

  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);

    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));

    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');

    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }

    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);

      _this.__select.appendChild(opt);
    });

    _this2.updateDisplay();

    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;

      _this.setValue(desiredValue);
    });

    _this2.domElement.appendChild(_this2.__select);

    return _this2;
  }

  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);

      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }

      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);

  function StringController(object, property) {
    classCallCheck(this, StringController);

    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));

    var _this = _this2;

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    _this2.__input = document.createElement('input');

    _this2.__input.setAttribute('type', 'text');

    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });

    _this2.updateDisplay();

    _this2.domElement.appendChild(_this2.__input);

    return _this2;
  }

  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }

      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();

  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }

  return 0;
}

var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);

  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);

    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));

    var _params = params || {};

    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;

    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }

    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }

  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;

      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }

      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }

      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}

var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);

  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);

    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));

    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;

    function onChange() {
      var attempted = parseFloat(_this.__input.value);

      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }

    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onBlur() {
      onFinish();
    }

    function onMouseDrag(e) {
      var diff = prevY - e.clientY;

      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prevY = e.clientY;
    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }

    _this2.__input = document.createElement('input');

    _this2.__input.setAttribute('type', 'text');

    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });

    _this2.updateDisplay();

    _this2.domElement.appendChild(_this2.__input);

    return _this2;
  }

  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}

var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);

  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);

    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, {
      min: min,
      max: max,
      step: step
    }));

    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');

    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }

    function onMouseDrag(e) {
      e.preventDefault();

      var bgRect = _this.__background.getBoundingClientRect();

      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));

      return false;
    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);

      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }

      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }

    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;

      var bgRect = _this.__background.getBoundingClientRect();

      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }

    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);

      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    _this2.updateDisplay();

    _this2.__background.appendChild(_this2.__foreground);

    _this2.domElement.appendChild(_this2.__background);

    return _this2;
  }

  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);

      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);

  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);

    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));

    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();

      _this.fire();

      return false;
    });
    dom.addClass(_this2.__button, 'button');

    _this2.domElement.appendChild(_this2.__button);

    return _this2;
  }

  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }

      this.getValue().call(this.object);

      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);

  function ColorController(object, property) {
    classCallCheck(this, ColorController);

    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));

    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function () {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function () {
      dom.addClass(this, 'drag').bind(window, 'touchend', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);

    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }

    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }

    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }

    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }

    function onBlur() {
      var i = interpret(this.value);

      if (i !== false) {
        _this.__color.__state = i;

        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }

    _this2.__saturation_field.appendChild(valueField);

    _this2.__selector.appendChild(_this2.__field_knob);

    _this2.__selector.appendChild(_this2.__saturation_field);

    _this2.__selector.appendChild(_this2.__hue_field);

    _this2.__hue_field.appendChild(_this2.__hue_knob);

    _this2.domElement.appendChild(_this2.__input);

    _this2.domElement.appendChild(_this2.__selector);

    _this2.updateDisplay();

    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }

      var fieldRect = _this.__saturation_field.getBoundingClientRect();

      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;

      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);

      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }

      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());

      return false;
    }

    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }

      var fieldRect = _this.__hue_field.getBoundingClientRect();

      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;

      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);

      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;
    }

    return _this2;
  }

  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());

      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);

        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }

      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;

      var _flip = 255 - flip;

      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);

var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];

function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}

function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];

    try {
      head.appendChild(injected);
    } catch (e) {}
  }
};
var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];

  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }

  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }

      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }

    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, {
        min: arguments[2],
        max: arguments[3],
        step: arguments[4]
      });
    }

    return new NumberControllerBox(object, property, {
      min: arguments[2],
      max: arguments[3]
    });
  }

  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }

  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }

  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }

  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}

var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;

    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }

  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;

      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;

      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };

      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();

var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];

var GUI = function GUI(pars) {
  var _this = this;

  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });

  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = {
      preset: DEFAULT_DEFAULT_PRESET_NAME
    };
  }

  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }

  params.resizable = Common.isUndefined(params.parent) && params.resizable;

  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }

  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this, {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }

        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }

        setPresetSelectIndex(this);

        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;

        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;

        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }

        this.onResize();

        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;

          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }

          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });

  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);

    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }

    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);

    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }

    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }

    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);

    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };

    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);

    if (!params.closed) {
      this.closed = false;
    }
  }

  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }

      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }

    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }

  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };

  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();

  if (params.resizable) {
    addResizeHandle(this);
  }

  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };

  this.saveToLocalStorageIfPossible = saveToLocalStorage;

  function resetWidth() {
    var root = _this.getRoot();

    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }

  if (!params.parent) {
    resetWidth();
  }
};

GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};

GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';

GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};

dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype, {
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);

    this.__controllers.splice(this.__controllers.indexOf(controller), 1);

    var _this = this;

    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }

    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }

    var _this = this;

    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }

    var newGuiParams = {
      name: name,
      parent: this
    };
    newGuiParams.autoPlace = this.autoPlace;

    if (this.load && this.load.folders && this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }

    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);

    delete this.__folders[folder.name];

    if (this.load && this.load.folders && this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }

    removeListeners(folder);

    var _this = this;

    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();

    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });

      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }

    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }

    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }

    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }

    var _this = this;

    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }

      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });

    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;

    while (gui.parent) {
      gui = gui.parent;
    }

    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;

    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;

      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }

      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }

    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }

    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }

    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }

      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });

    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;

    this.__listening.push(controller);

    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});

function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');

  if (newDom) {
    li.appendChild(newDom);
  }

  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }

  gui.onResize();
  return li;
}

function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);

  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}

function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];

  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}

function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller, {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }

      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);

      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);

      return controller;
    }
  });

  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, {
      min: controller.__min,
      max: controller.__max,
      step: controller.__step
    });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];

      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();

        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });

        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }

      return returned;
    };

    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }

  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }

    return val;
  }, controller.setValue);
}

function recallSavedValue(gui, controller) {
  var root = gui.getRoot();

  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);

  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];

    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }

    controllerMap[controller.property] = controller;

    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;

      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }

      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}

function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }

  var controller = void 0;

  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }

  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }

  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);

  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }

  augmentController(gui, li, controller);

  gui.__controllers.push(controller);

  return controller;
}

function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}

function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;

  gui.__preset_select.appendChild(opt);

  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}

function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}

function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');

  gui.__ul.insertBefore(div, gui.__ul.firstChild);

  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');

  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }

  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }

    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);

  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';

    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }

    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }

  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');

    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}

function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });

  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }

  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }

  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }

  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}

function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';

  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }

  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}

function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}

function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}

function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }

  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
exports.color = color;
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
exports.controllers = controllers;
var dom$1 = {
  dom: dom
};
exports.dom = dom$1;
var gui = {
  GUI: GUI
};
exports.gui = gui;
var GUI$1 = GUI;
exports.GUI = GUI$1;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};
var _default = index;
exports.default = _default;
},{}],"moduleBack.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("regenerator-runtime/runtime");

var THREE = _interopRequireWildcard(require("three"));

var _fragmentBg = _interopRequireDefault(require("./shaders/fragmentBg.glsl"));

var _vertexBg = _interopRequireDefault(require("./shaders/vertexBg.glsl"));

var _sound = _interopRequireDefault(require("/sounds/sound.mp3"));

var Tone = _interopRequireWildcard(require("tone"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// class soundT {
//     constructor(){
//         const autoPanner = new Tone.AutoPanner(0.5).toDestination().start();
//         const fatOsc = new Tone.FatOscillator("Cb1", "sine3", 10).connect(autoPanner).start();
//         const autoFilter = new Tone.AutoFilter({ frequency: 0.05, baseFrequency: 220, octaves: 2 }).toDestination().start();
//         const noise = new Tone.Noise({ type: "brown", volume: -22 }).connect(autoFilter).start();
//     }
// }
// new soundT();
// export {Ambient}
// Footer
// import { GUI } from 'dat.gui'
// const dat = require('dat.gui');
// const gui = new dat.GUI();
//importing shaders
// create an AudioListener and add it to the camera
var listener = new THREE.AudioListener(); // create a global audio source

var sound = new THREE.Audio(listener); // load a sound and set it as the Audio object's buffer

var audioLoader = new THREE.AudioLoader();
audioLoader.load(_sound.default, function (buffer) {
  sound.setBuffer(buffer);
  sound.setLoop(true);
  sound.setVolume(0.5); // sound.play();
}); //toggle sound function

function audioplay() {
  if (!sound.isPlaying) {
    sound.play();
  } else {
    sound.stop();
  }

  console.log(sound.isPlaying);
}

var analyser = new THREE.AudioAnalyser(sound, 128); //sound button
// const startButton = document.getElementById( 'audioSwitch' );
// startButton.addEventListener( 'click', audioplay );
// audioplay();

var SketchBack = /*#__PURE__*/function () {
  function SketchBack(options) {
    _classCallCheck(this, SketchBack);

    this.scene = new THREE.Scene();
    this.container = options.dom;
    this.width = this.container.offsetWidth;
    this.height = this.container.offsetHeight;
    this.renderer = new THREE.WebGLRenderer();
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(this.width, this.height);
    this.renderer.setClearColor(0x000000, 0);
    this.renderer.physicallyCorrectLights = true;
    this.renderer.outputEncoding = THREE.sRGBEncoding;
    this.container.appendChild(this.renderer.domElement);
    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 1000);
    var PI = 3.141592653589793238;
    this.camera.position.set(0, 0, -35);
    this.time = 0;
    this.sc = 0;
    this.aaaa = 0;
    this.spheresize = 5;
    this.heartBeat = 0; // this.cal = 0;

    this.col1 = 0x000000;
    this.aa = 0;
    this.set = {
      hb: 0.63,
      col1r: 0,
      col1g: 0,
      col1b: 0,
      col2r: 1,
      col2g: 1,
      col2b: 1,
      ss: 1,
      ss1: 0.04,
      ss2: 28.01,
      ss3: 0.16
    };
    this.isPlaying = true;
    this.addObjects();
    this.resize();
    this.render();
    this.setupResize();
  }

  _createClass(SketchBack, [{
    key: "settings",
    value: function settings() {// let that = this;
      // this.set = {
      //   hb: 0,
      // };
      // this.gui = new GUI();
      // // this.gui = new dat.GUI();
      // this.cubeFolder = this.gui.addFolder('Cube')
      // this.cubeFolder.add(this.settings, "progress", 0, 1, 0.01);
    }
  }, {
    key: "setupResize",
    value: function setupResize() {
      window.addEventListener("resize", this.resize.bind(this));
    }
  }, {
    key: "resize",
    value: function resize() {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;
      this.renderer.setSize(this.width, this.height);
      this.camera.aspect = this.width / this.height;
      this.camera.updateProjectionMatrix();
    }
  }, {
    key: "addObjects",
    value: function addObjects() {
      // let that = this;
      //creating shader material
      this.material = new THREE.ShaderMaterial({
        extensions: {
          derivatives: "#extension GL_OES_standard_derivatives : enable"
        },
        side: THREE.DoubleSide,
        uniforms: {
          hb: {
            type: "f",
            value: 0
          },
          col1r: {
            type: "f",
            value: 0
          },
          col1g: {
            type: "f",
            value: 0
          },
          col1b: {
            type: "f",
            value: 0
          },
          col2r: {
            type: "f",
            value: 0
          },
          col2g: {
            type: "f",
            value: 0
          },
          col2b: {
            type: "f",
            value: 0
          },
          blur: {
            type: "f",
            value: 0
          },
          ss1: {
            type: "f",
            value: 0
          },
          ss2: {
            type: "f",
            value: 0
          },
          ss3: {
            type: "f",
            value: 0
          },
          sc: {
            type: "f",
            value: 0
          },
          ba: {
            type: "f",
            value: 0
          },
          resolution: {
            type: "v4",
            value: new THREE.Vector4()
          },
          uvRate1: {
            value: new THREE.Vector2(1, 1)
          }
        },
        // wireframe: true,
        // transparent: true,
        vertexShader: _vertexBg.default,
        fragmentShader: _fragmentBg.default
      }); //creating a large sphere to go inside of
      // this.geometry = new THREE.SphereBufferGeometry(5.5, 100, 100);

      this.geometry = new THREE.SphereBufferGeometry(10, 100, 100, 100);
      this.plane = new THREE.Mesh(this.geometry, this.material);
      this.plane.position.z = 0;
      this.plane.scale.set(this.spheresize, this.spheresize, this.spheresize);
      this.scene.add(this.plane);
      this.plane.addEventListener('click', audioplay);
      this.dat = require('dat.gui');
      this.gui = new this.dat.GUI(); // this.gui.add(this.set, "col1r", 0, 1, 0.01).name('Color 1 R');
      // this.gui.add(this.set, "col1g", 0, 1, 0.01).name('Color 1 G');
      // this.gui.add(this.set, "col1b", 0, 1, 0.01).name('Color 1 B');
      // this.gui.add(this.set, "col2r", 0, 1, 0.01).name('Color 2 R');
      // this.gui.add(this.set, "col2g", 0, 1, 0.01).name('Color 2 G');
      // this.gui.add(this.set, "col2b", 0, 1, 0.01).name('Color 2 B');

      this.obj = {
        toggle_sound: function toggle_sound() {
          audioplay();
        }
      };
      this.gui.add(this.obj, 'toggle_sound');
      this.gui.add(this.set, "hb", 0, 1, 0.01).name('SS0');
      this.gui.add(this.set, "ss1", 0, 1, 0.01).name('SS1');
      this.gui.add(this.set, "ss2", 10, 50, 0.01).name('SS2');
      this.gui.add(this.set, "ss3", 0.01, 0.2, 0.001).name('SS3');
      this.gui.add(this.camera.position, "z", -35, 16, 0.01).name('Zoom'); // this.cubeFolder = this.gui.addFolder('Cube')
    }
  }, {
    key: "stop",
    value: function stop() {
      this.isPlaying = false;
    }
  }, {
    key: "play",
    value: function play() {
      if (!this.isPlaying) {
        this.render();
        this.isPlaying = true;
      }
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.isPlaying) return;
      this.time += 0.01; // audioplay();

      var data = analyser.getAverageFrequency();
      if (analyser) this.aa = data / 128.;
      this.plane.rotateY(this.aa / 100); //updating the uniforms 
      // this.material.uniforms.time.value = this.time;

      this.material.uniforms.hb.value = 1 - this.set.hb; // this.camera.position.z = (Math.sin(this.time/50 + 10))*49.;//0.95//this.set.col1r;

      this.material.uniforms.col1r.value = Math.abs(Math.sin(this.time / 50 + 10)); //0.95//this.set.col1r;

      this.material.uniforms.col1g.value = Math.abs(Math.sin(this.time / 50 + 20)); //0.82//this.set.col1g;

      this.material.uniforms.col1b.value = Math.abs(Math.sin(this.time / 50 + 30)); //0.9//this.set.col1b;

      this.material.uniforms.col2r.value = Math.abs(Math.sin(this.time / 50 + 40)); //0.54//this.set.col2r;

      this.material.uniforms.col2g.value = Math.abs(Math.sin(this.time / 50 + 50)); //0.78//this.set.col2g;

      this.material.uniforms.col2b.value = Math.abs(Math.sin(this.time / 50 + 60)); //1.0//this.set.col2b;

      this.material.uniforms.sc.value += this.aa / 100;
      this.material.uniforms.blur.value = this.aa;
      this.material.uniforms.ss1.value = this.set.ss1;
      this.material.uniforms.ss2.value = this.set.ss2;
      this.material.uniforms.ss3.value = this.set.ss3;
      this.spheresize = this.set.ss; // this.material.uniforms.col1r.value = Math.sin(this.time*2);
      // this.material.uniforms.col1g.value = Math.sin(this.time);
      // this.material.uniforms.col1b.value = Math.sin(this.time)/2;
      // this.material.uniforms.col2r.value = Math.sin(this.time);
      // this.material.uniforms.col2g.value = Math.sin(this.time*3);
      // this.material.uniforms.col2b.value = Math.sin(this.time/2);

      requestAnimationFrame(this.render.bind(this));
      this.renderer.render(this.scene, this.camera);
    }
  }]);

  return SketchBack;
}();

exports.default = SketchBack;
var sketch = new SketchBack({
  dom: document.getElementById("container")
}); // const gui = new dat.GUI();
//     gui.add(sketch.set, "progress", 0, 1, 0.01).name('progress');
// gui.add(sketch.set, "progress", 0, 1, 0.01).name('progress');
},{"regenerator-runtime/runtime":"../node_modules/regenerator-runtime/runtime.js","three":"../../../../node_modules/three/build/three.module.js","./shaders/fragmentBg.glsl":"shaders/fragmentBg.glsl","./shaders/vertexBg.glsl":"shaders/vertexBg.glsl","/sounds/sound.mp3":"sounds/sound.mp3","tone":"../node_modules/tone/build/esm/index.js","dat.gui":"../node_modules/dat.gui/build/dat.gui.module.js"}],"../node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "59799" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../node_modules/parcel-bundler/src/builtins/hmr-runtime.js","moduleBack.js"], null)
//# sourceMappingURL=/moduleBack.a1482e79.js.map